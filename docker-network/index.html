<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="aaron">



<meta name="description" content="全部的 K8S学习笔记总目录，请点击查看。 docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间，  多个容器之间是如何实现通信的呢？ 容器和宿主机之间又是如何实现的通信呢？ 使用-p参数是怎么实现的端口映射?  带着这些问题，我们来学习一下docker的网络模型，最后我会通过抓包的方式，给大家演示一下数据包在容器和宿主机之间的转换过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 网络">
<meta property="og:url" content="http://realtiger.github.io/docker-network/index.html">
<meta property="og:site_name" content="一雾银的博客">
<meta property="og:description" content="全部的 K8S学习笔记总目录，请点击查看。 docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间，  多个容器之间是如何实现通信的呢？ 容器和宿主机之间又是如何实现的通信呢？ 使用-p参数是怎么实现的端口映射?  带着这些问题，我们来学习一下docker的网络模型，最后我会通过抓包的方式，给大家演示一下数据包在容器和宿主机之间的转换过程。">
<meta property="og:locale">
<meta property="og:image" content="http://realtiger.github.io/post/docker/docker-network-bridge.jpeg">
<meta property="og:image" content="http://realtiger.github.io/post/docker/bridge-network.png">
<meta property="og:image" content="http://realtiger.github.io/post/docker/iptables.png">
<meta property="og:image" content="http://realtiger.github.io/post/docker/docker-network-request.drawio.png">
<meta property="og:image" content="http://realtiger.github.io/post/docker/docker-dnat.jpeg">
<meta property="og:image" content="http://realtiger.github.io/post/docker/docker-snat.jpeg">
<meta property="og:image" content="http://realtiger.github.io/post/docker/docker-network-container.jpeg">
<meta property="article:published_time" content="2023-07-07T11:14:57.000Z">
<meta property="article:modified_time" content="2023-08-28T09:13:33.105Z">
<meta property="article:author" content="aaron">
<meta property="article:tag" content="docker">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://realtiger.github.io/post/docker/docker-network-bridge.jpeg">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="一雾银的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">




<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Docker 网络 | 一雾银的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">aaron</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不爱游戏的程序员不是一个好厨师</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload>
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:ganchangde@163.com" title="Email" rel="external nofollow noopener noreferrer" target="_blank"></a>
                            
                                <a class="fa GitHub" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/realtiger" title="GitHub"></a>
                            
                                <a class="fa 知乎" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.zhihu.com/people/realtiger" title="知乎"></a>
                            
                                <a class="fa 博客园" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/cdinc" title="博客园"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/auth/" rel="tag">auth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate/" rel="tag">certificate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/containerd/" rel="tag">containerd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/devops/" rel="tag">devops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/" rel="tag">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hpa/" rel="tag">hpa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitmq/" rel="tag">rabbitmq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scheduler/" rel="tag">scheduler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssl/" rel="tag">ssl</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="external nofollow noopener noreferrer" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="external nofollow noopener noreferrer" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="external nofollow noopener noreferrer" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">一个啥都想学的菜鸡</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">aaron</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">aaron</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不爱游戏的程序员不是一个好厨师</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:ganchangde@163.com" title="Email" rel="external nofollow noopener noreferrer"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/realtiger" title="GitHub" rel="external nofollow noopener noreferrer"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/realtiger" title="知乎" rel="external nofollow noopener noreferrer"></a>
                            
                                <a class="fa 博客园" target="_blank" href="https://www.cnblogs.com/cdinc" title="博客园" rel="external nofollow noopener noreferrer"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap"><article id="post-docker-network" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/docker-network/" class="article-date">
      <time datetime="2023-07-07T11:14:57.000Z" itemprop="datePublished">2023-07-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Docker 网络
    </h1>
  

          
              <div style="margin-top:10px">
    <span class="post-time">
      <span class="post-meta-item-icon">
        <i class="fa fa-keyboard-o"></i>
        <span class="post-meta-item-text">  字数统计: </span>
        <span class="post-count">3.7k字</span>
      </span>
    </span>

    <span class="post-time">
      &nbsp; | &nbsp;
      <span class="post-meta-item-icon">
        <i class="fa fa-hourglass-half"></i>
        <span class="post-meta-item-text">  阅读时长: </span>
        <span class="post-count">15分</span>
      </span>
    </span>
</div>
          
      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p>
<p>docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间，</p>
<ul>
<li>多个容器之间是如何实现通信的呢？</li>
<li>容器和宿主机之间又是如何实现的通信呢？</li>
<li>使用-p参数是怎么实现的端口映射?</li>
</ul>
<p>带着这些问题，我们来学习一下docker的网络模型，最后我会通过抓包的方式，给大家演示一下数据包在容器和宿主机之间的转换过程。</p>
<span id="more"></span>

<h1 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h1><p>我们在使用 docker run 创建 Docker 容器时，可以用 –net 选项指定容器的网络模式，Docker 有以下4种网络模式：</p>
<ul>
<li>bridge模式，使用 –net&#x3D;bridge 指定，默认设置</li>
<li>host模式，使用 –net&#x3D;host 指定，容器内部网络空间共享宿主机的空间，效果类似直接在宿主机上启动一个进程，端口信息和宿主机共用</li>
<li>container模式，使用 –net&#x3D;container:NAME_or_ID 指定，指定容器与特定容器共享网络命名空间</li>
<li>none模式，使用 –net&#x3D;none 指定，网络模式为空，即仅保留网络命名空间，但是不做任何网络相关的配置(网卡、IP、路由等)</li>
</ul>
<h2 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h2><p>那我们之前在演示创建docker容器的时候其实是没有指定的网络模式的，如果不指定的话默认就会使用bridge模式，bridge本意是桥的意思，其实就是网桥模式。</p>
<p>那我们怎么理解网桥，如果需要做类比的话，我们可以把网桥看成一个二层的交换机设备。网桥模式示意图：</p>
<p><img src="/post/docker/docker-network-bridge.jpeg" alt="docker 网桥示意图"></p>
<p>Linux 中，能够起到<strong>虚拟交换机作用</strong>的网络设备，是网桥（Bridge）。它是一个工作在<strong>数据链路层</strong>（Data Link）的设备，主要功能是<strong>根据 MAC 地址将数据包转发到网桥的不同端口上</strong>。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y bridge-utils</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge <span class="built_in">id</span>               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242b5fbe57b       no              veth3a496ed</span><br></pre></td></tr></table></figure>

<p>有了网桥之后，那我们看下docker在启动一个容器的时候做了哪些事情才能实现容器间的互联互通</p>
<p>Docker 创建一个容器的时候，会执行如下操作：</p>
<ul>
<li>创建一对虚拟接口&#x2F;网卡，也就是veth pair网卡对；</li>
<li>veth pair的一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxxx；</li>
<li>veth pair的另一端放到新启动的容器内部，并修改名字作为 eth0，这个网卡&#x2F;接口只在容器的命名空间可见；</li>
<li>从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0</li>
<li>配置容器的默认路由</li>
</ul>
<p>那整个过程其实是docker自动帮我们完成的，清理掉所有容器，来验证。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 清掉所有容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f `docker ps -aq`</span><br><span class="line">$ docker ps</span><br><span class="line">$ brctl show <span class="comment"># 查看网桥中的接口，目前没有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建测试容器test1</span></span><br><span class="line">$ docker run -d --name test1 nginx:alpine</span><br><span class="line">$ brctl show <span class="comment"># 查看网桥中的接口，已经把test1的veth端接入到网桥中</span></span><br><span class="line">$ ip a |grep veth <span class="comment"># 已在宿主机中可以查看到</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test1 sh </span><br><span class="line">/ <span class="comment"># ifconfig  # 查看容器的eth0网卡及分配的容器ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再来启动一个测试容器，测试容器间的通信</span></span><br><span class="line">$ docker run -d --name test2 nginx:alpine</span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test2 sh</span><br><span class="line">/ <span class="comment"># sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apk/repositories</span></span><br><span class="line">/ <span class="comment"># apk add curl</span></span><br><span class="line">/ <span class="comment"># curl 172.17.0.8:80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为啥可以通信？</span></span><br><span class="line">/ <span class="comment"># route -n  # </span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. eth0 网卡是这个容器里的默认路由设备；所有对 172.17.0.0/16 网段的请求，也会被交给 eth0 来处理（第二条 172.17.0.0 路由规则），这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：凡是匹配到这条规则的 IP 包，应该经过本机的 eth0 网卡，通过二层网络(数据链路层)直接发往目的主机。</span></span><br><span class="line"><span class="comment"># 2. 而要通过二层网络到达 test1 容器，就需要有 172.17.0.8 这个 IP 地址对应的 MAC 地址。所以test2容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过 IP 地址查找对应的 MAC 地址。</span></span><br><span class="line"><span class="comment"># 3. 这个 eth0 网卡，是一个 Veth Pair，它的一端在这个 test2 容器的 Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上。网桥设备的一个特点是插在桥上的网卡都会被当成桥上的一个端口来处理，而端口的唯一作用就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥设备处理。</span></span><br><span class="line"><span class="comment"># 4. 因此ARP的广播请求也会由docker0来负责转发，这样网桥就维护了一份端口与mac的信息表，因此针对test2的eth0拿到mac地址后发出的各类请求，同样走到docker0网桥中由网桥负责转发到对应的容器中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网桥会维护一份mac映射表，我们可以在宿主机大概通过命令来看一下</span></span><br><span class="line">$ brctl showmacs docker0</span><br><span class="line"><span class="comment">## 这些mac地址是主机端的veth网卡对应的mac，可以查看一下</span></span><br><span class="line">$ ip a</span><br></pre></td></tr></table></figure>

<p><img src="/post/docker/bridge-network.png" alt="网桥网络"></p>
<p>我们如何知道网桥上的这些虚拟网卡与容器端是如何对应？</p>
<p>通过ifindex，网卡索引号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看test1容器的网卡索引</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test1 <span class="built_in">cat</span> /sys/class/net/eth0/ifindex</span><br><span class="line"></span><br><span class="line"><span class="comment">## 主机中找到虚拟网卡后面这个@ifxx的值，如果是同一个值，说明这个虚拟网卡和这个容器的eth0网卡是配对的。</span></span><br><span class="line">$ ip a |grep @<span class="keyword">if</span></span><br></pre></td></tr></table></figure>

<p>整理脚本，快速查看对应：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> container <span class="keyword">in</span> $(docker ps -q); <span class="keyword">do</span></span><br><span class="line">    iflink=`docker <span class="built_in">exec</span> -it <span class="variable">$container</span> sh -c <span class="string">&#x27;cat /sys/class/net/eth0/iflink&#x27;</span>`</span><br><span class="line">    iflink=`<span class="built_in">echo</span> <span class="variable">$iflink</span>|<span class="built_in">tr</span> -d <span class="string">&#x27;\r&#x27;</span>`</span><br><span class="line">    veth=`grep -l <span class="variable">$iflink</span> /sys/class/net/veth*/ifindex`</span><br><span class="line">    veth=`<span class="built_in">echo</span> <span class="variable">$veth</span>|sed -e <span class="string">&#x27;s;^.*net/\(.*\)/ifindex$;\1;&#x27;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$container</span>:<span class="variable">$veth</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>上面我们讲解了容器之间的通信，那么容器与宿主机的通信是如何做的？</p>
<p>添加端口映射：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动容器的时候通过-p参数添加宿主机端口与容器内部服务端口的映射</span></span><br><span class="line">$ docker run --name <span class="built_in">test</span> -d -p 8088:80 nginx:alpine</span><br><span class="line">$ curl localhost:8088</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>端口映射如何实现的？先来回顾iptables链表图</p>
<p><img src="/post/docker/iptables.png" alt="iptables"></p>
<blockquote>
<p>iptables运维 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables">https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables</a></p>
</blockquote>
<p>访问本机的8088端口，数据包会从流入方向进入本机，因此涉及到PREROUTING和INPUT链，我们是通过做宿主机与容器之间加的端口映射，所以肯定会涉及到端口转换，那哪个表是负责存储端口转换信息的呢，就是nat表，负责维护网络地址转换信息的。因此我们来查看一下PREROUTING链的nat表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL PREROUTING</span><br><span class="line">Chain PREROUTING (policy ACCEPT 159 packets, 20790 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    3   156 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure>

<p>规则利用了iptables的addrtype拓展，匹配网络类型为本地的包，如何确定哪些是匹配本地，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show table <span class="built_in">local</span> <span class="built_in">type</span> <span class="built_in">local</span></span><br><span class="line">127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1</span><br><span class="line">127.0.0.1 dev lo proto kernel scope host src 127.0.0.1</span><br><span class="line">172.17.0.1 dev docker0 proto kernel scope host src 172.17.0.1</span><br><span class="line">172.21.51.143 dev eth0 proto kernel scope host src 172.21.51.143</span><br></pre></td></tr></table></figure>

<p>也就是说目标地址类型匹配到这些的，会转发到我们的TARGET中，TARGET是动作，意味着对符合要求的数据包执行什么样的操作，最常见的为ACCEPT或者DROP，此处的TARGET为DOCKER，很明显DOCKER不是标准的动作，那DOCKER是什么呢？我们通常会定义自定义的链，这样把某类对应的规则放在自定义链中，然后把自定义的链绑定到标准的链路中，因此此处DOCKER 是自定义的链。那我们现在就来看一下DOCKER这个自定义链上的规则。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL DOCKER</span><br><span class="line">Chain DOCKER (2 references)                                                                                                </span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination                                            </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0                                             </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8088 to:172.17.0.2:80 </span><br></pre></td></tr></table></figure>

<p>此条规则就是对主机收到的目的端口为8088的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，172.17.0.2地址是不是就是我们上面创建的Docker容器的ip地址，流量走到网桥上了，后面就走网桥的转发就ok了。<br>所以，外界只需访问172.21.51.143:8088就可以访问到容器中的服务了。</p>
<p><img src="/post/docker/docker-network-request.drawio.png" alt="docker网络访问"></p>
<p>数据包在出口方向走POSTROUTING链，我们查看一下规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL POSTROUTING</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 1099 packets, 67268 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">   86  5438 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       172.17.0.4           172.17.0.4           tcp dpt:80</span><br></pre></td></tr></table></figure>

<p>大家注意MASQUERADE这个动作是什么意思，其实是一种更灵活的SNAT，把源地址转换成主机的出口ip地址，那解释一下这条规则的意思:</p>
<p>这条规则会将源地址为172.17.0.0&#x2F;16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。大概的过程就是ACK的包在容器里面发出来，会路由到网桥docker0，网桥根据宿主机的路由规则会转给宿主机网卡eth0，这时候包就从docker0网卡转到eth0网卡了，并从eth0网卡发出去，这时候这条规则就会生效了，把源地址换成了eth0的ip地址。</p>
<blockquote>
<p>注意一下，刚才这个过程涉及到了网卡间包的传递，那一定要打开主机的ip_forward转发服务，要不然包转不了，服务肯定访问不到。</p>
</blockquote>
<h3 id="抓包演示"><a href="#抓包演示" class="headerlink" title="抓包演示"></a>抓包演示</h3><p>我们先想一下，我们要抓哪个网卡的包</p>
<ul>
<li><p>首先访问宿主机的8088端口，我们抓一下宿主机的eth0</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i eth0 port 8088 -w host.cap</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后最终包会流入容器内，那我们抓一下容器内的eth0网卡</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器内安装一下tcpdump</span></span><br><span class="line">$ sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27;</span> /etc/apk/repositories</span><br><span class="line">$ apk add tcpdump</span><br><span class="line">$ tcpdump -i eth0 port 80 -w container.cap</span><br></pre></td></tr></table></figure></li>
</ul>
<p>到另一台机器访问一下，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl 172.21.51.143:8088/</span><br></pre></td></tr></table></figure>

<p>停止抓包，拷贝容器内的包到宿主机</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">cp</span> <span class="built_in">test</span>:/root/container.cap /root/</span><br></pre></td></tr></table></figure>

<p>把抓到的内容拷贝到本地，使用wireshark进行分析。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp root@172.21.51.143:/root/*.<span class="built_in">cap</span> /d/packages</span><br></pre></td></tr></table></figure>

<p>（wireshark合并包进行分析）</p>
<p><img src="/post/docker/docker-dnat.jpeg" alt="docker dnat"></p>
<p><img src="/post/docker/docker-snat.jpeg" alt="docker snat"></p>
<p>进到容器内的包做DNAT，出去的包做SNAT，这样对外面来讲，根本就不知道机器内部是谁提供服务，其实这就和一个内网多个机器公用一个外网IP地址上网的效果是一样的，那这也属于NAT功能的一个常见的应用场景。</p>
<h2 id="Host模式"><a href="#Host模式" class="headerlink" title="Host模式"></a>Host模式</h2><p>容器内部不会创建网络空间，共享宿主机的网络空间。比如直接通过host模式创建mysql容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --net host -d --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure>

<p>容器启动后，会默认监听3306端口，由于网络模式是host，因为可以直接通过宿主机的3306端口进行访问服务，效果等同于在宿主机中直接启动mysqld的进程。</p>
<h2 id="Conatiner模式"><a href="#Conatiner模式" class="headerlink" title="Conatiner模式"></a>Conatiner模式</h2><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<p><img src="/post/docker/docker-network-container.jpeg" alt="docker container网络"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动测试容器，共享mysql的网络空间</span></span><br><span class="line">$ docker run -ti --<span class="built_in">rm</span> --net=container:mysql busybox sh</span><br><span class="line">/ <span class="comment"># ip a</span></span><br><span class="line">/ <span class="comment"># netstat -tlp|grep 3306</span></span><br><span class="line">/ <span class="comment"># telnet localhost 3306</span></span><br></pre></td></tr></table></figure>

<p>在一些特殊的场景中非常有用，例如，kubernetes的pod，kubernetes为pod创建一个基础设施容器，同一pod下的其他容器都以container模式共享这个基础设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。</p>
<h2 id="None模式"><a href="#None模式" class="headerlink" title="None模式"></a>None模式</h2><p>只会创建对应的网络空间，不会配置网络堆栈（网卡、路由等）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建none的容器</span></span><br><span class="line">$ docker run -it  --name=network-none --net=none nginx:alpine sh</span><br><span class="line"><span class="comment"># ifconfig</span></span><br></pre></td></tr></table></figure>

<p>为了能让这个模式的docker容器能够访问外部网络，我们需要手动的创建虚拟网卡对，并将一端插入到docker0网桥中，另一端插入到容器的网络空间中。其本质就是bridge模式的实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟网卡对</span></span><br><span class="line">$ ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line"><span class="comment"># A端插入到docker0网桥</span></span><br><span class="line">$ brctl addif docker0 A</span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br><span class="line"></span><br><span class="line"><span class="comment"># B端插入到network-none容器中，需要借助ip netns,因此需要显示的创建命名network namespace</span></span><br><span class="line">$ PID=$(docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> network-none)</span><br><span class="line">$ <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ <span class="built_in">ln</span> -s /proc/<span class="variable">$PID</span>/ns/net /var/run/netns/<span class="variable">$PID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># B端放到容器的命名空间</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> B netns <span class="variable">$PID</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev B name eth0  <span class="comment"># 修改设备名称为eth0，和docker默认行为一致</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置ip</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip addr add 172.17.0.100/16 dev eth0</span><br><span class="line"><span class="comment"># 添加默认路由，指定给docker0网桥</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip route add default via 172.17.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试容器间通信</span></span><br></pre></td></tr></table></figure>

<p>前置知识：</p>
<ul>
<li>ip netns 命令用来管理 network namespace。它可以创建命名的 network namespace，然后通过名字来引用 network namespace</li>
<li>network namespace 在逻辑上是网络堆栈的一个副本，它有自己的路由、防火墙规则和网络设备。<br>默认情况下，子进程继承其父进程的 network namespace。也就是说，如果不显式创建新的 network namespace，所有进程都从 init 进程继承相同的默认 network namespace。</li>
<li>根据约定，命名的 network namespace 是可以打开的 <strong>&#x2F;var&#x2F;run&#x2F;netns&#x2F;</strong> 目录下的一个对象。比如有一个名称为 net1 的 network namespace 对象，则可以由打开 &#x2F;var&#x2F;run&#x2F;netns&#x2F;net1 对象产生的文件描述符引用 network namespace net1。通过引用该文件描述符，可以修改进程的 network namespace。</li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/docker-network/">Docker 网络</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">aaron</a></p>
        <p><span>发布时间:</span>2023-07-07, 19:14:57</p>
        <p><span>最后更新:</span>2023-08-28, 17:13:33</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/docker-network/" title="Docker 网络">http://realtiger.github.io/docker-network/</a>
            <span class="copy-path" data-clipboard-text="原文: http://realtiger.github.io/docker-network/　　作者: aaron" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="external nofollow noopener noreferrer" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/containerd-introduction/">
                    containerd 介绍 与 docker 总结
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/docker-service-running-principle/">
                    docker 运行原理
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bridge%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">bridge模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E6%BC%94%E7%A4%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text">抓包演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Host%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">Host模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conatiner%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">Conatiner模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#None%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">None模式</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Docker 网络　| 一雾银的博客　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/containerd-introduction/" title="上一篇: containerd 介绍 与 docker 总结">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/docker-service-running-principle/" title="下一篇: docker 运行原理">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/generate-a-self-signed-ssl-certificate/">生成自签名SSL证书</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-hpa/">k8s 动态扩缩容</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-auth/">k8s 认证和授权</a></li><li class="post-list-item"><a class="post-list-link" href="/rabbitmq-for-python/">rabbitmq for python</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-scheduler/">k8s 调度</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-etcd/">k8s etcd</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-service-discovery-and-load-balance/">k8s 服务发现和负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-service/">k8s service</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-deployment/">k8s deployment</a></li><li class="post-list-item"><a class="post-list-link" href="/pod-settings-and-config/">pod 常用设置和配置</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-force-delete-resource/">k8s 强制删除 pod/pvc/pv/ns 的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/linux-systemd-service-file/">linux中systemd及其service文件</a></li><li class="post-list-item"><a class="post-list-link" href="/linux-signals/">linux 信号介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-learning/">k8s 学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/k8s-introduction/">k8s 介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/containerd-introduction/">containerd 介绍 与 docker 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/docker-network/">Docker 网络</a></li><li class="post-list-item"><a class="post-list-link" href="/docker-service-running-principle/">docker 运行原理</a></li><li class="post-list-item"><a class="post-list-link" href="/sphinx-python-documentation-generator/">sphinx - python文档生成器</a></li><li class="post-list-item"><a class="post-list-link" href="/centos8-python-upgrade/">centos8 升级 python 版本</a></li><li class="post-list-item"><a class="post-list-link" href="/docker-file/">docker file</a></li><li class="post-list-item"><a class="post-list-link" href="/yaml-introduction/">yaml 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/docker-introduction/">docker 介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/python-design-patterns-03/">python 设计模式 03</a></li><li class="post-list-item"><a class="post-list-link" href="/python-design-patterns-02/">python 设计模式 02</a></li><li class="post-list-item"><a class="post-list-link" href="/python-design-patterns-01/">python 设计模式 01</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2023 aaron
            </div>
            <div class="footer-right">
                <!--<a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>-->
                <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>




    <script async src="/live2d-widget/autoload.js"></script>


  </div>
</body>
</html>