<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一雾银的博客</title>
  
  
  <link href="http://realtiger.github.io/atom.xml" rel="self"/>
  
  <link href="http://realtiger.github.io/"/>
  <updated>2023-08-06T15:14:13.658Z</updated>
  <id>http://realtiger.github.io/</id>
  
  <author>
    <name>aaron</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>containerd 介绍 与 docker 总结</title>
    <link href="http://realtiger.github.io/containerd-introduction/"/>
    <id>http://realtiger.github.io/containerd-introduction/</id>
    <published>2023-08-04T16:17:01.000Z</published>
    <updated>2023-08-06T15:14:13.658Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要介绍containerd的基本概念，以及docker的一些总结。</p><span id="more"></span><h1 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h1><p>容器运行时（ContainerRuntime），运行于 kubernetes（k8s）集群的每个节点中，负责容器的整个生命周期，其中 docker 是目前应用最广的。</p><p>随着容器云的发展，越来越多的容器运行时涌现。为了解决这些容器运行时和 k8s 的集成问题，在 k8s 1.5 版本中，社区推出了 CRI（ContainerRuntimeInterface,容器运行时接口），以支持更多的容器运行时。</p><p>Kubelet 通过 CRI 和容器运行时进行通信，使得容器运行时能够像插件一样单独运行。可以说每个容器运行时都有自己的优势，这就允许用户更容易选择和替换自己的容器运行时。</p><p><img src="/post/docker/cri-k8s.drawio.svg" alt="cri-k8s"></p><h2 id="CRI-amp-OCI"><a href="#CRI-amp-OCI" class="headerlink" title="CRI &amp; OCI"></a>CRI &amp; OCI</h2><p>OCI（OpenContainerInitiative，开放容器计划）定义了创建容器的格式和运行时的开源行业标准，包括镜像规范（ImageSpecification）和运行时规范(RuntimeSpecification)。</p><p>镜像规范定义了 OCI 镜像的标准。高层级运行时将会下载一个 OCI 镜像，并把它解压成 OCI 运行时文件系统包（filesystembundle）。</p><p><img src="/post/docker/oci+cri.drawio.svg" alt="oci+cri"></p><p>运行时规范则描述了如何从 OCI 运行时文件系统包运行容器程序，并且定义它的配置、运行环境和生命周期。如何为新容器设置命名空间(namepsaces)和控制组(cgroups)，以及挂载根文件系统等等操作，都是在这里定义的。它的一个参考实现是 runC。我们称其为低层级运行时（Low-levelRuntime）。除 runC 以外，也有很多其他的运行时遵循 OCI 标准，例如 kata-runtime。</p><h2 id="为什么弃用Docker"><a href="#为什么弃用Docker" class="headerlink" title="为什么弃用Docker"></a>为什么弃用Docker</h2><p>目前 docker 仍是 kubernetes 默认的容器运行时。那为什么会选择换掉 docker 呢？主要的原因是它的复杂性。</p><p>我们总结了 docker,containerd 以及 cri-o 的详细调用层级。Docker 的多层封装和调用，导致其在可维护性上略逊一筹，增加了线上问题的定位难度（貌似除了重启 docker，我们就毫无他法了）。Containerd 和 cri-o 的方案比起 docker 简洁很多。因此我们更偏向于选用更加简单和纯粹的 containerd 和 cri-o 作为我们的容器运行时。</p><p><img src="/post/docker/kubelet-cri.drawio.svg" alt="kubelet-cri"></p><p>我们对 containerd 和 cri-o 进行了一组性能测试，包括创建、启动、停止和删除容器，以比较它们所耗的时间。containerd 在各个方面都表现良好，除了启动容器这项。从总用时来看，containerd 的用时还是要比 cri-o 要短的。</p><p><img src="/post/docker/runcPerformance.webp" alt="runcPerformance"></p><p>从功能性来讲，containerd 和 cri-o 都符合 CRI 和 OCI 的标准。从稳定性来说，单独使用 containerd 和 cri-o 都没有足够的生产环境经验。但庆幸的是，containerd 一直在 docker 里使用，而 docker 的生产环境经验可以说比较充足。可见在稳定性上 containerd 略胜一筹。所以我们最终选用了 containerd</p><h1 id="containerd操作"><a href="#containerd操作" class="headerlink" title="containerd操作"></a>containerd操作</h1><p>更换 containerd 后，常用的 docker 命令也不再有用，containerd 命令行客户端如下图所示：</p><p><img src="/post/docker/containerd-client.drawio.svg" alt="containerd"></p><ul><li>ctr -v 输出的是 containerd 的版本，crictl -v 输出的是当前 k8s 的版本，从结果显而易见你可以认为 crictl 是用于 k8s 的。</li><li>一般来说你某个主机安装了 k8s 后，命令行才会有 crictl 命令。而 ctr 是跟 k8s 无关的，你主机安装了 containerd 服务后就可以操作 ctr 命令。</li></ul><p>先提前放出docker&#x2F;ctr&#x2F;crictl之间命令的对比，后面会详细介绍。</p><table><thead><tr><th>命令</th><th>docker</th><th>ctr（containerd）</th><th>crictl（kubernetes）</th></tr></thead><tbody><tr><td>查看运行的容器</td><td>docker ps</td><td>ctr task ls&#x2F;ctr container ls</td><td>crictl ps</td></tr><tr><td>查看镜像</td><td>docker images</td><td>ctr image ls</td><td>crictl images</td></tr><tr><td>查看容器日志</td><td>docker logs</td><td>无</td><td>crictl logs</td></tr><tr><td>查看容器数据信息</td><td>docker inspect</td><td>ctr container info</td><td>crictl inspect</td></tr><tr><td>查看容器资源</td><td>docker stats</td><td>无</td><td>crictl stats</td></tr><tr><td>启动&#x2F;关闭已有的容器</td><td>docker start&#x2F;stop</td><td>ctr task start&#x2F;kill</td><td>crictl start&#x2F;stop</td></tr><tr><td>运行一个新的容器</td><td>docker run</td><td>ctr run</td><td>无（最小单元为pod）</td></tr><tr><td>打标签</td><td>docker tag</td><td>ctr image tag</td><td>无</td></tr><tr><td>创建一个新的容器</td><td>docker create</td><td>ctr container create</td><td>crictl create</td></tr><tr><td>导入镜像</td><td>docker load</td><td>ctr image import</td><td>无</td></tr><tr><td>导出镜像</td><td>docker save</td><td>ctr image export</td><td>无</td></tr><tr><td>删除容器</td><td>docker rm</td><td>ctr container rm</td><td>crictl rm</td></tr><tr><td>删除镜像</td><td>docker rmi</td><td>ctr image rm</td><td>crictl rmi</td></tr><tr><td>拉取镜像</td><td>docker pull</td><td>ctr image pull</td><td>ctictl pull</td></tr><tr><td>推送镜像</td><td>docker push</td><td>ctr image push</td><td>无</td></tr><tr><td>登录或在容器内部执行命令</td><td>docker exec</td><td>无</td><td>crictl exec</td></tr><tr><td>清空不用的容器</td><td>docker image prune</td><td>无</td><td>crictl rmi –prune</td></tr></tbody></table><p>更多命令操作，可以直接在命令行输入命令查看帮助。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br><span class="line">ctr --help</span><br><span class="line">crictl --help</span><br></pre></td></tr></table></figure><p>以下是各种客户端操作 containerd 的命令，因为之后会安装k8s，很多操作通过k8s直接就完成了，所以对应命令可以先做了解即可。</p><h2 id="containerd-客户端-ctr"><a href="#containerd-客户端-ctr" class="headerlink" title="containerd 客户端 ctr"></a>containerd 客户端 ctr</h2><p>ctr 是 containerd 项目的一部分提供的命令行客户端。如果一台机器上运行了 containerd，那么ctr二进制文件也一般会进行安装。</p><p>由于 containerd 也有namespaces的概念，对于上层编排系统的支持，ctr 客户端主要区分了3个命名空间分别是k8s.io、moby和default，以上我们用 crictl 操作的均在 k8s.io 命名空间，使用 ctr 看镜像列表就需要加上 -n 参数。crictl 是只有一个 k8s.io 命名空间，但是没有 -n 参数。</p><blockquote><p>【温馨提示】ctr images pull 拉取的镜像默认放在default，而 crictl pull 和 kubelet 默认拉取的镜像都在 k8s.io 命名空间下。所以通过 ctr 导入镜像的时候特别注意一点，最好指定命名空间。</p></blockquote><h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 注意 -n 不能放在命令最后面，下面查看的镜像是一样的</span><br><span class="line">ctr -n=k8s.io image ls</span><br><span class="line">ctr -n k8s.io image ls</span><br><span class="line"></span><br><span class="line"># 使用ctr命令指定命名空间导入镜像</span><br><span class="line">ctr -n=k8s.io image import dashboard.tar</span><br></pre></td></tr></table></figure><h3 id="ctr-命令"><a href="#ctr-命令" class="headerlink" title="ctr 命令"></a>ctr 命令</h3><p>ctr 命令的参数和全局参数如下。</p><p>参数命令的格式为：<code>ctr [global options] command [command options] [arguments...]</code></p><p>全局参数可以在任何命令后面使用，并且可以多个参数组合使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS:</span><br><span class="line">   plugins, plugin            provides information about containerd plugins</span><br><span class="line">   version                    print the client and server versions</span><br><span class="line">   containers, c, container   manage containers</span><br><span class="line">   content                    manage content</span><br><span class="line">   events, event              display containerd events</span><br><span class="line">   images, image, i           manage images</span><br><span class="line">   leases                     manage leases</span><br><span class="line">   namespaces, namespace, ns  manage namespaces</span><br><span class="line">   pprof                      provide golang pprof outputs for containerd</span><br><span class="line">   run                        run a container</span><br><span class="line">   snapshots, snapshot        manage snapshots</span><br><span class="line">   tasks, t, task             manage tasks</span><br><span class="line">   install                    install a new package</span><br><span class="line">   oci                        OCI tools</span><br><span class="line">   shim                       interact with a shim directly</span><br><span class="line">   help, h                    Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">--debug                      enable debug output in logs</span><br><span class="line">--address value, -a value    address for containerd&#x27;s GRPC server (default: &quot;/run/containerd/containerd.sock&quot;) [$CONTAINERD_ADDRESS]</span><br><span class="line">--timeout value              total timeout for ctr commands (default: 0s)</span><br><span class="line">--connect-timeout value      timeout for connecting to containerd (default: 0s)</span><br><span class="line">--namespace value, -n value  namespace to use with commands (default: &quot;default&quot;) [$CONTAINERD_NAMESPACE]</span><br><span class="line">--help, -h                   show help</span><br><span class="line">--version, -v                print the version</span><br></pre></td></tr></table></figure><ol><li><p>查看版本</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr -v</span><br><span class="line">ctr --version</span><br></pre></td></tr></table></figure></li><li><p>指定空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr -n k8s.io image ls</span><br></pre></td></tr></table></figure></li></ol><h3 id="namespace-相关操作"><a href="#namespace-相关操作" class="headerlink" title="namespace 相关操作"></a>namespace 相关操作</h3><p>ctr 所有的命令都支持 -n 参数，用于指定命名空间，如果不指定命名空间，默认为default命名空间。命名空间的概念类似于 docker 的仓库，但是不同的是，docker 的仓库是一个集中的仓库，而 ctr 的命名空间是分布式的，每个命名空间都是一个独立的仓库。</p><p>命令 <code>ctr namespace</code> 用于管理命名空间，包括查看、创建和删除命名空间。可以简化为 <code>ctr ns</code>。</p><ol><li><p>查看命名空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr namespace ls</span><br></pre></td></tr></table></figure></li><li><p>创建命名空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr namespace create k8s.io</span><br></pre></td></tr></table></figure></li><li><p>删除命名空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr namespace rm k8s.io</span><br></pre></td></tr></table></figure></li></ol><h3 id="镜像相关操作"><a href="#镜像相关操作" class="headerlink" title="镜像相关操作"></a>镜像相关操作</h3><p>镜像相关命令如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># ctr image -h</span><br><span class="line">NAME:</span><br><span class="line">   ctr images - manage images</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr images command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line"></span><br><span class="line">   check       check existing images to ensure all content is available locally</span><br><span class="line">   export      export images</span><br><span class="line">   import      import images</span><br><span class="line">   list, ls    list images known to containerd</span><br><span class="line">   mount       mount an image to a target path</span><br><span class="line">   unmount     unmount the image from the target</span><br><span class="line">   pull        pull an image from a remote</span><br><span class="line">   push        push an image to a remote</span><br><span class="line">   remove, rm  remove one or more images by reference</span><br><span class="line">   tag         tag an image</span><br><span class="line">   label       set and clear labels for an image</span><br><span class="line">   convert     convert an image</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br></pre></td></tr></table></figure><ol><li><p>检查镜像列表，确认镜像是否存在以及镜像的完整性</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr image check</span><br><span class="line">ctr i check</span><br></pre></td></tr></table></figure></li><li><p>导入&#x2F;导出镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr i import dashboard.tar</span><br><span class="line">ctr i export dashboard.tar</span><br></pre></td></tr></table></figure></li><li><p>查看镜像列表</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr i ls</span><br><span class="line">ctr i list</span><br></pre></td></tr></table></figure></li><li><p>挂载&#x2F;卸载镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ctr 支持将镜像挂载到指定目录，这样就可以直接访问镜像中的文件了，而不需要启动容器，可以确认镜像中的文件是否正确</span><br><span class="line">ctr i mount dashboard.tar /tmp/dashboard</span><br><span class="line">ctr i unmount dashboard.tar /tmp/dashboard</span><br></pre></td></tr></table></figure></li><li><p>拉取推送镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 拉取镜像</span><br><span class="line"># docker默认是docker.io官网去找镜像，所以docker拉去镜像可以这样写：docker pull nginx:alpine，而containerd没有默认仓库，所以必须写完整的镜像名字才能拉去镜像</span><br><span class="line">ctr i pull docker.io/library/nginx:alpine</span><br><span class="line">   </span><br><span class="line"># 推送镜像到harbor</span><br><span class="line">#</span><br><span class="line"># --namespace=k8s.io 指定命名空间，不是必须，根据环境而定</span><br><span class="line"># --skip-verify 跳过认证</span><br><span class="line"># --user 指定harbor用户名及密码</span><br><span class="line">ctr --namespace=k8s.io images push harbor.mydomain.com/k8s/pause:1.25.1 --skip-verify --user admin:Harbor12345</span><br><span class="line"></span><br><span class="line"># 不想-u user:password每次必须使用 ctr pull/ctr push，可以使用nerdctl，下面有介绍</span><br><span class="line">ctr images pull --user admin:Harbor12345  --tlscacert=/etc/containerd/harbor.mydomain.com/ca.crt harbor.mydomain.com/k8s/pause:1.25.1</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr i rm nginx:alpine</span><br><span class="line">ctr i remove nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>打标签</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># crictl 没有 tag 命令，只能使用 nerdctl 和 ctr，必须指定命名空间，要不然 kubelet 无法使用。</span><br><span class="line">ctr -n k8s.io i tag my-nginx:v1 harbor.mydomain.com/my-nginx:v1</span><br><span class="line"># nerdctl -n k8s.io tag my-nginx:v1 harbor.mydomain.com/my-nginx:v1</span><br><span class="line"></span><br><span class="line"># 查看镜像</span><br><span class="line">ctr -n k8s.io i ls</span><br><span class="line"># nerdctl -n k8s.io images myharbor-minio.com/bigdata/nginx:nerctl</span><br></pre></td></tr></table></figure></li><li><p>镜像转换</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ctr 支持将镜像转换为 OCI 格式，这样就可以使用其他容器运行时运行镜像了，比如 runc</span><br><span class="line">ctr i convert --oci nginx:alpine nginx:alpine-oci</span><br><span class="line"># 也支持将 OCI 格式的镜像转换为 docker 格式</span><br><span class="line">ctr i convert nginx:alpine nginx:alpine-docker</span><br></pre></td></tr></table></figure></li><li><p>镜像构建</p><p>containerd 不提供开箱即用的镜像构建支持。一般使用更高级别的工具用来构建镜像，比如docker。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile &lt;&lt;EOF</span><br><span class="line">FROM nginx:alpine</span><br><span class="line">RUN echo &#x27;Build Image From Containerd&#x27; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 可以使用docker构建镜像，然后导出到本地，再使用ctr导入到containerd</span><br><span class="line">docker build -t my-nginx:v1 .</span><br><span class="line">docker save -o my-nginx.tar my-nginx:v1</span><br><span class="line"> </span><br><span class="line">ctr images import my-nginx.tar</span><br><span class="line"></span><br><span class="line"># 或者使用nerdctl进行构建，与docker功能一样</span><br><span class="line"># 不加-n指定命名空间，crictl看不到，kubelet也不能使用它，默认在default命名空间下</span><br><span class="line">nerdctl -n k8s.io build -t nginx:nerctl -f ./Dockerfile .</span><br><span class="line"></span><br><span class="line"># 参数解释：(下一节会有 nerctl 介绍)</span><br><span class="line"># -t：指定镜像名称</span><br><span class="line"># . ：当前目录Dockerfile</span><br><span class="line"># -f：指定Dockerfile路径</span><br><span class="line">#  --no-cache：不缓存</span><br></pre></td></tr></table></figure></li></ol><h3 id="容器相关操作"><a href="#容器相关操作" class="headerlink" title="容器相关操作"></a>容器相关操作</h3><p>容器相关操作，包括创建、启动、停止、删除等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">:~# ctr container --help</span><br><span class="line">NAME:</span><br><span class="line">   ctr containers - manage containers</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr containers command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   create           create container</span><br><span class="line">   delete, del, rm  delete one or more existing containers</span><br><span class="line">   info             get info about a container</span><br><span class="line">   list, ls         list containers</span><br><span class="line">   label            set and clear labels for a container</span><br><span class="line">   checkpoint       checkpoint a container</span><br><span class="line">   restore          restore a container from checkpoint</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br></pre></td></tr></table></figure><ol><li><p>创建容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># container 只是创建了静态容器，此时容器还未启动运行。如果要启动容器，需要使用 task start 命令。</span><br><span class="line">ctr c create harbor.mydomain.com/my-nginx:v1 my-nginx</span><br></pre></td></tr></table></figure></li><li><p>删除容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctr c rm my-nginx</span><br><span class="line">ctr c delete my-nginx</span><br><span class="line">ctr c del my-nginx</span><br></pre></td></tr></table></figure></li><li><p>查看指定容器的信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr c info my-nginx</span><br></pre></td></tr></table></figure></li><li><p>查看所有容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr c ls</span><br><span class="line">ctr c list</span><br></pre></td></tr></table></figure></li><li><p>容器标签</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 容器标签可以用来标记容器，方便管理</span><br><span class="line">ctr c label my-nginx mylabel=nginx</span><br></pre></td></tr></table></figure></li><li><p>容器检查点</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 容器检查点可以用来备份容器，方便恢复</span><br><span class="line">ctr c checkpoint my-nginx mycheckpoint</span><br><span class="line">ctr c restore my-nginx mycheckpoint</span><br></pre></td></tr></table></figure></li></ol><h3 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h3><p>管理任务，包括创建、启动、停止、删除等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># ctr task --help</span><br><span class="line">NAME:</span><br><span class="line">   ctr tasks - manage tasks</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr tasks command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   attach           attach to the IO of a running container</span><br><span class="line">   checkpoint       checkpoint a container</span><br><span class="line">   delete, rm       delete one or more tasks</span><br><span class="line">   exec             execute additional processes in an existing container</span><br><span class="line">   list, ls         list tasks</span><br><span class="line">   kill             signal a container (default: SIGTERM)</span><br><span class="line">   pause            pause an existing container</span><br><span class="line">   ps               list processes for container</span><br><span class="line">   resume           resume a paused container</span><br><span class="line">   start            start a container that has been created</span><br><span class="line">   metrics, metric  get a single data point of metrics for a task with the built-in Linux runtime</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br></pre></td></tr></table></figure><ol><li><p>启动已经创建的容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr t start my-nginx</span><br><span class="line">ctr t start -d my-nginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr t ls</span><br><span class="line">ctr t list</span><br></pre></td></tr></table></figure></li><li><p>查看容器中的进程</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr t ps my-nginx</span><br></pre></td></tr></table></figure></li><li><p>容器中执行命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr t exec my-nginx ls /</span><br></pre></td></tr></table></figure></li><li><p>暂停&#x2F;回复容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr t pause my-nginx</span><br><span class="line">ctr t resume my-nginx</span><br></pre></td></tr></table></figure></li><li><p>杀死&#x2F;删除容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 只是给容器发送了 SIGTERM 信号，容器还是存在的，状态为 stopped</span><br><span class="line">ctr t kill my-nginx</span><br><span class="line"># 删除容器，容器必须是 stopped 状态</span><br><span class="line">ctr t rm my-nginx</span><br><span class="line">ctr t delete my-nginx</span><br></pre></td></tr></table></figure></li></ol><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>容器运行需要进行两步，第一步是创建容器，第二步是启动容器。</p><p>使用 <code>ctr run</code> 命令可以一步到位，创建并启动容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># ctr run --help</span><br><span class="line">NAME:</span><br><span class="line">   ctr run - run a container</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr run [command options] [flags] Image|RootFS ID [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --rm                                    remove the container after running</span><br><span class="line">   --null-io                               send all IO to /dev/null</span><br><span class="line">   --log-uri value                         log uri</span><br><span class="line">   --detach, -d                            detach from the task after it has started execution</span><br><span class="line">   --fifo-dir value                        directory used for storing IO FIFOs</span><br><span class="line">   --cgroup value                          cgroup path (To disable use of cgroup, set to &quot;&quot; explicitly)</span><br><span class="line">   --platform value                        run image for specific platform</span><br><span class="line">   --runc-binary value                     specify runc-compatible binary</span><br><span class="line">   --runc-root value                       specify runc-compatible root</span><br><span class="line">   --runc-systemd-cgroup                   start runc with systemd cgroup manager</span><br><span class="line">   --uidmap container-uid:host-uid:length  run inside a user namespace with the specified UID mapping range; specified with the format container-uid:host-uid:length</span><br><span class="line">   --gidmap container-gid:host-gid:length  run inside a user namespace with the specified GID mapping range; specified with the format container-gid:host-gid:length</span><br><span class="line">   --remap-labels                          provide the user namespace ID remapping to the snapshotter via label options; requires snapshotter support</span><br><span class="line">   --cpus value                            set the CFS cpu quota (default: 0)</span><br><span class="line">   --cni                                   enable cni networking for the container</span><br><span class="line">   --snapshotter value                     snapshotter name. Empty value stands for the default value. [$CONTAINERD_SNAPSHOTTER]</span><br><span class="line">   --config value, -c value                path to the runtime-specific spec config file</span><br><span class="line">   --cwd value                             specify the working directory of the process</span><br><span class="line">   --env value                             specify additional container environment variables (e.g. FOO=bar)</span><br><span class="line">   --env-file value                        specify additional container environment variables in a file(e.g. FOO=bar, one per line)</span><br><span class="line">   --label value                           specify additional labels (e.g. foo=bar)</span><br><span class="line">   --mount value                           specify additional container mount (e.g. type=bind,src=/tmp,dst=/host,options=rbind:ro)</span><br><span class="line">   --net-host                              enable host networking for the container</span><br><span class="line">   --privileged                            run privileged container</span><br><span class="line">   --read-only                             set the containers filesystem as readonly</span><br><span class="line">   --runtime value                         runtime name (default: &quot;io.containerd.runc.v2&quot;)</span><br><span class="line">   --runtime-config-path value             optional runtime config path</span><br><span class="line">   --tty, -t                               allocate a TTY for the container</span><br><span class="line">   --with-ns value                         specify existing Linux namespaces to join at container runtime (format &#x27;&lt;nstype&gt;:&lt;path&gt;&#x27;)</span><br><span class="line">   --pid-file value                        file path to write the task&#x27;s pid</span><br><span class="line">   --gpus value                            add gpus to the container (default: 0)</span><br><span class="line">   --allow-new-privs                       turn off OCI spec&#x27;s NoNewPrivileges feature flag</span><br><span class="line">   --memory-limit value                    memory limit (in bytes) for the container (default: 0)</span><br><span class="line">   --device value                          file path to a device to add to the container; or a path to a directory tree of devices to add to the container</span><br><span class="line">   --seccomp                               enable the default seccomp profile</span><br><span class="line">   --seccomp-profile value                 file path to custom seccomp profile. seccomp must be set to true, before using seccomp-profile</span><br><span class="line">   --apparmor-default-profile value        enable AppArmor with the default profile with the specified name, e.g. &quot;cri-containerd.apparmor.d&quot;</span><br><span class="line">   --apparmor-profile value                enable AppArmor with an existing custom profile</span><br><span class="line">   --rootfs                                use custom rootfs that is not managed by containerd snapshotter</span><br><span class="line">   --no-pivot                              disable use of pivot-root (linux only)</span><br><span class="line">   --cpu-quota value                       Limit CPU CFS quota (default: -1)</span><br><span class="line">   --cpu-period value                      Limit CPU CFS period (default: 0)</span><br></pre></td></tr></table></figure><p>创建并启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr run -d --tty --net-host --name my-nginx docker.io/library/nginx:latest</span><br></pre></td></tr></table></figure><h2 id="containerd-客户端-nerdctl"><a href="#containerd-客户端-nerdctl" class="headerlink" title="containerd 客户端 nerdctl"></a>containerd 客户端 nerdctl</h2><p>推荐使用 nerdctl，使用效果与 docker 命令的语法一致<br>github下载链接：<a href="https://github.com/containerd/nerdctl/releases">https://github.com/containerd/nerdctl/releases</a></p><ul><li>精简 (nerdctl-{version}-linux-amd64.tar.gz): 只包含nerdctl</li><li>完整 (nerdctl-full-{version}-linux-amd64.tar.gz): 包含 containerd, runc, and CNI等依赖</li></ul><p>nerdctl 的目标并不是单纯地复制 docker 的功能，它还实现了很多 docker 不具备的功能，例如延迟拉取镜像（lazy-pulling）、镜像加密（imgcrypt）等。</p><p><img src="/post/docker/nerdctl.png" alt="nerdctl"></p><h3 id="安装-nerdctl"><a href="#安装-nerdctl" class="headerlink" title="安装 nerdctl"></a>安装 nerdctl</h3><p>精简版只包含nerdctl，完整版包含nerdctl和CNI插件等依赖，k8s的网络插件会在&#x2F;opt&#x2F;cni&#x2F;bin&#x2F;下会生成cni插件目录，所以这里选择精简版。</p><ol><li><p>精简版 nerdctl 安装</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/containerd/nerdctl/releases/download/v0.22.2/nerdctl-0.22.2-linux-amd64.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar -xf nerdctl-0.22.2-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">ln -s /opt/k8s/nerdctl/nerdctl /usr/local/bin/nerdctl</span><br></pre></td></tr></table></figure></li><li><p>完整版 nerdctl 安装</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/containerd/nerdctl/releases/download/v0.22.2/nerdctl-full-0.22.2-linux-amd64.tar.gz</span><br><span class="line">tar -xf nerdctl-full-0.16.0-linux-amd64.tar.gz -C /usr/local/</span><br><span class="line">cp /usr/local/lib/systemd/system/*.service /etc/systemd/system/</span><br><span class="line"></span><br><span class="line"># 启动服务buildkit</span><br><span class="line">systemctl enable buildkit containerd --now</span><br><span class="line">systemctl status buildkit containerd</span><br></pre></td></tr></table></figure></li><li><p>安装 buildkit 支持构建镜像</p><p> buildkit GitHub地址： <a href="https://github.com/moby/buildkit">https://github.com/moby/buildkit</a></p><p> 使用精简版 nerdctl 无法直接通过 containerd 构建镜像，需要与buildkit组全使用以实现镜像构建。当然你也可以安装上面的完整nerdctl。<br> buildkit项目是Docker公司开源出来的一个构建工具包，支持OCI标准的镜像构建。它主要包含以下部分:</p><ul><li>服务端buildkitd，当前支持runc和containerd作为worker，默认是runc；</li><li>客户端buildctl，负责解析Dockerfile，并向服务端buildkitd发出构建请求。</li><li>buildkit是典型的C&#x2F;S架构，client和server可以不在一台服务器上。而nerdctl在构建镜像方面也可以作为buildkitd的客户端。</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># https://github.com/moby/buildkit/releases</span><br><span class="line">wget https://github.com/moby/buildkit/releases/download/v0.10.4/buildkit-v0.10.4.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xf buildkit-v0.10.4.linux-amd64.tar.gz  -C /usr/local/</span><br><span class="line"></span><br><span class="line"># 配置buildkit的启动文件，可以从这里下载：https://github.com/moby/buildkit/tree/master/examples/systemd</span><br><span class="line"># buildkit需要配置两个文件:</span><br><span class="line"># 1. /usr/lib/systemd/system/buildkit.socket</span><br><span class="line"># 2. /usr/lib/systemd/system/buildkit.service</span><br><span class="line"></span><br><span class="line">cat &gt; /usr/lib/systemd/system/buildkit.socket &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=BuildKit</span><br><span class="line">Documentation=https://github.com/moby/buildkit</span><br><span class="line">[Socket]</span><br><span class="line">ListenStream=%t/buildkit/buildkitd.sock</span><br><span class="line">SocketMode=0660</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sockets.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; /usr/lib/systemd/system/buildkit.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=BuildKit</span><br><span class="line">Requires=buildkit.socket</span><br><span class="line">After=buildkit.socket</span><br><span class="line">Documentation=https://github.com/moby/buildkit</span><br><span class="line">[Service]</span><br><span class="line"># Replace runc builds with containerd builds  </span><br><span class="line">ExecStart=/usr/local/bin/buildkitd --addr fd://</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 启动buildkit</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable buildkit --now</span><br></pre></td></tr></table></figure></li><li><p>设置nerdctl自动补全</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编辑文件</span><br><span class="line">vim /etc/profile</span><br><span class="line">source &lt;(nerdctl completion bash)</span><br><span class="line"># 让其生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><h3 id="namespace-相关操作-1"><a href="#namespace-相关操作-1" class="headerlink" title="namespace 相关操作"></a>namespace 相关操作</h3><ol><li><p>创建 namespace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl namespace create mynamespace</span><br></pre></td></tr></table></figure></li><li><p>列出 namespace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl namespace ls</span><br></pre></td></tr></table></figure></li><li><p>删除 namespace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl namespace rm mynamespace</span><br></pre></td></tr></table></figure></li></ol><h3 id="镜像相关操作-1"><a href="#镜像相关操作-1" class="headerlink" title="镜像相关操作"></a>镜像相关操作</h3><ol><li><p>拉取镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl pull nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>列出镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl image ls</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl image rm nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>拉取推送镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 拉取镜像</span><br><span class="line">nerdctl pull nginx:alpine</span><br><span class="line"># 重命名镜像</span><br><span class="line">nerdctl image tag nginx:alpine harbor.mydomain.com/library/nginx:alpine</span><br><span class="line"># 推送镜像</span><br><span class="line">nerdctl push harbor.mydomain.com/library/nginx:alpine</span><br></pre></td></tr></table></figure><p> 更详细的镜像拉取操作请参考下面的内容：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># http方式，配置如下：</span><br><span class="line">mkdir -p /etc/containerd/harbor.mydomain.com</span><br><span class="line">cat &gt; /etc/containerd/certs.d/harbor.mydomain.com/hosts.toml &lt;&lt;EOF</span><br><span class="line">server = &quot;https://docker.io&quot;</span><br><span class="line"></span><br><span class="line">[host.&quot;http://myharbor-minio.com&quot;]</span><br><span class="line">capabilities = [&quot;pull&quot;, &quot;resolve&quot;,&quot;push&quot;]</span><br><span class="line"># skip_verify = true</span><br><span class="line"># ca = &quot;ca.crt&quot;   #相对路径</span><br><span class="line"># ca = &quot;/opt/auth/ca.crt&quot;  #绝对路径</span><br><span class="line"># ca = [&quot;/opt/auth/ca.crt&quot;]</span><br><span class="line"># ca = [&quot;ca.crt&quot;]</span><br><span class="line"># client = [[&quot;/opt/auth/nginx.cclinux.cn.crt&quot;, &quot;/opt/auth/nginx.cclinux.cn.key&quot;]]</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"># https方式，配置如下：</span><br><span class="line">mkdir -p /etc/containerd/certs.d/harbor.secure.mydomain.com:443</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/containerd/certs.d/harbor.secure.mydomain.com\:443/hosts.toml &lt;&lt;EOF</span><br><span class="line">server = &quot;https://docker.io&quot;</span><br><span class="line"></span><br><span class="line">[host.&quot;https://harbor.secure.mydomain.com:443&quot;]</span><br><span class="line">capabilities = [&quot;pull&quot;, &quot;resolve&quot;,&quot;push&quot;]</span><br><span class="line">skip_verify = true</span><br><span class="line"># ca = &quot;ca.crt&quot;   #相对路径</span><br><span class="line"># ca = &quot;/opt/auth/ca.crt&quot;  #绝对路径</span><br><span class="line"># ca = [&quot;/opt/auth/ca.crt&quot;]</span><br><span class="line">ca = [&quot;/etc/containerd/harbor.secure.mydomain.com/ca.crt&quot;]</span><br><span class="line"># client = [[&quot;/opt/auth/nginx.cclinux.cn.crt&quot;, &quot;/opt/auth/nginx.cclinux.cn.key&quot;]]</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"># 可以通过 nerdctl 登录</span><br><span class="line">echo Harbor12345 | nerdctl login --username &quot;admin&quot; --password-stdin harbor.secure.mydomain.com:443</span><br><span class="line">   </span><br><span class="line"># 登出命令</span><br><span class="line"># nerdctl logout harbor.secure.mydomain.com:443</span><br><span class="line">   </span><br><span class="line"># 推送到私有仓库</span><br><span class="line">nerdctl --insecure-registry --namespace=k8s.io push harbor.secure.mydomain.com:443/k8s/pause:1.25.1</span><br></pre></td></tr></table></figure></li><li><p>镜像构建</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 从Dockerfile构建镜像</span><br><span class="line">nerdctl build -t nginx:alpine -f Dockerfile .</span><br><span class="line"># 从Dockerfile构建镜像并推送到私有仓库</span><br><span class="line">nerdctl build -t harbor.secure.mydomain.com:443/k8s/nginx:alpine -f Dockerfile .</span><br></pre></td></tr></table></figure></li></ol><h3 id="容器相关操作-1"><a href="#容器相关操作-1" class="headerlink" title="容器相关操作"></a>容器相关操作</h3><ol><li><p>创建容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl run -d --name mynginx -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>列出容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl ps -a</span><br></pre></td></tr></table></figure></li><li><p>删除容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl rm mynginx</span><br></pre></td></tr></table></figure></li><li><p>进入容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl exec -it mynginx sh</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl logs mynginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器详细信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl inspect mynginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器内进程</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl top mynginx</span><br></pre></td></tr></table></figure></li></ol><h2 id="k8s-操作-containerd-的客户端-crictl"><a href="#k8s-操作-containerd-的客户端-crictl" class="headerlink" title="k8s 操作 containerd 的客户端 crictl"></a>k8s 操作 containerd 的客户端 crictl</h2><h3 id="命令示例-1"><a href="#命令示例-1" class="headerlink" title="命令示例"></a>命令示例</h3><p>使用 crictl 命令之前，需要先配置 <code>/etc/crictl.yaml</code> 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/crictl.yaml</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">runtime-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">timeout: 10</span><br><span class="line">debug: false</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># 也可以通过命令进行设置</span><br><span class="line">crictl config runtime-endpoint unix:///run/containerd/containerd.sock</span><br><span class="line">crictl config image-endpoint unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>命令行示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># crictl 没有 -n 参数，操作都在 k8s.io 命名空间下。</span><br><span class="line">crictl image ls</span><br><span class="line">crictl images</span><br><span class="line"># crictl image list = ctr -n k8s.io image list</span><br><span class="line"># crictl image ls = ctr -n k8s.io image ls</span><br><span class="line"># crictl images = ctr -n k8s.io image list</span><br><span class="line"># crictl images = ctr -n k8s.io image ls</span><br></pre></td></tr></table></figure><h3 id="namespace-相关操作-2"><a href="#namespace-相关操作-2" class="headerlink" title="namespace 相关操作"></a>namespace 相关操作</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的 namespace</span><br><span class="line">crictl namespace list</span><br><span class="line"># 创建 namespace</span><br><span class="line">crictl namespace create k8s.io</span><br><span class="line"># 删除 namespace</span><br><span class="line">crictl namespace remove k8s.io</span><br></pre></td></tr></table></figure></code></pre><h3 id="image-相关操作"><a href="#image-相关操作" class="headerlink" title="image 相关操作"></a>image 相关操作</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的 image</span><br><span class="line">crictl image list</span><br><span class="line"># 拉取 image</span><br><span class="line">crictl pull nginx:alpine</span><br><span class="line"># 删除 image</span><br><span class="line">crictl rmi nginx:alpine</span><br></pre></td></tr></table></figure></code></pre><h3 id="container-相关操作"><a href="#container-相关操作" class="headerlink" title="container 相关操作"></a>container 相关操作</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的 container</span><br><span class="line">crictl ps -a</span><br><span class="line"># 创建 container</span><br><span class="line">crictl run -d --name mynginx -p 80:80 nginx:alpine</span><br><span class="line"># 删除 container</span><br><span class="line">crictl rm mynginx</span><br><span class="line"># 进入 container</span><br><span class="line">crictl exec -it mynginx sh</span><br><span class="line"># 查看 container 日志</span><br><span class="line">crictl logs mynginx</span><br><span class="line"># 查看 container 详细信息</span><br><span class="line">crictl inspect mynginx</span><br><span class="line"># 查看 container 内进程</span><br><span class="line">crictl top mynginx</span><br></pre></td></tr></table></figure></code></pre><h1 id="docker-总结"><a href="#docker-总结" class="headerlink" title="docker 总结"></a>docker 总结</h1><h2 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h2><ol><li><p>清理主机上所有退出的容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">rm</span>  $(docker ps -aq)</span><br></pre></td></tr></table></figure></li><li><p>调试或者排查容器启动错误</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 若有时遇到容器启动失败的情况，可以先使用相同的镜像启动一个临时容器，先进入容器</span></span><br><span class="line">$ docker run --<span class="built_in">rm</span> -ti &lt;image_id&gt; sh</span><br><span class="line"><span class="comment">## 进入容器后，手动执行该容器对应的ENTRYPOINT或者CMD命令，这样即使出错，容器也不会退出，因为bash作为1号进程，我们只要不退出容器，该容器就不会自动退出</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="docker总结"><a href="#docker总结" class="headerlink" title="docker总结"></a>docker总结</h2><p><img src="/post/docker/Docker.png" alt="Docker"></p><ol><li>为了解决软件交付过程中的环境依赖，同时提供一种更加轻量的虚拟化技术，Docker出现了。</li><li>2013年诞生，15年开始迅速发展，从17.03月开始，使用时间日期管理版本，稳定版以每季度为准。</li><li>Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理。</li><li>使用yum部署docker，启动后通过操作docker这个命令行，自动调用docker daemon完成容器相关操作。</li><li>常用操作，围绕<code>镜像|容器|仓库</code>三大核心要素<ul><li>systemctl  start|stop|restart docker</li><li>docker build | pull  -&gt; docker tag -&gt; docker push</li><li>docker run –name my-demo  -d  -p 8080:80 -v  &#x2F;opt&#x2F;data:&#x2F;data  demo:v20200327 ping xx.com</li><li>docker cp  &#x2F;path&#x2F;a.txt  mycontainer:&#x2F;opt</li><li>docker exec -ti  mycontainer  &#x2F;bin&#x2F;sh</li><li>docker logs -f –tail&#x3D;100 mycontainer</li></ul></li><li>通过dockerfile构建业务镜像，先使用基础镜像，然后通过一系列的指令把我们的业务应用所需要的运行环境和依赖都打包到镜像中，然后通过CMD或者ENTRYPOINT指令把镜像启动时的入口制定好，完成封装即可。有点类似于，先找来一个集装箱模板(基础镜像)，然后把项目依赖的服务都扔到集装箱中，然后设置好服务的启动入口，关闭箱门，即完成了业务镜像的制作。</li><li>容器的实现依赖于内核模块提供的namespace和control-group的功能，通过namespace创建一块虚拟空间，空间内实现了各类资源(进程、网络、文件系统)的隔离，提供control-group实现了对隔离的空间的资源使用的限制。</li><li>docker镜像使用分层的方式进行存储，根据主机的存储驱动的不同，实现方式会不同，kernel在3.10.0-514以上自动支持overlay2 存储驱动，也是目前Docker推荐的方式。</li><li>得益于分层存储的模式，多个容器可以通过copy-on-write的策略，在镜像的最上层加一个可写层，同时利用存储驱动的UnionFS的能力，实现一个镜像快速启动多个容器的场景。</li><li>docker的网络模式分为4种，最常用的为bridge和host模式。bridge模式通过docker0网桥，启动容器的时候通过创建一对虚拟网卡，将容器连接在桥上，同时维护了虚拟网卡与网桥端口的关系，实现容器间的通信。容器与宿主机之间的通信通过iptables端口映射的方式，docker利用iptables的PREROUTING和POSTROUTING的nat功能，实现了SNAT与DNAT，使得容器内部的服务被完美的保护起来。</li><li>本章重点内容是docker的核心要素及基础的操作，实现原理以及docker的网络模式为选修包，目的为了帮助有docker基础及经验的同学更好的进一步理解docker。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节主要介绍containerd的基本概念，以及docker的一些总结。&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://realtiger.github.io/tags/docker/"/>
    
    <category term="k8s" scheme="http://realtiger.github.io/tags/k8s/"/>
    
    <category term="containerd" scheme="http://realtiger.github.io/tags/containerd/"/>
    
  </entry>
  
  <entry>
    <title>Docker 网络</title>
    <link href="http://realtiger.github.io/docker-network/"/>
    <id>http://realtiger.github.io/docker-network/</id>
    <published>2023-07-07T11:14:57.000Z</published>
    <updated>2023-08-04T16:00:41.389Z</updated>
    
    <content type="html"><![CDATA[<p>docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间，</p><ul><li>多个容器之间是如何实现通信的呢？</li><li>容器和宿主机之间又是如何实现的通信呢？</li><li>使用-p参数是怎么实现的端口映射?</li></ul><p>带着这些问题，我们来学习一下docker的网络模型，最后我会通过抓包的方式，给大家演示一下数据包在容器和宿主机之间的转换过程。</p><span id="more"></span><h1 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h1><p>我们在使用 docker run 创建 Docker 容器时，可以用 –net 选项指定容器的网络模式，Docker 有以下4种网络模式：</p><ul><li>bridge模式，使用 –net&#x3D;bridge 指定，默认设置</li><li>host模式，使用 –net&#x3D;host 指定，容器内部网络空间共享宿主机的空间，效果类似直接在宿主机上启动一个进程，端口信息和宿主机共用</li><li>container模式，使用 –net&#x3D;container:NAME_or_ID 指定，指定容器与特定容器共享网络命名空间</li><li>none模式，使用 –net&#x3D;none 指定，网络模式为空，即仅保留网络命名空间，但是不做任何网络相关的配置(网卡、IP、路由等)</li></ul><h2 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h2><p>那我们之前在演示创建docker容器的时候其实是没有指定的网络模式的，如果不指定的话默认就会使用bridge模式，bridge本意是桥的意思，其实就是网桥模式。</p><p>那我们怎么理解网桥，如果需要做类比的话，我们可以把网桥看成一个二层的交换机设备。网桥模式示意图：</p><p><img src="/post/docker/docker-network-bridge.jpeg" alt="docker 网桥示意图"></p><p>Linux 中，能够起到<strong>虚拟交换机作用</strong>的网络设备，是网桥（Bridge）。它是一个工作在<strong>数据链路层</strong>（Data Link）的设备，主要功能是<strong>根据 MAC 地址将数据包转发到网桥的不同端口上</strong>。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y bridge-utils</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge <span class="built_in">id</span>               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242b5fbe57b       no              veth3a496ed</span><br></pre></td></tr></table></figure><p>有了网桥之后，那我们看下docker在启动一个容器的时候做了哪些事情才能实现容器间的互联互通</p><p>Docker 创建一个容器的时候，会执行如下操作：</p><ul><li>创建一对虚拟接口&#x2F;网卡，也就是veth pair网卡对；</li><li>veth pair的一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxxx；</li><li>veth pair的另一端放到新启动的容器内部，并修改名字作为 eth0，这个网卡&#x2F;接口只在容器的命名空间可见；</li><li>从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0</li><li>配置容器的默认路由</li></ul><p>那整个过程其实是docker自动帮我们完成的，清理掉所有容器，来验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 清掉所有容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f `docker ps -aq`</span><br><span class="line">$ docker ps</span><br><span class="line">$ brctl show <span class="comment"># 查看网桥中的接口，目前没有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建测试容器test1</span></span><br><span class="line">$ docker run -d --name test1 nginx:alpine</span><br><span class="line">$ brctl show <span class="comment"># 查看网桥中的接口，已经把test1的veth端接入到网桥中</span></span><br><span class="line">$ ip a |grep veth <span class="comment"># 已在宿主机中可以查看到</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test1 sh </span><br><span class="line">/ <span class="comment"># ifconfig  # 查看容器的eth0网卡及分配的容器ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再来启动一个测试容器，测试容器间的通信</span></span><br><span class="line">$ docker run -d --name test2 nginx:alpine</span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test2 sh</span><br><span class="line">/ <span class="comment"># sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apk/repositories</span></span><br><span class="line">/ <span class="comment"># apk add curl</span></span><br><span class="line">/ <span class="comment"># curl 172.17.0.8:80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为啥可以通信？</span></span><br><span class="line">/ <span class="comment"># route -n  # </span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. eth0 网卡是这个容器里的默认路由设备；所有对 172.17.0.0/16 网段的请求，也会被交给 eth0 来处理（第二条 172.17.0.0 路由规则），这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：凡是匹配到这条规则的 IP 包，应该经过本机的 eth0 网卡，通过二层网络(数据链路层)直接发往目的主机。</span></span><br><span class="line"><span class="comment"># 2. 而要通过二层网络到达 test1 容器，就需要有 172.17.0.8 这个 IP 地址对应的 MAC 地址。所以test2容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过 IP 地址查找对应的 MAC 地址。</span></span><br><span class="line"><span class="comment"># 3. 这个 eth0 网卡，是一个 Veth Pair，它的一端在这个 test2 容器的 Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上。网桥设备的一个特点是插在桥上的网卡都会被当成桥上的一个端口来处理，而端口的唯一作用就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥设备处理。</span></span><br><span class="line"><span class="comment"># 4. 因此ARP的广播请求也会由docker0来负责转发，这样网桥就维护了一份端口与mac的信息表，因此针对test2的eth0拿到mac地址后发出的各类请求，同样走到docker0网桥中由网桥负责转发到对应的容器中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网桥会维护一份mac映射表，我们可以在宿主机大概通过命令来看一下</span></span><br><span class="line">$ brctl showmacs docker0</span><br><span class="line"><span class="comment">## 这些mac地址是主机端的veth网卡对应的mac，可以查看一下</span></span><br><span class="line">$ ip a</span><br></pre></td></tr></table></figure><p><img src="/post/docker/bridge-network.png" alt="网桥网络"></p><p>我们如何知道网桥上的这些虚拟网卡与容器端是如何对应？</p><p>通过ifindex，网卡索引号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看test1容器的网卡索引</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test1 <span class="built_in">cat</span> /sys/class/net/eth0/ifindex</span><br><span class="line"></span><br><span class="line"><span class="comment">## 主机中找到虚拟网卡后面这个@ifxx的值，如果是同一个值，说明这个虚拟网卡和这个容器的eth0网卡是配对的。</span></span><br><span class="line">$ ip a |grep @<span class="keyword">if</span></span><br></pre></td></tr></table></figure><p>整理脚本，快速查看对应：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> container <span class="keyword">in</span> $(docker ps -q); <span class="keyword">do</span></span><br><span class="line">    iflink=`docker <span class="built_in">exec</span> -it <span class="variable">$container</span> sh -c <span class="string">&#x27;cat /sys/class/net/eth0/iflink&#x27;</span>`</span><br><span class="line">    iflink=`<span class="built_in">echo</span> <span class="variable">$iflink</span>|<span class="built_in">tr</span> -d <span class="string">&#x27;\r&#x27;</span>`</span><br><span class="line">    veth=`grep -l <span class="variable">$iflink</span> /sys/class/net/veth*/ifindex`</span><br><span class="line">    veth=`<span class="built_in">echo</span> <span class="variable">$veth</span>|sed -e <span class="string">&#x27;s;^.*net/\(.*\)/ifindex$;\1;&#x27;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$container</span>:<span class="variable">$veth</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上面我们讲解了容器之间的通信，那么容器与宿主机的通信是如何做的？</p><p>添加端口映射：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动容器的时候通过-p参数添加宿主机端口与容器内部服务端口的映射</span></span><br><span class="line">$ docker run --name <span class="built_in">test</span> -d -p 8088:80 nginx:alpine</span><br><span class="line">$ curl localhost:8088</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>端口映射如何实现的？先来回顾iptables链表图</p><p><img src="/post/docker/iptables.png" alt="iptables"></p><blockquote><p>iptables运维 <a href="https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables">https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables</a></p></blockquote><p>访问本机的8088端口，数据包会从流入方向进入本机，因此涉及到PREROUTING和INPUT链，我们是通过做宿主机与容器之间加的端口映射，所以肯定会涉及到端口转换，那哪个表是负责存储端口转换信息的呢，就是nat表，负责维护网络地址转换信息的。因此我们来查看一下PREROUTING链的nat表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL PREROUTING</span><br><span class="line">Chain PREROUTING (policy ACCEPT 159 packets, 20790 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    3   156 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><p>规则利用了iptables的addrtype拓展，匹配网络类型为本地的包，如何确定哪些是匹配本地，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show table <span class="built_in">local</span> <span class="built_in">type</span> <span class="built_in">local</span></span><br><span class="line">127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1</span><br><span class="line">127.0.0.1 dev lo proto kernel scope host src 127.0.0.1</span><br><span class="line">172.17.0.1 dev docker0 proto kernel scope host src 172.17.0.1</span><br><span class="line">172.21.51.143 dev eth0 proto kernel scope host src 172.21.51.143</span><br></pre></td></tr></table></figure><p>也就是说目标地址类型匹配到这些的，会转发到我们的TARGET中，TARGET是动作，意味着对符合要求的数据包执行什么样的操作，最常见的为ACCEPT或者DROP，此处的TARGET为DOCKER，很明显DOCKER不是标准的动作，那DOCKER是什么呢？我们通常会定义自定义的链，这样把某类对应的规则放在自定义链中，然后把自定义的链绑定到标准的链路中，因此此处DOCKER 是自定义的链。那我们现在就来看一下DOCKER这个自定义链上的规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL DOCKER</span><br><span class="line">Chain DOCKER (2 references)                                                                                                </span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination                                            </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0                                             </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8088 to:172.17.0.2:80 </span><br></pre></td></tr></table></figure><p>此条规则就是对主机收到的目的端口为8088的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，172.17.0.2地址是不是就是我们上面创建的Docker容器的ip地址，流量走到网桥上了，后面就走网桥的转发就ok了。<br>所以，外界只需访问172.21.51.143:8088就可以访问到容器中的服务了。</p><p><img src="/post/docker/docker-network-request.drawio.png" alt="docker网络访问"></p><p>数据包在出口方向走POSTROUTING链，我们查看一下规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL POSTROUTING</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 1099 packets, 67268 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">   86  5438 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       172.17.0.4           172.17.0.4           tcp dpt:80</span><br></pre></td></tr></table></figure><p>大家注意MASQUERADE这个动作是什么意思，其实是一种更灵活的SNAT，把源地址转换成主机的出口ip地址，那解释一下这条规则的意思:</p><p>这条规则会将源地址为172.17.0.0&#x2F;16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。大概的过程就是ACK的包在容器里面发出来，会路由到网桥docker0，网桥根据宿主机的路由规则会转给宿主机网卡eth0，这时候包就从docker0网卡转到eth0网卡了，并从eth0网卡发出去，这时候这条规则就会生效了，把源地址换成了eth0的ip地址。</p><blockquote><p>注意一下，刚才这个过程涉及到了网卡间包的传递，那一定要打开主机的ip_forward转发服务，要不然包转不了，服务肯定访问不到。</p></blockquote><h3 id="抓包演示"><a href="#抓包演示" class="headerlink" title="抓包演示"></a>抓包演示</h3><p>我们先想一下，我们要抓哪个网卡的包</p><ul><li><p>首先访问宿主机的8088端口，我们抓一下宿主机的eth0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i eth0 port 8088 -w host.cap</span><br></pre></td></tr></table></figure></li><li><p>然后最终包会流入容器内，那我们抓一下容器内的eth0网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器内安装一下tcpdump</span></span><br><span class="line">$ sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27;</span> /etc/apk/repositories</span><br><span class="line">$ apk add tcpdump</span><br><span class="line">$ tcpdump -i eth0 port 80 -w container.cap</span><br></pre></td></tr></table></figure></li></ul><p>到另一台机器访问一下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl 172.21.51.143:8088/</span><br></pre></td></tr></table></figure><p>停止抓包，拷贝容器内的包到宿主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">cp</span> <span class="built_in">test</span>:/root/container.cap /root/</span><br></pre></td></tr></table></figure><p>把抓到的内容拷贝到本地，使用wireshark进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp root@172.21.51.143:/root/*.<span class="built_in">cap</span> /d/packages</span><br></pre></td></tr></table></figure><p>（wireshark合并包进行分析）</p><p><img src="/post/docker/docker-dnat.jpeg" alt="docker dnat"></p><p><img src="/post/docker/docker-snat.jpeg" alt="docker snat"></p><p>进到容器内的包做DNAT，出去的包做SNAT，这样对外面来讲，根本就不知道机器内部是谁提供服务，其实这就和一个内网多个机器公用一个外网IP地址上网的效果是一样的，那这也属于NAT功能的一个常见的应用场景。</p><h2 id="Host模式"><a href="#Host模式" class="headerlink" title="Host模式"></a>Host模式</h2><p>容器内部不会创建网络空间，共享宿主机的网络空间。比如直接通过host模式创建mysql容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --net host -d --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure><p>容器启动后，会默认监听3306端口，由于网络模式是host，因为可以直接通过宿主机的3306端口进行访问服务，效果等同于在宿主机中直接启动mysqld的进程。</p><h2 id="Conatiner模式"><a href="#Conatiner模式" class="headerlink" title="Conatiner模式"></a>Conatiner模式</h2><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p><img src="/post/docker/docker-network-container.jpeg" alt="docker container网络"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动测试容器，共享mysql的网络空间</span></span><br><span class="line">$ docker run -ti --<span class="built_in">rm</span> --net=container:mysql busybox sh</span><br><span class="line">/ <span class="comment"># ip a</span></span><br><span class="line">/ <span class="comment"># netstat -tlp|grep 3306</span></span><br><span class="line">/ <span class="comment"># telnet localhost 3306</span></span><br></pre></td></tr></table></figure><p>在一些特殊的场景中非常有用，例如，kubernetes的pod，kubernetes为pod创建一个基础设施容器，同一pod下的其他容器都以container模式共享这个基础设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。</p><h2 id="None模式"><a href="#None模式" class="headerlink" title="None模式"></a>None模式</h2><p>只会创建对应的网络空间，不会配置网络堆栈（网卡、路由等）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建none的容器</span></span><br><span class="line">$ docker run -it  --name=network-none --net=none nginx:alpine sh</span><br><span class="line"><span class="comment"># ifconfig</span></span><br></pre></td></tr></table></figure><p>为了能让这个模式的docker容器能够访问外部网络，我们需要手动的创建虚拟网卡对，并将一端插入到docker0网桥中，另一端插入到容器的网络空间中。其本质就是bridge模式的实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟网卡对</span></span><br><span class="line">$ ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line"><span class="comment"># A端插入到docker0网桥</span></span><br><span class="line">$ brctl addif docker0 A</span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br><span class="line"></span><br><span class="line"><span class="comment"># B端插入到network-none容器中，需要借助ip netns,因此需要显示的创建命名network namespace</span></span><br><span class="line">$ PID=$(docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> network-none)</span><br><span class="line">$ <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ <span class="built_in">ln</span> -s /proc/<span class="variable">$PID</span>/ns/net /var/run/netns/<span class="variable">$PID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># B端放到容器的命名空间</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> B netns <span class="variable">$PID</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev B name eth0  <span class="comment"># 修改设备名称为eth0，和docker默认行为一致</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置ip</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip addr add 172.17.0.100/16 dev eth0</span><br><span class="line"><span class="comment"># 添加默认路由，指定给docker0网桥</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip route add default via 172.17.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试容器间通信</span></span><br></pre></td></tr></table></figure><p>前置知识：</p><ul><li>ip netns 命令用来管理 network namespace。它可以创建命名的 network namespace，然后通过名字来引用 network namespace</li><li>network namespace 在逻辑上是网络堆栈的一个副本，它有自己的路由、防火墙规则和网络设备。<br>默认情况下，子进程继承其父进程的 network namespace。也就是说，如果不显式创建新的 network namespace，所有进程都从 init 进程继承相同的默认 network namespace。</li><li>根据约定，命名的 network namespace 是可以打开的 <strong>&#x2F;var&#x2F;run&#x2F;netns&#x2F;</strong> 目录下的一个对象。比如有一个名称为 net1 的 network namespace 对象，则可以由打开 &#x2F;var&#x2F;run&#x2F;netns&#x2F;net1 对象产生的文件描述符引用 network namespace net1。通过引用该文件描述符，可以修改进程的 network namespace。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个容器之间是如何实现通信的呢？&lt;/li&gt;
&lt;li&gt;容器和宿主机之间又是如何实现的通信呢？&lt;/li&gt;
&lt;li&gt;使用-p参数是怎么实现的端口映射?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;带着这些问题，我们来学习一下docker的网络模型，最后我会通过抓包的方式，给大家演示一下数据包在容器和宿主机之间的转换过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://realtiger.github.io/tags/docker/"/>
    
    <category term="k8s" scheme="http://realtiger.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>docker 运行原理</title>
    <link href="http://realtiger.github.io/docker-service-running-principle/"/>
    <id>http://realtiger.github.io/docker-service-running-principle/</id>
    <published>2023-06-19T04:57:42.000Z</published>
    <updated>2023-07-07T12:05:34.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>docker优势主要是轻量级的虚拟化以及容器快速启停。</p><p>而虚拟化核心需要解决两个问题：资源隔离与资源限制</p><ul><li>虚拟机硬件虚拟化技术， 通过一个 hypervisor 层实现对资源的彻底隔离。</li><li>容器则是操作系统级别的虚拟化，利用的是内核的 Cgroup 和 Namespace 特性，此功能完全通过软件实现。</li></ul><span id="more"></span><h2 id="Namespace-资源隔离"><a href="#Namespace-资源隔离" class="headerlink" title="Namespace 资源隔离"></a>Namespace 资源隔离</h2><p>命名空间是全局资源的一种抽象，将资源放到不同的命名空间中，各个命名空间中的资源是相互隔离的。</p><table><thead><tr><th><strong>分类</strong></th><th><strong>系统调用参数</strong></th><th><strong>相关内核版本</strong></th></tr></thead><tbody><tr><td>Mount namespaces</td><td>CLONE_NEWNS</td><td><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux 2.4.19</a></td></tr><tr><td>UTS namespaces</td><td>CLONE_NEWUTS</td><td><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td></tr><tr><td>IPC namespaces</td><td>CLONE_NEWIPC</td><td><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td></tr><tr><td>PID namespaces</td><td>CLONE_NEWPID</td><td><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td></tr><tr><td>Network namespaces</td><td>CLONE_NEWNET</td><td><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td></tr><tr><td>User namespaces</td><td>CLONE_NEWUSER</td><td><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于 Linux 3.8</a></td></tr></tbody></table><p>我们知道，docker容器对于操作系统来讲其实是一个进程，我们可以通过原始的方式来模拟一下容器实现资源隔离的基本原理：</p><p>linux系统中，通常可以通过<code>clone()</code>实现进程创建的系统调用 ，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*child_func)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>child_func</strong> : 传入子进程运行的程序主函数。</li><li><strong>child_stack</strong> : 传入子进程使用的栈空间。</li><li><strong>flags</strong> : 表示使用哪些 <code>CLONE_*</code> 标志位。</li><li><strong>args</strong> : 用于传入用户参数。</li></ul><p>示例一：实现进程独立的UTS空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">  <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">  sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">  execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD , <span class="literal">NULL</span>);</span><br><span class="line">  waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行编译并测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o ns_uts ns_uts.c</span><br><span class="line">$ ./ns_uts</span><br><span class="line">$ hostname</span><br></pre></td></tr></table></figure><p>示例二：实现容器独立的进程空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">  <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line">  sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">  execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">  <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD , <span class="literal">NULL</span>);</span><br><span class="line">  waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行编译并测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o ns_pid ns_pid.c</span><br><span class="line">$ ./ns_pid</span><br><span class="line">$ <span class="built_in">echo</span> $$</span><br></pre></td></tr></table></figure><p>如何确定进程是否属于同一个namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ./ns_pid</span><br><span class="line">Parent [ 8061] - start a container!</span><br><span class="line">$ pstree -p 8061</span><br><span class="line">pid1(8061)───bash(8062)───pstree(8816)</span><br><span class="line">$ <span class="built_in">ls</span> -l /proc/8061/ns</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 net -&gt; net:[4026531968]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 uts -&gt; uts:[4026531838]</span><br><span class="line">$ <span class="built_in">ls</span> -l /proc/8062/ns</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 net -&gt; net:[4026531968]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 pid -&gt; pid:[4026534845]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 uts -&gt; uts:[4026534844]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 发现pid和uts是和父进程使用了不同的ns，其他的则是继承了父进程的命名空间</span></span><br></pre></td></tr></table></figure><p>综上：通俗来讲，docker在启动一个容器的时候，会调用Linux Kernel<br>Namespace的接口，来创建一块虚拟空间，创建的时候，可以支持设置下面这几种（可以随意选择）,docker默认都设置。</p><ul><li>pid：用于进程隔离（PID：进程ID）</li><li>net：管理网络接口（NET：网络）</li><li>ipc：管理对 IPC 资源的访问（IPC：进程间通信（信号量、消息队列和共享内存））</li><li>mnt：管理文件系统挂载点（MNT：挂载）</li><li>uts：隔离主机名和域名</li><li>user：隔离用户和用户组</li></ul><blockquote><p>linux namespace 可以支持创建进程的时候，通过参数传递（CLONE_NEW*）来确定这个新启动的进程以及进程衍生的子进程是否拥有独立的进程空间，网络空间，文件系统空间，用户空间等等。<br>docker容器对于宿主机来说，其实就是一个进程，创建容器时，给这个容器进程指定了独立的进程空间，网络空间，文件系统空间，用户空间等等，这样就实现了容器的资源隔离。</p></blockquote><h2 id="CGroup-资源限制"><a href="#CGroup-资源限制" class="headerlink" title="CGroup 资源限制"></a>CGroup 资源限制</h2><p>通过namespace可以保证容器之间的隔离，但是无法控制每个容器可以占用多少资源， 如果其中的某一个容器正在执行 CPU<br>密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题。</p><p><img src="/post/docker/cgroup.png" alt="cgroup"></p><p>Control Groups（简称 CGroups）</p><blockquote><p>cgroups是Linux内核提供的一种机制，这种机制可以根据需求吧一系列系统任务及其子任务整合(或分隔)<br>到按资源划分等级的不同组中，从而为系统资源管理提供一个统一的框架。</p></blockquote><p>CGroups能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I&#x2F;O 。每一个 CGroup<br>都是一组被相同的标准和参数限制的进程。而我们需要做的，其实就是把容器这个进程加入到指定的Cgroup中。</p><p>验证cgroup的内存限制：</p><ul><li><p>准备一个程序，每秒钟申请1MB的内存, <code>mem-allocate.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MB (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MB);</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, MB);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dM memory allocated\n&quot;</span>, ++i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建cgroup文件及脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/fs/cgroup/memory/</span><br><span class="line"><span class="built_in">mkdir</span> -p memory-process &amp;&amp; <span class="built_in">cd</span> memory-process</span><br><span class="line"><span class="built_in">echo</span> 30M &gt; memory.limit_in_bytes </span><br><span class="line">gcc mem-allocate.c -o mem-allocate</span><br></pre></td></tr></table></figure></li><li><p>准备脚本<code>cgroup-test.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> 30</span><br><span class="line">./mem-allocate</span><br></pre></td></tr></table></figure></li><li><p>用cgroup限制进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动程序</span></span><br><span class="line">./cgroup-test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看程序进程</span></span><br><span class="line">ps aux|grep cgroup-test</span><br><span class="line"><span class="built_in">echo</span> 16079 &gt; /sys/fs/cgroup/memory/memory-process/cgroup.procs</span><br></pre></td></tr></table></figure></li></ul><h2 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS 联合文件系统"></a>UnionFS 联合文件系统</h2><p>Linux namespace和cgroup分别解决了容器的资源隔离与资源限制，那么容器是很轻量的，通常每台机器中可以运行几十上百个容器，<br>这些个容器是共用一个image，还是各自将这个image复制了一份，然后各自独立运行呢？</p><p>如果每个容器之间都是全量的文件系统拷贝，那么会导致至少如下问题：</p><ul><li>运行容器的速度会变慢</li><li>容器和镜像对宿主机的磁盘空间的压力</li></ul><p>怎么解决这个问题呢？这就需要联合文件系统（UnionFS）了。</p><p>Docker使用了UnionFS的存储驱动。</p><ul><li>镜像分层存储 + 写时复制</li><li>UnionFS</li></ul><p>Docker 镜像是由一系列的层组成的，每层代表 Dockerfile 中的一条指令，比如下面的 Dockerfile 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">15.04</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> python /app/app.py</span></span><br></pre></td></tr></table></figure><p>这里的 Dockerfile 包含4条命令，其中每一行就创建了一层，下面显示了上述Dockerfile构建出来的镜像运行的容器层的结构。</p><p><img src="/post/docker/container-layers.jpg" alt="container-layers"></p><p>镜像就是由这些层一层一层堆叠起来的，镜像中的这些层都是只读的，当我们运行容器的时候，就可以在这些基础层至上添加新的可写层，也就是我们通常说的<code>容器层</code><br>，对于运行中的容器所做的所有更改（比如写入新文件、修改现有文件、删除文件）都将写入这个容器层。</p><p>对容器层的操作，主要利用了写时复制（CoW）技术。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景。<br>CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论有多少个容器共享同一个image，所做的写操作都是对从image中复制到自己的文件系统中的复本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离，相互不影响。使用CoW可以有效的提高磁盘的利用率。</p><p><img src="/post/docker/sharing-layers.jpg" alt="sharing-layers"></p><p><strong>镜像中每一层的文件都是分散在不同的目录中的，如何把这些不同目录的文件整合到一起呢？</strong></p><p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统联合到同一个挂载点的文件系统服务。它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，整个联合的过程被称为联合挂载（Union<br>Mount）。</p><p><img src="/post/docker/aufs.png" alt="aufs"></p><p>上图是AUFS的实现，AUFS是作为Docker存储驱动的一种实现，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和<br>Btrfs 等等，在最新的 Docker 中，overlay2 取代了 aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs<br>作为 Docker 的默认驱动。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h1&gt;&lt;p&gt;docker优势主要是轻量级的虚拟化以及容器快速启停。&lt;/p&gt;
&lt;p&gt;而虚拟化核心需要解决两个问题：资源隔离与资源限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机硬件虚拟化技术， 通过一个 hypervisor 层实现对资源的彻底隔离。&lt;/li&gt;
&lt;li&gt;容器则是操作系统级别的虚拟化，利用的是内核的 Cgroup 和 Namespace 特性，此功能完全通过软件实现。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://realtiger.github.io/tags/docker/"/>
    
    <category term="k8s" scheme="http://realtiger.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>sphinx - python文档生成器</title>
    <link href="http://realtiger.github.io/sphinx-python-documentation-generator/"/>
    <id>http://realtiger.github.io/sphinx-python-documentation-generator/</id>
    <published>2023-05-17T15:39:02.000Z</published>
    <updated>2023-07-07T12:08:12.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sphinx"><a href="#Sphinx" class="headerlink" title="Sphinx"></a>Sphinx</h1><p>Sphinx 是一个python第三方库，它将一组纯文本源文件转换为各种输出格式的工具，自动生成交叉引用、索引等，也就是说，如果您有一个包含 reStructuredText 或 Markdown 的源代码注释等，Sphinx可以生成一系列HTML文件、PDF文件（通过LaTeX）、手册页等等。</p><p>Sphinx专注于文档，特别是手写文档，然而，Sphinx也可以用来生成博客、主页甚至书籍。Sphinx的大部分功能来自其默认纯文本标记格式（reStructuredText）的丰富性。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先我们先安装它，使用pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sphinx</span><br></pre></td></tr></table></figure><p>安装之后可以替换主题，如果你有一个特定的主题，你可以使用pip安装它，例如，我们使用sphinx_rtd_theme主题，主题会主动安装sphinx，所以如果我们直接安装主题，上一步的安装可以省略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install sphinx_rtd_theme</span><br></pre></td></tr></table></figure><p>安装完成后可以使用命令sphinx-build查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-build --version</span><br><span class="line">sphinx-build 6.2.1</span><br></pre></td></tr></table></figure><h2 id="设置文档源"><a href="#设置文档源" class="headerlink" title="设置文档源"></a>设置文档源</h2><p>Sphinx纯文本文档源集合的根目录称为 source directory . 此目录还包含sphinx配置文件 conf.py ，在这里您可以配置Sphinx如何读取源代码和构建文档的所有方面。 </p><p>Sphinx有一个命令叫 sphinx-quickstart 设置源目录并创建默认 conf.py 从几个问题中配置最有用的配置值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sphinx-quickstart docs</span><br></pre></td></tr></table></figure><p>以下是我创建的时候的信息，其中 &gt; 表示输入，[] 表示默认值。这里可以根据需要进行设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-quickstart docs</span><br><span class="line">欢迎使用 Sphinx 6.2.1 快速配置工具。</span><br><span class="line"></span><br><span class="line">请输入接下来各项设定的值（如果方括号中指定了默认值，直接</span><br><span class="line">按回车即可使用默认值）。</span><br><span class="line"></span><br><span class="line">已选择根路径：docs</span><br><span class="line"></span><br><span class="line">有两种方式来设置用于放置 Sphinx 输出的构建目录：</span><br><span class="line">一是在根路径下创建“_build”目录，二是在根路径下创建“<span class="built_in">source</span>”</span><br><span class="line">和“build”两个独立的目录。</span><br><span class="line">&gt; 独立的源文件和构建目录（y/n） [n]: y</span><br><span class="line"></span><br><span class="line">项目名称将会出现在文档的许多地方。</span><br><span class="line">&gt; 项目名称: Lumache</span><br><span class="line">&gt; 作者名称: aaron</span><br><span class="line">&gt; 项目发行版本 []: 1.0</span><br><span class="line"></span><br><span class="line">如果用英语以外的语言编写文档，</span><br><span class="line">你可以在此按语言代码选择语种。</span><br><span class="line">Sphinx 会把内置文本翻译成相应语言的版本。</span><br><span class="line"></span><br><span class="line">支持的语言代码列表见：</span><br><span class="line">https://www.sphinx-doc.org/en/master/usage/configuration.html<span class="comment">#confval-language。</span></span><br><span class="line">&gt; 项目语种 [en]:</span><br><span class="line"></span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/source/conf.py。</span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/source/index.rst。</span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/Makefile。</span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/make.bat。</span><br><span class="line"></span><br><span class="line">完成：已创建初始目录结构。</span><br><span class="line"></span><br><span class="line">你现在可以填写主文档文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/source/index.rst 然后创建其他文档源文件了。 像这样用 Makefile 构建文档：</span><br><span class="line">  make builder</span><br><span class="line">此处的“builder”代指支持的构建器名称，比如 html、latex 或 linkcheck。</span><br></pre></td></tr></table></figure><p>全部完成之后，我们可以看到docs目录下的文件结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docs</span><br><span class="line">├── build</span><br><span class="line">├── make.bat</span><br><span class="line">├── Makefile</span><br><span class="line">└── <span class="built_in">source</span></span><br><span class="line">    ├── conf.py</span><br><span class="line">    ├── index.rst</span><br><span class="line">    ├── _static</span><br><span class="line">    └── _templates</span><br></pre></td></tr></table></figure><p>这些文件中的每个文件的目的是：</p><ul><li>build&#x2F; 一个空目录(目前)，它将保存呈现的文档。</li><li>make.bat and Makefile 方便的脚本可以简化一些常见的Sphinx操作，比如呈现内容。</li><li>source&#x2F;conf.py 保存Sphinx项目配置的一个Python脚本。它包含您为指定的项目名称和版本 sphinx-quickstart ，以及一些额外的配置密钥。</li><li>source&#x2F;index.rst 这个 root document 作为欢迎页面，并包含“目录树”的根(或 toctree )。</li></ul><p>现在运行以下命令，这样我们就可以得到一个空白的HTML文档了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-build -b html docs/source/ docs/build/html</span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在创建输出目录... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 1 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[新配置] 有 1 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] index                                                     </span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[100%] index                                                       </span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 docs/build/html 目录。</span><br></pre></td></tr></table></figure><p>然后在浏览器中打开 docs&#x2F;build&#x2F;html&#x2F;index.html ，你就可以看到一个简单的欢迎页面了。</p><p><img src="/post/sphinx/sphinx-first-show.png" alt="sphinx简单欢迎页"></p><h2 id="构建文档"><a href="#构建文档" class="headerlink" title="构建文档"></a>构建文档</h2><p>这里显示的首页就是docs&#x2F;source&#x2F;index.rst中的内容，我们可以在这里添加一些内容，然后重新构建文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.. Lumache documentation master file, created by</span><br><span class="line">   sphinx-quickstart on Mon May 22 23:33:09 2023.</span><br><span class="line">   You can adapt this file completely to your liking, but it should at least</span><br><span class="line">   contain the root `toctree` directive.</span><br><span class="line"></span><br><span class="line">Welcome to Lumache<span class="string">&#x27;s documentation!</span></span><br><span class="line"><span class="string">===================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.. toctree::</span></span><br><span class="line"><span class="string">   :maxdepth: 2</span></span><br><span class="line"><span class="string">   :caption: Contents:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**Lumache** (/lu&#x27;</span>make/) is a Python library <span class="keyword">for</span> cooks and food lovers that</span><br><span class="line">creates recipes mixing random ingredients.  It pulls data from the `Open Food</span><br><span class="line">Facts database &lt;https://world.openfoodfacts.org/&gt;`_ and offers a *simple* and</span><br><span class="line">*intuitive* API.</span><br><span class="line"></span><br><span class="line">.. note::</span><br><span class="line"></span><br><span class="line">   This project is under active development.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>它展示了reStrutiredText语法的几个功能，包括：</p><pre><code>- 使用 === 标记了一个标题- 以下两个示例的内联标记：**strong emphasis** (通常为粗体)和 *emphasis* (通常为斜体)- 一个行内的链接 (用于链接到 Open Food Facts)- 一个 note 提示</code></pre><p>现在，要使用新内容，可以使用刚才用过的 sphinx-build 命令，或者按如下方式利用make脚本生成，注意，这种方式需要系统中安装有make程序：、</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> docs</span><br><span class="line">$ make html</span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 1 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[新配置] 有 1 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] index                                                                                                                                                          </span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[100%] index                                                                                                                                                            </span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 build/html 目录。</span><br></pre></td></tr></table></figure><p>运行完成之后，再次打开docs&#x2F;build&#x2F;html&#x2F;index.html，你就可以看到新的内容了。</p><p><img src="/post/sphinx/index-new-content.png" alt="欢迎页新内容"></p><p>当然，sphinx还支持其他的文档格式，比如PDF，ePub等，这里就不再赘述了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># epub 格式生成方式</span><br><span class="line">$ make epub</span><br></pre></td></tr></table></figure><h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><p>sphinx还有很多内置的扩展来定制化功能。</p><h3 id="内置扩展"><a href="#内置扩展" class="headerlink" title="内置扩展"></a>内置扩展</h3><p>比如我们找到 docs&#x2F;source&#x2F;conf.py 添加一个扩展，这个扩展可以显示页面集成的时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docs/source/conf.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add any Sphinx extension module names here, as strings. They can be</span></span><br><span class="line"><span class="comment"># extensions coming with Sphinx (named &#x27;sphinx.ext.*&#x27;) or your custom</span></span><br><span class="line"><span class="comment"># ones.</span></span><br><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>添加扩展之后，就能在控制台输出的末尾看到页面生成的时间了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ make html</span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 0 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[扩展发生了变化 (<span class="string">&#x27;sphinx.ext.duration&#x27;</span>)] 有 1 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] index</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[100%] index</span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line"></span><br><span class="line">====================== 最长读取耗时 =======================</span><br><span class="line">0.030 index</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 build/html 目录。</span><br></pre></td></tr></table></figure><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>还记得我们在刚开始创建项目的时候，我们安装一个第三方的主题吗？这里我们可以修改 conf.py 来更换主题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The theme to use for HTML and HTML Help pages.  See the documentation for</span></span><br><span class="line"><span class="comment"># a list of builtin themes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">html_theme = <span class="string">&#x27;sphinx_rtd_theme&#x27;</span></span><br></pre></td></tr></table></figure><p>更改后，我们重新生成页面，就能看到新的主题了。</p><p>!(new theme)[&#x2F;post&#x2F;sphinx&#x2F;new-theme.png]</p><h2 id="叙事性文档"><a href="#叙事性文档" class="headerlink" title="叙事性文档"></a>叙事性文档</h2><h3 id="跨多页组织文档"><a href="#跨多页组织文档" class="headerlink" title="跨多页组织文档"></a>跨多页组织文档</h3><p>终于开始写文档了，我们可以在 docs&#x2F;source 目录下创建一个新的文件，比如 usage.rst ，然后在 index.rst 中添加一个链接到这个文件。</p><p>首先编写 usage.rst 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>这个新文件包含两个 section 页眉、普通段落文本和 code-block 指令</p><p>code-block 指令将内容块呈现为源代码，并使用适当的语法突出显示(在本例中为泛型 console 文本)。</p><p>文档的结构由一系列标题样式决定，这意味着通过使用 — 的 “Installation” 以及之后的部分，对于使用 &#x3D;&#x3D;&#x3D; 的 “Usage” 部分，您已经将 “Installation” 声明为 subsection “用法”的概念。</p><p>要为了完成显示，您还需要在 index.rst 添加一个 usage.rst 的链接，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Lumache&#x27;s documentation!</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   usage</span><br><span class="line">   </span><br><span class="line">**Lumache** (/lu&#x27;make/) is a Python library for cooks and food lovers that</span><br><span class="line">creates recipes mixing random ingredients.  It pulls data from the `Open Food</span><br><span class="line">Facts database &lt;https://world.openfoodfacts.org/&gt;`_ and offers a *simple* and</span><br><span class="line">*intuitive* API.</span><br><span class="line"></span><br><span class="line">.. note::</span><br><span class="line"></span><br><span class="line">   This project is under active development.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>更新页面，就能看到新的内容了。</p><blockquote><p>警告</p><p>外部文档 toctree 将导致 WARNING: document isn’t included in any toctree 消息，并且用户将无法访问。</p></blockquote><p><img src="/post/sphinx/doc-link01.png" alt="跨多页组织链接01"></p><p><img src="/post/sphinx/doc-link02.png" alt="跨多页组织链接02"></p><h3 id="添加交叉引用"><a href="#添加交叉引用" class="headerlink" title="添加交叉引用"></a>添加交叉引用</h3><p>Sphinx的一个强大功能是能够无缝地添加 cross-references 文档的特定部分：文档、章节、图形、代码对象等。</p><p>要添加交叉引用，请将这句话添加到 index.rst 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.. Lumache documentation master file, created by</span><br><span class="line">   sphinx-quickstart on Mon May 22 23:33:09 2023.</span><br><span class="line">   You can adapt this file completely to your liking, but it should at least</span><br><span class="line">   contain the root `toctree` directive.</span><br><span class="line"></span><br><span class="line">Welcome to Lumache&#x27;s documentation!</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   usage</span><br><span class="line"></span><br><span class="line">Check out the :doc:`usage` section for further information.</span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>这个 doc 会自动引用项目中的特定文档，在本例中为 usage.rst 。</p><p>当然也可以添加对项目任意部分的交叉引用。为此，需要使用 ref 角色，并添加显式 label ，它的作用就是 a target 。</p><p>例如，修改 usage.rst 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br></pre></td></tr></table></figure><p>并且将 label 添加到 index.rst 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.. Lumache documentation master file, created by</span><br><span class="line">   sphinx-quickstart on Mon May 22 23:33:09 2023.</span><br><span class="line">   You can adapt this file completely to your liking, but it should at least</span><br><span class="line">   contain the root `toctree` directive.</span><br><span class="line"></span><br><span class="line">Welcome to Lumache&#x27;s documentation!</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   usage</span><br><span class="line"></span><br><span class="line">Check out the :doc:`usage` section for further information, including how to</span><br><span class="line">:ref:`install &lt;installation&gt;` the project.</span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>重新生成页面，就能看到新的内容了。</p><h2 id="使用Sphinx描述代码"><a href="#使用Sphinx描述代码" class="headerlink" title="使用Sphinx描述代码"></a>使用Sphinx描述代码</h2><h3 id="记录Python对象"><a href="#记录Python对象" class="headerlink" title="记录Python对象"></a>记录Python对象</h3><p>Sphinx提供了几个角色和指令来记录Python对象，所有这些对象都集中在 <a href="https://www.osgeo.cn/sphinx/usage/restructuredtext/domains.html#python-domain">the Python domain</a> 。例如，可以使用 py:function 指令来记录一个Python函数，这里我们修改usage.rst，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br></pre></td></tr></table></figure><p><img src="/post/sphinx/describing-code01.png" alt="python对象描述"></p><p>请注意以下几点：</p><ul><li>Sphinx解析了 .. py:function 指令，并相应地突出显示模块、函数名和参数。</li><li>指令内容包括对该函数的一行描述，以及 info field list 包含函数参数、其预期类型、返回值和返回类型。</li></ul><blockquote><p>备注</p><p>这个 py: 前缀指定 domain 。您可以配置默认域，以便可以省略前缀，或者全局使用 primary_domain 配置，或使用 default-domain 指令将其从被调用的位置更改到文件的末尾。例如，如果将其设置为 py (默认设置)，您可以编写 .. function:: 直接去吧。</p></blockquote><h3 id="交叉引用Python对象"><a href="#交叉引用Python对象" class="headerlink" title="交叉引用Python对象"></a>交叉引用Python对象</h3><p>默认情况下，这些指令中的大多数生成可以从文档的任何部分交叉引用的实体 (a corresponding role)[<a href="https://www.osgeo.cn/sphinx/usage/restructuredtext/domains.html#python-roles]">https://www.osgeo.cn/sphinx/usage/restructuredtext/domains.html#python-roles]</a> 。对于函数，可以使用 py:func，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br></pre></td></tr></table></figure><p>在生成代码文档时，Sphinx只使用对象的名称自动生成交叉引用，而不必显式使用角色，页面表现为一个链接跳转。</p><p>我们也可以使用属性来描述函数引发的自定义异常，比如py:exception 指令：</p><p>首先定义一个异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.. py:exception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">   Raised if the kind is invalid.</span><br></pre></td></tr></table></figure><p>然后在函数的原始描述中引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :raise lumache.InvalidKindError: If the kind is invalid.</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br></pre></td></tr></table></figure><p>usage.rst 完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :raise lumache.InvalidKindError: If the kind is invalid.</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br><span class="line"></span><br><span class="line">.. py:exception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">   Raised if the kind is invalid.</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br></pre></td></tr></table></figure><p>重新更新页面，等待构建完成，就可以看到新的效果了，效果如下所示。</p><p><img src="/post/sphinx/describing-code02.png" alt="python异常描述"></p><h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><p>Sphinx 不仅提供了一种在文档中编写代码示例的方法，还提供了在文档中编写测试的方法。</p><p>这些测试可以在构建文档时运行，以确保文档中的示例代码仍然有效。这些测试称为文档测试，它们使用 <a href="https://docs.python.org/3/library/doctest.html">doctest</a> 模块。</p><p>对于代码描述和正常的代码实现逻辑保持一致是很重要的。在Sphinx中实现这一点的方法之一是在文档中包含代码片段，称为 doctests ，在构建文档时执行。</p><p>要显示这个功能，需要 Sphinx 需要能够导入代码。为了要做到这一点，请在 conf.py 中头部添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If extensions (or modules to document with autodoc) are in another directory,</span></span><br><span class="line"><span class="comment"># add these directories to sys.path here.</span></span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, pathlib.Path(__file__).parents[<span class="number">2</span>].resolve().as_posix())</span><br></pre></td></tr></table></figure><p>这句话的意思是，将项目的根目录添加到 sys.path 中，这样就可以将项目根目录添加到 python 的查找路径，以便在 Sphinx 中执行 Python 命令可以导入项目中的任何模块。</p><blockquote><p>备注</p><p>一种替代更改 sys.path 变量的目的是创建一个 pyproject.toml 文件，并使代码可安装，这样它的行为就像任何其他的Python库一样。然而， sys.path 方法更简单。</p></blockquote><p>然后，再启用 doctest 功能，需要在 conf.py 中添加扩展：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>整体的 conf.py 文件内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ cat source/conf.py</span><br><span class="line"><span class="comment"># Configuration file for the Sphinx documentation builder.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For the full list of built-in configuration values, see the documentation:</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If extensions (or modules to document with autodoc) are in another directory,</span></span><br><span class="line"><span class="comment"># add these directories to sys.path here.</span></span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, pathlib.Path(__file__).parents[<span class="number">2</span>].resolve().as_posix())</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Project information -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information</span></span><br><span class="line"></span><br><span class="line">project = <span class="string">&#x27;Lumache&#x27;</span></span><br><span class="line">copyright = <span class="string">&#x27;2023, aaron&#x27;</span></span><br><span class="line">author = <span class="string">&#x27;aaron&#x27;</span></span><br><span class="line">release = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- General configuration ---------------------------------------------------</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration</span></span><br><span class="line"></span><br><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">templates_path = [<span class="string">&#x27;_templates&#x27;</span>]</span><br><span class="line">exclude_patterns = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Options for HTML output -------------------------------------------------</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output</span></span><br><span class="line"></span><br><span class="line">html_theme = <span class="string">&#x27;sphinx_rtd_theme&#x27;</span></span><br><span class="line">html_static_path = [<span class="string">&#x27;_static&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在 source&#x2F;usage.rst 文件中添加一个 doctest 块，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import lumache</span><br><span class="line">&gt;&gt;&gt; lumache.get_random_ingredients()</span><br><span class="line">[&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br></pre></td></tr></table></figure><p>这里我将测试块添加到最后，你也可以根据需要在对应的位置进行添加，整体的 usage.rst 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :raise lumache.InvalidKindError: If the kind is invalid.</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br><span class="line"></span><br><span class="line">.. py:exception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">   Raised if the kind is invalid.</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import lumache</span><br><span class="line">&gt;&gt;&gt; lumache.get_random_ingredients()</span><br><span class="line">[&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br></pre></td></tr></table></figure><p>doctest 包括要运行的 Python 指令，前面有 &gt;&gt;&gt; 标准的 Python 解释器提示符，以及每条指令的预期输出。通过这种方式，Sphinx 可以检查实际输出是否与预期输出匹配。</p><p>为了观察 doctest 失败是什么样子(而不是上面的代码错误)，让我们首先不正确地编写返回值。在项目根目录（也就是docs的上级目录）中创建一个 lumache.py 文件，文件内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_ingredients</span>(<span class="params">kind=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a list of random ingredients as strings.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;bacon&quot;</span>, <span class="string">&quot;spam&quot;</span>]</span><br></pre></td></tr></table></figure><p>现在可以运行测试语句来执行文档的测试，显然，这个测试会失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有make程序也可以使用这个语句进行测试 sphinx-build -b doctest <span class="built_in">source</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make doctest</span></span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在创建输出目录... 完成</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [doctest]： 2 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[扩展发生了变化 (&#x27;sphinx.ext.doctest&#x27;)] 有 2 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[ 50%] index</span><br><span class="line">正在读取源文件……[100%] usage</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">running tests...</span><br><span class="line"></span><br><span class="line">Document: usage</span><br><span class="line">---------------</span><br><span class="line">**********************************************************************</span><br><span class="line">File &quot;usage.rst&quot;, line 42, in default</span><br><span class="line">Failed example:</span><br><span class="line">    lumache.get_random_ingredients()</span><br><span class="line">Expected:</span><br><span class="line">    [&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br><span class="line">Got:</span><br><span class="line">    [&#x27;eggs&#x27;, &#x27;bacon&#x27;, &#x27;spam&#x27;]</span><br><span class="line">**********************************************************************</span><br><span class="line">1 items had failures:</span><br><span class="line">   1 of   2 in default</span><br><span class="line">2 tests in 1 items.</span><br><span class="line">1 passed and 1 failed.</span><br><span class="line">***Test Failed*** 1 failures.</span><br><span class="line"></span><br><span class="line">Doctest summary</span><br><span class="line">===============</span><br><span class="line">    2 tests</span><br><span class="line">    1 failure in tests</span><br><span class="line">    0 failures in setup code</span><br><span class="line">    0 failures in cleanup code</span><br><span class="line"></span><br><span class="line">====================== 最长读取耗时 =======================</span><br><span class="line">0.030 usage</span><br><span class="line">0.027 index</span><br><span class="line">构建完成但存在问题。</span><br><span class="line">make: *** [Makefile:20：doctest] 错误 1</span><br></pre></td></tr></table></figure><p>现在，我们将代码进行修改，使其通过测试，修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_ingredients</span>(<span class="params">kind=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a list of random ingredients as strings.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;shells&quot;</span>, <span class="string">&quot;gorgonzola&quot;</span>, <span class="string">&quot;parsley&quot;</span>]</span><br></pre></td></tr></table></figure><p>再次运行测试，可以看到测试通过了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [doctest]： 2 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：有 0 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">running tests...</span><br><span class="line"></span><br><span class="line">Document: usage</span><br><span class="line">---------------</span><br><span class="line">1 items passed all tests:</span><br><span class="line">   2 tests in default</span><br><span class="line">2 tests in 1 items.</span><br><span class="line">2 passed and 0 failed.</span><br><span class="line">Test passed.</span><br><span class="line"></span><br><span class="line">Doctest summary</span><br><span class="line">===============</span><br><span class="line">    2 tests</span><br><span class="line">    0 failures in tests</span><br><span class="line">    0 failures in setup code</span><br><span class="line">    0 failures in cleanup code</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">已完成源文件的文档测试，结果保存在 build/doctest/output.txt 中，请查阅。</span><br></pre></td></tr></table></figure><h2 id="自动生成文档"><a href="#自动生成文档" class="headerlink" title="自动生成文档"></a>自动生成文档</h2><p>Sphinx 可以根据代码中的 docstring 自动生成文档，这样可以减少文档的编写工作量，同时也可以保证文档与代码的一致性。</p><h3 id="文档字符串自动生成文档"><a href="#文档字符串自动生成文档" class="headerlink" title="文档字符串自动生成文档"></a>文档字符串自动生成文档</h3><p>要使用这个功能，需要先启动 Sphinx 的 autodoc 扩展。在 conf.py 文件中添加如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.autodoc&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接下来我们先将 lumache.py 文件中的代码进行修改，添加一个异常类以及函数的docstring，修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InvalidKindError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Raised if the kind is invalid.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_ingredients</span>(<span class="params">kind=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return a list of random ingredients as strings.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param kind: Optional &quot;kind&quot; of ingredients.</span></span><br><span class="line"><span class="string">    :type kind: list[str] or None</span></span><br><span class="line"><span class="string">    :raise lumache.InvalidKindError: If the kind is invalid.</span></span><br><span class="line"><span class="string">    :return: The ingredients list.</span></span><br><span class="line"><span class="string">    :rtype: list[str]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;shells&quot;</span>, <span class="string">&quot;gorgonzola&quot;</span>, <span class="string">&quot;parsley&quot;</span>]</span><br></pre></td></tr></table></figure><p>然后，将 .. py:function 和 .. py:exception 标记指向原始的 python 文件，使用自动生成字段 autofunction 、 autoexception 添加到文档中，这样 Sphinx 就会自动将这些内容添加到文档中。</p><p>修改后的 usage.rst 文档如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. autofunction:: lumache.get_random_ingredients</span><br><span class="line"></span><br><span class="line">.. autoexception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import lumache</span><br><span class="line">&gt;&gt;&gt; lumache.get_random_ingredients()</span><br><span class="line">[&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br></pre></td></tr></table></figure><p>现在，运行 make html 命令，可以看到文档中已经包含了我们添加的内容，和之前手写的文档没有什么不同：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make html</span></span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 0 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：有 0 个新增文件，有 1 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] usage</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[ 50%] index</span><br><span class="line">正在写入输出……[100%] usage</span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line"></span><br><span class="line">====================== 最长读取耗时 =======================</span><br><span class="line">0.049 usage</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 build/html 目录。</span><br></pre></td></tr></table></figure><p><img src="/post/sphinx/autodoc.png" alt="使用签名和文档字符串自动生成文档"></p><h3 id="生成全面的API参考"><a href="#生成全面的API参考" class="headerlink" title="生成全面的API参考"></a>生成全面的API参考</h3><p>在使用时 sphinx.ext.autodoc 使代码和文档保持同步变得容易得多，但它仍然需要您编写 auto* 指令为您要记录的每个对象指定。Sphinx提供了另一个级别的自动化： autosummary 。</p><p>这个 autosummary 指令生成的文档包含所有使用 autodoc 指令的地方。</p><p>要使用它，需要先启用扩展：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.autodoc&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.autosummary&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着，创建一个新的 rst 文件，命名为 api.rst ，并添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">API reference</span><br><span class="line">=============</span><br><span class="line">.. autosummary::</span><br><span class="line">   :toctree: _autosummary</span><br><span class="line"></span><br><span class="line">   lumache.get_random_ingredients</span><br><span class="line">   lumache.InvalidKindError</span><br></pre></td></tr></table></figure><p>别忘了将 api.rst 文件添加到 index.rst 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   installation</span><br><span class="line">   usage</span><br><span class="line">   api</span><br></pre></td></tr></table></figure><p>最后，在构建完运行 make html ，它将包含两个新页面：</p><ul><li>api.html ，对应于 docs&#x2F;source&#x2F;api.rst 并包含一个表，其中包含您在 autosummary 指令(在本例中，只有一个)。</li><li>generated&#x2F;lumache.html ，对应于自动创建的文件 generated&#x2F;lumache.rst 并包含模块成员的摘要，在本例中为一个函数和一个异常。</li></ul><p>摘要页面中的每个链接都会将您带到您最初使用相应 autodoc 指令，在本例中为 usage.rst 文件。</p><p><img src="/post/sphinx/autosummary.png" alt="自动生成摘要首页"></p><p><img src="/post/sphinx/autosummary_api.png" alt="自动生成摘要api"></p><p><img src="/post/sphinx/autosummary_lumache.png" alt="自动生成摘要lumache"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了 Sphinx 的基本用法，包括安装、配置、使用、自定义主题、自动化文档生成等。Sphinx 是一个非常强大的文档生成工具，可以帮助我们快速生成文档，提高文档的质量，减少文档的维护成本。</p><p>主要的内容均来自于 Sphinx 官方文档中的 《使用sphinx》一节，本文只是对官方文档的一个简单翻译和总结，希望能够帮助到大家。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.sphinx-doc.org/en/master/">Sphinx官方文档</a></li><li><a href="https://www.sphinx-doc.org/zh_CN/master/">Sphinx官方文档中文版</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Sphinx&quot;&gt;&lt;a href=&quot;#Sphinx&quot; class=&quot;headerlink&quot; title=&quot;Sphinx&quot;&gt;&lt;/a&gt;Sphinx&lt;/h1&gt;&lt;p&gt;Sphinx 是一个python第三方库，它将一组纯文本源文件转换为各种输出格式的工具，自动生成交叉引用、索引等，也就是说，如果您有一个包含 reStructuredText 或 Markdown 的源代码注释等，Sphinx可以生成一系列HTML文件、PDF文件（通过LaTeX）、手册页等等。&lt;/p&gt;
&lt;p&gt;Sphinx专注于文档，特别是手写文档，然而，Sphinx也可以用来生成博客、主页甚至书籍。Sphinx的大部分功能来自其默认纯文本标记格式（reStructuredText）的丰富性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://realtiger.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>centos8 升级 python 版本</title>
    <link href="http://realtiger.github.io/centos8-python-upgrade/"/>
    <id>http://realtiger.github.io/centos8-python-upgrade/</id>
    <published>2023-05-12T13:11:03.000Z</published>
    <updated>2023-05-12T13:12:42.913Z</updated>
    
    <content type="html"><![CDATA[<p>经常遇到给linux升级python的需求，这里记录一下</p><p>linux版本：centos8</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"># init</span><br><span class="line"># 修改centos8的yum源</span><br><span class="line">find /etc/yum.repos.d/ -type f | xargs -i sed -i &#x27;s#http://mirror.centos.org/$contentdir/$releasever/#https://mirrors.aliyun.com/centos/8-stream/#g&#x27; &#123;&#125;</span><br><span class="line"></span><br><span class="line">sudo sed -i &#x27;s/SELINUX=\w*/SELINUX=disabled/&#x27; /etc/selinux/config</span><br><span class="line">sudo dnf -y install epel-release</span><br><span class="line">sudo dnf install -y bash-com* bzip2-devel bind-utils cmake dkms dos2unix drpm expect gcc gcc-c++ gdb gdm git kernel-devel kernel-headers libffi libffi-devel lrzsz make ncurses-devel nfs-utils nmap openssl-devel rsync sqlite-devel sysstat tar telnet tmux traceroute tree unzip vim wget yum-utils zlib-devel xz-devel</span><br><span class="line">sudo touch /etc/profile.d/custom.sh</span><br><span class="line"></span><br><span class="line"># 安装rust</span><br><span class="line">sudo curl https://sh.rustup.rs -sSf | sh</span><br><span class="line"></span><br><span class="line"># 安装python</span><br><span class="line">python_version=&quot;3.9.1&quot;</span><br><span class="line">wget https://www.python.org/ftp/python/$&#123;python_version&#125;/Python-$&#123;python_version&#125;.tar.xz</span><br><span class="line">sudo dnf install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel gcc libffi make libffi-devel -y</span><br><span class="line">tar Jxvf Python-$&#123;python_version&#125;.tar.xz</span><br><span class="line">cd Python-$&#123;python_version&#125;/</span><br><span class="line">sudo ./configure --prefix=/usr/local/python3 --enable-shared  --enable-optimizations --with-ssl</span><br><span class="line">sudo make</span><br><span class="line">sudo make altinstall</span><br><span class="line"></span><br><span class="line">sudo bash -c &#x27;echo &quot;/usr/local/python3/lib&quot; &gt; /etc/ld.so.conf.d/python3.conf&#x27;</span><br><span class="line">sudo ldconfig</span><br><span class="line">sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python</span><br><span class="line">sudo ln -s /usr/local/python3/bin/pip3 /usr/bin/pip</span><br><span class="line">python -V</span><br><span class="line">pip -V</span><br><span class="line"></span><br><span class="line">user=&quot;aaron&quot;</span><br><span class="line">home_path=&quot;/home/$&#123;user&#125;/&quot;</span><br><span class="line">root_path=&quot;/root/&quot;</span><br><span class="line"></span><br><span class="line">sudo bash -c &#x27;echo -e &quot;[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n&quot; &gt; /etc/pip.conf&#x27;</span><br><span class="line">sudo pip install --upgrade pip</span><br><span class="line">sudo pip install ipython</span><br><span class="line">sudo ln -s /usr/local/python3/bin/ipython /usr/bin/</span><br><span class="line">sudo pip install virtualenv</span><br><span class="line">sudo ln -s /usr/local/python3/bin/virtualenv /usr/bin/</span><br><span class="line">sudo pip install virtualenvwrapper</span><br><span class="line">sudo ln -s /usr/local/python3/bin/virtualenvwrapper /usr/bin/</span><br><span class="line">sudo mkdir $&#123;home_path&#125;.virtualenvs $&#123;root_path&#125;.virtualenvs</span><br><span class="line">grep -q &#x27;^if \[ ! -d &quot;$HOME/.virtualenvs&quot; ];then$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;if [ ! -d \&quot;\$HOME/.virtualenvs\&quot; ];then\n  mkdir \$HOME/.virtualenvs\nfi&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^export WORKON_HOME=$HOME/.virtualenvs$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;export WORKON_HOME=\$HOME/.virtualenvs&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^export PROJECT_HOME=$HOME/.workspaces$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;export PROJECT_HOME=\$HOME/.workspaces&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^source /usr/local/python3/bin/virtualenvwrapper.sh$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;source /usr/local/python3/bin/virtualenvwrapper.sh&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line"></span><br><span class="line"># vimrc</span><br><span class="line">sudo mkdir -p $&#123;home_path&#125;.undodir $&#123;root_path&#125;.undodir $&#123;home_path&#125;.vim $&#123;root_path&#125;.vim</span><br><span class="line">sudo chown -R $&#123;user&#125;: $&#123;home_path&#125;</span><br><span class="line"># 参考vimrc</span><br><span class="line">vim  $&#123;home_path&#125;.vim/vimrc</span><br><span class="line">sudo cp  $&#123;home_path&#125;.vim/vimrc $&#123;root_path&#125;.vim/</span><br><span class="line">grep -q &#x27;^export EDITOR=/usr/bin/vim$&#x27; /etc/profile.d/custom.sh &amp;&amp; sudo sed -i &#x27;s/^export EDITOR.*$/export EDITOR=/usr/bin/vim/&#x27; /etc/profile.d/custom.sh || sudo bash -c &#x27;echo &quot;EDITOR=/usr/bin/vim/&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^if \[ ! -d &quot;$HOME/.undodir&quot; ];then$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;if [ ! -d \&quot;\$HOME/.undodir\&quot; ];then\n  mkdir \$HOME/.undodir\nfi\n&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line"># 参考init.sh</span><br><span class="line">sudo vim /etc/init.sh</span><br><span class="line">ln -s /etc/init.sh $&#123;home_path&#125;.init.sh</span><br><span class="line">sudo ln -s /etc/init.sh $&#123;root_path&#125;.init.sh</span><br><span class="line">grep -q &#x27;^if \[ -f ~/.init.sh ]; then$&#x27; $&#123;home_path&#125;.bash_profile || sh -c &#x27;echo -e &quot;if [ -f ~/.init.sh ]; then\n    . ~/.init.sh login\nfi\n&quot; &gt;&gt; $&#123;home_path&#125;.bash_profile&#x27;</span><br><span class="line">sudo grep -q &#x27;^if \[ -f ~/.init.sh ]; then$&#x27; $&#123;root_path&#125;.bash_profile || sudo sh -c &#x27;echo -e &quot;if [ -f ~/.init.sh ]; then\n    . ~/.init.sh login\nfi\n&quot; &gt;&gt; $&#123;root_path&#125;.bash_profile&#x27;</span><br><span class="line"># 参考ssh_banner</span><br><span class="line">sudo vim /etc/ssh_banner</span><br><span class="line">sudo grep -q &#x27;^Banner .*$&#x27; /etc/ssh/sshd_config || sudo sh -c &#x27;echo -e &quot;Banner /etc/ssh_banner&quot; &gt;&gt; /etc/ssh/sshd_config&#x27;</span><br><span class="line"></span><br><span class="line"># docker</span><br><span class="line">sudo dnf remove docker docker-common docker-selinux docker-engine -y</span><br><span class="line">sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo dnf install device-mapper-persistent-data lvm2 -y</span><br><span class="line">sudo dnf install docker-ce --nobest -y</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo usermod -aG docker $&#123;user&#125;</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"># 注意修改权限</span><br><span class="line">sudo chown -R $&#123;user&#125;: $&#123;home_path&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo pip install jupyter</span><br><span class="line">ll $&#123;home_path&#125;.jupyter/jupyter_notebook_config.py</span><br><span class="line">sudo ln -s /usr/local/python3/bin/jupyter-notebook /usr/bin/</span><br><span class="line">jupyter-notebook --generate-config</span><br><span class="line">mkdir -p $&#123;home_path&#125;project/ipython</span><br><span class="line">vim $&#123;home_path&#125;.jupyter/jupyter_notebook_config.py</span><br><span class="line">    c.NotebookApp.ip = &#x27;192.168.100.10&#x27;</span><br><span class="line">    c.NotebookApp.notebook_dir = &#x27;/home/aaron/project/ipython&#x27;</span><br><span class="line">    c.NotebookApp.open_browser = False</span><br><span class="line">    # jupyter</span><br><span class="line">    c.NotebookApp.password = &#x27;argon2:$argon2id$v=19$m=10240,t=10,p=8$ZyZnmpT3p/nmdXpgVV3mQw$JWkHVEJos0t/XQNix9uwvQ&#x27;</span><br><span class="line">    c.NotebookApp.password_required = True</span><br><span class="line">    c.NotebookApp.port = 8880</span><br><span class="line">    </span><br><span class="line"># 添加系统systemd</span><br><span class="line">sudo vim /usr/lib/systemd/system/jupyter-notebook.service</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经常遇到给linux升级python的需求，这里记录一下&lt;/p&gt;
&lt;p&gt;linux版本：centos8&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://realtiger.github.io/tags/python/"/>
    
    <category term="linux" scheme="http://realtiger.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>docker file</title>
    <link href="http://realtiger.github.io/docker-file/"/>
    <id>http://realtiger.github.io/docker-file/</id>
    <published>2023-05-10T17:54:58.000Z</published>
    <updated>2023-05-14T11:50:31.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile介绍"><a href="#Dockerfile介绍" class="headerlink" title="Dockerfile介绍"></a>Dockerfile介绍</h1><p>Dockerfile是一堆指令，在docker build的时候，按照该指令进行操作，最终生成我们期望的镜像</p><span id="more"></span><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><ul><li><p>FROM 指定基础镜像，必须为第一个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  FROM &lt;image&gt;</span><br><span class="line">  FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">示例：</span><br><span class="line">  FROM mysql:5.7</span><br><span class="line">注意：</span><br><span class="line">  tag是可选的，如果不使用tag时，会使用latest版本的基础镜像</span><br></pre></td></tr></table></figure></li><li><p>MAINTAINER 镜像维护者的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  MAINTAINER &lt;name&gt;</span><br><span class="line">示例：</span><br><span class="line">  MAINTAINER Yongxin Li</span><br><span class="line">  MAINTAINER inspur_lyx@hotmail.com</span><br><span class="line">  MAINTAINER Yongxin Li &lt;inspur_lyx@hotmail.com&gt;</span><br></pre></td></tr></table></figure><p>查看镜像的MAINTAINER</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 通过docker inspect命令查看镜像Author的值。</span><br><span class="line"></span><br><span class="line">docker inspect -f &#123;&#123;&quot;.Author&quot;&#125;&#125; &lt;镜像ID&gt;</span><br></pre></td></tr></table></figure></li><li><p>LABEL 镜像元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line">示例：</span><br><span class="line">  LABEL &quot;email&quot;=&quot;Securitit@13.com&quot;</span><br><span class="line">  LABEL email-host=&quot;www.host.com&quot;</span><br><span class="line">  LABEL email-version=&quot;1.0&quot;</span><br><span class="line">  LABEL email-description=&quot;This is my \</span><br><span class="line">        persional email.&quot;</span><br><span class="line">  LABEL multi.label-1=&quot;value-1&quot; multi.label-2=&quot;value-2&quot; multi.label-3=&quot;value-3&quot;</span><br><span class="line">  LABEL multi.label-4=&quot;value-4&quot; \</span><br><span class="line">        multi.label-5=&quot;value-5&quot; \</span><br><span class="line">        multi.label-6=&quot;value-6&quot;</span><br></pre></td></tr></table></figure><ul><li>基础镜像或父镜像中包含的元数据由当前镜像继承。如果元数据已经存在，但具有不同的值，则最近应用的值将覆盖以前设置的任何值。</li><li>可以使用LABEL maintainer&#x3D;”xxx”代替MAINTAINER xxx，两者设置的值，在镜像的描述文件中所处位置是不一样的。<ul><li>MAINTAINER xxx位于顶层Author属性中。</li><li>LABEL maintainer&#x3D;”xxx”位于Config.Labels.maintainer属性中，查看镜像的 LABEL <code>docker inspect -f &#123;&#123;".Config.Labels"&#125;&#125; &lt;镜像ID&gt;</code></li></ul></li><li>MAINTAINER已经过时，在新版本已不推荐使用，推荐使用LABEL完成元数据设置。</li></ul></li><li><p>COPY|ADD 添加本地文件到镜像中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">示例：</span><br><span class="line">  ADD hom* /mydir/          # 添加所有以&quot;hom&quot;开头的文件</span><br><span class="line">  ADD test relativeDir/     # 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/</span><br><span class="line">  ADD test /absoluteDir/    # 添加 &quot;test&quot; 到 /absoluteDir/</span><br></pre></td></tr></table></figure></li><li><p>WORKDIR 工作目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  WORKDIR /path/to/workdir</span><br><span class="line">示例：</span><br><span class="line">  WORKDIR /a  (这时工作目录为/a)</span><br><span class="line">注意：</span><br><span class="line">  通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行</span><br></pre></td></tr></table></figure></li><li><p>RUN 构建镜像过程中执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  RUN &lt;command&gt;</span><br><span class="line">示例：</span><br><span class="line">  RUN yum install nginx</span><br><span class="line">  RUN pip install django</span><br><span class="line">  RUN mkdir test &amp;&amp; rm -rf /var/lib/unusedfiles</span><br><span class="line">注意：</span><br><span class="line">  RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</span><br></pre></td></tr></table></figure></li><li><p>CMD 构建容器后调用，也就是在容器启动时才进行调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (执行可执行文件，优先)</span><br><span class="line">  CMD [&quot;param1&quot;,&quot;param2&quot;] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)</span><br><span class="line">  CMD command param1 param2 (执行shell内部命令)</span><br><span class="line">示例：</span><br><span class="line">  CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</span><br><span class="line">  CMD ping www.baidu.com</span><br><span class="line">注意：</span><br><span class="line">  CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</span><br></pre></td></tr></table></figure></li><li><p>ENTRYPOINT 设置容器初始化命令，使其可执行化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (可执行文件, 优先)</span><br><span class="line">  ENTRYPOINT command param1 param2 (shell内部命令)</span><br><span class="line">示例：</span><br><span class="line">  ENTRYPOINT [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</span><br><span class="line">注意：</span><br><span class="line">  ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令</span><br></pre></td></tr></table></figure></li><li><p>ENV</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">  ENV &lt;key&gt;=&lt;value&gt;</span><br><span class="line">示例：</span><br><span class="line">  ENV myName John</span><br><span class="line">  ENV myCat=fluffy</span><br></pre></td></tr></table></figure></li><li><p>EXPOSE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line">示例：</span><br><span class="line">  EXPOSE 80 443</span><br><span class="line">  EXPOSE 8080</span><br><span class="line">  EXPOSE 11211/tcp 11211/udp</span><br><span class="line">注意：</span><br><span class="line">  EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口</span><br></pre></td></tr></table></figure></li></ul><h2 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h2><ul><li><p>基础环境镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --update ca-certificates &amp;&amp; <span class="built_in">rm</span> -rf /var/cache/apk/* &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  find /usr/share/ca-certificates/mozilla/ -name <span class="string">&quot;*.crt&quot;</span> -<span class="built_in">exec</span> keytool -import -trustcacerts \</span></span><br><span class="line"><span class="language-bash">  -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts -storepass changeit -noprompt \</span></span><br><span class="line"><span class="language-bash">  -file &#123;&#125; -<span class="built_in">alias</span> &#123;&#125; \; &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  keytool -list -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts --storepass changeit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> MAVEN_VERSION <span class="number">3.5</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">ENV</span> MAVEN_HOME /usr/lib/mvn</span><br><span class="line"><span class="keyword">ENV</span> PATH $MAVEN_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget http://archive.apache.org/dist/maven/maven-3/<span class="variable">$MAVEN_VERSION</span>/binaries/apache-maven-<span class="variable">$MAVEN_VERSION</span>-bin.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  tar -zxvf apache-maven-<span class="variable">$MAVEN_VERSION</span>-bin.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  <span class="built_in">rm</span> apache-maven-<span class="variable">$MAVEN_VERSION</span>-bin.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  <span class="built_in">mv</span> apache-maven-<span class="variable">$MAVEN_VERSION</span> /usr/lib/mvn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span></span><br></pre></td></tr></table></figure></li><li><p>前端镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.19</span>.<span class="number">0</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;mritd &lt;mritd@linux.com&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> TZ=<span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="keyword">ENV</span> TZ $&#123;TZ&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk upgrade --update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add bash tzdata curl wget ca-certificates \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">ln</span> -sf /usr/share/zoneinfo/<span class="variable">$&#123;TZ&#125;</span> /etc/localtime \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;TZ&#125;</span> &gt; /etc/timezone \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /usr/share/nginx/html /var/cache/apk/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> dist /usr/share/nginx/html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">443</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>java镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>u111</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS <span class="string">&quot;\</span></span><br><span class="line"><span class="string">-Xmx4096m \</span></span><br><span class="line"><span class="string">-XX:MetaspaceSize=256m \</span></span><br><span class="line"><span class="string">-XX:MaxMetaspaceSize=256m&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/java/jdk</span><br><span class="line"><span class="keyword">ENV</span> PATH $&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/myapp.jar myapp.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> java <span class="variable">$&#123;JAVA_OPTS&#125;</span> -jar myapp.jar</span></span><br></pre></td></tr></table></figure></li><li><p>golang镜像</p><p>使用多阶段构建，请查看本文下面出现的《多阶段构建》章节。</p></li></ul><h2 id="1号进程"><a href="#1号进程" class="headerlink" title="1号进程"></a>1号进程</h2><p>接下来通过1号进程理解容器的本质</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it nginx:1.19.0-alpine /bin/sh</span><br><span class="line"><span class="comment">#/ ps aux</span></span><br></pre></td></tr></table></figure><p>容器启动的时候可以通过命令去覆盖默认的CMD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name xxx nginx:alpine &lt;自定义命令&gt;</span><br><span class="line"><span class="comment"># &lt;自定义命令&gt;会覆盖镜像中指定的CMD指令，作为容器的1号进程启动。</span></span><br><span class="line"></span><br><span class="line">$ docker run -d --name test-3 nginx:alpine <span class="built_in">echo</span> 123</span><br><span class="line"></span><br><span class="line">$ docker run -d --name test-4 nginx:alpine ping www.baidu.com</span><br></pre></td></tr></table></figure><p>本质上讲容器是利用namespace和cgroup等技术在宿主机中创建的独立的虚拟空间，这个空间内的网络、进程、挂载等资源都是隔离的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it nginx:1.19.0-alpine /bin/sh</span><br><span class="line"><span class="comment">#/ ip addr</span></span><br><span class="line"><span class="comment">#/ ls -l /</span></span><br><span class="line"><span class="comment">#/ apt install xxx</span></span><br><span class="line"><span class="comment">#/ #安装的软件对宿主机和其他容器没有任何影响，和虚拟机不同的是，容器间共享一个内核，所以容器内没法升级内核</span></span><br></pre></td></tr></table></figure><h2 id="多阶构建"><a href="#多阶构建" class="headerlink" title="多阶构建"></a>多阶构建</h2><h3 id="java项目"><a href="#java项目" class="headerlink" title="java项目"></a>java项目</h3><p>这里先使用java镜像为例，介绍多阶构建的使用。</p><p>项目地址：(springboot-app)[<a href="https://gitee.com/agagin/springboot-app.git]">https://gitee.com/agagin/springboot-app.git]</a></p><h4 id="原始构建："><a href="#原始构建：" class="headerlink" title="原始构建："></a>原始构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> srinivasansekar/javamvn</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/springboot-app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">  . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -jar /opt/springboot-app/target/sample.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t sample:v1 -f Dockerfile</span><br></pre></td></tr></table></figure><h4 id="多阶构建："><a href="#多阶构建：" class="headerlink" title="多阶构建："></a>多阶构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> maven as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/springboot-app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">  . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /opt/springboot-app/target/sample.jar sample.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -jar /sample.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t sample:v2 -f Dockerfile.multi</span><br></pre></td></tr></table></figure><h3 id="golang项目"><a href="#golang项目" class="headerlink" title="golang项目"></a>golang项目</h3><p>项目地址：(href-counter)[<a href="https://gitee.com/agagin/href-counter.git]">https://gitee.com/agagin/href-counter.git]</a></p><h4 id="原始构建：-1"><a href="#原始构建：-1" class="headerlink" title="原始构建："></a>原始构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> vendor vendor</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"><span class="keyword">ENV</span> GOPROXY https://goproxy.cn</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t href-counter:v1 -f Dockerfile</span><br></pre></td></tr></table></figure><h4 id="多阶构建：-1"><a href="#多阶构建：-1" class="headerlink" title="多阶构建："></a>多阶构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span> AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> vendor vendor</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go.</span></span><br><span class="line"><span class="keyword">ENV</span> GOPROXY https://goproxy.cn</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.10</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder  /go/src/github.com/alexellis/href-counter/app    .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t href-counter:v2 -f Dockerfile.multi</span><br></pre></td></tr></table></figure><h3 id="虚悬镜像-dangling-image"><a href="#虚悬镜像-dangling-image" class="headerlink" title="虚悬镜像 dangling image"></a>虚悬镜像 dangling image</h3><p>我们多阶构建完成后，通过 docker image ls (与 docker images相同)查看镜像时会发现一个或多个镜像ID和标签都为 none 关键字的镜像，这称为虚悬镜像(dangling image)，也就是我们多阶构建的中间镜像。再构建同名且同tag的镜像的时候，原本的镜像也会变为虚悬镜像。</p><p>虚悬镜像，我们并不需要它们，但是它们还占用存储空间。该如何删除呢？可以查找出镜像id进行删除，也可以通过docker命令删除。</p><ol><li>列出虚悬镜像 <code>docker image ls -f dangling=true</code></li><li>删除虚悬镜像 <code>docker image prune</code></li></ol><h3 id="多阶构建原则"><a href="#多阶构建原则" class="headerlink" title="多阶构建原则"></a>多阶构建原则</h3><ul><li>不必要的内容不要放在镜像中</li><li>减少不必要的层文件</li><li>减少网络传输操作</li><li>可以适当的包含一些调试命令</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Dockerfile介绍&quot;&gt;&lt;a href=&quot;#Dockerfile介绍&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile介绍&quot;&gt;&lt;/a&gt;Dockerfile介绍&lt;/h1&gt;&lt;p&gt;Dockerfile是一堆指令，在docker build的时候，按照该指令进行操作，最终生成我们期望的镜像&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://realtiger.github.io/tags/docker/"/>
    
    <category term="k8s" scheme="http://realtiger.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>yaml 入门</title>
    <link href="http://realtiger.github.io/yaml-introduction/"/>
    <id>http://realtiger.github.io/yaml-introduction/</id>
    <published>2023-05-05T10:36:06.000Z</published>
    <updated>2023-07-07T12:07:44.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yaml介绍"><a href="#yaml介绍" class="headerlink" title="yaml介绍"></a>yaml介绍</h1><p>官网介绍如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%YAML 1.2</span><br><span class="line">---</span><br><span class="line">YAML: YAML Ain&#x27;t Markup Language™</span><br><span class="line"></span><br><span class="line">What It Is:</span><br><span class="line">  YAML is a human-friendly data serialization</span><br><span class="line">  language for all programming languages.</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>这里的语法使用python举例，python使用的库是PyYAML</p><p>所有的 YAML 文件开始行都应该是 —。这是 YAML 格式的一部分, 表明一个文件的开始。</p><p>基本语法规则如下:</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li># 表示注释，从这个字符一直到行尾，都会被解析器忽略。</li></ul><p>YAML 支持的数据结构有三种:</p><ol><li>对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hashes） &#x2F; 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</li><li>纯量（scalars）：单个的、不可再分的值</li></ol><h2 id="对象-key-value键值对"><a href="#对象-key-value键值对" class="headerlink" title="对象 key-value键值对"></a>对象 key-value键值对</h2><p>使用格式为key: value。冒号后面要加一个空格。</p><h3 id="简单展示"><a href="#简单展示" class="headerlink" title="简单展示"></a>简单展示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 表示url属性值</span></span><br><span class="line"><span class="string">url: https://www.iluvatar.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 yaml 文件</span></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(value))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;url&#x27;: &#x27;https://www.iluvatar.com&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用缩进代表层级结构"><a href="#使用缩进代表层级结构" class="headerlink" title="使用缩进代表层级结构"></a>使用缩进代表层级结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 可以使用缩进表示层级结构</span></span><br><span class="line"><span class="string">host:</span></span><br><span class="line"><span class="string">    # 这样没有层级结构，所以解析的时候会报错</span></span><br><span class="line"><span class="string">    # ip:</span></span><br><span class="line"><span class="string">    # 172.16.0.1</span></span><br><span class="line"><span class="string">    ip:</span></span><br><span class="line"><span class="string">        172.16.0.1</span></span><br><span class="line"><span class="string">    # 定义相同的key并不报错，而是覆盖之前的相同key中的value</span></span><br><span class="line"><span class="string">    ip:</span></span><br><span class="line"><span class="string">        172.16.0.2</span></span><br><span class="line"><span class="string">    # 没有空格的话会被认为是一个键，并且报错没有检测到: 以及value</span></span><br><span class="line"><span class="string">    # ip:172.16.0.3</span></span><br><span class="line"><span class="string">    mask: 255.255.255.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 yaml 文件</span></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(value))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;host&#x27;: &#123;&#x27;ip&#x27;: &#x27;172.16.0.2&#x27;, &#x27;mask&#x27;: &#x27;255.255.255.0&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="一行显示"><a href="#一行显示" class="headerlink" title="一行显示"></a>一行显示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># yaml 也支持将所有的对象写在一行的写法</span></span><br><span class="line"><span class="string"># 注意： 如果键值对没有使用空格分开会被认为是一个键</span></span><br><span class="line"><span class="string">host: &#123;ip: 172.16.0.1,ip: 172.16.0.2, ip:172.16.0.3 ,mask: 255.255.255.0&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 yaml 文件</span></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(value))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;host&#x27;: &#123;&#x27;ip&#x27;: &#x27;172.16.0.2&#x27;, &#x27;ip:172.16.0.3&#x27;: None, &#x27;mask&#x27;: &#x27;255.255.255.0&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="数组-Array-x2F-List"><a href="#数组-Array-x2F-List" class="headerlink" title="数组 Array&#x2F;List"></a>数组 Array&#x2F;List</h2><h3 id="简单展示-1"><a href="#简单展示-1" class="headerlink" title="简单展示"></a>简单展示</h3><p>列表中的所有成员都开始于相同的缩进级别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">ipaddr:</span></span><br><span class="line"><span class="string"># IP地址列表</span></span><br><span class="line"><span class="string">- 192.168.10.1</span></span><br><span class="line"><span class="string">- 192.168.10.2</span></span><br><span class="line"><span class="string">- 192.168.10.3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;ipaddr&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;</span><br></pre></td></tr></table></figure><h3 id="缩进显示"><a href="#缩进显示" class="headerlink" title="缩进显示"></a>缩进显示</h3><p>子成员是一个数组，则可以在该项下面缩进一个空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line">import yaml</span><br><span class="line"></span><br><span class="line"># yaml 文件内容</span><br><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">ipaddr:</span><br><span class="line">- ens192:</span><br><span class="line">  # 下一级的定义要空两个空格以上</span><br><span class="line">  - 192.168.10.1</span><br><span class="line">  - 192.168.10.2</span><br><span class="line">  - 192.168.10.3</span><br><span class="line">file:</span><br><span class="line">  # 数组的子成员还是一个数组，空一个空格即可</span><br><span class="line">  -</span><br><span class="line">   - etc</span><br><span class="line">   - sysconfig</span><br><span class="line">   - network-scripts</span><br><span class="line">   - ifcfg-ens192</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line">print(value)</span><br><span class="line"># 这里使用pprint打印稍微美观一些</span><br><span class="line">pprint(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;ipaddr&#x27;: [&#123;&#x27;ens192&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;], &#x27;file&#x27;: [[&#x27;etc&#x27;, &#x27;sysconfig&#x27;, &#x27;network-scripts&#x27;, &#x27;ifcfg-ens192&#x27;]]&#125;</span><br><span class="line">&#123;&#x27;file&#x27;: [[&#x27;etc&#x27;, &#x27;sysconfig&#x27;, &#x27;network-scripts&#x27;, &#x27;ifcfg-ens192&#x27;]],</span><br><span class="line"> &#x27;ipaddr&#x27;: [&#123;&#x27;ens192&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="行内表示"><a href="#行内表示" class="headerlink" title="行内表示"></a>行内表示</h3><p>因为程序差不多，之后只提供yaml文件内容以及pprint打印的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">ipaddr:</span><br><span class="line"># 行内表示格式正确就行，中间的空格位数不影响</span><br><span class="line">- ens192: [ 192.168.10.1, 192.168.10.2, 192.168.10.3 ]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;ipaddr&#x27;: [&#123;&#x27;ens192&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>yaml中的常量包含以下几种</p><ul><li>字符串</li><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul><p>具体看以下示例应该就清楚了，不过多解释了</p><p>其中字符串有几个规则需要注意</p><ul><li>字符串默认不使用引号表示，如：<code>str: 这是一行字符串</code></li><li>如果字符串之中包含空格或特殊字符，需要放在引号之中，如：<code>str: &#39;内容：字符串&#39;</code></li><li>单引号和双引号都可以使用，双引号不会对特殊字符转义，如：<code>str: &#123;s1: &#39;内容\n字符串&#39;, s2: &quot;内容\n字符串&quot;&#125;</code></li><li>单引号之中如果还有单引号，必须连续使用两个单引号转义，如：<code>str: &#39;labor&#39;&#39;s day&#39;</code></li><li>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格</li><li>多行字符串可以使用 | 保留换行符，也可以使用 &gt; 折叠换行，下一节会介绍</li><li><ul><li>表示保留文字块末尾的换行，- 表示删除字符串末尾的换行，下一节会介绍</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">boolean:</span><br><span class="line">    # true,True都可以</span><br><span class="line">    - TRUE</span><br><span class="line">    # false，False都可以</span><br><span class="line">    - FALSE</span><br><span class="line">float:</span><br><span class="line">    - 3.14</span><br><span class="line">    # 可以使用科学计数法</span><br><span class="line">    - 6.8523015e+5</span><br><span class="line">int:</span><br><span class="line">    - 123</span><br><span class="line">    # 二进制表示</span><br><span class="line">    - 0b1010_0111_0100_1010_1110</span><br><span class="line">null:</span><br><span class="line">    nodeName: &#x27;node&#x27;</span><br><span class="line">    # 使用~表示null</span><br><span class="line">    parent: ~</span><br><span class="line">string:</span><br><span class="line">    - 字符串行</span><br><span class="line">    - newline</span><br><span class="line">    # 可以使用双引号或者单引号包裹特殊字符</span><br><span class="line">    - &#x27;Hello world&#x27;</span><br><span class="line">    # 字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="line">    - one_line</span><br><span class="line">      two_line</span><br><span class="line">date:</span><br><span class="line">    # 日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="line">    - 2018-02-17</span><br><span class="line">datetime:</span><br><span class="line">    # 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br><span class="line">    -  2018-02-17T15:02:31+08:00</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;None: &#123;&#x27;nodeName&#x27;: &#x27;node&#x27;, &#x27;parent&#x27;: None&#125;,</span><br><span class="line"> &#x27;boolean&#x27;: [True, False],</span><br><span class="line"> &#x27;date&#x27;: [datetime.date(2018, 2, 17)],</span><br><span class="line"> &#x27;datetime&#x27;: [datetime.datetime(2018, 2, 17, 15, 2, 31, tzinfo=datetime.timezone(datetime.timedelta(seconds=28800)))],</span><br><span class="line"> &#x27;float&#x27;: [3.14, 685230.15],</span><br><span class="line"> &#x27;int&#x27;: [123, 685230],</span><br><span class="line"> &#x27;string&#x27;: [&#x27;字符串行&#x27;, &#x27;newline&#x27;, &#x27;Hello world&#x27;, &#x27;one_line two_line&#x27;]&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><h3 id="类型强转"><a href="#类型强转" class="headerlink" title="!! 类型强转"></a>!! 类型强转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">int2string: !!str 123</span><br><span class="line">boolean2string: !!str true</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;boolean2string&#x27;: &#x27;true&#x27;, &#x27;int2string&#x27;: &#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="…-和-—"><a href="#…-和-—" class="headerlink" title="… 和 —"></a>… 和 —</h3><p>… 和—配合使用，在一个配置文件中代表一个文件的结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line">import yaml</span><br><span class="line"></span><br><span class="line"># yaml 文件内容</span><br><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">---</span><br><span class="line">time: 10:05:07</span><br><span class="line">user: userA</span><br><span class="line">action: &#x27;delete job (id: 13579)&#x27;</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">time: 11:13:45</span><br><span class="line">user: userB</span><br><span class="line">action: download dataset A</span><br><span class="line">...</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">values = yaml.safe_load_all(yaml_context)</span><br><span class="line"></span><br><span class="line">print(values)</span><br><span class="line">for value in values:</span><br><span class="line">    pprint(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object load_all at 0x000001C786A58C80&gt;</span><br><span class="line">&#123;&#x27;action&#x27;: &#x27;delete job (id: 13579)&#x27;, &#x27;time&#x27;: 36307, &#x27;user&#x27;: &#x27;userA&#x27;&#125;</span><br><span class="line">&#123;&#x27;action&#x27;: &#x27;download dataset A&#x27;, &#x27;time&#x27;: 40425, &#x27;user&#x27;: &#x27;userB&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="控制符-和-gt-控制符"><a href="#控制符-和-gt-控制符" class="headerlink" title="| 控制符 和 &gt; 控制符"></a>| 控制符 和 &gt; 控制符</h3><p>这两个符号是YAML中字符串经常使用的符号</p><h4 id="控制符"><a href="#控制符" class="headerlink" title="| 控制符"></a>| 控制符</h4><p>这个控制符的作用是保留文本每一行尾部的换行符。</p><ul><li>| 保证整段文本最后有且只有一个换行符</li><li>|+ 保留整段文本最后的所有换行符</li><li>|- 删除整段文本最后的所有换行符</li></ul><ol><li><p>最后有且只有一个换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: |</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash\n-c \n\n\nsleep 3600\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>保留整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: |+</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash\n-c \n\n\nsleep 3600\n\n\n\n\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: |-</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash\n-c \n\n\nsleep 3600&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="gt-控制符"><a href="#gt-控制符" class="headerlink" title="&gt; 控制符"></a>&gt; 控制符</h4><p>这个控制符的作用是将每一行尾部的换行符替换为空格，也就是将多行文本视为一行</p><ul><li><blockquote><p>保证文本最后有且只有一个换行符</p></blockquote></li><li><blockquote><ul><li>保留文本最后的所有换行符</li></ul></blockquote></li><li><blockquote><ul><li>删除文本最后的所有换行符</li></ul></blockquote></li></ul><ol><li><p>最后有且只有一个换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: &gt;</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash -c \n\nsleep 3600\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>保留整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: &gt;+</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash -c \n\nsleep 3600\n\n\n\n\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: &gt;-</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash -c \n\nsleep 3600&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="引用-amp-和"><a href="#引用-amp-和" class="headerlink" title="引用 &amp; 和 *"></a>引用 &amp; 和 *</h3><p>重复的内容在YAML中可以使用&amp;来完成锚点定义，使用*来完成锚点引用，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">defaults: &amp;defaults</span><br><span class="line">  host: localhost</span><br><span class="line">  db: postgres</span><br><span class="line"></span><br><span class="line">production:</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line">  host: 10.10.10.123</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  db: mysql</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">staging:</span><br><span class="line">  env: *defaults</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;defaults&#x27;: &#123;&#x27;db&#x27;: &#x27;postgres&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;&#125;,</span><br><span class="line"> &#x27;development&#x27;: &#123;&#x27;db&#x27;: &#x27;mysql&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;&#125;,</span><br><span class="line"> &#x27;production&#x27;: &#123;&#x27;db&#x27;: &#x27;postgres&#x27;, &#x27;host&#x27;: &#x27;10.10.10.123&#x27;&#125;,</span><br><span class="line"> &#x27;staging&#x27;: &#123;&#x27;env&#x27;: &#123;&#x27;db&#x27;: &#x27;postgres&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>CentOS 搭建 nfs server</p><h1 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h1><ol><li><p>安装软件包</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y rpcbind nfs-utils</span><br></pre></td></tr></table></figure></li><li><p>创建共享目录</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir -p /srv/data/nfs_data</span><br><span class="line"># chmod 777 /srv/data/nfs_data</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><p>将配置文件exports填写以下内容</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/exports</span><br><span class="line"></span><br><span class="line">/data/nfs_data/data *(insecure,rw,sync,no_root_squash,fsid=0)</span><br></pre></td></tr></table></figure></li><li><p>启动 nfs 服务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rpcbind</span><br><span class="line">systemctl enable nfs-server</span><br><span class="line"></span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs-server</span><br></pre></td></tr></table></figure></li><li><p>检查配置是否生效</p><p>使用 exportfs 命令，会显示共享的目录</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># exportfs</span><br><span class="line">/srv/data/nfs_data</span><br><span class="line">                &lt;world&gt;</span><br></pre></td></tr></table></figure></li><li><p>开发防火墙</p><p>服务器端开放 111、662、875、892、2049 的 tcp &#x2F; udp 端口即可</p></li></ol><h1 id="客户端挂载"><a href="#客户端挂载" class="headerlink" title="客户端挂载"></a>客户端挂载</h1><ol><li><p>客户端安装软件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br></pre></td></tr></table></figure></li><li><p>执行命令检查共享目录</p><p>使用命令 showmount 进行显示，注意替换成当前的服务器地址，这里是 10.6.70.4</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># showmount -e 10.6.70.4</span><br><span class="line">Export list for 10.6.70.4:</span><br><span class="line">/srv/data/nfs_data *</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>挂载并测试</p><p>客户端挂载并创建测试文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ls /mnt/</span><br><span class="line"># mount -t nfs 10.6.70.4:/ /mnt/</span><br><span class="line"># ls /mnt/</span><br><span class="line"># echo &#x27;aaa&#x27; &gt; /mnt/a.txt</span><br></pre></td></tr></table></figure><p>服务器端查看目录，可以看到已经生成文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /srv/data/nfs_data/a.txt</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;yaml介绍&quot;&gt;&lt;a href=&quot;#yaml介绍&quot; class=&quot;headerlink&quot; title=&quot;yaml介绍&quot;&gt;&lt;/a&gt;yaml介绍&lt;/h1&gt;&lt;p&gt;官网介绍如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;%YAML 1.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;YAML: YAML Ain&amp;#x27;t Markup Language™&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;What It Is:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  YAML is a human-friendly data serialization&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  language for all programming languages.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="http://realtiger.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>docker 介绍</title>
    <link href="http://realtiger.github.io/docker-introduction/"/>
    <id>http://realtiger.github.io/docker-introduction/</id>
    <published>2023-05-04T09:10:17.000Z</published>
    <updated>2023-05-10T17:54:12.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识docker"><a href="#认识docker" class="headerlink" title="认识docker"></a>认识docker</h1><p>Docker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。</p><p>Hypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。</p><p>Container Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。Docker是其中最知名的一种容器Container Runtime，其他的还有 CoreOS 容器 Rkt ，Podman。</p><span id="more"></span><p><img src="/post/docker/docker-different.svg" alt="docker-different"></p><p>docker能做什么呢？ 它主要基于轻量的特性，解决软件交付过程中的环境依赖</p><ul><li>可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署</li><li>可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删）</li><li>container容器之间相互隔离，且每个容器可以设置资源限额</li><li>提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立</li></ul><h1 id="docker的发展史"><a href="#docker的发展史" class="headerlink" title="docker的发展史"></a>docker的发展史</h1><h6 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h6><p>13年成立，15年开始，迎来了飞速发展。</p><p>Docker 1.8 之前，使用<a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，Docker在上层做了封装， 把LXC复杂的容器创建与使用方式简化为自己的一套命令体系。</p><p>之后，为了实现跨平台等复杂的场景，Docker抽出了libcontainer项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。</p><p>2015年6月，Docker牵头成立了 OCI（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。</p><p>OCI成立后，libcontainer 交给OCI组织来维护，但是libcontainer中只包含了与kernel交互的库，因此基于libcontainer项目，后面又加入了一个CLI工具，并且项目改名为runC (<a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a> )， 目前runC已经成为一个功能强大的runtime工具。</p><p>Docker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了<strong>containerd</strong>。containerd向上为Docker Daemon提供了<code>gRPC接口</code>，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过<code>containerd-shim</code>结合<code>runC</code>，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。</p><p><img src="/post/docker/containerd.png" alt="containerd"></p><ul><li>runC（libcontainer）是符合OCI标准的一个实现，与底层系统交互</li><li>containerd是实现了OCI之上的容器的高级功能，比如镜像管理、容器执行的调用等</li><li>Dockerd目前是最上层与CLI交互的进程，接收cli的请求并与containerd协作</li></ul><h1 id="docker总结"><a href="#docker总结" class="headerlink" title="docker总结"></a>docker总结</h1><ol><li>为了提供一种更加轻量的虚拟化技术，docker出现了</li><li>借助于docker容器的轻、快等特性，解决了软件交付过程中的环境依赖问题，使得docker得以快速发展</li><li>Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理</li><li>docker-ce，每季度发布stable版本。18.06，18.09，19.03</li><li>发展至今，docker已经通过制定OCI标准对最初的项目做了拆分，其中runC和containerd是docker的核心项目，理解docker整个请求的流程，对我们深入理解docker有很大的帮助</li></ol><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>docker安装查看这篇文章 <a href="http://www.ganchangde.com/article/cc0cb74b891f731e4f37c683b3f7362b5481e0f1_Vc1tfQHK_0">docker安装（Centos8版本）</a></p><h1 id="核心要素"><a href="#核心要素" class="headerlink" title="核心要素"></a>核心要素</h1><p>docker中的三大核心要素：镜像(Image)、容器(Container)、仓库(Registry)</p><ol><li>镜像（Image）:打包了业务代码及运行环境的包，是静态的文件，不能直接对外提供服务。</li><li>容器（Container）: 镜像的运行时，可以对外提供服务。</li><li>仓库（Registry）: 存放镜像的地方<ul><li>公有仓库，Docker Hub，阿里仓库，网易仓库…</li><li>私有仓库，企业内部搭建<ul><li>Docker Registry，Docker官方提供的镜像仓库存储服务</li><li>Harbor, 是Docker Registry的更高级封装，它除了提供友好的Web UI界面，角色和用户权限管理，用户操作审计等功能</li></ul></li><li>镜像访问地址形式 registry.devops.com&#x2F;demo&#x2F;hello:latest,若没有前面的url地址，则默认寻找Docker Hub中的镜像，若没有tag标签，则使用latest作为标签。 比如，docker pull nginx，会被解析成docker.io&#x2F;library&#x2F;nginx:latest</li><li>公有的仓库中，一般存在这么几类镜像<ul><li>操作系统基础镜像（centos，ubuntu，suse，alpine）</li><li>中间件（nginx，redis，mysql，tomcat）</li><li>语言编译环境（python，java，golang）</li><li>业务镜像（django-demo…）</li></ul></li></ul></li></ol><p>容器和仓库不会直接交互，都是以镜像为载体来操作。</p><h1 id="docker基本命令"><a href="#docker基本命令" class="headerlink" title="docker基本命令"></a>docker基本命令</h1><p><img src="/post/docker/docker-command.jpg" alt="docker-command"></p><ol><li><p>查看镜像列表</p><p>根据以下指标确定唯一镜像</p><ul><li>image_id</li><li>repository:tag</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx         alpine              377c0837328f        2 weeks ago         19.7MB</span><br></pre></td></tr></table></figure></li><li><p>如何获取镜像</p><ul><li><p>从远程仓库拉取</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐alpine</span></span><br><span class="line">$ docker pull nginx:alpine</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure></li><li><p>使用tag命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure></li><li><p>本地构建（通过Dockerfile）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t my-nginx:ubuntu -f Dockerfile</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如何通过镜像启动容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name my-nginx-alpine -d nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>如何知道容器内部运行了什么程序？</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部,分配一个tty终端</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti my-nginx-alpine /bin/sh</span><br><span class="line"><span class="comment"># ps aux</span></span><br></pre></td></tr></table></figure></li><li><p>docker怎么知道容器启动后该执行什么命令？</p><p> 通过docker build来模拟构建一个nginx的镜像，</p><ul><li><p>创建Dockerfile</p>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告诉docker使用哪个基础镜像作为模板，后续命令都以这个镜像为基础 </span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list &amp;&amp; sed -i <span class="string">&#x27;s/security.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN命令会在上面指定的镜像里执行命令 </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt install -y nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#告诉docker，启动容器时执行如下命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>构建本地镜像</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t my-nginx:ubuntu -f Dockerfile</span><br></pre></td></tr></table></figure></li><li><p>使用新镜像启动容器</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name my-nginx-ubuntu -d my-nginx:ubuntu</span><br></pre></td></tr></table></figure></li><li><p>进入容器查看进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -ti my-nginx-ubuntu /bin/sh</span><br><span class="line"><span class="comment"># ps aux</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如何访问容器内服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti my-nginx-alpine /bin/sh</span><br><span class="line"><span class="comment"># ps aux|grep nginx</span></span><br><span class="line"><span class="comment"># curl localhost:80</span></span><br></pre></td></tr></table></figure></li><li><p>宿主机中如何访问容器服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删掉旧服务,重新启动</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f my-nginx-alpine</span><br><span class="line">$ docker run --name my-nginx-alpine -d -p 8080:80 nginx:alpine</span><br><span class="line">$ curl 172.21.51.143:8080</span><br></pre></td></tr></table></figure></li><li><p>docker client如何与daemon通信</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /var/run/docker.sock</span></span><br><span class="line">$ docker run --name portainer -d -p 9001:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span><br></pre></td></tr></table></figure></li><li><p>导出镜像到文件中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save -o nginx-alpine.tar nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>从文件中加载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i nginx-alpine.tar</span><br></pre></td></tr></table></figure></li><li><p>部署带认证的镜像仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Docker Registry 认证文件目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /var/lib/registry_auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 htpasswd 来创建加密文件</span></span><br><span class="line">yum install -y httpd-tools</span><br><span class="line">htpasswd -Bbn admin admin &gt; /var/lib/registry_auth/htpasswd</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用docker镜像启动镜像仓库服务</span></span><br><span class="line">docker run -p 5000:5000 \</span><br><span class="line">--restart=always \</span><br><span class="line">--name registry \</span><br><span class="line">-v /var/lib/registry:/var/lib/registry \</span><br><span class="line">-v /var/lib/registry_auth/:/auth/ \</span><br><span class="line">-e <span class="string">&quot;REGISTRY_AUTH=htpasswd&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd&quot;</span> \</span><br><span class="line">-d registry</span><br></pre></td></tr></table></figure></li><li><p>推送本地镜像到镜像仓库中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 镜像仓库给外部访问，不能通过localhost，尝试使用内网地址172.21.51.143:5000/nginx:alpine</span></span><br><span class="line">docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine</span><br><span class="line">docker push 172.21.51.143:5000/nginx:alpine</span><br><span class="line">The push refers to repository [172.21.51.143:5000/nginx]</span><br><span class="line">Get https://172.21.51.143:5000/v2/: http: server gave HTTP response to HTTPS client</span><br><span class="line"><span class="comment">## docker默认不允许向http的仓库地址推送，如何做成https的，参考：https://docs.docker.com/registry/deploying/#run-an-externally-accessible-registry</span></span><br><span class="line"><span class="comment">## 我们没有可信证书机构颁发的证书和域名，自签名证书需要在每个节点中拷贝证书文件，比较麻烦，因此我们通过配置daemon的方式，来跳过证书的验证：</span></span><br><span class="line"><span class="built_in">cat</span> /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://8xpk5wnt.mirror.aliyuncs.com&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;172.21.51.143:5000&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">systemctl restart docker</span><br><span class="line">docker push 172.21.51.143:5000/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会提示认证失败 ，no basic auth credentials,需要登录</span></span><br><span class="line">docker login 172.21.51.143:5000</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看仓库内元数据</span></span><br><span class="line">curl -u admin:admin -X GET http://172.21.51.143:5000/v2/_catalog</span><br><span class="line">curl -u admin:admin  -X GET http://172.21.51.143:5000/v2/nginx/tags/list</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>查看容器列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看运行状态的容器列表</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看全部状态的容器列表</span></span><br><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 后台启动</span></span><br><span class="line">$ docker run --name nginx -d nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">## 映射端口,把容器的端口映射到宿主机中,-p &lt;host_port&gt;:&lt;container_port&gt;</span></span><br><span class="line">$ docker run --name nginx -d -p 8080:80 nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">## 资源限制,最大可用内存500M</span></span><br><span class="line">$ docker run --memory=500m nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>容器数据持久化</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 挂载主机目录</span></span><br><span class="line">$ docker run --name nginx -d -v /opt:/opt nginx:alpine</span><br><span class="line">$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d -v /opt/mysql/:/var/lib/mysql mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>进入容器或者执行容器内的命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -ti &lt;container_id_or_name&gt; /bin/sh</span><br><span class="line">$ docker <span class="built_in">exec</span> &lt;container_id_or_name&gt; hostname</span><br></pre></td></tr></table></figure></li><li><p>主机与容器之间拷贝数据</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 主机拷贝到容器</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;data&#x27;</span>&gt;/tmp/test.txt</span><br><span class="line">$ docker <span class="built_in">cp</span> /tmp/test.txt nginx:/tmp</span><br><span class="line">$ docker <span class="built_in">exec</span> nginx <span class="built_in">cat</span> /tmp/test.txt</span><br><span class="line">data</span><br><span class="line"></span><br><span class="line"><span class="comment">## 容器拷贝到主机</span></span><br><span class="line">$ docker <span class="built_in">cp</span> nginx:/tmp/test.txt ./</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看全部日志</span></span><br><span class="line">$ docker logs nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 实时查看最新日志</span></span><br><span class="line">$ docker logs -f nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从最新的100条开始查看</span></span><br><span class="line">$ docker logs --<span class="built_in">tail</span>=100 -f nginx</span><br></pre></td></tr></table></figure></li><li><p>停止或者删除容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 停止运行中的容器</span></span><br><span class="line">$ docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动退出容器</span></span><br><span class="line">$ docker start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除非运行中状态的容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除运行中的容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f nginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器或者镜像的明细</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看容器详细信息，包括容器IP地址等</span></span><br><span class="line">$ docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看镜像的明细信息</span></span><br><span class="line">$ docker inspect nginx:alpine</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;认识docker&quot;&gt;&lt;a href=&quot;#认识docker&quot; class=&quot;headerlink&quot; title=&quot;认识docker&quot;&gt;&lt;/a&gt;认识docker&lt;/h1&gt;&lt;p&gt;Docker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。&lt;/p&gt;
&lt;p&gt;Hypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。&lt;/p&gt;
&lt;p&gt;Container Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。Docker是其中最知名的一种容器Container Runtime，其他的还有 CoreOS 容器 Rkt ，Podman。&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://realtiger.github.io/tags/docker/"/>
    
    <category term="k8s" scheme="http://realtiger.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>python 设计模式 03</title>
    <link href="http://realtiger.github.io/python-design-patterns-03/"/>
    <id>http://realtiger.github.io/python-design-patterns-03/</id>
    <published>2023-04-30T08:47:39.000Z</published>
    <updated>2023-07-07T12:07:18.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><span id="more"></span><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>给定一个语言，定义它的文法、语法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p>主要是解释器使用，这里省略</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>责任链模式，将多个处理方法连接成一条链条，请求将在这条链条上流动直到该链条中有一个节点可以处理该请求。通常这条链条是一个对象包含对另一个对象的引用而形成链条，每个节点有对请求的条件，当不满足条件将传递给下一个节点处理。</p><p>责任链模式就是种“推卸”责任的模式，你的问题在我这里能解决我就解决，不行就把你推给另一个对象。至于到底谁解决了这个问题了呢?我管呢!</p><h3 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象处理者(Handler)：定义了处理请求的抽象方法和一个设置责任链的下一个处理者的方法。</li><li>具体处理者(ConcreteHandler)：实现处理请求的方法，判断自己能否处理本次请求，如果能，则处理，如果不能，则把请求转发给责任链的下一个处理者。</li><li>客户类(Client)：创建处理链，对链头提交请求，并不需要关心处理细节。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>若某个请求可以由多个对象进行处理，但具体由哪个对象处理该请求则是由请求内容和对象处理权限确定。</li><li>在请求处理者不明确的情况下，对多个处理者中的一个提交请求。</li><li>需要动态处理一组对象处理请求，比如新增新的处理者。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Request(Enum):</span><br><span class="line">    VACATION = 1</span><br><span class="line">    SALARY_RAISE = 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Handler(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def set_next(self, handler):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def handle(self, request: Request, number: int):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteHandler(Handler):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._next = None</span><br><span class="line"></span><br><span class="line">    def set_next(self, handler):</span><br><span class="line">        self._next = handler</span><br><span class="line">        return handler</span><br><span class="line"></span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if self._next:</span><br><span class="line">            return self._next.handle(request, number)</span><br><span class="line">        print(&quot;No handler found for request: &#123;&#125;&quot;.format(request))</span><br><span class="line"></span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            print(&quot;You can&#x27;t take a vacation.&quot;)</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            print(&quot;You can&#x27;t get a raise.&quot;)</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GeneralManager(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 10:</span><br><span class="line">                print(&quot;General Manager: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 1000:</span><br><span class="line">                print(&quot;General Manager: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DepartmentManager(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 5:</span><br><span class="line">                print(&quot;Department Manager: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 500:</span><br><span class="line">                print(&quot;Department Manager: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        print(&quot;Department Manager: My permissions are insufficient. I&#x27;ll pass this request to next one.&quot;)</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Supervisor(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 3:</span><br><span class="line">                print(&quot;Supervisor: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 300:</span><br><span class="line">                print(&quot;Supervisor: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        print(&quot;Supervisor: My permissions are insufficient. I&#x27;ll pass this request to next one.&quot;)</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Employee(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 1:</span><br><span class="line">                print(&quot;Employee: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 100:</span><br><span class="line">                print(&quot;Employee: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        print(&quot;Employee: My permissions are insufficient. I&#x27;ll pass this request to next one.&quot;)</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Client:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._employee = Employee()</span><br><span class="line">        self._supervisor = Supervisor()</span><br><span class="line">        self._department_manager = DepartmentManager()</span><br><span class="line">        self._general_manager = GeneralManager()</span><br><span class="line"></span><br><span class="line">        self._employee.set_next(self._supervisor).set_next(self._department_manager).set_next(self._general_manager)</span><br><span class="line"></span><br><span class="line">    def make_request(self, request, number):</span><br><span class="line">        self._employee.handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    client = Client()</span><br><span class="line">    print(&quot;######## Client: I want to take a vacation for 2 days.&quot;)</span><br><span class="line">    client.make_request(Request.VACATION, 2)</span><br><span class="line">    print(&quot;######## Client: I want to raise my salary for 200.&quot;)</span><br><span class="line">    client.make_request(Request.SALARY_RAISE, 200)</span><br><span class="line">    print(&quot;######## Client: I want to take a vacation for 7 days.&quot;)</span><br><span class="line">    client.make_request(Request.VACATION, 7)</span><br><span class="line">    print(&quot;######## Client: I want to raise my salary for 600.&quot;)</span><br><span class="line">    client.make_request(Request.SALARY_RAISE, 600)</span><br><span class="line">    print(&quot;######## Client: I want to take a vacation for 12 days.&quot;)</span><br><span class="line">    client.make_request(Request.VACATION, 12)</span><br><span class="line">    print(&quot;######## Client: I want to raise my salary for 1200.&quot;)</span><br><span class="line">    client.make_request(Request.SALARY_RAISE, 1200)</span><br></pre></td></tr></table></figure><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>命令模式可将请求转换为一个包含与请求相关的所有信息的独立对象，这个独立对象实现了调用者与接收者之间的解耦，命令模式最大的杀手锏是它能非常轻松的实现撤销操作。</p><p>主要的应用场景就是GUI，将每一个具体命令封装称为一个类，使用不同的命令则调用不同的类，参数通过类进行传递。</p><p>这里省略</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来，放入一个独立的迭代器对象中。迭代器类定义了访问该列表元素的接口。迭代器类提供的方法负责跟踪当前的元素，即它知道哪些元素已经遍历过了，哪些元素还没有被遍历。</p><p>迭代器模式能够提供一种方法按照顺序访问一个聚合对象中的所有元素，而又不需要暴露该对象的内部表示。</p><p>python中提供了iter()方法实现，这里略过</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p><p>主要使用在多个类相互耦合，形成了网状结构时，将上述网状结构分离为星型结构。</p><h3 id="角色：-1"><a href="#角色：-1" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li><li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li><li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>如机场调度系统（多个跑道、飞机、指挥塔之间的调度）</li><li>路由系统；著名的MVC框架中，其中的C（Controller）就是M（Model）和V（View）的中介者。</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象中介者</span><br><span class="line">class Mediator(ABC):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.x = 0</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def register(self, colleague):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象同事类</span><br><span class="line">class Colleague:</span><br><span class="line">    def __init__(self, name, x):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体同事类 汽车</span><br><span class="line">class ConcreteColleagueCar(Colleague):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体同事类 鸟</span><br><span class="line">class ConcreteColleagueBird(Colleague):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体中介类</span><br><span class="line">class ConcreteMediator(Mediator):</span><br><span class="line">    collections = []</span><br><span class="line"></span><br><span class="line">    def register(self, colleague):</span><br><span class="line">        self.collections.append(colleague)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        for colleague in self.collections:</span><br><span class="line">            print(colleague.name, colleague.x)</span><br><span class="line">            print(f&#x27;place x is &#123;self.x&#125; - &#123;self.x + colleague.x&#125;&#x27;)</span><br><span class="line">            self.x = self.x + colleague.x + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mediator = ConcreteMediator()</span><br><span class="line">    car1 = ConcreteColleagueCar(&#x27;car1&#x27;, 1)</span><br><span class="line">    car2 = ConcreteColleagueCar(&#x27;car2&#x27;, 1)</span><br><span class="line">    bird1 = ConcreteColleagueBird(&#x27;bird1&#x27;, 2)</span><br><span class="line">    bird2 = ConcreteColleagueBird(&#x27;bird2&#x27;, 2)</span><br><span class="line">    mediator.register(car1)</span><br><span class="line">    mediator.register(car2)</span><br><span class="line">    mediator.register(bird1)</span><br><span class="line">    mediator.register(bird2)</span><br><span class="line"></span><br><span class="line">    mediator.show()</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>通过让对象彼此解耦，增加对象的复用性</li><li>通过将控制逻辑集中，可以简化系统维护</li><li>通过中介者使一对多变成了一对一，便于理解</li><li>符合迪米特原则</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>在具体中介者类中包含了同事之间的交互细节，如果设计不好，引入中介者会使程序变的复杂</li><li>中介者承担过多责任，是中心化模式，若中介者出现了问题，整个系统将会崩溃</li></ol><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.bilibili.com/video/BV1Y8411V7gR/">一个被Eclipse，NetBean等项目使用的设计模式</a></p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><p>备忘录模式（Memento Pattern）用于保存一个对象的某个状态，以便在适当的时候恢复对象。特点是不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br>跟原型模式很像，不过在原型模式中保存对象的一切，而备忘录模式中只保存恢复时需要的数据。</p><h3 id="角色：-2"><a href="#角色：-2" class="headerlink" title="角色："></a>角色：</h3><ul><li>Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。</li><li>Memento(备忘录)<br>：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。</li><li>Caretaker(管理者): 负责备忘录Memento，不能对Memento的内容进行访问或者操作。</li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>需要保存和恢复数据的相关状态场景。如保存游戏状态的场景；撤销场景，如Ctrl-Z操作；事务回滚的应用。一般情况下事务回滚有两种方式：一是把从恢复点开始的操作都反向执行一遍；二是直接恢复到恢复点的各种状态。两种方式各有优缺点，要结合业务场景，决定使用哪种模式；</li><li>副本监控场景。备忘录可以当作一个临时的副本监控，实现非实时和准实时的监控。</li></ol><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Originator(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def save(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def restore(self, memento):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def set(self, state):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def get(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteOriginator(Originator):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._state = None</span><br><span class="line"></span><br><span class="line">    def save(self):</span><br><span class="line">        return ConcreteMemento(self._state)</span><br><span class="line"></span><br><span class="line">    def restore(self, memento):</span><br><span class="line">        self._state = memento.get_state()</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        print(f&quot;State: &#123;self._state&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def set(self, state):</span><br><span class="line">        self._state = state</span><br><span class="line"></span><br><span class="line">    def get(self):</span><br><span class="line">        return self._state</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Memento(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def get_name(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def get_date(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteMemento(Memento):</span><br><span class="line">    def __init__(self, state):</span><br><span class="line">        self._state = state</span><br><span class="line">        self._date = str(datetime.now())[:19]</span><br><span class="line"></span><br><span class="line">    def get_state(self):</span><br><span class="line">        return self._state</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        return f&quot;&#123;self._date&#125; / (&#123;self._state[0:9]&#125;...)&quot;</span><br><span class="line"></span><br><span class="line">    def get_date(self):</span><br><span class="line">        return self._date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Caretaker:</span><br><span class="line">    def __init__(self, originator):</span><br><span class="line">        self._mementos = []</span><br><span class="line">        self._originator = originator</span><br><span class="line"></span><br><span class="line">    def backup(self):</span><br><span class="line">        print(&quot;Caretaker: Saving Originator&#x27;s state...&quot;)</span><br><span class="line">        self._mementos.append(self._originator.save())</span><br><span class="line"></span><br><span class="line">    def undo(self):</span><br><span class="line">        if not len(self._mementos):</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        memento = self._mementos.pop()</span><br><span class="line">        print(f&quot;Caretaker: Restoring state to: &#123;memento.get_name()&#125;&quot;)</span><br><span class="line">        try:</span><br><span class="line">            self._originator.restore(memento)</span><br><span class="line">        except Exception:</span><br><span class="line">            self.undo()</span><br><span class="line"></span><br><span class="line">    def show_history(self):</span><br><span class="line">        print(&quot;Caretaker: Here&#x27;s the list of mementos:&quot;)</span><br><span class="line">        for memento in self._mementos:</span><br><span class="line">            print(memento.get_name())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    originator = ConcreteOriginator()</span><br><span class="line">    caretaker = Caretaker(originator)</span><br><span class="line"></span><br><span class="line">    originator.set(&quot;State #1&quot;)</span><br><span class="line">    originator.set(&quot;State #2&quot;)</span><br><span class="line">    caretaker.backup()</span><br><span class="line"></span><br><span class="line">    originator.set(&quot;State #3&quot;)</span><br><span class="line">    caretaker.backup()</span><br><span class="line"></span><br><span class="line">    originator.set(&quot;State #4&quot;)</span><br><span class="line">    caretaker.backup()</span><br><span class="line"></span><br><span class="line">    caretaker.undo()</span><br><span class="line">    caretaker.undo()</span><br><span class="line"></span><br><span class="line">    caretaker.show_history()</span><br><span class="line"></span><br><span class="line">    print(&quot;\nClient: Now, let&#x27;s rollback!\n&quot;)</span><br><span class="line">    caretaker.undo()</span><br><span class="line"></span><br><span class="line">    originator.show()</span><br><span class="line"></span><br><span class="line">    # Output:</span><br><span class="line">    # Caretaker: Saving Originator&#x27;s state...</span><br><span class="line">    # Caretaker: Saving Originator&#x27;s state...</span><br><span class="line">    # Caretaker: Restoring state to: 2020-07-07 22:07:54 / (State #4...)</span><br><span class="line">    # Caretaker: Restoring state to: 2020-07-07 22:07:54 / (State #3...)</span><br><span class="line">    # Caretaker: Here&#x27;s the list of mementos:</span><br><span class="line">    # 2020-07-07 22:07:54 / (State #2...)</span><br><span class="line">    #</span><br><span class="line">    # Client: Now, let&#x27;s rollback!</span><br><span class="line">    #</span><br><span class="line">    # Caretaker: Restoring state to: 2020-07-07 22:07:54 / (State #2...)</span><br><span class="line">    # State: State #2</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，<br>使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</li><li>本模式简化了发起人的类。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需<br>要的这些状态的版本。</li><li>当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。</li><li>当负责人角色将一个备忘录存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。</li><li>当发起人角色的状态改变的时候，有可能这个协议无效。</li></ol><h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.bilibili.com/video/BV1Za4113734">用Java实现Redis的RDB机制 离不开这个设计模式</a></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="内容-6"><a href="#内容-6" class="headerlink" title="内容"></a>内容</h3><p>观察者模式应用比较广泛，又被称为“发布-订阅”模式。它用来定义对象间一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都得到通知并被自动更新。</p><h3 id="角色：-3"><a href="#角色：-3" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象主题(Subject)</li><li>具体主题（ConcreteSubject）– 发布者</li><li>抽象观察者(Observer)</li><li>具体观察者（ConcreteObserver）– 订阅者</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当一个抽象模型有两个方面，其中一个方面依赖另一个方面。将这两者封装在独立对象中以使它们可以各自独立地改变和复用</li><li>当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象待改变</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧耦合的。</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象主题</span><br><span class="line">class Subject(object):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def register(self, observer):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def unregister(self, observer):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def notify(self, notice):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象的订阅者</span><br><span class="line">class Observer(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def update(self, notice):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param notice: Notice类的对象</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体主题， 微信服务号</span><br><span class="line">class ConcreteSubject(Subject):</span><br><span class="line">    def __init__(self, service_name):</span><br><span class="line">        self._users = []</span><br><span class="line"></span><br><span class="line">        # 服务号名称</span><br><span class="line">        self.service_name = service_name</span><br><span class="line"></span><br><span class="line">    # 添加订阅者信息</span><br><span class="line">    def register(self, observer):</span><br><span class="line">        if observer not in self._users:</span><br><span class="line">            self._users.append(observer)</span><br><span class="line"></span><br><span class="line">    # 用户取消关注，取消订阅者</span><br><span class="line">    def unregister(self, observer):</span><br><span class="line">        self._users.remove(observer)</span><br><span class="line"></span><br><span class="line">    # 通知所有订阅者</span><br><span class="line">    def notify(self, notice):</span><br><span class="line">        for observer in self._users:</span><br><span class="line">            observer.update(notice)</span><br><span class="line"></span><br><span class="line">    # 发布消息</span><br><span class="line">    def write_new_post(self, post_name):</span><br><span class="line">        print(&#x27;微信服务号&#123;&#125;：&#123;&#125;&#x27;.format(self.service_name, post_name))</span><br><span class="line">        self.notify(post_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体订阅者，微信用户</span><br><span class="line">class ConcreteObserver(Observer):</span><br><span class="line">    def __init__(self, username):</span><br><span class="line">        self.username = username</span><br><span class="line"></span><br><span class="line">    def update(self, post_name):</span><br><span class="line">        print(f&#x27;微信用户&#123;self.username&#125;接收到消息，公众号发布了新帖子：&#123;post_name&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 程序入口</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 微信服务号</span><br><span class="line">    python_service = ConcreteSubject(&quot;Python论坛&quot;)</span><br><span class="line">    # 用户对象</span><br><span class="line">    user1 = ConcreteObserver(&#x27;cd&#x27;)</span><br><span class="line">    user2 = ConcreteObserver(&#x27;yx&#x27;)</span><br><span class="line">    user3 = ConcreteObserver(&#x27;xl&#x27;)</span><br><span class="line">    # 订阅Python论坛公帐号</span><br><span class="line">    python_service.register(user1)</span><br><span class="line">    python_service.register(user2)</span><br><span class="line">    python_service.register(user3)</span><br><span class="line">    # 公众号发布文章通知所有订阅</span><br><span class="line">    python_service.write_new_post(&quot;python设计模式01&quot;)</span><br><span class="line">    # 用户2取消订阅旅游知识号</span><br><span class="line">    python_service.unregister(user2)</span><br><span class="line">    # 取消订阅的用户接收不到通知</span><br><span class="line">    python_service.write_new_post(&quot;python设计模式02&quot;)</span><br><span class="line"></span><br><span class="line"># Output</span><br><span class="line"># 微信服务号Python论坛：python设计模式01</span><br><span class="line"># 微信用户cd接收到消息，公众号发布了新帖子：python设计模式01</span><br><span class="line"># 微信用户yx接收到消息，公众号发布了新帖子：python设计模式01</span><br><span class="line"># 微信用户xl接收到消息，公众号发布了新帖子：python设计模式01</span><br><span class="line"># 微信服务号Python论坛：python设计模式02</span><br><span class="line"># 微信用户cd接收到消息，公众号发布了新帖子：python设计模式02</span><br><span class="line"># 微信用户xl接收到消息，公众号发布了新帖子：python设计模式02</span><br></pre></td></tr></table></figure><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol><li>目标和观察者之间的抽象耦合最小</li><li>支持广播通信。</li></ol><h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><ul><li>中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。</li><li>中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接，<br>使得部分对象可作为其他对象的附属发挥作用。</li><li>有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。<br>当中介者以这种方式实现时， 它可能看上去与观察者非常相似。</li><li>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同，<br>但这仍是一种中介者模式。</li><li>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象，<br>而只有一些分布式的观察者。</li></ul><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="内容-7"><a href="#内容-7" class="headerlink" title="内容"></a>内容</h3><p>行为模式关注的是对象的响应性。它们通过对象之间的交互以实现更强大的功能。状态设计模式是一种行为设计模式，有时也被称为状态模式对象。在此模式中，一个对象可以基于其内部状态封装多个行为。状态模式也可以看作是在运行时改变对象行为的一种方式。</p><p>状态设计模式允许对象在其内部状态变化时改变其行为。这看起来就像对象本身已经改变了它的类一样。状态设计模式常用于开发有限状态机，并帮助协调状态处理操作。</p><h3 id="角色：-4"><a href="#角色：-4" class="headerlink" title="角色："></a>角色：</h3><ul><li>State：这被认为是封装对象行为的接口。这个行为与对象的状态相关联。</li><li>ConcreteState：这是实现State接口的子类。ConcreteState实现对象的特定状态相关联的实际行为</li><li>Context：这定义了客户感兴趣的接口。Context还维护一个ConcreteState子类的实例，该子类在内部定义了对象的特定状态的实现</li></ul><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class State(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def handle(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteStateA(State):</span><br><span class="line">    def handle(self):</span><br><span class="line">        print(&quot;ConcreteStateA&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteStateB(State):</span><br><span class="line">    def handle(self):</span><br><span class="line">        print(&quot;ConcreteStateB&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Context(State):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.state = None</span><br><span class="line"></span><br><span class="line">    def get_state(self):</span><br><span class="line">        return self.state</span><br><span class="line"></span><br><span class="line">    def set_state(self, state):</span><br><span class="line">        self.state = state</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        self.state.handle()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context = Context()</span><br><span class="line">state = ConcreteStateA()</span><br><span class="line">stateB = ConcreteStateB()</span><br><span class="line">context.set_state(state)</span><br><span class="line">context.handle()</span><br><span class="line">state = ConcreteStateB()</span><br><span class="line">context.set_state(state)</span><br><span class="line">context.handle()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算机开关机状态</span><br><span class="line">class ComputerState:</span><br><span class="line">    name = &#x27;state&#x27;</span><br><span class="line">    allowed = []</span><br><span class="line"></span><br><span class="line">    def switch(self, state):</span><br><span class="line">        if state.name in self.allowed:</span><br><span class="line">            print(&#x27;Current:&#x27;, self, &#x27;=&gt;switched to new state&#x27;, state.name)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;Current:&#x27;, self, &#x27;=&gt;switched to&#x27;, state.name, &#x27;not possible&#x27;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Off(ComputerState):</span><br><span class="line">    name = &#x27;off&#x27;</span><br><span class="line">    allowed = [&#x27;on&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class On(ComputerState):</span><br><span class="line">    name = &#x27;on&#x27;</span><br><span class="line">    allowed = [&#x27;off&#x27;, &#x27;suspend&#x27;, &#x27;hibernate&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Suspend(ComputerState):</span><br><span class="line">    name = &#x27;suspend&#x27;</span><br><span class="line">    allowed = [&#x27;on&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Hibernate(ComputerState):</span><br><span class="line">    name = &#x27;hibernate&#x27;</span><br><span class="line">    allowed = [&#x27;on&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Computer(object):</span><br><span class="line">    def __init__(self, model=&#x27;HP&#x27;):</span><br><span class="line">        self.model = model</span><br><span class="line">        self.state = Off()</span><br><span class="line"></span><br><span class="line">    def change(self, state):</span><br><span class="line">        self.state.switch(state)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    comp = Computer()</span><br><span class="line">    comp.change(On)</span><br><span class="line">    comp.change(Off)</span><br><span class="line">    comp.change(On)</span><br><span class="line">    comp.change(Suspend)</span><br><span class="line">    comp.change(Hibernate)</span><br><span class="line">    comp.change(On)</span><br><span class="line">    comp.change(Off)</span><br></pre></td></tr></table></figure><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>在状态设计模式中，对象的行为是其状态的函数结果，并且行为在运动时根据状态而改变。这消除了if&#x2F;else或switch&#x2F;case条件逻辑的依赖。</li><li>使用状态模式，实现多态行为的好处显而易见的，并且更易于添加状态来支持额外的行为</li><li>状态设计还提高了聚合性，因为特定于状态的行为被聚合到ConcreteState类中，并且放置在代码中的同一个地方</li><li>使用状态设计模式，通过只添加一个ConcreteState类来添加行为是非常容易的。因此，状态模式不仅改善了扩展应用程序行为时的灵活性，而且全面提高了代码的可维护性。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>类爆炸：由于每个状态都需要在ConcreteState的帮助下定义，因此我们可能导致创建了太多功能比较单一的类。我们不妨考虑有限状态机的情况——如果有许多状态，但是每个状态与另一个状态没有太大的不同，我们仍然需要将它们写成单独的ConcreteState类。这即增加了代码量，又使得状态机构更加难以审查。</li><li>随着每个新行为的引入，Context类都需要进行相应的更新处理每个行为。这使得上下文行为更容易受到每个新的行为的影响。</li></ul><h3 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.bilibili.com/video/BV1oi4y1g7Nn/">五分钟学设计模式.09.状态模式</a></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="内容-8"><a href="#内容-8" class="headerlink" title="内容"></a>内容</h3><p>定义一系列的算法，把它们封装起来，并且使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化。</p><h3 id="角色：-5"><a href="#角色：-5" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象策略 Strategy：定义了一个共同的接口。所有具体的算法类实现这个接口。环境（上下文）类 Context 使用这个接口调用具体的算法类。</li><li>具体策略 ConcreteStrategy：封装了具体的算法，实现同一个接口。</li><li>上下文 Context：环境（上下文）类。用于配置一个具体的算法策略对象，维持一个策略接口类型的参考（Reference），并且可以定义一个让接口<br>Strategy 的具体对象访问的接口。在简单情况下，Context 类可以省略。</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>在以下情况之一发生时可以使用策略模式。</p><ul><li>当有多个仅在行为上不同但是相关的类存在时，策略模式提供了一个为一个类配置多种行为之一的方法。</li><li>当一个算法使用用户不应该知道的数据时，使用策略模式可以将算法的实现细节隐藏起来，避免暴露与算法相关的复杂细节。注意，虽然可以将算法的实现细节封装起来，但是客户程序必须知道各个策略子类的接口。</li><li>当一个类有多种行为，这些行为以大块的条件语句实现时可以使用策略模式，这时可以将条件块移入它们自己的 Strategy 类。</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象策略</span><br><span class="line">class Strategy(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def execute(self, data):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体策略</span><br><span class="line">class CStrategy(Strategy):</span><br><span class="line">    def execute(self, data):</span><br><span class="line">        print(f&quot;使用C算法处理&#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体策略</span><br><span class="line">class NStrategy(Strategy):</span><br><span class="line">    def execute(self, data):</span><br><span class="line">        print(F&quot;使用N算法处理&#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 上下文</span><br><span class="line">class Context:</span><br><span class="line">    def __init__(self, strategy, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.strategy = strategy</span><br><span class="line">        # 可以定义用户不知道的东西</span><br><span class="line">        self.date = datetime.now()</span><br><span class="line"></span><br><span class="line">    def set_strategy(self, strategy):</span><br><span class="line">        self.strategy = strategy</span><br><span class="line"></span><br><span class="line">    def do_strategy(self):</span><br><span class="line">        self.strategy.execute(self.data)</span><br><span class="line"></span><br><span class="line"># Client</span><br><span class="line">data = &quot;Hello!&quot;</span><br><span class="line">context = Context(None, data)</span><br><span class="line"></span><br><span class="line"># 使用C算法处理</span><br><span class="line">context.set_strategy(CStrategy())</span><br><span class="line">context.do_strategy()</span><br><span class="line"># 使用N算法处理</span><br><span class="line">context.set_strategy(NStrategy())</span><br><span class="line">context.do_strategy()</span><br></pre></td></tr></table></figure><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ol><li>得到一系列可以复用的算法，这些算法继承一个共同的抽象类，因此共有的功能可以放到超类中。</li><li>将不同的算法封装在不同的策略子类中，使逻辑更加清晰，各个算法可以独立地变化，消除了大量的 if…else 语句。</li><li>提供了相同行为的不同实现。客户可以根据不同时间或空间要求选择不同的策略。</li><li>使功能改变或者扩展更容易。具体地说，修改一个算法不必重新编译“Client”与“Context”类。增加一个新算法时，在应用程序暂时还不想使用该新算法的情况下，不必重新编译“Client”与“Context”类。</li></ol><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这与“依赖倒置原则”是背道而驰的。</li><li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</li><li>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</li><li>在客户类中通常存在许多与策略类各个分支相关的条件语句，用于选择产生策略子类对象，然后将这些对象传递给 Context 类，而<br>Context 类则直接使用此对象调用策略模式的策略子类的方法。</li></ol><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="内容-9"><a href="#内容-9" class="headerlink" title="内容"></a>内容</h3><p>访问者模式是指作用于一个对象结构体上的元素的操作。访问者可以使用户在不改变该结构体中的类的基础上定义一个新的操作。</p><h3 id="角色：-6"><a href="#角色：-6" class="headerlink" title="角色："></a>角色：</h3><ul><li>Visitor：为每个 Element 的对象声明一个访问操作。该访问操作的名字最好要包含被访问的类的名字，以便确认该访问操作是专门针对哪个具体的类，如 visitFamilyNoChildren 是专门为了服务类 FamilyNoChildren 的。</li><li>ConcreteVisitor：实现 Visitor 声明的运算。每个运算实现为对应的类的对象定义的算法的一部分。ConcreteVisitor 提供算法的环境并且存储其局部状态。</li><li>Element：定义了一些基本的方法，其中包含提供基本数据的方法，例如一些 get()与 set()方法。重要的是，每个 Element 子类都必须定义一个接收者方法，该方法以 Visitor 为参数类型：Accept(Visitor)，其作用是为被访问者对象和访问者对象之间的交互提供接口。</li><li>ConcreteElement：具体的 Element 的子类，例如 ElementA，该类包含一个 accept 方法接收访问者对象。另外，该类还可能定义一些其他的方法以帮助访问者实现一些功能。</li><li>ObjectStructure：提供一个高层接口，允许访问者访问 Element 的子类。在该类中可以包含一个结构，例如 ArrayList、Vector 等，提供所要访问的 element 的列表。</li></ul><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当一个对象的结构中，包含有多种类型的具有不同接口的对象，且用户要在这些对象上进行依赖于具体的类的运算时，需要用到访问者模式。这就是为什么访问者模式要针对每个被访问的子类都设计一个不同的接口的原因。事实上，如果每个被访问的子类都有相同的接口，包括构造方法、其他方法、参数都一致，则访问者类只需要设计一个访问方法，在该方法中含有一个用于区别不同的被访问的子类的参数即可，例如可以使用被访问者基类作为参数类型。在对象的结构中包含有多种类型的有不同接口的对象时，各个不同的访问方法可能为访问所对应的类提供不同的参数类型。</li><li>当有多个不同的并且互不相关的运算将作用到这些对象上，而用户不希望这些运算混淆这些类时，可以使用访问者模式将相关的操作放到独立的类中，例如为了实现每个结点类中的计算价格方法，可以将所有的计算价格方法放到一个 VisitPrice 类中。</li><li>在对象的数据类型很少改变，但是需要经常改变操作或者增加新的操作的情况下，可以使用访问者模式。反之，如果 Element 的子类经常改变结构，例如需要增加一个新的税种，这就需要在访问者类中增加新的访问方法，因此，在这种情况下使用访问者模式代价较高，尽量不要使用访问者模式。</li></ul><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Visitor(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def visit_element_a(self, element_a):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def visit_element_b(self, element_b):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteVisitor1(Visitor):</span><br><span class="line">    def visit_element_a(self, element_a):</span><br><span class="line">        print(&#x27;ConcreteVisitor1&#x27;, &#x27;element_a&#x27;)</span><br><span class="line"></span><br><span class="line">    def visit_element_b(self, element_b):</span><br><span class="line">        print(&#x27;ConcreteVisitor1&#x27;, &#x27;element_b&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteVisitor2(Visitor):</span><br><span class="line">    def visit_element_a(self, element_a):</span><br><span class="line">        print(&#x27;ConcreteVisitor2&#x27;, &#x27;element_a&#x27;)</span><br><span class="line"></span><br><span class="line">    def visit_element_b(self, element_b):</span><br><span class="line">        print(&#x27;ConcreteVisitor2&#x27;, &#x27;element_b&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Element(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def accept(self, visitor):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ElementA(Element):</span><br><span class="line">    def accept(self, visitor):</span><br><span class="line">        visitor.visit_element_a(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ElementB(Element):</span><br><span class="line">    def accept(self, visitor):</span><br><span class="line">        visitor.visit_element_b(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ObjectStructure:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.elements = [ElementA(), ElementB()]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Client:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def main():</span><br><span class="line">        object_structure = ObjectStructure()</span><br><span class="line">        visitor = ConcreteVisitor1()</span><br><span class="line">        for element in object_structure.elements:</span><br><span class="line">            element.accept(visitor)</span><br><span class="line">        visitor = ConcreteVisitor2()</span><br><span class="line">        for element in object_structure.elements:</span><br><span class="line">            element.accept(visitor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    Client.main()</span><br></pre></td></tr></table></figure><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ol><li>使得在访问者类中针对复杂类结构中的某个类添加新方法较为容易，即只需要简单地添加一个新的访问者方法即可。如果不采用访问者模式，这需要在每个类中添加一个新的方法。</li><li>访问者将相关的方法集中在一个具体的访问者类中，而其他相关的方法集中在另外一个具体的访问者类中。也就是说，访问者子类是按照方法的类型来分类的。</li></ol><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>在增加新的元素类的时候比较困难。每增加一个新的元素类，所有的访问者类都要增加一个新的方法，这违背了“开闭原则”。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="内容-10"><a href="#内容-10" class="headerlink" title="内容"></a>内容</h3><p>定义一个操作中的算法骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h3 id="角色：-7"><a href="#角色：-7" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象类 AbstractClass：声明一个定义算法步骤的接口，作用是定义抽象类（钩子操作），实现一个模板方法作为算法的骨架</li><li>具体类 ConcreteClass：定义子类特定的步骤，作用是实现原子操作。</li></ul><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一次性实现一个算法的不变部分，各个子类中的公共行为应该被提取出来并集中到一个公共父类中以避免代码重复</li><li>控制子类扩展</li><li>当多个算法或类实现类似或相同逻辑的时候</li><li>在子类中实现算法有助于减少重复代码的时候</li><li>可以让子类利用覆盖实现行为来定义多个算法的时候</li></ul><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AbstractClass(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def parse(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def allocate(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def preprocessing(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def training(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def inference(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def saving_result(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def template_method(self):</span><br><span class="line">        print(&quot;算法流程&quot;)</span><br><span class="line">        print(&quot;1. 解析数据&quot;)</span><br><span class="line">        self.parse()</span><br><span class="line">        print(&quot;2. 分配资源&quot;)</span><br><span class="line">        self.allocate()</span><br><span class="line">        print(&quot;3. 预处理&quot;)</span><br><span class="line">        self.preprocessing()</span><br><span class="line">        print(&quot;4. 训练&quot;)</span><br><span class="line">        self.training()</span><br><span class="line">        print(&quot;5. 推理&quot;)</span><br><span class="line">        self.inference()</span><br><span class="line">        print(&quot;6. 保存结果&quot;)</span><br><span class="line">        self.saving_result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteClass(AbstractClass):</span><br><span class="line">    def parse(self):</span><br><span class="line">        print(&quot;解析数据&quot;)</span><br><span class="line"></span><br><span class="line">    def allocate(self):</span><br><span class="line">        print(&quot;分配资源&quot;)</span><br><span class="line"></span><br><span class="line">    def preprocessing(self):</span><br><span class="line">        print(&quot;预处理&quot;)</span><br><span class="line"></span><br><span class="line">    def training(self):</span><br><span class="line">        print(&quot;训练&quot;)</span><br><span class="line"></span><br><span class="line">    def inference(self):</span><br><span class="line">        print(&quot;推理&quot;)</span><br><span class="line"></span><br><span class="line">    def saving_result(self):</span><br><span class="line">        print(&quot;保存结果&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Client(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 应该通过命令、参数等可配置不同的具体的类，这里为了简单直接实例化</span><br><span class="line">        self.concreate = ConcreteClass()</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        self.concreate.template_method()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client = Client()</span><br><span class="line">client.main()</span><br></pre></td></tr></table></figure><h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ol><li>没有重复代码</li><li>由于模板方法模式使用继承而不是合成，因此能够对代码进行重用。所以，只有为数不多的几个方法需要重写。</li><li>灵活性允许子类决定如何实现算法中的步骤。</li></ol><h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ol><li>调试和理解模板方法模式中的流程序列有时会令人困惑。你最终实现的方法可能是一个不应该实现的方法，或根本没有实现抽象方法。文档和严格的错误处理必须由程序员完成。</li><li>模板框架的维护可能是一个问题，因为任何层次（低层或高层）的变更都可能对现实造成干扰。因此使用模板方法模式可能使维护变得异常痛苦。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;行为型模式&quot;&gt;&lt;a href=&quot;#行为型模式&quot; class=&quot;headerlink&quot; title=&quot;行为型模式&quot;&gt;&lt;/a&gt;行为型模式&lt;/h1&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://realtiger.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 设计模式 02</title>
    <link href="http://realtiger.github.io/python-design-patterns-02/"/>
    <id>http://realtiger.github.io/python-design-patterns-02/</id>
    <published>2023-04-30T08:47:39.000Z</published>
    <updated>2023-07-07T12:07:18.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重载（Overload）和重写（Override）"><a href="#重载（Overload）和重写（Override）" class="headerlink" title="重载（Overload）和重写（Override）"></a>重载（Overload）和重写（Override）</h1><span id="more"></span><h2 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>方法重载的好处就是让类以统一的方式处理不同类型的一种手段，调用方法时通过传递给他们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性。</p><p>它的特点是：重载发生在本类，方法名相同，参数列表不同，与返回值无关，只和方法名，参数的类型相关。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>没有重载前，不同的参数的方法需要定义不同的名字防止冲突（JAVA示例）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestMath &#123;</span><br><span class="line"></span><br><span class="line">    public int sumWithTwoNum(int num1, int num2) &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int sumWithThreeNum(int num1, int num2, int num3) &#123;</span><br><span class="line">        return num1 + num2 + num3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sumWithFourNum(int num1, int num2, int num3, int num4) &#123;</span><br><span class="line">        return num1 + num2 + num3 + num4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载后可以定义为同一个名字的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestMath &#123;</span><br><span class="line"></span><br><span class="line">    public int sum(int num1, int num2) &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int sum(int num1, int num2, int num3) &#123;</span><br><span class="line">        return num1 + num2 + num3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sum(int num1, int num2, int num3, int num4) &#123;</span><br><span class="line">        return num1 + num2 + num3 + num4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java重载有一些规则，比如仅仅是返回值类型不同和修饰符不同都不构成方法的重载，仅仅是方法参数的名称不同也不构成重载。</p><p>主要是介绍python，只介绍重载定义，具体重载规则请自行百度学习。</p><h2 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h2><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写。</p><p>重写是发生在类的继承关系，或者类的实现关系中的，重写后的方法和原方法需要保持完全相同的返回值类型、方法名、参数个数以及参数类型，简单来说，就是子类重写的方法必须和父类保持完全一致，说白了就是多态。</p><p>比如：定义了一个动物类，其中有一个进食的方法，动物类有两个子类：猫类和狗类，猫类应该对这个进食的方法重写，具体为：猫吃鱼，而狗类则应重写为：狗啃骨头。因为猫和狗进食的具体内容都不同，所以需要重写。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>不同对象调用父类的同一方法产生不同的结果。调用不同的子类将会产生不同的行为，而无须明确知道这个子类实际上是什么，这是多态的重要应用场景。多态的表现形式之一就是继承，先抽象，再继承。</p><p>鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。</p><p>鸭子类型这一名字出自美国James Whitcomb Riley(有的材料说他是诗人，有的说他是测试人员)提出的如下的表述：</p><p>When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.</p><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Duck:</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&quot;Walk like a duck&quot;)</span><br><span class="line"></span><br><span class="line">    def quack(self):</span><br><span class="line">        print(&quot;Quack like a duck&quot;)</span><br><span class="line"></span><br><span class="line">    def attack(self):</span><br><span class="line">        print(&quot;Attack like a duck&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 可达鸭</span><br><span class="line">class MallardDuck(Duck):</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&quot;MallardDuck walking&quot;)</span><br><span class="line"></span><br><span class="line">    def quack(self):</span><br><span class="line">        print(&quot;MallardDuck quacking&quot;)</span><br><span class="line"></span><br><span class="line">    def attack(self):</span><br><span class="line">        print(&quot;MallardDuck attacking&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 大葱鸭</span><br><span class="line">class FarfetchdDuck(Duck):</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&quot;FarfetchdDuck walking&quot;)</span><br><span class="line"></span><br><span class="line">    def quack(self):</span><br><span class="line">        print(&quot;FarfetchdDuck quacking&quot;)</span><br><span class="line"></span><br><span class="line">    def attack(self):</span><br><span class="line">        print(&quot;FarfetchdDuck attacking&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 和火箭队战斗</span><br><span class="line">def fight_with_team_rocket(duck: Duck):</span><br><span class="line">    duck.walk()</span><br><span class="line">    duck.quack()</span><br><span class="line">    duck.attack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mallard_duck = MallardDuck()</span><br><span class="line">    fight_with_team_rocket(mallard_duck)</span><br><span class="line">    farfetchd_duck = FarfetchdDuck()</span><br><span class="line">    fight_with_team_rocket(farfetchd_duck)</span><br></pre></td></tr></table></figure><h1 id="C-设计模式"><a href="#C-设计模式" class="headerlink" title="C# 设计模式"></a>C# 设计模式</h1><p>继承分为「接口继承」和「实现继承」。在编程语言或者 framework 中实现「接口继承」比较容易，一般保证一定的二进制接口兼容，或者一定的命名规范即可（比如 SICP 中的查表 data-driven）。著名的 Microsoft Component Object Model 和 CORBA 只有接口继承。实现「实现继承」则相对复杂。一般需要在编译级别支持，所以多为语言本身支持。拥有「实现继承」的语言可以通过通过自限的方式模拟「接口继承」。C++ 实现了完全的「多实现继承」，所以它可以完全通过自限的方式模拟「多接口继承」。Java 和 C# 只有「单实现继承」，如果通过自限的方式只能支持「单接口继承」，所以 Java 和 C# 引入了特别的 interface。</p><p>作者：冯东<br>链接：<a href="https://www.zhihu.com/question/20685467/answer/15848984">https://www.zhihu.com/question/20685467/answer/15848984</a><br>来源：知乎</p><p>根据以上信息可以知道，再Java或者C#中，实现设计模式都是通过接口的方式进行设计。</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>两种实现方式：</p><ol><li>类适配器：使用多继承</li><li>对象适配器：使用组合</li></ol><h3 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h3><ul><li>目标接口（Target）</li><li>待适配的类（Adaptee）</li><li>适配器（Adapter）</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>想使用一个已经存在的类，而它的接口不符合你的要求<br>2.（对象适配器）想使用一些已经存在的子类，但不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>类适配器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ColMap(AlgorithmInterface):</span><br><span class="line">    def __init__(self, params):</span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(f&quot;I am running with params: &#123;self.params&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TorchNgp:</span><br><span class="line">    def view(self):</span><br><span class="line">        print(&quot;I am running with no params&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类适配器</span><br><span class="line">class TorchNgpAdapter(AlgorithmInterface, TorchNgp):</span><br><span class="line">    def run(self):</span><br><span class="line">        self.view()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># web点击算法发起任务</span><br><span class="line">def web_show_and_click(algorithm):</span><br><span class="line">    algorithm.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    colmap = ColMap(&quot;params&quot;)</span><br><span class="line">    web_show_and_click(colmap)</span><br><span class="line"></span><br><span class="line">    torch_ngp = TorchNgpAdapter()</span><br><span class="line">    web_show_and_click(torch_ngp)</span><br></pre></td></tr></table></figure><p>对象适配器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ColMap(AlgorithmInterface):</span><br><span class="line">    def __init__(self, params):</span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(f&quot;I am running with params: &#123;self.params&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TorchNgp:</span><br><span class="line">    def view(self):</span><br><span class="line">        print(&quot;I am running with no params&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类适配器</span><br><span class="line">class AlgorithmAdapter(AlgorithmInterface):</span><br><span class="line">    def __init__(self, algorithm):</span><br><span class="line">        self.algorithm = algorithm</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        if hasattr(self.algorithm, &quot;run&quot;):</span><br><span class="line">            self.algorithm.run()</span><br><span class="line">        elif hasattr(self.algorithm, &quot;view&quot;):</span><br><span class="line">            self.algorithm.view()</span><br><span class="line">        else:</span><br><span class="line">            raise NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># web点击算法发起任务</span><br><span class="line">def web_show_and_click(algorithm):</span><br><span class="line">    algorithm.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    col_map = ColMap(&quot;params&quot;)</span><br><span class="line">    torch_ngp = TorchNgp()</span><br><span class="line">    web_show_and_click(AlgorithmAdapter(col_map))</span><br><span class="line">    web_show_and_click(AlgorithmAdapter(torch_ngp))</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>聚合(aggregation)：指的是整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构。从而找出一些组成类，该整体类和组成类之间就形成了聚合关系。需求描述中“包含”、“组成”、“分为…部分”等词常意味着聚合关系。</p><p>简单的说就是类中使用的实例是外部传入的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Cpu:</span><br><span class="line">    def show(self):</span><br><span class="line">        print(&quot;I am cpu&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Computer:</span><br><span class="line">    def __init__(self, cpu):</span><br><span class="line">        self.cpu = cpu</span><br><span class="line"></span><br><span class="line">    def has_cpu(self):</span><br><span class="line">        self.cpu.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cpu = Cpu()</span><br><span class="line">computer = Computer(cpu)</span><br><span class="line">computer.has_cpu()</span><br></pre></td></tr></table></figure><p>组合(composition)：也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在。部分对象与整体对象之间具有共生死的关系。</p><p>简单的说就是使用的实例是类中生成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Cpu:</span><br><span class="line">    def show(self):</span><br><span class="line">        print(&quot;I am cpu&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Computer:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.cpu = Cpu()</span><br><span class="line"></span><br><span class="line">    def has_cpu(self):</span><br><span class="line">        self.cpu.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">computer = Computer()</span><br><span class="line">computer.has_cpu()</span><br></pre></td></tr></table></figure><h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>将一个事物的两个维度分离，使其都可以独立地变化</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象（Abstraction）</li><li>细化抽象（RefinedAbstraction）</li><li>实现者（Implementor）</li><li>具体实现者（ConcreteImplementor</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 实现者</span><br><span class="line">class GL(ABC):</span><br><span class="line">    def __init__(self, loader):</span><br><span class="line">        self.loader = loader</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def screen(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象</span><br><span class="line">class Loader(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def loader(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 细化抽象</span><br><span class="line">class PlyLoader(Loader):</span><br><span class="line">    def loader(self):</span><br><span class="line">        print(&quot;ply loader&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ObjLoader(Loader):</span><br><span class="line">    def loader(self):</span><br><span class="line">        print(&quot;obj loader&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体实现者</span><br><span class="line">class WebGL(GL):</span><br><span class="line">    def screen(self):</span><br><span class="line">        self.loader.loader()</span><br><span class="line">        print(&quot;call webgl screen method&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OpenGL(GL):</span><br><span class="line">    def screen(self):</span><br><span class="line">        self.loader.loader()</span><br><span class="line">        print(&quot;call opengl screen method&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    webgl = WebGL(PlyLoader())</span><br><span class="line">    webgl.screen()</span><br><span class="line">    opengl = OpenGL(ObjLoader())</span><br><span class="line">    opengl.screen()</span><br></pre></td></tr></table></figure><p>这样之后即使再增加其他模型的加在类或者其他类型的GL方式都可以方便的添加。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当事物有两个维度上的表现，两个维度都可能扩展时。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>抽象和实现相分离</li><li>优秀的扩展能力</li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象组件（Component）</li><li>叶子组件（Leaf）</li><li>复合组件（Composite）</li><li>客户端（Client）</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def train_model(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ColMapApp(AlgorithmInterface):</span><br><span class="line">    def __init__(self, params):</span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    def train_model(self):</span><br><span class="line">        print(f&quot;ColMapApp am training with params: &#123;self.params&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TorchNgpApp(AlgorithmInterface):</span><br><span class="line">    def train_model(self):</span><br><span class="line">        print(f&quot;TorchNgpApp am training with no params&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class NewBeeApp(AlgorithmInterface):</span><br><span class="line">    def __init__(self, algorithms):</span><br><span class="line">        self.algorithms = []</span><br><span class="line"></span><br><span class="line">        for algorithm in algorithms:</span><br><span class="line">            self.add_algorithm(algorithm)</span><br><span class="line"></span><br><span class="line">    def add_algorithm(self, algorithm):</span><br><span class="line">        self.algorithms.append(algorithm)</span><br><span class="line"></span><br><span class="line">    def train_model(self):</span><br><span class="line">        print(&quot;###### NewBeeApp Training ######&quot;)</span><br><span class="line">        for algorithm in self.algorithms:</span><br><span class="line">            algorithm.train_model()</span><br><span class="line">        print(&quot;###### NewBeeApp Trained ######&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># web点击算法发起任务</span><br><span class="line">def web_show_and_click(algorithm):</span><br><span class="line">    algorithm.train_model()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    colmap_app = ColMapApp(params=&quot;colmap_params&quot;)</span><br><span class="line">    torch_ngp_app = TorchNgpApp()</span><br><span class="line">    new_bee_app = NewBeeApp(algorithms=[colmap_app, torch_ngp_app])</span><br><span class="line"></span><br><span class="line">    # 单个算法发起任务</span><br><span class="line">    web_show_and_click(colmap_app)</span><br><span class="line">    # 组合算法发起任务，调用方式相同</span><br><span class="line">    web_show_and_click(new_bee_app)</span><br></pre></td></tr></table></figure><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>表示对象的“部分-整体”层次结构（特别是结构是递归的）</li><li>希望用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中的所有对象</li></ol><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>定义了包含基本对象和组合对象的类层次结构</li><li>简化客户端代码，即客户端可以一致地使用组合对象和单个对象</li><li>更容易增加新类型的组件</li></ul><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>装饰模式是在原有对象的基础上，动态增加一个新的特性。与继承的最大区别是，这种新增特性是比较泛化的，可以被多种对象增加。</p><p>python中通常用的是通过函数装饰器或者类装饰器，直接对对象所属的类进行装饰，语言特性已包含，因此此设计模式略过。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>外观模式又被称为门面模式，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><h3 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h3><ul><li>外观（facade）</li><li>子系统类（subsystem classes）</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class LoaderModel:</span><br><span class="line">    def loader(self):</span><br><span class="line">        print(&quot;loader model&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DrawScreen:</span><br><span class="line">    def draw(self):</span><br><span class="line">        print(&quot;draw screen&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LoadAnimation:</span><br><span class="line">    def animation(self):</span><br><span class="line">        print(&quot;load animation&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Page:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.loader = LoaderModel()</span><br><span class="line">        self.draw = DrawScreen()</span><br><span class="line">        self.animation = LoadAnimation()</span><br><span class="line"></span><br><span class="line">    def load(self):</span><br><span class="line">        self.loader.loader()</span><br><span class="line">        self.draw.draw()</span><br><span class="line">        self.animation.animation()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    page = Page()</span><br><span class="line">    page.load()</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个例子是比如维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展，但是它包含很重要的功能，新的开发必须依赖于它，这样增加外观Facade类，为系统封装一个比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>减少系统相互依赖</li><li>提高了灵活性</li><li>提高了安全性</li></ul><h2 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式(Flyweight)"></a>享元模式(Flyweight)</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><ul><li>图形图像处理软件：在图形图像处理软件中，可能需要创建大量的形状对象，如矩形、圆形等。通过使用享元模式，可以共享形状对象的属性，从而减少内存使用和提高性能。</li><li>游戏开发：在游戏开发中，可能需要创建大量的游戏角色、武器等对象。通过使用享元模式，可以共享游戏对象的属性，从而减少内存使用和提高性能。</li><li>网络服务器：在网络服务器中，可能需要创建大量的网络连接对象。通过使用享元模式，可以共享网络连接对象的属性，从而减少内存使用和提高性能。</li><li>数据库连接池：在数据库连接池中，可能需要创建大量的数据库连接对象。通过使用享元模式，可以共享数据库连接对象的属性，从而减少内存使用和提高性能。</li></ul><h3 id="角色：-1"><a href="#角色：-1" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象享元角色（Flyweight）</li><li>具体享元角色（Concrete Flyweight）</li><li>非享元角色（Unsharable Flyweight)</li><li>享元工厂角色（Flyweight Factory）</li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>想使用一个已经存在的类，而它的接口不符合你的要求<br>2.（对象适配器）想使用一些已经存在的子类，但不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ol><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Flyweight(ABC):</span><br><span class="line">    def __init__(self, shared_state):</span><br><span class="line">        self.shared_state = shared_state</span><br><span class="line">        print(f&quot;Flyweight: (&#123;self.shared_state&#125;)&quot;)</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self, unique_state):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteFlyweight(Flyweight):</span><br><span class="line">    def show(self, unique_state):</span><br><span class="line">        print(f&quot;ConcreteFlyweight: (&#123;self.shared_state&#125;, &#123;unique_state&#125;)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FlyweightFactory:</span><br><span class="line">    _flyweights = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def __init__(self, shared_states):</span><br><span class="line">        for shared_state in shared_states:</span><br><span class="line">            self._flyweights[str(shared_state)] = ConcreteFlyweight(shared_state)</span><br><span class="line"></span><br><span class="line">    def get_flyweight(self, shared_state):</span><br><span class="line">        key = str(shared_state)</span><br><span class="line">        if key not in self._flyweights:</span><br><span class="line">            self._flyweights[key] = ConcreteFlyweight(shared_state)</span><br><span class="line">        return self._flyweights[key]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示模型的客户端代码</span><br><span class="line">class Client:</span><br><span class="line">    def __init__(self, factory):</span><br><span class="line">        self.factory = factory</span><br><span class="line"></span><br><span class="line">    def screen(self, model, position):</span><br><span class="line">        flyweight = self.factory.get_flyweight(model)</span><br><span class="line">        flyweight.show(position)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这里定义模型类，load_model在FlyweightFactory中的初始化时调用</span><br><span class="line">class Model:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 初始化模型</span><br><span class="line">    roma = Model(&quot;罗马斗兽场&quot;)</span><br><span class="line">    lion = Model(&quot;狮子&quot;)</span><br><span class="line">    wolf = Model(&quot;狼&quot;)</span><br><span class="line">    bird = Model(&quot;鸟&quot;)</span><br><span class="line">    car = Model(&quot;汽车&quot;)</span><br><span class="line"></span><br><span class="line">    # 客户端代码, 初始化时加载模型</span><br><span class="line">    client = Client(FlyweightFactory([roma, lion, bird, car]))</span><br><span class="line"></span><br><span class="line">    # 显示模型</span><br><span class="line">    client.screen(roma, (0, 0, 0))</span><br><span class="line">    client.screen(lion, (1, 1, 1))</span><br><span class="line">    client.screen(wolf, (2, 2, 2))</span><br><span class="line">    client.screen(bird, (3, 3, 3))</span><br><span class="line">    client.screen(car, (4, 4, 4))</span><br><span class="line">    client.screen(lion, (5, 5, 5))</span><br><span class="line">    client.screen(wolf, (6, 6, 6))</span><br><span class="line">    client.screen(bird, (7, 7, 7))</span><br></pre></td></tr></table></figure><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.为了共享对象，需要将不能共享的状态外部化，会增加程序的复杂性</p><p>2.对享元模式的外部状态会增长运行时间</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="内容-6"><a href="#内容-6" class="headerlink" title="内容"></a>内容</h3><p>为其他对象提供一种代理，以此控制一个对象的访问方式。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><h3 id="角色：-2"><a href="#角色：-2" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象角色（Subject）</li><li>真实角色（Real Subject）</li><li>代理角色（Proxy）</li></ul><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>远程代理：隐藏对象位于远程地址空间的事实。例如写入数据，而数据库不在本地，需要远程访问。隐藏数据库不在本地的事实，使用代理进行远程存储。</li><li>虚代理：为了节省资源开销，在功能没有被真正调用时，就不运行。例如浏览器中的无图模式，不显示图片，等你真正需要查看某张时，点击才会真正加载图像，不点击时，只会告诉你，此处是一张图像，并不显示</li><li>保护代理：访问一个对象时有一些附加的内务处理。例如为了区分用户权限而设置的代理，普通用户只有访问权限，而开发人员有写入权限。</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Subject(ABC):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.model = None</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RealSubject(Subject):</span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        if not self.model:</span><br><span class="line">            print(f&quot;本地模型 &#123;model&#125; 加载中...&quot;)</span><br><span class="line">            self.model = model</span><br><span class="line">        print(f&quot;&#123;model&#125; 模型加载完成！&quot;)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        print(f&quot;&#123;self.model&#125; 模型展示！&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RemoteProxy(Subject):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.subject = RealSubject()</span><br><span class="line"></span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        print(&quot;远程模型加载中...&quot;)</span><br><span class="line">        self.subject.model = model</span><br><span class="line">        self.subject.load(model)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        return self.subject.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class VirtualProxy(Subject):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.subject = RemoteProxy()</span><br><span class="line"></span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        self.model = model</span><br><span class="line">        print(&quot;虚拟模型已经记录...&quot;)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        if not self.model:</span><br><span class="line">            print(&quot;虚拟模型未记录！&quot;)</span><br><span class="line">            return</span><br><span class="line">        print(&quot;虚拟模型展示！&quot;)</span><br><span class="line">        self.subject.load(self.model)</span><br><span class="line">        self.subject.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ProtectionProxy(Subject):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.subject = VirtualProxy()</span><br><span class="line"></span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        user = args[0]</span><br><span class="line">        if user == &quot;admin&quot;:</span><br><span class="line">            self.subject.load(model)</span><br><span class="line">            self.model = model</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;权限不足！&quot;)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        if not self.model:</span><br><span class="line">            print(&quot;模型未加载！&quot;)</span><br><span class="line">            return</span><br><span class="line">        self.subject.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def client_code(models_and_users):</span><br><span class="line">    proxy_list = []</span><br><span class="line"></span><br><span class="line">    for user, model in models_and_users:</span><br><span class="line">        # proxy = RealSubject()</span><br><span class="line">        # proxy = RemoteProxy()</span><br><span class="line">        # proxy = VirtualProxy()</span><br><span class="line">        proxy = ProtectionProxy()</span><br><span class="line">        proxy.load(model, user)</span><br><span class="line">        proxy_list.append(proxy)</span><br><span class="line"></span><br><span class="line">    for proxy in proxy_list:</span><br><span class="line">        proxy.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    model_and_user = [</span><br><span class="line">        (&quot;admin&quot;, &quot;roma&quot;),</span><br><span class="line">        (&quot;user&quot;, &quot;bird&quot;),</span><br><span class="line">        (&quot;admin&quot;, &quot;car&quot;)</span><br><span class="line">    ]</span><br><span class="line">    client_code(model_and_user)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;重载（Overload）和重写（Override）&quot;&gt;&lt;a href=&quot;#重载（Overload）和重写（Override）&quot; class=&quot;headerlink&quot; title=&quot;重载（Overload）和重写（Override）&quot;&gt;&lt;/a&gt;重载（Overload）和重写（Override）&lt;/h1&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://realtiger.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 设计模式 01</title>
    <link href="http://realtiger.github.io/python-design-patterns-01/"/>
    <id>http://realtiger.github.io/python-design-patterns-01/</id>
    <published>2023-04-25T15:12:37.000Z</published>
    <updated>2023-07-07T12:07:18.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式（Design pattern）是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</p><p>每一个设计模式系统地命名、解释和评价了面向对象系统中一个重要的和重复出现的设计。</p><p>这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。</p><p>我们使用设计模式最终的目的是实现代码的高内聚和低耦合。</p><p>设计模式中有一些重要的人物如，“四人帮”（Gang of Four， GoF）：Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides，他们写了一本书在设计模式中影响比较大《设计模式：可复用面向对象软件的基础》</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>这里的设计模式特指OOP中的设计模式，说明之前需要明确几个概念。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象的三大特性：</p><ul><li>封装：将数据、方法封装到一个类里；具有公有和私有属性。</li><li>继承：多个类之间复用代码使用继承。</li><li>多态：python本身就是一门多态语言，不用程序员去考虑多态，语言特性自己做了。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口：若干抽象方法的集合。<br>作用：限制实现接口的类必须按照接口给定的调用方式实现这些方法；对高层模块隐藏了类的内部实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@abstractmethod：抽象方法，含abstractmethod方法的类不能实例化，继承了含abstractmethod方法的子类必须复写所有abstractmethod装饰的方法，未被装饰的可以不重写</span><br><span class="line">@property：方法伪装属性，方法返回值及属性值，被装饰方法不能有参数，必须实例化后调用，类不能调用</span><br><span class="line">@classmethod：类方法，可以通过实例对象和类对象调用，被该函数修饰的方法第一个参数代表类本身常用cls，被修饰函数内可调用类属性，不能调用实例属性</span><br><span class="line">@staticmethod：静态方法，可以通过实例对象和类对象调用，被装饰函数可无参数，被装饰函数内部通过类名.属性引用 类属性或类方法，不能引用实例属性</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># abstract class 有抽象方法就是抽象类：抽象类不可被实例化</span><br><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># class BaseAlgorithmInterface:</span><br><span class="line">#     def run(self):</span><br><span class="line">#         raise NotImplementedError</span><br><span class="line">#</span><br><span class="line">class BaseAlgorithmInterface(ABC):</span><br><span class="line">    # 该类被子类继承时必须实现被abstractmethod装饰的方法</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Colmap(BaseAlgorithmInterface):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;do something with Colmap&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerf(BaseAlgorithmInterface):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;do something with HashNert&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = Colmap()</span><br><span class="line">c.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="面向对象设计SOLID原则"><a href="#面向对象设计SOLID原则" class="headerlink" title="面向对象设计SOLID原则"></a>面向对象设计SOLID原则</h1><ol><li><p>单一职责原则</p><p>就一个类而言，应该仅有一个引起它变化的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱他的设计，当变化发生时，设计会遭受到意想不到的破坏；软件设计真正要做的许多内容就是发现职责并把那些职责相互分离。</p></li><li><p>开放-封闭原则</p><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p><p>该原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的可维护、可扩展、可复用、灵活性好。</p><p>设计人员必须对于他设计的模块应该对哪种变化封闭做出选择，必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。最初编写程序时假设变化不会发生，当变化发生时，就创建抽象来隔离以后发生的同类变化，拒绝不成熟的抽象。</p></li><li><p>里氏替换原则</p><p>所有引用父类的地方必须能透明地使用其子类的对象。</p><p>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</p></li><li><p>依赖倒置原则</p><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p><p>要针对接口编程，而不是针对实现编程。该原则可以说是面向对象设计的标志，编写时考虑的是如何对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口。</p></li><li><p>迪迷特原则（最少知识原则）</p><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>该原则其根本思想，是强调了类之间的松耦合；类之间的耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</p></li><li><p>接口隔离原则</p><p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></li><li><p>合成&#x2F;聚合复用原则</p><p>尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p><p>聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p><p>优先使用对象的合成&#x2F;聚合将有助于你保持每个类被封装，并被击中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p></li></ol><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ol><li><p>创建型模式（5种）</p><p>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p><ul><li>工厂方法模式</li><li>抽象工厂模式</li><li>创建者模式</li><li>原型模式</li><li>单例模式</li></ul></li><li><p>结构型模式（7种）</p><p>把类或对象结合在一起形成一个更大的结构。</p><ul><li>适配器模式</li><li>桥模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul></li><li><p>行为型模式（11种）</p><p>类和对象如何交互，及划分责任和算法。</p><ul><li>解释器模式</li><li>责任链模式</li><li>命令模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>访问者模式</li><li>模板方法模式</li></ul></li></ol><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>工厂角色（Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseAlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Colmap(BaseAlgorithmInterface):</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with Colmap&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerf(BaseAlgorithmInterface):</span><br><span class="line">    def __init__(self, application=None):</span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        if self.application:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with &#123;self.application&#125; base on HashNerf&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with HashNerf&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmFactory:</span><br><span class="line">    def create_algorithm(self, name):</span><br><span class="line">        match name:</span><br><span class="line">            case &#x27;colmap&#x27;:</span><br><span class="line">                return Colmap()</span><br><span class="line">            case &#x27;hashnerf&#x27;:</span><br><span class="line">                return HashNerf()</span><br><span class="line">            case &#x27;slam&#x27;:</span><br><span class="line">                return HashNerf(application=&#x27;slam&#x27;)</span><br><span class="line">            case _:</span><br><span class="line">                raise ValueError(f&#x27;Algorithm &#123;name&#125; is not supported&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line"># 算法应用创建工厂</span><br><span class="line">algorithm_factory = AlgorithmFactory()</span><br><span class="line"></span><br><span class="line">nerf = algorithm_factory.create_algorithm(&#x27;hashnerf&#x27;)</span><br><span class="line">nerf.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br><span class="line"></span><br><span class="line"># 隐藏类的内部实现</span><br><span class="line">slam = algorithm_factory.create_algorithm(&#x27;slam&#x27;)</span><br><span class="line">slam.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>隐藏了对象创建的实现细节</li><li>客户端不需要修改代码</li></ul><p>缺点：</p><ul><li>违反了单一职责原则，将创建逻辑几种到一个工厂类里</li><li>当添加新产品时，需要修改工厂类代码，违反了开闭原则</li></ul><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>定义一个用于创建对象的接口（工厂接口），让子类决定实例化哪一个产品类。</p><h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象工厂角色（Creator）</li><li>具体工厂角色（Concrete Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseAlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Colmap(BaseAlgorithmInterface):</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with Colmap&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerf(BaseAlgorithmInterface):</span><br><span class="line">    def __init__(self, application=None):</span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        if self.application:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with &#123;self.application&#125; base on HashNerf&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with HashNerf&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体工厂 #####</span><br><span class="line">class ColmapFactory:</span><br><span class="line">    def create_algorithm(self):</span><br><span class="line">        return Colmap()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerfFactory:</span><br><span class="line">    def create_algorithm(self):</span><br><span class="line">        return HashNerf()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SlamFactory:</span><br><span class="line">    def create_algorithm(self):</span><br><span class="line">        return HashNerf(application=&#x27;slam&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line">nerf = HashNerfFactory().create_algorithm()</span><br><span class="line">nerf.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br><span class="line"></span><br><span class="line">slam = SlamFactory().create_algorithm()</span><br><span class="line">slam.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>每个具体产品都对应一个具体工厂类，不需要修改工厂类代码</li><li>隐藏了对象创建的实现细节</li></ul><p>缺点：</p><ul><li>每增加一个具体产品类，就必须增加一个相应的具体工厂类</li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象。</p><p>例：生产一部手机，需要手机壳、CPU、操作系统三类对象进行组装，其中每类对象都有不同的种类。对每个具体工厂，分别生产一部手机所需要的三个对象。</p><p>相比工厂方法模式，抽象工厂模式中的每个具体工厂都生产一套产品。</p><h3 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象工厂角色（Creator）</li><li>具体工厂角色（Concrete Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li><li>客户端（Client）</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 抽象产品 #####</span><br><span class="line">class PhoneShell(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CPU(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OS(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show_os(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 抽象工厂 #####</span><br><span class="line">class PhoneFactory(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def make_shell(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def make_os(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体产品 #####</span><br><span class="line">class SmallShell(PhoneShell):</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        print(&quot;普通手机小手机壳&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BigShell(PhoneShell):</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        print(&quot;普通手机大手机壳&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AppleShell(PhoneShell):</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        print(&quot;苹果手机壳&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SnapDragonCPU(CPU):</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        print(&quot;骁龙CPU&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MediaTekCPU(CPU):</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        print(&quot;联发科CPU&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AppleCPU(CPU):</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        print(&quot;苹果CPU&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Android(OS):</span><br><span class="line">    def show_os(self):</span><br><span class="line">        print(&quot;Android系统&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IOS(OS):</span><br><span class="line">    def show_os(self):</span><br><span class="line">        print(&quot;iOS系统&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体工厂 #####</span><br><span class="line">class MiFactory(PhoneFactory):</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        return SnapDragonCPU()</span><br><span class="line"></span><br><span class="line">    def make_os(self):</span><br><span class="line">        return Android()</span><br><span class="line"></span><br><span class="line">    def make_shell(self):</span><br><span class="line">        return BigShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HuaweiFactory(PhoneFactory):</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        return MediaTekCPU()</span><br><span class="line"></span><br><span class="line">    def make_os(self):</span><br><span class="line">        return Android()</span><br><span class="line"></span><br><span class="line">    def make_shell(self):</span><br><span class="line">        return SmallShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IPhoneFactory(PhoneFactory):</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        return AppleCPU()</span><br><span class="line"></span><br><span class="line">    def make_os(self):</span><br><span class="line">        return IOS()</span><br><span class="line"></span><br><span class="line">    def make_shell(self):</span><br><span class="line">        return AppleShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line">class Phone:</span><br><span class="line">    def __init__(self, cpu, os, shell):</span><br><span class="line">        self.cpu = cpu</span><br><span class="line">        self.os = os</span><br><span class="line">        self.shell = shell</span><br><span class="line"></span><br><span class="line">    def show_info(self):</span><br><span class="line">        print(&quot;手机信息:&quot;)</span><br><span class="line">        self.cpu.show_cpu()</span><br><span class="line">        self.os.show_os()</span><br><span class="line">        self.shell.show_shell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def make_phone(factory):</span><br><span class="line">    cpu = factory.make_cpu()</span><br><span class="line">    os = factory.make_os()</span><br><span class="line">    shell = factory.make_shell()</span><br><span class="line">    return Phone(cpu, os, shell)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = make_phone(IPhoneFactory())</span><br><span class="line">p1.show_info()</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>将客户端与类的具体实现相分离</li><li>每个工厂创建了一个完整的产品系列，使得易于交换产品系列</li><li>有利于产品的一致性（即产品之间的约束关系）</li></ul><p>缺点：</p><ul><li>难以支持新种类的（抽象）产品</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="角色-3"><a href="#角色-3" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象建造者（Builder）</li><li>具体建造者（Concrete Builder）</li><li>指挥者（Director）</li><li>产品（Product）</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 产品 #####</span><br><span class="line">class Player:</span><br><span class="line">    def __init__(self, face=None, body=None, arm=None, leg=None):</span><br><span class="line">        self.face = face</span><br><span class="line">        self.body = body</span><br><span class="line">        self.arm = arm</span><br><span class="line">        self.leg = leg</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;%s, %s, %s, %s&quot; % (self.face, self.body, self.arm, self.leg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 抽象建造者 #####</span><br><span class="line">class PlayerBuilder(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_face(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_body(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_arm(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_leg(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体建造者 #####</span><br><span class="line">class SexyGirlBuilder(PlayerBuilder):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.player = Player()</span><br><span class="line"></span><br><span class="line">    def build_face(self):</span><br><span class="line">        self.player.face = &quot;漂亮脸蛋&quot;</span><br><span class="line"></span><br><span class="line">    def build_body(self):</span><br><span class="line">        self.player.body = &quot;苗条&quot;</span><br><span class="line"></span><br><span class="line">    def build_arm(self):</span><br><span class="line">        self.player.arm = &quot;漂亮胳膊&quot;</span><br><span class="line"></span><br><span class="line">    def build_leg(self):</span><br><span class="line">        self.player.leg = &quot;大长腿&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Monster(PlayerBuilder):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.player = Player()</span><br><span class="line"></span><br><span class="line">    def build_face(self):</span><br><span class="line">        self.player.face = &quot;怪兽脸&quot;</span><br><span class="line"></span><br><span class="line">    def build_body(self):</span><br><span class="line">        self.player.body = &quot;怪兽身材&quot;</span><br><span class="line"></span><br><span class="line">    def build_arm(self):</span><br><span class="line">        self.player.arm = &quot;长毛的胳膊&quot;</span><br><span class="line"></span><br><span class="line">    def build_leg(self):</span><br><span class="line">        self.player.leg = &quot;长毛的腿&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 指挥者 #####</span><br><span class="line">class PlayerDirector:  # 控制组装顺序</span><br><span class="line">    def build_player(self, builder):</span><br><span class="line">        builder.build_body()</span><br><span class="line">        builder.build_face()</span><br><span class="line">        builder.build_arm()</span><br><span class="line">        builder.build_leg()</span><br><span class="line">        return builder.player</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line">builder = Monster()</span><br><span class="line">director = PlayerDirector()</span><br><span class="line">player = director.build_player(builder)</span><br><span class="line">print(player)</span><br></pre></td></tr></table></figure><p>建造者模式与抽象工厂模式相似，也用来创建复杂对象。</p><p>主要区别是建造者模式着重一步步构造一个复杂对象，而抽象工厂模式着重于多个系列的产品对象。</p><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>隐藏了一个产品的内部结构和装配过程</li><li>将构造代码与表示代码分开，构造顺序修改不影响表示代码</li><li>可以对构造过程进行更精细的控制</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>保证一个类只有一个实例，并提供一个访问它的全局访问点。</p><h3 id="角色-4"><a href="#角色-4" class="headerlink" title="角色"></a>角色</h3><p>单例（Singleton）</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>在 Python 中，我们可以用多种方法来实现单例模式：</p><ul><li>使用模块</li><li>使用装饰器</li><li>使用类</li><li>基于 <strong>new</strong> 方法实现</li><li>基于 metaclass 方式实现</li></ul><h4 id="1-使用模块"><a href="#1-使用模块" class="headerlink" title="1. 使用模块"></a>1. 使用模块</h4><p>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。</p><p>因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p><p>单独定义一个文件，保存为 singleton.py 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Singleton:</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;I am running&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">singleton = Singleton()</span><br></pre></td></tr></table></figure><p>使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from singleton import singleton</span><br><span class="line"></span><br><span class="line"># Now, we can call the run method on the singleton object:</span><br><span class="line">singleton.run()</span><br></pre></td></tr></table></figure><h4 id="2-使用装饰器"><a href="#2-使用装饰器" class="headerlink" title="2. 使用装饰器"></a>2. 使用装饰器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls):</span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def _singleton(*args, **kwargs):</span><br><span class="line">        if cls not in _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        return _instance[cls]</span><br><span class="line"></span><br><span class="line">    return _singleton</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class SingletonObject:</span><br><span class="line">    a = 1</span><br><span class="line"></span><br><span class="line">    def __init__(self, x=0):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = SingletonObject(2)</span><br><span class="line">a2 = SingletonObject(3)</span><br><span class="line"></span><br><span class="line">print(a1.x)</span><br><span class="line">print(a2.x)</span><br></pre></td></tr></table></figure><h4 id="3-使用类"><a href="#3-使用类" class="headerlink" title="3. 使用类"></a>3. 使用类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">            with Singleton._instance_lock:</span><br><span class="line">                if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">                    Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        return Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    singleton_obj = Singleton.instance()</span><br><span class="line">    print(singleton_obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    t = threading.Thread(target=task, args=[i, ])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(20)</span><br><span class="line">obj = Singleton.instance()</span><br><span class="line">print(obj)</span><br></pre></td></tr></table></figure><p>这种方式实现的单例模式，使用时会有限制，以后实例化必须通过 obj &#x3D; Singleton.instance()</p><p>如果用 obj &#x3D; Singleton()，这种方式得到的不是单例。</p><h4 id="4-基于-new-方法实现"><a href="#4-基于-new-方法实现" class="headerlink" title="4. 基于 new 方法实现"></a>4. 基于 <strong>new</strong> 方法实现</h4><p>当我们实例化一个对象时，先执行类的 <strong>new</strong> 方法（我们没写时，默认调用 object.__new__），实例化对象；然后再执行类的 <strong>init</strong> 方法，对这个对象进行初始化，所有可以基于此，实现单例模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">            with Singleton._instance_lock:</span><br><span class="line">                if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">                    Singleton._instance = object.__new__(cls)</span><br><span class="line">        return Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    obj = Singleton()</span><br><span class="line">    print(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    t = threading.Thread(target=task, args=[i, ])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">obj1 = Singleton()</span><br><span class="line">obj2 = Singleton()</span><br><span class="line">print(obj1, obj2)</span><br></pre></td></tr></table></figure><p>采用这种方式的单例模式，以后实例化对象时，和平时实例化对象的方法一样 obj &#x3D; Singleton()</p><h4 id="5-基于-metaclass-方式实现"><a href="#5-基于-metaclass-方式实现" class="headerlink" title="5. 基于 metaclass 方式实现"></a>5. 基于 metaclass 方式实现</h4><p>相关知识:</p><ul><li>类由 type 创建，创建类时，type 的 <strong>init</strong> 方法自动执行，类() 执行 type 的 <strong>call</strong> 方法(类的 <strong>new</strong> 方法，类的 <strong>init</strong> 方法)</li><li>对象由类创建，创建对象时，类的 <strong>init</strong> 方法自动执行，对象()执行类的 <strong>call</strong> 方法</li></ul><p>元类使用例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class TestType(type):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;TestType.__new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __init__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;TestType.__init__&quot;)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;TestType.__call__&quot;)</span><br><span class="line">        return super().__call__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Test(metaclass=TestType):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;Test.__new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;Test.__init__&quot;)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;Test.__call__&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 1. 什么都不调用时输出 #####</span><br><span class="line"># TestType.__new__</span><br><span class="line"># TestType.__init__</span><br><span class="line"></span><br><span class="line"># ##### 2. 实例化类时输出 #####</span><br><span class="line"># TestType.__new__</span><br><span class="line"># TestType.__init__</span><br><span class="line"># TestType.__call__</span><br><span class="line"># Test.__new__</span><br><span class="line"># Test.__init__</span><br><span class="line">#</span><br><span class="line"># test = Test()</span><br><span class="line"></span><br><span class="line"># ##### 3. 调用实例时输出 #####</span><br><span class="line"># TestType.__new__</span><br><span class="line"># TestType.__init__</span><br><span class="line"># TestType.__call__</span><br><span class="line"># Test.__new__</span><br><span class="line"># Test.__init__</span><br><span class="line"># Test.__call__</span><br><span class="line">test = Test()</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>单例模式实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingletonType(type):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(cls, &quot;_instance&quot;):</span><br><span class="line">            with SingletonType._instance_lock:</span><br><span class="line">                if not hasattr(cls, &quot;_instance&quot;):</span><br><span class="line">                    cls._instance = super(SingletonType, cls).__call__(*args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(metaclass=SingletonType):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &#x27;_instance&#x27;))</span><br><span class="line">obj1 = Foo(&#x27;name&#x27;)</span><br><span class="line">print(hasattr(Foo, &#x27;_instance&#x27;))</span><br><span class="line">print(Foo._instance)</span><br><span class="line">obj2 = Foo(&#x27;name&#x27;)</span><br><span class="line">print(obj1, obj2)</span><br></pre></td></tr></table></figure><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>对唯一实例的受控访问</li><li>单例相当于全局变量，但防止了命名空间被污染</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><p>也可以称为复制模式。本质就是克隆对象，在对象初始化操作比较复杂的情况下，很实用，这既隐藏了对象创建的细节，又能大大降低耗时，提高性能。</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Book:</span><br><span class="line">    def __init__(self, name, authors, price, **rest):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        rest的例子有：出版商、长度、标签、出版日期</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.authors = authors</span><br><span class="line">        self.price = price</span><br><span class="line">        # 添加其他额外属性</span><br><span class="line">        self.__dict__.update(rest)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        format_string = &#x27;&#x27;</span><br><span class="line">        for key, value in self.__dict__.items():</span><br><span class="line">            format_string = f&#x27;&#123;format_string&#125;&#123;key&#125;: &#123;value&#125;, &#x27;</span><br><span class="line">        return format_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Prototype:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化一个原型列表</span><br><span class="line">        self.objects = dict()</span><br><span class="line"></span><br><span class="line">    def register(self, identifier, obj):</span><br><span class="line">        # 在原型列表中注册原型对象</span><br><span class="line">        self.objects[identifier] = obj</span><br><span class="line"></span><br><span class="line">    def unregister(self, identifier):</span><br><span class="line">        # 从原型列表中删除原型对象</span><br><span class="line">        del self.objects[identifier]</span><br><span class="line"></span><br><span class="line">    def clone(self, identifier, **attr):</span><br><span class="line">        # 根据 identifier 在原型列表中查找原型对象并克隆</span><br><span class="line">        found = self.objects.get(identifier)</span><br><span class="line">        if not found:</span><br><span class="line">            raise ValueError(&#x27;Incorrect object identifier: &#123;&#125;&#x27;.format(identifier))</span><br><span class="line">        obj = copy.deepcopy(found)</span><br><span class="line">        # 用新的属性值替换原型对象中的对应属性</span><br><span class="line">        obj.__dict__.update(attr)</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    book1 = Book(</span><br><span class="line">        &#x27;The C Programming Language&#x27;,</span><br><span class="line">        (&#x27;Brian W. Kernighan&#x27;, &#x27;Dennis M.Ritchie&#x27;),</span><br><span class="line">        price=118,</span><br><span class="line">        publisher=&#x27;Prentice Hall&#x27;,</span><br><span class="line">        length=228, publication_date=&#x27;1978-02-22&#x27;,</span><br><span class="line">        tags=(&#x27;C&#x27;, &#x27;programming&#x27;, &#x27;algorithms&#x27;, &#x27;data structures&#x27;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    prototype = Prototype()</span><br><span class="line">    register_id = &#x27;book1&#x27;</span><br><span class="line"></span><br><span class="line">    # 注册原型对象</span><br><span class="line">    prototype.register(register_id, book1)</span><br><span class="line">    book2 = prototype.clone(</span><br><span class="line">        register_id,</span><br><span class="line">        name=&#x27;The C Programming Language(ANSI)&#x27;,</span><br><span class="line">        price=48.99,</span><br><span class="line">        length=274,</span><br><span class="line">        publication_date=&#x27;1988-04-01&#x27;,</span><br><span class="line">        edition=2</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    print(book1)</span><br><span class="line">    print(book2)</span><br><span class="line">    print(f&quot;ID book1 : &#123;id(book1)&#125; != ID book2 : &#123;id(book2)&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>其实这段代码在 Python 中，要实现一样的效果，并没有这么复杂。以下代码除了原型模式类删除之外，只有 main 函数有些变更。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Book:</span><br><span class="line">    def __init__(self, name, authors, price, **rest):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        rest的例子有：出版商、长度、标签、出版日期</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.authors = authors</span><br><span class="line">        self.price = price</span><br><span class="line">        # 添加其他额外属性</span><br><span class="line">        self.__dict__.update(rest)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        format_string = &#x27;&#x27;</span><br><span class="line">        for key, value in self.__dict__.items():</span><br><span class="line">            format_string = f&#x27;&#123;format_string&#125;&#123;key&#125;: &#123;value&#125;, &#x27;</span><br><span class="line">        return format_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    book1 = Book(</span><br><span class="line">        &#x27;The C Programming Language&#x27;,</span><br><span class="line">        (&#x27;Brian W. Kernighan&#x27;, &#x27;Dennis M.Ritchie&#x27;),</span><br><span class="line">        price=118,</span><br><span class="line">        publisher=&#x27;Prentice Hall&#x27;,</span><br><span class="line">        length=228, publication_date=&#x27;1978-02-22&#x27;,</span><br><span class="line">        tags=(&#x27;C&#x27;, &#x27;programming&#x27;, &#x27;algorithms&#x27;, &#x27;data structures&#x27;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 这里我们彻底抛弃之前的原型设计模式的写法，同样的内容，经过不同的方式，可以得到同样的效果。</span><br><span class="line">    book2 = copy.deepcopy(book1)</span><br><span class="line">    book2.name = &#x27;The C Programming Language(ANSI)&#x27;</span><br><span class="line">    book2.price = 48.99</span><br><span class="line">    book2.length = 274</span><br><span class="line">    book2.publication_date = &#x27;1988-04-01&#x27;</span><br><span class="line">    book2.edition = 2</span><br><span class="line"></span><br><span class="line">    print(book1)</span><br><span class="line">    print(book2)</span><br><span class="line">    print(f&quot;ID book1 : &#123;id(book1)&#125; != ID book2 : &#123;id(book2)&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>原型模式用于创建复杂的和耗时的实例，复制一个已经存在的实例使程序运行更高效。</li></ul><p>缺点：</p><ul><li>每一个产品类都必须配置一个克隆方法，并且这个克隆方法需要对类的功能进行整体考虑。</li></ul><h2 id="创建型模式小结"><a href="#创建型模式小结" class="headerlink" title="创建型模式小结"></a>创建型模式小结</h2><p>抽象工厂模式和建造者模式相比于简单工厂模式和工厂方法模式而言更灵活也更复杂。</p><p>通常情况下，设计以简单工厂模式或工厂方法模式开始，当你发现设计需要更大的灵活性时，则向更复杂的设计模式演化。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h1&gt;&lt;p&gt;设计模式（Design pattern）是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。&lt;/p&gt;
&lt;p&gt;每一个设计模式系统地命名、解释和评价了面向对象系统中一个重要的和重复出现的设计。&lt;/p&gt;
&lt;p&gt;这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。&lt;/p&gt;
&lt;p&gt;我们使用设计模式最终的目的是实现代码的高内聚和低耦合。&lt;/p&gt;
&lt;p&gt;设计模式中有一些重要的人物如，“四人帮”（Gang of Four， GoF）：Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides，他们写了一本书在设计模式中影响比较大《设计模式：可复用面向对象软件的基础》&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://realtiger.github.io/tags/python/"/>
    
  </entry>
  
</feed>
