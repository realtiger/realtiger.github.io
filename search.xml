<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>k8s deployment</title>
      <link href="/k8s-deployment/"/>
      <url>/k8s-deployment/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>以下主要介绍 k8s 中的 deployment ，deployment 是 k8s 中最常用的资源类型之一，用于管理 pod 的生命周期。</p><span id="more"></span><h1 id="改造之前的-pod"><a href="#改造之前的-pod" class="headerlink" title="改造之前的 pod"></a>改造之前的 pod</h1><p>之前我们使用 pod 来管理应用，但是 pod 有如下缺点：</p><ul><li>pod 无法实现滚动升级</li><li>pod 无法实现回滚</li><li>pod 无法实现自动伸缩</li><li>pod 无法实现自动恢复</li><li>pod 无法实现自动发布</li><li>pod 无法实现自动扩容</li><li>pod 无法实现自动缩容</li><li>pod 无法实现自动重启</li></ul><p>为了解决这些问题，我们需要使用 deployment 来管理应用。</p><h2 id="创建-deployment-文件"><a href="#创建-deployment-文件" class="headerlink" title="创建 deployment 文件"></a>创建 deployment 文件</h2><p>首先创建数据的文件，将其改造为 deployment 方式 <code>deploy-mysql.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 指定Pod副本数</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 指定Pod的选择器</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="comment"># 指定Pod的模板，与上一节定义的Pod模板类似</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">        <span class="attr">hostPath:</span> </span><br><span class="line">          <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">      <span class="comment"># 使用节点选择器将Pod调度到指定label的节点</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_USER</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">secretKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">MYSQL_USER</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">secretKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;myblog&quot;</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">50m</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">500Mi</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>之后创建业务应用的 deployment 文件 <code>deploy-myblog.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 指定Pod副本数</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 指定Pod的选择器</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="comment"># 环境变量全部使用 configmap 和 secret 中的配置</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">configMapKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">secretKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="comment"># 资源限制</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">200Mi</span></span><br></pre></td></tr></table></figure><h2 id="创建-deployment"><a href="#创建-deployment" class="headerlink" title="创建 deployment"></a>创建 deployment</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f deploy-mysql.yaml</span><br><span class="line">$ kubectl apply -f deploy-myblog.yaml</span><br></pre></td></tr></table></figure><h2 id="查看-deployment"><a href="#查看-deployment" class="headerlink" title="查看 deployment"></a>查看 deployment</h2><h3 id="此时可以通过-kubectl-get-deploy-n-test-查看-deployment-的状态："><a href="#此时可以通过-kubectl-get-deploy-n-test-查看-deployment-的状态：" class="headerlink" title="此时可以通过 kubectl get deploy -n test 查看 deployment 的状态："></a>此时可以通过 <code>kubectl get deploy -n test</code> 查看 deployment 的状态：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy -n <span class="built_in">test</span></span><br><span class="line">NAME     READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">mysql    1/1     1            1           2m</span><br><span class="line">myblog   1/1     1            1           2m</span><br></pre></td></tr></table></figure><ul><li><code>NAME</code> 列出了集群中 Deployments 的名称。</li><li><code>READY</code>显示当前正在运行的副本数&#x2F;期望的副本数。</li><li><code>UP-TO-DATE</code>显示已更新以实现期望状态的副本数。</li><li><code>AVAILABLE</code>显示应用程序可供用户使用的副本数。</li><li><code>AGE</code> 显示应用程序运行的时间量。</li></ul><h3 id="查看-pod"><a href="#查看-pod" class="headerlink" title="查看 pod"></a>查看 pod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po -n <span class="built_in">test</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">mysql-7b4f8f8d5f-4j4q4   1/1     Running   0          2m</span><br><span class="line">myblog-7c96c9f76b-qbbg7  1/1     Running   0          2m</span><br></pre></td></tr></table></figure><h3 id="查看-replicaSet"><a href="#查看-replicaSet" class="headerlink" title="查看 replicaSet"></a>查看 replicaSet</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rs -n <span class="built_in">test</span></span><br><span class="line">NAME               DESIRED   CURRENT   READY   AGE</span><br><span class="line">mysql-7b4f8f8d5f   1         1         1       2m</span><br><span class="line">myblog-7c96c9f76b  1         1         1       2m</span><br></pre></td></tr></table></figure><h3 id="查看-deployment-详细信息"><a href="#查看-deployment-详细信息" class="headerlink" title="查看 deployment 详细信息"></a>查看 deployment 详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe deploy mysql -n <span class="built_in">test</span></span><br><span class="line">Name:                   mysql</span><br><span class="line">Namespace:              <span class="built_in">test</span></span><br><span class="line">CreationTimestamp:      Fri, 03 Sep 2021 23:59:15 +0800</span><br><span class="line">Labels:                 &lt;none&gt;</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               app=mysql</span><br><span class="line">Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  1 max unavailable, 1 max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=mysql</span><br><span class="line">  Containers:</span><br><span class="line">   mysql:</span><br><span class="line">    Image:      mysql:5.7</span><br><span class="line">    Port:       3306/TCP</span><br><span class="line">    Host Port:  0/TCP</span><br><span class="line">    Args:</span><br><span class="line">      --character-set-server=utf8mb4</span><br><span class="line">      --collation-server=utf8mb4_unicode_ci</span><br><span class="line">    Limits:</span><br><span class="line">      cpu:     100m</span><br><span class="line">      memory:  500Mi</span><br><span class="line">    Requests:</span><br><span class="line">      cpu:        50m</span><br><span class="line">      memory:     100Mi</span><br><span class="line">    Readiness:    tcp-socket :3306 delay=5s <span class="built_in">timeout</span>=1s period=10s <span class="comment">#success=1 #failure=3</span></span><br><span class="line">    Liveness:     tcp-socket :3306 delay=15s <span class="built_in">timeout</span>=1s period=20s <span class="comment">#success=1 #failure=3</span></span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/lib/mysql from mysql-data (rw)</span><br><span class="line">  Volumes:</span><br><span class="line">   mysql-data:</span><br><span class="line">    Type:          HostPath (bare host directory volume)</span><br><span class="line">    Path:          /opt/mysql/data</span><br><span class="line">    HostPathType:</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure><h2 id="副本保障机制"><a href="#副本保障机制" class="headerlink" title="副本保障机制"></a>副本保障机制</h2><p>controller实时检测pod状态，并保障副本数一直处于期望的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除pod，观察pod状态变化</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> delete pod myblog-7c96c9f76b-qbbg7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观察pod</span></span><br><span class="line">$ kubectl get pods -o wide -n <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置两个副本, 或者通过 kubectl -n test edit deploy myblog 的方式，最好通过修改文件，然后 apply 的方式，这样 yaml 文件可以保持同步</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> scale deploy myblog --replicas=2</span><br><span class="line">deployment.extensions/myblog scaled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观察pod</span></span><br><span class="line">$ kubectl get pods -o wide -n <span class="built_in">test</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">mysql-7b4f8f8d5f-4j4q4    1/1     Running   0          3m18s</span><br><span class="line">myblog-7c96c9f76b-qbbg7   1/1     Running   0          11m</span><br><span class="line">myblog-7c96c9f76b-s6brm   1/1     Running   0          3m18s</span><br></pre></td></tr></table></figure><h2 id="Pod驱逐策略"><a href="#Pod驱逐策略" class="headerlink" title="Pod驱逐策略"></a>Pod驱逐策略</h2><p>K8S 有个特色功能叫 pod eviction，它在某些场景下如节点 NotReady，或者资源不足时，把 pod 驱逐至其它节点，这也是出于业务保护的角度去考虑的。</p><ol><li><p>Kube-controller-manager: 周期性检查所有节点状态，当节点处于 NotReady 状态超过一段时间后，驱逐该节点上所有 pod。</p><ul><li><p><code>pod-eviction-timeout</code>：NotReady 状态节点超过该时间后，执行驱逐，默认 5 min，适用于k8s 1.13版本之前</p></li><li><p>1.13版本后，集群开启<code> TaintBasedEvictions 与TaintNodesByCondition</code> 功能，即<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/">taint-based-evictions</a>，即节点若失联或者出现各种异常情况，k8s会自动为node打上污点，同时为pod默认添加如下容忍设置：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><p> 即各pod可以独立设置驱逐容忍时间。</p></li></ul></li><li><p>Kubelet: 周期性检查本节点资源，当资源不足时，按照优先级驱逐部分 pod</p><ul><li><code>memory.available</code>：节点可用内存</li><li><code>nodefs.available</code>：节点根盘可用存储空间</li><li><code>nodefs.inodesFree</code>：节点inodes可用数量</li><li><code>imagefs.available</code>：镜像存储盘的可用空间</li><li><code>imagefs.inodesFree</code>：镜像存储盘的inodes可用数量</li></ul></li></ol><h2 id="服务更新方法"><a href="#服务更新方法" class="headerlink" title="服务更新方法"></a>服务更新方法</h2><p>修改服务，重新打tag模拟服务更新至下一个版本。</p><p>更新方式：</p><ol><li>修改yaml文件，使用<code>kubectl -n test apply -f deploy-myblog.yaml</code>来应用更新</li><li><code>kubectl -n test edit deploy myblog</code>在线更新</li><li><code>kubectl -n test set image deploy myblog myblog=harbor.mydomain.com/test/myblog:v2 --record</code></li></ol><h2 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">    <span class="comment">#指定更新方式为滚动更新，默认策略，通过get deploy yaml查看</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><p><img src="/post/docker/update.png" alt="update"></p><p>策略控制：</p><ul><li>maxSurge：最大激增数, 指更新过程中, 最多可以比replicas预先设定值多出的pod数量, 可以为固定值或百分比,默认为desired Pods数的25%。计算时向上取整(比如3.4，取4)，更新过程中最多会有replicas + maxSurge个pod</li><li>maxUnavailable： 指更新过程中, 最多有几个pod处于无法服务状态 , 可以为固定值或百分比，默认为desired Pods数的25%。计算时向下取整(比如3.6，取3)</li></ul><p><em>在Deployment rollout时，需要保证Available(Ready) Pods数不低于 desired pods number - maxUnavailable; 保证所有的非异常状态Pods数不多于 desired pods number + maxSurge</em>。</p><p>以myblog为例，使用默认的策略，更新过程:</p><ol><li>maxSurge 25%，2个实例，向上取整，则maxSurge为1，意味着最多可以有2+1&#x3D;3个Pod，那么此时会新创建1个ReplicaSet，RS-new，把副本数置为1，此时呢，副本控制器就去创建这个新的Pod</li><li>同时，maxUnavailable是25%，副本数2*25%，向下取整，则为0，意味着，滚动更新的过程中，不能有少于2个可用的Pod，因此，旧的Replica（RS-old）会先保持不动，等RS-new管理的Pod状态Ready后，此时已经有3个Ready状态的Pod了，那么由于只要保证有2个可用的Pod即可，因此，RS-old的副本数会有2个变成1个，此时，会删掉一个旧的Pod</li><li>删掉旧的Pod的时候，由于总的Pod数量又变成2个了，因此，距离最大的3个还有1个Pod可以创建，所以，RS-new把管理的副本数由1改成2，此时又会创建1个新的Pod，等RS-new管理了2个Pod都ready后，那么就可以把RS-old的副本数由1置为0了，这样就完成了滚动更新</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看滚动更新事件</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> describe deploy myblog</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  11s   deployment-controller  Scaled up replica <span class="built_in">set</span> myblog-6cf56fc848 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  11s   deployment-controller  Scaled down replica <span class="built_in">set</span> myblog-6fdcf98f9 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  11s   deployment-controller  Scaled up replica <span class="built_in">set</span> myblog-6cf56fc848 to 2</span><br><span class="line">  Normal  ScalingReplicaSet  6s    deployment-controller  Scaled down replica <span class="built_in">set</span> myblog-6fdcf98f9 to 0</span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME                     DESIRED   CURRENT   READY   AGE</span><br><span class="line">myblog-6cf56fc848   2         2         2       16h</span><br><span class="line">myblog-6fdcf98f9    0         0         0       16h</span><br></pre></td></tr></table></figure><p>除了滚动更新以外，还有一种策略是Recreate，直接在当前的pod基础上先删后建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  strategy:</span><br><span class="line">    <span class="built_in">type</span>: Recreate</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们的mysql服务应该使用Recreate来管理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> edit deploy mysql</span><br><span class="line">...</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: mysql</span><br><span class="line">  strategy:</span><br><span class="line">    <span class="built_in">type</span>: Recreate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: mysql</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="服务回滚"><a href="#服务回滚" class="headerlink" title="服务回滚"></a>服务回滚</h2><p>通过滚动升级的策略可以平滑的升级Deployment，若升级出现问题，需要最快且最好的方式回退到上一次能够提供正常工作的版本。为此K8S提供了回滚机制。</p><p><strong>revision</strong>：更新应用时，K8S都会记录当前的版本号，即为revision，当升级出现问题时，可通过回滚到某个特定的revision，默认配置下，K8S只会保留最近的几个revision，可以通过Deployment配置文件中的spec.revisionHistoryLimit属性增加revision数量，默认是10。</p><p>查看当前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> rollout <span class="built_in">history</span> deploy myblog <span class="comment">##CHANGE-CAUSE为空</span></span><br><span class="line">$ kubectl delete -f deploy-myblog.yaml <span class="comment">## 方便演示到具体效果，删掉已有deployment</span></span><br></pre></td></tr></table></figure><p>记录回滚：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f deploy-myblog.yaml --record</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">set</span> image deploy myblog myblog=harbor.mydomain.com/test/myblog:v2 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>查看deployment更新历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> rollout <span class="built_in">history</span> deploy myblog</span><br><span class="line">deployment.extensions/myblog</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl create --filename=deploy-myblog.yaml --record=<span class="literal">true</span></span><br><span class="line">2         kubectl <span class="built_in">set</span> image deploy myblog myblog=harbor.mydomain.com/test/myblog:v1 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>回滚到具体的REVISION:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> rollout undo deploy myblog --to-revision=1</span><br><span class="line">deployment.extensions/myblog rolled back</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问应用测试</span></span><br><span class="line">curl 10.244.1.150:8002/blog/index/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pod 常用设置和配置</title>
      <link href="/pod-settings-and-config/"/>
      <url>/pod-settings-and-config/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>以下主要是介绍数据持久化、健康检查、重启策略、镜像拉取策略、资源限制等常用设置、 confingmap&amp;secret 以及 Pod 生命周期的配置的使用。</p><span id="more"></span><p>本节所有的内容都基于假设我们创建了一个mysql的数据库以及一个基于 Django 的 web 服务的 Pod 之后的操作。</p><h1 id="Pod-数据持久化"><a href="#Pod-数据持久化" class="headerlink" title="Pod 数据持久化"></a>Pod 数据持久化</h1><p>如果我们因为各种原因删除了 Pod，由于 mysql 的数据都在容器内部，会造成数据丢失，因此需要数据进行持久化，数据持久化的数据会保存在对应的硬盘上，不随容器的关闭而删除。</p><h2 id="使用-hostpath-挂载"><a href="#使用-hostpath-挂载" class="headerlink" title="使用 hostpath 挂载"></a>使用 hostpath 挂载</h2><p>因为保存在对应的宿主机上，所以需要使用 nodeSelector 定点，下面是 pod-with-volume.yaml 的文件内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">myblog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 声明挂载的卷</span></span><br><span class="line">  <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">hostPath:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">  <span class="comment"># 使用节点选择器将 Pod 调度到指定label的节点</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;myblog&quot;</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="comment"># 使用上面声明的卷挂载到容器内部</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">          <span class="comment"># 挂载到容器内部的路径</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>有了上面的文件就可以进行创建了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若存在旧的同名服务，先删除掉</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> delete pod myblog</span><br><span class="line"><span class="comment">## 创建 Pod</span></span><br><span class="line">$ kubectl create -f pod-with-volume.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 Pod 状态Pending</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po</span><br><span class="line">NAME     READY   STATUS    RESTARTS   AGE</span><br><span class="line">myblog   0/2     Pending   0          32s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看原因，提示调度失败，因为节点不满足node selector</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> describe po myblog</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  12s (x2 over 12s)  default-scheduler  0/3 nodes are available: 3 node(s) didn<span class="string">&#x27;t match node selector.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"># 为节点打标签</span></span><br><span class="line"><span class="string">$ kubectl label node k8s-node1 component=mysql</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 再次查看，已经运行成功</span></span><br><span class="line"><span class="string">$ kubectl -n test get po</span></span><br><span class="line"><span class="string">NAME     READY   STATUS    RESTARTS   AGE     IP             NODE</span></span><br><span class="line"><span class="string">myblog   2/2     Running   0          3m54s   10.244.1.150   k8s-node1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 到 k8s-node1 节点，查看 /opt/mysql/data</span></span><br><span class="line"><span class="string">$ ll /opt/mysql/data/</span></span><br><span class="line"><span class="string">total 188484</span></span><br><span class="line"><span class="string">-rw-r----- 1 polkitd input       56 Mar 29 09:20 auto.cnf</span></span><br><span class="line"><span class="string">-rw------- 1 polkitd input     1676 Mar 29 09:20 ca-key.pem</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 polkitd input     1112 Mar 29 09:20 ca.pem</span></span><br><span class="line"><span class="string">drwxr-x--- 2 polkitd input     8192 Mar 29 09:20 sys</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 执行 migrate，创建数据库表，然后删掉 Pod，再次创建后验证数据是否存在</span></span><br><span class="line"><span class="string">$ kubectl -n test exec -ti myblog python3 manage.py migrate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 访问服务，正常</span></span><br><span class="line"><span class="string">$ curl 10.244.1.150:8002/blog/index/ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 删除 Pod</span></span><br><span class="line"><span class="string">$ kubectl delete -f pod-with-volume.yaml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 再次创建 Pod</span></span><br><span class="line"><span class="string">$ kubectl create -f pod-with-volume.yaml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看 Pod ip并访问服务</span></span><br><span class="line"><span class="string">$ kubectl -n test get po -o wide</span></span><br><span class="line"><span class="string">NAME     READY   STATUS    RESTARTS   AGE   IP             NODE  </span></span><br><span class="line"><span class="string">myblog   2/2     Running   0          7s    10.244.1.151   k8s-node1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 未重新做migrate，服务正常</span></span><br><span class="line"><span class="string">$ curl 10.244.1.151:8002/blog/index/</span></span><br></pre></td></tr></table></figure><h2 id="使用-PV-PVC连接分布式存储解决方案"><a href="#使用-PV-PVC连接分布式存储解决方案" class="headerlink" title="使用 PV+PVC连接分布式存储解决方案"></a>使用 PV+PVC连接分布式存储解决方案</h2><p>hostpath 方式只能将 Pod 固定在特定的机器上，但是 k8s 支持网络存储，可以将数据存储在网络存储上，这样就可以实现 Pod 的迁移，下面是支持 PV+PVC 的协议方式。</p><ul><li>ceph</li><li>glusterfs</li><li>nfs</li></ul><p>具体关于 PV+PVC 的用法会在之后介绍，具体目录可以参考 <a href="https://realtiger.github.io/k8s-learning">k8s 学习笔记</a>。</p><h1 id="服务健康检查"><a href="#服务健康检查" class="headerlink" title="服务健康检查"></a>服务健康检查</h1><p>检测容器服务是否健康的手段，若不健康，会根据设置的重启策略（restartPolicy）进行操作，三种检测机制可以分别单独设置，若不设置，默认认为 Pod 是健康的。</p><p>以下是两种机制的介绍。</p><h2 id="LivenessProbe-探针-（存活探针）"><a href="#LivenessProbe-探针-（存活探针）" class="headerlink" title="LivenessProbe 探针 （存活探针）"></a>LivenessProbe 探针 （存活探针）</h2><p>存活性探测：用于判断容器是否存活，即 Pod 是否为 running 状态，如果 LivenessProbe 探针探测到容器不健康，则 kubelet 将 kill 掉容器，并根据容器的重启策略是否重启，如果一个容器不包含 LivenessProbe 探针，则 Kubelet 认为容器的 LivenessProbe 探针的返回值永远成功。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>  <span class="comment"># 容器启动后第一次执行探测是需要等待多少秒</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span>  <span class="comment"># 执行探测的频率</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">2</span>  <span class="comment"># 探测超时时间</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>可配置的参数如下：</p><ol><li>initialDelaySeconds：容器启动后第一次执行探测是需要等待多少秒。</li><li>periodSeconds：执行探测的频率。默认是10秒，最小1秒。</li><li>timeoutSeconds：探测超时时间。默认1秒，最小1秒。</li><li>successThreshold：探测失败后，最少连续探测成功多少次才被认定为成功。默认是1。</li><li>failureThreshold：探测成功后，最少连续探测失败多少次。默认是3，最小值是1。</li></ol><p>上面例子配置的情况，健康检查的逻辑为：K8S 将在 Pod 开始启动 20s(initialDelaySeconds) 后探测 Pod 内的 8000 端口是否可以建立 TCP 连接，并且每 15 秒钟探测一次，如果连续 3 次探测失败，则 kubelet 重启该容器</p><h2 id="ReadinessProbe-探针-（就绪探针）"><a href="#ReadinessProbe-探针-（就绪探针）" class="headerlink" title="ReadinessProbe 探针 （就绪探针）"></a>ReadinessProbe 探针 （就绪探针）</h2><p>可用性探测：用于判断容器是否正常提供服务，即容器的 Ready 是否为 True，是否可以接收请求，如果 ReadinessProbe 探测失败，则容器的 Ready 将为 False， Endpoint Controller 控制器将此 Pod 的 Endpoint 从对应的 service 的 Endpoint 列表中移除，不再将任何请求调度此 Pod 上，直到下次探测成功。（剔除此 Pod 不参与接收请求不会将流量转发给此 Pod）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">readinessProbe:</span> </span><br><span class="line">      <span class="attr">httpGet:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">10</span> </span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>上面例子配置的情况，健康检查的逻辑为：K8S 将在 Pod 开始启动 10s(initialDelaySeconds) 后利用 HTTP 访问 8002 端口的 &#x2F;blog&#x2F;index&#x2F;，如果超过 2s 或者返回码不在 200~399 内，则健康检查失败</p><h2 id="StartupProbe-探针-（启动探针）"><a href="#StartupProbe-探针-（启动探针）" class="headerlink" title="StartupProbe 探针 （启动探针）"></a>StartupProbe 探针 （启动探针）</h2><p>启动探针：kubelet 使用 startup probe 来指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被禁用，直到该探针成功为止。此探针主要用于判断容器是否已经启动完成，如果 StartupProbe 探针探测失败，则 kubelet 将 kill 掉容器，并根据容器的重启策略是否重启，如果一个容器不包含 StartupProbe 探针，则 Kubelet 认为容器的 StartupProbe 探针的返回值永远成功。</p><p>如果你的容器需要在启动期间加载大型数据、配置文件等操作，那么这个时候我们可以使用启动探针。</p><p>该探针在 Kubernetes v1.20 版本才变成稳定状态，对于所包含的容器需要较长时间才能启动就绪的 Pod 而言，启动探针是有用的。你不再需要配置一个较长的存活态探测时间间隔，只需要设置另一个独立的配置选项，对启动期间的容器执行探测，从而允许使用远远超出存活态时间间隔所允许的时长。</p><p>如果你的容器启动时间通常超出 initialDelaySeconds + failureThreshold × periodSeconds 总值，你应该设置一个启动探针，对存活态探针所使用的同一端点执行检查。 periodSeconds 的默认值是 10 秒，还应该将其failureThreshold 设置得足够高，以便容器有充足的时间完成启动，并且避免更改存活态探针所使用的默认值。 这一设置有助于减少死锁状况的发生。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">startupProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">30</span> <span class="comment"># 尽量设置大一点，避免死锁</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="检查方式"><a href="#检查方式" class="headerlink" title="检查方式"></a>检查方式</h2><p>probe 是由 kubelet 对容器执行的定期诊断，要执行诊断，kubelet 既可以在容器内执行代码，也可以发出一个网络请求。使用探针来检查容器有四种不同的方法。每个探针都必须准确定义为这四种机制中的一种：</p><ul><li><p>exec：通过执行命令来检查服务是否正常，返回值为0则表示容器健康</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  livenessProbe:</span><br><span class="line">    <span class="built_in">exec</span>:</span><br><span class="line">      <span class="built_in">command</span>:</span><br><span class="line">      - <span class="built_in">cat</span></span><br><span class="line">      - /tmp/healthy</span><br><span class="line">    initialDelaySeconds: 5</span><br><span class="line">    periodSeconds: 5</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>httpGet方式：通过发送http请求检查服务是否正常，返回200-399状态码则表明容器健康，如上面的例子</p></li><li><p>tcpSocket：通过容器的IP和Port执行TCP检查，如果能够建立TCP连接，则表明容器健康。实际上就是检查容器的端口。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  livenessProbe:</span><br><span class="line">    tcpSocket:</span><br><span class="line">      port: 8002</span><br><span class="line">    initialDelaySeconds: 10  <span class="comment"># 容器启动后第一次执行探测是需要等待多少秒</span></span><br><span class="line">    periodSeconds: 10     <span class="comment"># 执行探测的频率</span></span><br><span class="line">    timeoutSeconds: 2        <span class="comment"># 探测超时时间</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>grpc：使用 gRPC 执行一个远程过程调用，目标应该实现 gRPC 健康检查。如果响应的状态是 SERVING，则认为诊断成功。不过需要注意 gRPC 探针是一个 Alpha 特性，只有在启用了 GRPCContainerProbe 特性门户时才可用。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    livenessProbe:</span><br><span class="line">      grpc:</span><br><span class="line">        port: 8002</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>另外，对于 HTTP 和 TCP 存活检测可以使用命名的 port</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-port</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="attr">hostPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line"></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">liveness-port</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br></pre></td></tr></table></figure><p>每次探测都将获得以下三种结果之一：</p><ul><li>Success（成功）：容器通过了诊断。</li><li>Failure（失败）：容器未通过诊断。</li><li>Unknown（未知）：诊断失败，因此不会采取任何行动。</li></ul><p>不过需要注意应尽量避免使用 TCP 探测，因为 TCP 探测实际就是 kubelet 向指定端口发送 TCP SYN 握手包，当端口被监听内核就会直接响应 ACK，探测就会成功。当程序死锁或 hang 住的情况，这些并不影响端口监听，所以探测结果还是健康，流量打到表面健康但实际不健康的 Pod 上，就无法处理请求，从而引发业务故障。</p><h2 id="健康检查示例"><a href="#健康检查示例" class="headerlink" title="健康检查示例"></a>健康检查示例</h2><p>比如上面的 <code>pod-with-volume.yaml</code> 文件，我们改造一下，添加上面的探针配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">myblog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 声明挂载的卷</span></span><br><span class="line">  <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">hostPath:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">  <span class="comment"># 使用节点选择器将 Pod 调度到指定label的节点</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>  <span class="comment"># 容器启动后第一次执行探测是需要等待多少秒</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span> <span class="comment"># 执行探测的频率</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span><span class="comment"># 探测超时时间</span></span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;myblog&quot;</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="comment"># 使用上面声明的卷挂载到容器内部</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">          <span class="comment"># 挂载到容器内部的路径</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>上面的文件已经给 myblog-api 添加了探针配置， K8S 将在 Pod 开始<strong>启动 10s(initialDelaySeconds)后</strong>利用 HTTP 访问 8002 端口的 &#x2F;blog&#x2F;index&#x2F; ，如果<strong>超过2s</strong>或者返回码不在 200~399 内，则健康检查失败</p><blockquote><p>Readiness 决定了 Service 是否将流量导入到该 Pod，Liveness 决定了容器是否需要被重启</p></blockquote><h1 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h1><p>Pod 的重启策略（RestartPolicy）应用于 Pod 内的所有容器，并且仅在 Pod 所处的 Node 上由 kubelet 进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet 将根据 RestartPolicy 的设置来进行相应的操作。</p><p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值为 Always。</p><ul><li>Always：当容器进程退出后，由kubelet自动重启该容器；</li><li>OnFailure：当容器终止运行且退出码不为0时，由kubelet自动重启该容器；</li><li>Never：不论容器运行状态如何，kubelet都不会重启该容器。</li></ul><p>演示重启策略：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-restart-policy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><ol><li>使用默认的重启策略，即 restartPolicy: Always ，无论容器是否是正常退出，都会自动重启容器</li><li>使用OnFailure的策略时<ul><li>如果把exit 1，去掉，即让容器的进程正常退出的话，则不会重启</li><li>只有非正常退出状态才会重启</li></ul></li><li>使用Never时，退出了就不再重启</li></ol><p>可以看出，若容器正常退出，Pod 的状态会是Completed，非正常退出，状态为CrashLoopBackOff</p><h1 id="镜像拉取策略"><a href="#镜像拉取策略" class="headerlink" title="镜像拉取策略"></a>镜像拉取策略</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure><p>设置镜像的拉取策略，默认为IfNotPresent</p><ul><li>Always，总是拉取镜像，即使本地有镜像也从仓库拉取</li><li>IfNotPresent ，本地有则使用本地镜像，本地没有则去仓库拉取</li><li>Never，只使用本地镜像，本地没有则报错</li></ul><h1 id="Pod-资源限制"><a href="#Pod-资源限制" class="headerlink" title="Pod 资源限制"></a>Pod 资源限制</h1><p>为了保证充分利用集群资源，且确保重要容器在运行周期内能够分配到足够的资源稳定运行，因此平台需要具备 Pod 的资源限制的能力。 对于一个 Pod 来说，资源最基础的2个的指标就是：CPU和内存。</p><p>Kubernetes 提供了个采用 requests 和 limits 两种类型参数对资源进行预分配和使用限制。</p><p>将最开始的文件加上目前的所有字段，完整文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">myblog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 重启策略</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">hostPath:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">      <span class="comment"># 镜像拉取策略</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment"># 资源限制</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;myblog&quot;</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="comment"># 使用上面声明的卷挂载到容器内部</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">          <span class="comment"># 挂载到容器内部的路径</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><ul><li><p>requests：</p><ul><li>容器使用的最小资源需求,作用于 schedule 阶段，作为容器调度时资源分配的判断依赖</li><li>只有当前节点上可分配的资源量 &gt;&#x3D; request 时才允许将容器调度到该节点</li><li>request 参数不限制容器的最大可使用资源</li><li>requests.cpu 被转成 docker 的 –cpu-shares 参数，与 cgroup cpu.shares 功能相同 (无论宿主机有多少个 cpu 或者内核，–cpu-shares 选项都会按照比例分配 cpu 资源）</li><li>requests.memory 没有对应的 docker 参数，仅作为 k8s 调度依据</li></ul></li><li><p>limits：</p><ul><li>容器能使用资源的最大值</li><li>设置为 0 表示对使用的资源不做限制, 可无限的使用</li><li>当 Pod 内存超过 limit 时，会被 oom</li><li>当 cpu 超过 limit 时，不会被 kill，但是会限制不超过 limit 值</li><li>limits.cpu 会被转换成 docker 的 –cpu-quota 参数。与 cgroup cpu.cfs_quota_us 功能相同</li><li>limits.memory 会被转换成 docker 的 –memory 参数。用来限制容器使用的最大内存</li></ul></li></ul><p>对于 CPU，我们知道计算机里 CPU 的资源是按 <code>“时间片”</code> 的方式来进行分配的，系统里的每一个操作都需要 CPU 的处理，所以，哪个任务要是申请的 CPU 时间片越多，那么它得到的 CPU 资源就越多。</p><p>然后还需要了解下 CGroup 里面对于 CPU 资源的单位换算：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 CPU =  1000 millicpu（1 Core = 1000m）</span><br></pre></td></tr></table></figure><p>这里的 <code>m</code> 就是毫、毫核的意思，Kubernetes 集群中的每一个节点可以通过操作系统的命令来确认本节点的 CPU 内核数量，然后将这个数量乘以1000，得到的就是节点总 CPU 总毫数。比如一个节点有四核，那么该节点的 CPU 总毫量为 4000m。</p><p><code>docker run</code>命令和 CPU 限制相关的所有选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>--cpuset-cpus=&quot;&quot;</code></td><td>允许使用的 CPU 集，值可以为 0-3,0,1</td></tr><tr><td><code>-c</code>,<code>--cpu-shares=0</code></td><td>CPU 共享权值（相对权重）</td></tr><tr><td><code>cpu-period=0</code></td><td>限制 CPU CFS 的周期，范围从 100ms~1s，即[1000, 1000000]</td></tr><tr><td><code>--cpu-quota=0</code></td><td>限制 CPU CFS 配额，必须不小于1ms，即 &gt;&#x3D; 1000，绝对限制</td></tr></tbody></table><p>举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpu-period=50000 --cpu-quota=25000 ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure><p>将 CFS 调度的周期设为 50000，将容器在每个周期内的 CPU 配额设置为 25000，表示该容器每 50ms 可以得到 50% 的 CPU 运行时间。</p><blockquote><p>注意：若内存使用超出限制，会引发系统的 OOM 机制，因 CPU 是可压缩资源，不会引发 Pod 退出或重建</p></blockquote><h1 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h1><p>yaml 的环境变量中有很多敏感的信息，比如账号密码，直接暴漏在 yaml 文件中存在安全性问题。对于开发、测试、生产环境，由于配置均不同，每套环境部署的时候都要修改yaml，带来额外的开销。</p><p>k8s提供了两类资源，<code>configMap</code> 和 <code>Secret</code>，可以用来实现业务配置的统一管理， 允许将配置文件与镜像文件分离，以使容器化的应用程序具有可移植性 。</p><h2 id="configMap"><a href="#configMap" class="headerlink" title="configMap"></a>configMap</h2><p>通常用来管理应用的配置文件或者环境变量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">MYSQL_HOST:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="attr">MYSQL_DATABASE:</span> <span class="string">&quot;myblog&quot;</span></span><br></pre></td></tr></table></figure><p>创建并查看configmap：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f configmap.yaml</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get configmap myblog -oyaml</span><br></pre></td></tr></table></figure><p>或者可以使用命令的方式，从文件中创建，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> env-configs.txt</span><br><span class="line">MYSQL_HOST=127.0.0.1</span><br><span class="line">MYSQL_DATABASE=myblog</span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create configmap myblog --from-env-file=env-configs.txt</span><br></pre></td></tr></table></figure><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>管理敏感类的信息，默认会base64编码存储，有三种类型</p><ul><li>Service Account ：用来访问 Kubernetes API ，由 Kubernetes 自动创建，并且会自动挂载到 Pod 的 &#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount 目录中；创建 ServiceAccount 后，Pod 中指定 serviceAccount 后，自动创建该 ServiceAccount 对应的 secret；</li><li>Opaque ： base64编码格式的 Secret，用来存储密码、密钥等；</li><li>kubernetes.io&#x2F;dockerconfigjson ：用来存储私有docker registry的认证信息。</li></ul><p>secret的创建和configmap类似，可以通过文件或者命令的方式创建，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">Opaque</span>  </span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">MYSQL_PASSWD:</span> <span class="string">MTIzNDU2</span>  <span class="comment">#注意加-n参数， echo -n root|base64</span></span><br></pre></td></tr></table></figure><p>创建并查看secret：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f secret.yaml</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get secret myblog-secret -oyaml</span><br></pre></td></tr></table></figure><p>或者可以使用命令的方式，从文件中创建，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> env-secret.txt</span><br><span class="line">MYSQL_PASSWD=MTIzNDU2</span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create secret generic myblog-secret --from-env-file=env-secret.txt</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get secret myblog-secret -oyaml</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>在配置中使用 configmap 和 secret：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">myblog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">hostPath:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="comment"># 环境变量全部使用 configmap 和 secret 中的配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment"># 资源限制</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="comment"># 环境变量全部使用 configmap 和 secret 中的配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="comment"># 使用上面声明的卷挂载到容器内部</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">          <span class="comment"># 挂载到容器内部的路径</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在部署不同的环境时，Pod 的 yaml 无须再变化，只需要在每套环境中维护一套 <code>ConfigMap</code> 和 <code>Secret</code> 即可。但是注意 <code>configmap</code> 和 <code>secret</code> 不能跨 <code>namespace</code> 使用，且更新后，Pod 内的 env 不会自动更新，重建后才会更新。</p><h1 id="如何编写资源yaml"><a href="#如何编写资源yaml" class="headerlink" title="如何编写资源yaml"></a>如何编写资源yaml</h1><p>这里主要说一下如何编写资源yaml，主要是一些技巧。</p><ol><li><p>从机器中已有的资源中提取yaml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取系统命名空间的所有资源，根据资源本身的yaml文件，可以进行修改</span></span><br><span class="line">$ kubectl -n kube-system -o yaml get po,deployment,ds</span><br></pre></td></tr></table></figure></li><li><p>学会在官网查找， <a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a></p></li><li><p>从kubernetes-api文档中查找， <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#pod-v1-core">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#pod-v1-core</a></p></li><li><p>kubectl explain 查看具体字段含义</p></li></ol><h1 id="Pod-状态与生命周期"><a href="#Pod-状态与生命周期" class="headerlink" title="Pod 状态与生命周期"></a>Pod 状态与生命周期</h1><p>下图展示了一个 Pod 的完整生命周期过程，其中包含 <code>Init Container</code>、<code>Pod Hook</code>、<code>健康检查</code> 三个主要部分。</p><p>生命周期示意图：</p><p><img src="/post/docker/pod-lifecycle-status.svg" alt="pod-lifecycle-status"></p><p>启动和关闭示意：</p><p><img src="/post/docker/pod-lifecycle-start-stop.svg" alt="pod-lifecycle-start-stop"></p><p>Pod 的基本状态如下表所示，这些信息都是集群自动维护的：</p><table><thead><tr><th>状态值</th><th>描述</th></tr></thead><tbody><tr><td>Pending</td><td>API Server已经创建该 Pod，等待调度器调度</td></tr><tr><td>ContainerCreating</td><td>拉取镜像启动容器中</td></tr><tr><td>Running</td><td>Pod 内容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态</td></tr><tr><td>Succeeded|Completed</td><td>Pod 内所有容器均已成功执行退出，且不再重启</td></tr><tr><td>Failed|Error</td><td>Pod 内所有容器均已退出，但至少有一个容器退出为失败状态</td></tr><tr><td>CrashLoopBackOff</td><td>Pod 内有容器启动失败，比如配置文件丢失导致主进程启动失败</td></tr><tr><td>Unknown</td><td>由于某种原因无法获取该 Pod 的状态，可能由于网络通信不畅导致</td></tr></tbody></table><h2 id="初始化容器"><a href="#初始化容器" class="headerlink" title="初始化容器"></a>初始化容器</h2><p>Init Container：顾名思义，用于初始化工作，执行完就结束，可以理解为一次性任务。可以是一个或者多个，如果有多个的话，这些容器会按定义的顺序依次执行。我们知道一个 Pod 里面的所有容器是共享数据卷和 Network Namespace的，所以 Init Container 里面产生的数据可以被主容器使用到。从上面的 Pod 生命周期的图中可以看出初始化容器是独立与主容器之外的，只有所有的初始化容器执行完之后，主容器才会被启动。</p><p>含有以下特点：</p><ul><li>支持大部分应用容器配置，但不支持健康检查</li><li>优先应用容器执行</li></ul><p>主要用来实现如下目的：</p><ul><li>验证业务应用依赖的组件是否均已启动</li><li>修改目录的权限</li><li>调整系统参数</li><li>初始化应用配置，比如集群的配置信息等</li><li>比如将 Pod 注册到注册中心、配置中心等</li></ul><p>参考配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-init</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">pod-init</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api-init</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/sbin/sysctl</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-w</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vm.max_map_count=262144</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">alpine:3.6</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api-change-permission</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;chown -R 1000:1000 /var/www/html&quot;</span>]</span><br><span class="line">      <span class="attr">image:</span> <span class="string">alpine:3.6</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">configMapKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">secretKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/var/www/htm</span></span><br><span class="line">  <span class="attr">volumes:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125; <span class="comment"># emptyDir&#123;&#125; 是一个临时的目录，数据会保存在 kubelet 的工作目录下面，生命周期等同于 Pod 的生命周期</span></span><br></pre></td></tr></table></figure><h2 id="Pod-Hook"><a href="#Pod-Hook" class="headerlink" title="Pod Hook"></a>Pod Hook</h2><p>我们知道 Pod 是 Kubernetes 集群中的最小单元，而 Pod 是由容器组成的，所以在讨论 Pod 的生命周期的时候我们可以先来讨论下容器的生命周期。</p><p>实际上 Kubernetes 为我们的容器提供了生命周期的钩子，就是我们说的 Pod Hook。Pod Hook 是由 kubelet 发起的，当容器中的进程启动前或者容器中的进程终止之前运行，这是包含在容器的生命周期之中。我们可以同时为 Pod 中的所有容器都配置 hook。</p><p>Kubernetes 为我们提供了两种钩子函数：</p><ul><li>PostStart：Kubernetes 在容器创建后立即发送 postStart 事件，然而 postStart 处理函数的调用不保证早于容器的入口点（entrypoint） 的执行。 postStart 处理函数与容器的代码是异步执行的，但 Kubernetes的容器管理逻辑会一直阻塞等待 postStart 处理函数执行完毕。只有 postStart 处理函数执行完毕，容器的状态才会变成 RUNNING 。</li><li>PreStop：这个钩子在容器终止之前立即被调用。它是阻塞的，所以它必须在删除容器的调用发出之前完成。主要用于优雅关闭应用程序、通知其他系统等。</li></ul><blockquote><p>PostStart用的不是很多，而PreStop用的相对很多.<br>Kubernetes 只有在 Pod 结束（Terminated）的时候才会发送 preStop 事件，这意味着在 Pod 完成（Completed）时 preStop 的事件处理逻辑不会被触发</p></blockquote><h2 id="验证Pod生命周期"><a href="#验证Pod生命周期" class="headerlink" title="验证Pod生命周期"></a>验证Pod生命周期</h2><p>编写以下 yaml 文件，包括 initContainer、lifecycle、readinessProbe、livenessProbe、preStop、postStart的配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-lifecycle</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">pod-lifecycle</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): INIT &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">record</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/record/record.txt</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): START &gt;&gt; /record/record.txt; sleep 10; echo $(date +%s): END &gt;&gt; /record/record.txt;&#x27;</span>]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">record</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/record/record.txt</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): LIVENESS &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): READINESS &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">      <span class="attr">lifecycle:</span></span><br><span class="line">        <span class="attr">postStart:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): POST-START &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">        <span class="attr">preStop:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): PRE-STOP &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">record</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp/record</span></span><br></pre></td></tr></table></figure><p>创建 Pod 测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pod-lifecycle.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看demo状态</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po -o wide -w</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看调度节点的/tmp/record/record.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> /tmp/record/record.txt</span><br><span class="line">1585424708: INIT</span><br><span class="line">1585424746: START</span><br><span class="line">1585424746: POST-START</span><br><span class="line">1585424754: READINESS</span><br><span class="line">1585424756: LIVENESS</span><br><span class="line">1585424756: END</span><br></pre></td></tr></table></figure><p>上面的输出没有 <code>PRE-STOP</code> 是因为必须主动杀掉 Pod 才会触发 <code>pre-stop hook</code>，如果是 Pod 自己 Down 掉，则不会执行 <code>pre-stop hook</code> ,且杀掉Pod进程前，进程必须是正常运行状态，否则不会执行pre-stop钩子。</p><p>Hook 调用的日志没有暴露给 Pod，如果处理程序由于某种原因失败，它将产生一个事件。对于 PostStart，这是FailedPostStartHook 事件，对于 PreStop，是 FailedPreStopHook 事件，我们可以通过运行 kubectl -n test describe pod pod-lifecycle 来查看事件。</p><h2 id="Pod-的终止"><a href="#Pod-的终止" class="headerlink" title="Pod 的终止"></a>Pod 的终止</h2><p>Pod 的终止有两种方式：正常终止和强制终止。</p><h3 id="正常终止"><a href="#正常终止" class="headerlink" title="正常终止"></a>正常终止</h3><p>终止流程如下：</p><ol><li>用户发出删除 Pod 指令，Pod 被删除，状态变为 Terminating，从 API 层面看就是 Pod metadata 中的deletionTimestamp 字段会被标记上删除时间。</li><li>kube-proxy watch 到了就开始更新转发规则，将 Pod 从 service 的 endpoints 列表中摘除掉，新的流量不再转发到该 Pod。</li><li>kubelet watch 到了就开始销毁 Pod。</li><li>如果 Pod 中有 container 配置了 preStop Hook ，则 Pod 被标记为 Terminating 状态时，以同步的方式启动执行；若宽限期结束后 preStop 仍未执行结束，则会额外获得一个 2 秒的小宽限期。</li><li>发送 SIGTERM 信号给容器内主进程以通知容器进程开始优雅停止。</li><li>等待 container 中的主进程完全停止，如果在宽限期结束后还未完全停止，就发送 SIGKILL 信号将其强制杀死。</li><li>所有容器进程终止，清理 Pod 资源。</li><li>通知 APIServer Pod 销毁完成，完成 Pod 删除。</li></ol><p>对于长连接类型的业务，比如游戏类应用，我们可以将 terminationGracePeriodSeconds 设置大一点，避免过早的被 SIGKILL 杀死，但是具体多长时间是不好预估的，所以最好在业务层面进行优化。比如 Pod 销毁时的优雅终止逻辑里面主动通知下客户端，让客户端连到新的后端，然后客户端来保证这两个连接的平滑切换。等旧 Pod 上所有客户端连接都连切换到了新 Pod 上，才最终退出。</p><h3 id="强制终止-Pod"><a href="#强制终止-Pod" class="headerlink" title="强制终止 Pod"></a>强制终止 Pod</h3><p>默认情况下，所有的删除操作都会有 30 秒钟的宽限期限。kubectl delete 命令支持 <code>grace-period=&lt;seconds&gt;</code> 选项，允许你重载默认值，设定自己希望的期限值。</p><p>将宽限期限强制设置为 0 意味着立即从 APIServer 删除 Pod，如果 Pod 仍然运行于某节点上，强制删除操作会触发 kubelet 立即执行清理操作。 注意：你必须在设置 grace-period&#x3D;0 的同时额外设置 force 参数才能发起强制删除请求。</p><p>执行强制删除操作时，APIServer 不再等待来自 kubelet 关于 Pod 已经在原来运行的节点上终止执行的确认消息。APIServer 直接删除 Pod 对象，这样新的与之同名的 Pod 即可以被创建。在节点侧，被设置为立即终止的 Pod 仍然会在被强行杀死之前获得一点点的宽限时间。</p><p>对于已失败的 Pod 而言，对应的 API 对象仍然会保留在集群的 API 服务器上，直到用户或者控制器进程显式地将其删除。</p><p>控制器组件会在 Pod 个数超出所配置的阈值 （根据 kube-controller-manager 的 terminated-pod-gc-threshold 设置）时删除已终止的 Pod（phase 值为 Succeeded 或 Failed）。这一行为会避免随着时间不断创建和终止 Pod 而引起的资源泄露问题。</p><p>当然，这种方法伴随着一些风险，所以用强制删除 Pod 的命令需要慎用。</p><h3 id="业务代码处理-SIGTERM-信信号"><a href="#业务代码处理-SIGTERM-信信号" class="headerlink" title="业务代码处理 SIGTERM 信信号"></a>业务代码处理 SIGTERM 信信号</h3><p>要实现优雅退出，我们需要业务代码得支持下优雅退出的逻辑，在业务代码里面处理下 SIGTERM 信号，一般主要逻辑就是”排水”，即等待存量的任务或连接完全结束，再退出进程。下面我们给出几种常用编程语言实现优雅退出的示例。</p><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//registers the channel</span></span><br><span class="line">    signal.Notify(sigs, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sig := &lt;-sigs</span><br><span class="line">        fmt.Println(<span class="string">&quot;Caught SIGTERM, shutting down&quot;</span>)</span><br><span class="line">        <span class="comment">// Finish any outstanding requests, then...</span></span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Starting application&quot;</span>)</span><br><span class="line">    <span class="comment">// Main logic goes here</span></span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">&quot;exiting&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> signal, time, os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shutdown</span>(<span class="params">signum, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Caught SIGTERM, shutting down&#x27;</span>)</span><br><span class="line">    <span class="comment"># Finish any outstanding requests, then...</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Register handler</span></span><br><span class="line">    signal.signal(signal.SIGTERM, shutdown)</span><br><span class="line">    <span class="comment"># Main logic goes here</span></span><br></pre></td></tr></table></figure><h4 id="Node-JS"><a href="#Node-JS" class="headerlink" title="Node JS"></a>Node JS</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;SIGTERM&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;SIGTERM signal received.&#x27;</span>);</span><br><span class="line">    <span class="comment">// Finish any outstanding requests, then...</span></span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Signal;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SignalHandler;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleSignalHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String<span class="string">&quot;&quot;</span>. args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">Signal.handle(<span class="keyword">new</span> <span class="title class_">Signal</span>(<span class="string">&quot;TERM&quot;</span>), <span class="keyword">new</span> <span class="title class_">SignalHandler</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Signal sig)</span> &#123;</span><br><span class="line">System.out.format(<span class="string">&quot;\nProgram execution took %f seconds\n&quot;</span>,</span><br><span class="line">(System.nanoTime() - start) / <span class="number">1e9f</span>);</span><br><span class="line"> System.exit(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">System.out.println(counter<span class="string">&quot;2);</span></span><br><span class="line"><span class="string">Thread.sleep(500);</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;   </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Signal;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SignalHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleSignalHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        Signal.handle(<span class="keyword">new</span> <span class="title class_">Signal</span>(<span class="string">&quot;TERM&quot;</span>), <span class="keyword">new</span> <span class="title class_">SignalHandler</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Signal sig)</span> &#123;</span><br><span class="line">                System.out.format(<span class="string">&quot;\nProgram execution took %f seconds\n&quot;</span>,</span><br><span class="line">                        (System.nanoTime() - start) / <span class="number">1e9f</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(counter++);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redirecting Filehanders</span></span><br><span class="line"><span class="built_in">ln</span> -sf /proc/$$/fd/1 /log/stdout.log</span><br><span class="line"><span class="built_in">ln</span> -sf /proc/$$/fd/2 /log/stderr.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre execution handler</span></span><br><span class="line"><span class="function"><span class="title">pre_execution_handler</span></span>() &#123;</span><br><span class="line">  <span class="comment"># Pre Execution</span></span><br><span class="line">  <span class="comment"># put your pre execution steps here</span></span><br><span class="line">    : <span class="comment"># delete this nop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Post execution handler</span></span><br><span class="line"><span class="function"><span class="title">post_execution_handler</span></span>() &#123;</span><br><span class="line">  <span class="comment"># Post Execution</span></span><br><span class="line">  <span class="comment"># put your post execution steps here</span></span><br><span class="line">    : <span class="comment"># delete this nop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sigterm Handler</span></span><br><span class="line"><span class="function"><span class="title">sigterm_handler</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$pid</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># the above if statement is important because it ensures</span></span><br><span class="line">    <span class="comment"># that the application has already started. without it you</span></span><br><span class="line">    <span class="comment"># could attempt cleanup steps if the application failed to</span></span><br><span class="line">    <span class="comment"># start, causing errors.</span></span><br><span class="line">    <span class="built_in">kill</span> -15 <span class="string">&quot;<span class="variable">$pid</span>&quot;</span></span><br><span class="line">    <span class="built_in">wait</span> <span class="string">&quot;<span class="variable">$pid</span>&quot;</span></span><br><span class="line">    post_execution_handler</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">exit</span> 143; <span class="comment"># 128 + 15 = SIGTERM</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup signal trap</span></span><br><span class="line"><span class="comment"># on callback execute the specified handler</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;sigterm_handler&#x27;</span> SIGTERM</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Initialization</span></span><br><span class="line">pre_execution_handler</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start Process</span></span><br><span class="line"><span class="comment"># run process in background and record PID</span></span><br><span class="line">&gt;/log/stdout.log 2&gt;/log/stderr.log <span class="string">&quot;<span class="variable">$@</span>&quot;</span> &amp;</span><br><span class="line">pid=<span class="string">&quot;$!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application can log to stdout/stderr, /log/stdout.log or /log/stderr.log</span></span><br><span class="line"><span class="comment"># Wait forever until app dies</span></span><br><span class="line"><span class="built_in">wait</span> <span class="string">&quot;<span class="variable">$pid</span>&quot;</span></span><br><span class="line">return_code=<span class="string">&quot;$?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cleanup</span></span><br><span class="line">post_execution_handler</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo the return code of the application</span></span><br><span class="line"><span class="built_in">exit</span> <span class="variable">$return_code</span></span><br></pre></td></tr></table></figure><h3 id="收不到-SIGTERM-信信号"><a href="#收不到-SIGTERM-信信号" class="headerlink" title="收不到 SIGTERM 信信号"></a>收不到 SIGTERM 信信号</h3><p>上面我们给出了几种常见的捕捉 SIGTERM 信号的代码，然后我们就可以执行停止逻辑以实现优雅退出了。在 Kubernetes环境中，业务发版时经常会对工作负载进行滚动更新，当旧版本 Pod 被删除时，K8s 会对 Pod 中各个容器中的主进程发送 SIGTERM 信号，当达到退出宽限期后进程还未完全停止的话，就会发送 SIGKILL 信号将其强制杀死。但是有的场景下在 Kubernetes 环境中实际运行时，有时候可能会发现在滚动更新时，我们业务的优雅终止逻辑并没有被执行，现象是在等了较长时间后，业务进程直接被 SIGKILL 强制杀死了。</p><p>这是什么原因造成的呢？通常情况下这都是因为容器启动入口使用了 shell，比如使用了类似 &#x2F;bin&#x2F;sh -c my-app 这样的启动入口。或者使用 &#x2F;entrypoint.sh 这样的脚本文件作为入口，在脚本中再启动业务进程，比如下面的entrypoint.sh 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">python /app/my-app.py</span><br></pre></td></tr></table></figure><p>这就可能就会导致容器内的业务进程收不到 SIGTERM 信号，原因是:</p><ol><li>容器主进程是 shell，业务进程是在 shell 中启动的，变成了 shell 进程的子进程了。</li><li>shell 进程默认会忽略 SIGTERM 信号，父进程不退出，子进程也不会退出，导致业务逻辑不会触发停止逻辑。</li><li>等到 k8s 的 terminationGracePeriodSeconds 时间（默认30秒）到了，shell 进程被 SIGKILL 强制杀死，子进程也会被 SIGKILL 强制杀死。</li></ol><p>怎么解决这个问题呢？解决方法有几种：</p><ol><li><p>使用 exec 启动</p><p> 在 shell 中启动二进制的命令前加一个 exec 命令即可让该二进制启动的进程代替当前 shell 进程，即让新启动的进程成为主进程:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> python /app/my-app.py</span><br></pre></td></tr></table></figure><p> 然后业务进程就可以正常接收所有信号了，实现优雅退出当然也可以了。</p></li><li><p>多进程场景</p><p> 通常我们一个容器只会有一个进程，但有些时候我们不得不启动多个进程，比如从传统部署迁移到 Kubernetes 的过渡期间，使用了富容器，即单个容器中需要启动多个业务进程，这时候我们可以通过 shell 来启动，但却无法使用上面的 exec 方式来传递信号了，因为 exec 只能让一个进程替代当前 shell 成为主进程。</p><p> 这个时候我们可以在 shell 中使用 trap 来捕获信号，当收到信号后触发回调函数来将信号通过 kill 命令传递给业务进程。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">   </span><br><span class="line">/bin/app1 &amp; pid1=<span class="string">&quot;$!&quot;</span> <span class="comment"># 启动第一个业务进程并记录 pid</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;app1 started with pid <span class="variable">$pid1</span>&quot;</span></span><br><span class="line">   </span><br><span class="line">/bin/app2 &amp; pid2=<span class="string">&quot;$!&quot;</span> <span class="comment"># 启动第二个业务进程并记录 pid</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;app2 started with pid <span class="variable">$pid2</span>&quot;</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="title">handle_sigterm</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[INFO] Received SIGTERM&quot;</span></span><br><span class="line">    <span class="built_in">kill</span> -SIGTERM <span class="variable">$pid1</span> <span class="variable">$pid2</span> <span class="comment"># 传递 SIGTERM 给业务进程</span></span><br><span class="line">    <span class="built_in">wait</span> <span class="variable">$pid1</span> <span class="variable">$pid2</span> <span class="comment"># 等待所有业务进程完全终止</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">trap</span> handle_sigterm SIGTERM <span class="comment"># 捕获 SIGTERM 信号并回调 handle_sigterm 函数</span></span><br><span class="line"><span class="built_in">wait</span> <span class="comment"># 等待回调执行完，主进程再退出</span></span><br></pre></td></tr></table></figure></li><li><p>使用 tini</p><p> 前面一种方案实际是用脚本实现了一个极简的 init 系统 (或 supervisor ) 来管理所有子进程，只不过它的逻辑很简陋，仅仅简单的透传指定信号给子进程，其实社区有更完善的方案，dumb-init (<a href="https://github.com/Yelp/dumb-init)%E5%92%8C">https://github.com/Yelp/dumb-init)和</a> tini (<a href="https://github.com/krallin/tini)%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA">https://github.com/krallin/tini)都可以作为</a> init 进程，作为主进程 (PID 1) 在容器中启动，然后它再运行 shell 来执行我们指定的脚本 (shell 作为子进程)，shell 中启动的业务进程也成为它的子进程，当它收到信号时会将其传递给所有的子进程，从而也能完美解决 shell 无法传递信号问题，并且还有回收僵尸进程的能力，这也是我们强烈推荐的一种方式。</p><p> 如下所示是一个以 dumb-init 制作镜像的 Dockerfile 示例:</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y dumb-init</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> start.sh /</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> app1 /bin/app1</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> app2 /bin/app2</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;dumb-init&quot;</span>, <span class="string">&quot;*&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/start.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p> 下面则是以 tini 为例制作镜像的 Dockerfile 示例:</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">ENV</span> TINI_VERSION v0.<span class="number">19.0</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/krallin/tini/releases/download/<span class="variable">$&#123;TINI_VERSION&#125;</span>/tini /tini</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> entrypoint.sh /entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /tini /entrypoint.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/tini&quot;</span>, <span class="string">&quot;*&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/start.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p> 此时 start.sh 脚本中当然也可以是多个进程：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">/bin/app1 &amp;</span><br><span class="line">/bin/app2 &amp;</span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure></li></ol><p>优雅退出是 K8s 中非常重要的一个特性，对于实现应用零宕机滚动更新非常重要。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li>实现 k8s 平台与特定的容器运行时解耦，提供更加灵活的业务部署方式，引入了 Pod 概念</li><li>k8s 使用 yaml 格式定义资源文件，yaml比json更加简洁</li><li>通过kubectl apply | get | exec | logs | delete 等操作k8s资源，必须指定 namespace</li><li>每启动一个 Pod ，为了实现网络空间共享，会先创建 Infra 容器（也就是 pause 容器），并把其他容器网络加入该容器，实现Pod内所有容器使用同一个网络空间</li><li>通过 livenessProbe和readinessProbe 实现 Pod 的存活性和就绪健康检查</li><li>通过 requests 和 limit 分别限定容器初始资源申请与最高上限资源申请</li><li>Pod 通过 initContainer 和 lifecycle 分别来执行初始化、Pod 启动和删除时候的操作，使得功能更加全面和灵活</li><li>编写 yaml 讲究方法，学习 k8s，养成从官方网站查询知识的习惯</li></ol><p>那么只使用 Pod ，会有哪些问题呢？</p><ol><li>业务应用启动多个副本怎么做？</li><li>Pod重建后IP会变化，外部如何访问Pod服务？</li><li>运行业务Pod的某个节点挂了，可以自动帮我把Pod转移到集群中的可用节点启动起来？</li><li>我的业务应用功能是收集节点监控数据,需要把Pod运行在k8集群的各个节点上？</li></ol><p>为了解决上面的问题，k8s 需要使用Controller来管理Pod，比如Deployment、StatefulSet、DaemonSet、Job、CronJob等，下面就会详细介绍其中的几类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 强制删除 pod/pvc/pv/ns 的方法</title>
      <link href="/k8s-force-delete-resource/"/>
      <url>/k8s-force-delete-resource/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意：强制删除的操作具有一定的风险，建议在生产环境中慎用。</p></blockquote><span id="more"></span><p>如果namespace、pod、pv、pvc 处于 “Terminating” 状态时，可能是因为kubelet 阻塞，此时为了完成之后的操作，就需要进行强制删除。</p><p>典型的应用场景是 statefulset 的 pod 无法删除，导致 statefulset 无法更新。</p><p>如果所有资源都处于 “Terminating” 状态，需要按照 pod -&gt; pvc -&gt; pv -&gt; ns 的顺序进行强制删除。</p><h2 id="强制删除-pod"><a href="#强制删除-pod" class="headerlink" title="强制删除 pod"></a>强制删除 pod</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 pod 状态</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; get pod -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除 pod</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; delete pod &lt;pod_name&gt; --grace-period=0 --force</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>--grace-period</code>：表示等待多少秒后强制删除，默认是30秒，在删除pod时，会给pod发送一个信号，让pod自己进行清理工作，如果超过了这个时间，pod还没有清理完，就会强制删除。如果设置为0，表示不等待，直接强制删除。</li><li><code>--force</code>：表示强制删除</li></ul><h2 id="强制删除-pvc-amp-pv"><a href="#强制删除-pvc-amp-pv" class="headerlink" title="强制删除 pvc &amp; pv"></a>强制删除 pvc &amp; pv</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 pvc &amp; pv 状态</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; get pvc -o wide</span><br><span class="line">$ kubectl -n &lt;namespace&gt; get pv -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除 pvc &amp; pv</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; patch pvc &lt;pvc_name&gt; -p <span class="string">&#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:null&#125;&#125;&#x27;</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; patch pv &lt;pv_name&gt; -p <span class="string">&#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:null&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>patch</code>：表示修改资源的内容</li><li><code>&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:null&#125;&#125;</code>：表示将资源的 finalizers 字段设置为 null，finalizers 字段是用来阻止资源被删除的，如果设置为 null，就可以强制删除了。</li><li>设置之后，即直接删除了etcd中的记录。</li></ul><h2 id="强制删除-namespace"><a href="#强制删除-namespace" class="headerlink" title="强制删除 namespace"></a>强制删除 namespace</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 namespace 状态</span></span><br><span class="line">$ kubectl get namespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 namespace 中的 finalizers 字段</span></span><br><span class="line">$ kubectl get namespace &lt;namespace&gt; -o yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出信息如下：</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2023-06-17T05:29:36Z&quot;</span></span><br><span class="line">  deletionTimestamp: <span class="string">&quot;2023-08-19T12:50:32Z&quot;</span></span><br><span class="line">  name: &lt;terminating-namespace&gt;</span><br><span class="line">  resourceVersion: <span class="string">&quot;226501792&quot;</span></span><br><span class="line">  uid: 3249789c-6db7-4995-9f88-a562546dbfdb</span><br><span class="line">spec:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">status:</span><br><span class="line">  phase: Active</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 导出 json 格式的 namespace 信息到文件中</span></span><br><span class="line">$ kubectl get namespace &lt;namespace&gt; -o json &gt; namespace.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 namespace.json 文件，删除 finalizers 字段</span></span><br><span class="line">$ <span class="built_in">cat</span> namespace.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: 以下内容的 finalizers 字段已经被清空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Namespace&quot;</span>,</span><br><span class="line">    <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;creationTimestamp&quot;</span>: <span class="string">&quot;2023-06-17T05:29:36Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;deletionTimestamp&quot;</span>: <span class="string">&quot;2023-08-19T12:50:32Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;&lt;terminating-namespace&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceVersion&quot;</span>: <span class="string">&quot;226501792&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uid&quot;</span>: <span class="string">&quot;3249789c-6db7-4995-9f88-a562546dbfdb&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;spec&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;finalizers&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;status&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;phase&quot;</span>: <span class="string">&quot;Active&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启代理</span></span><br><span class="line">$ kubectl proxy</span><br></pre></td></tr></table></figure><p>执行完成以上命令后，终端会 hang 住，此时不要关闭终端，打开一个新的终端，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新 namespace 信息，注意：这里的 &lt;namespace&gt; 是指上面的 &lt;terminating-namespace&gt;，文件 namespace.json 是指上面生成的文件，访问的 url 是上面的 proxy 代理的地址</span></span><br><span class="line">$ curl -k -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X PUT --data-binary @namespace.json http://127.0.0.1:8001/api/v1/namespaces/&lt;namespace&gt;/finalize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出信息如下：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Namespace&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;&lt;terminating-namespace&gt;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;selfLink&quot;</span>: <span class="string">&quot;/api/v1/namespaces/&lt;terminating-namespace&gt;/finalize&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: <span class="string">&quot;3249789c-6db7-4995-9f88-a562546dbfdb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;resourceVersion&quot;</span>: <span class="string">&quot;226501792&quot;</span>,</span><br><span class="line">    <span class="string">&quot;creationTimestamp&quot;</span>: <span class="string">&quot;2023-06-17T05:29:36Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;deletionTimestamp&quot;</span>: <span class="string">&quot;2023-08-19T12:50:32Z&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;spec&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;finalizers&quot;</span>: null</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;phase&quot;</span>: <span class="string">&quot;Terminating&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 namespace 状态，确认 namespace 已经被删除</span></span><br><span class="line">$ kubectl get namespace</span><br></pre></td></tr></table></figure><p>之后两个终端都可以关闭了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中systemd及其service文件</title>
      <link href="/linux-systemd-service-file/"/>
      <url>/linux-systemd-service-file/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是systemd-service"><a href="#什么是systemd-service" class="headerlink" title="什么是systemd service"></a>什么是systemd service</h1><p>systemd是一个Linux系统初始化的系统和服务管理器，它为系统的引导和服务管理提供了新的解决方案。systemd service是systemd管理下的服务，是一种与传统init.d脚本不同的服务管理方式。</p><p>与init.d脚本相比，systemd service具有以下优势：</p><ol><li>支持并行启动服务，加快系统启动速度；</li><li>支持前置和后置依赖关系，有利于服务的启动顺序管理；</li><li>支持动态的服务控制，如启动、停止、重启和重载配置等；</li></ol><span id="more"></span><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>对于那些支持 systemd 的软件，安装的时候，会自动在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录添加一个配置文件。</p><p>如果你想让该软件开机启动，就执行下面的命令（以nginx.service为例）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><p>上面的命令相当于在&#x2F;etc&#x2F;systemd&#x2F;system目录添加一个符号链接，指向&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system里面的nginx.service文件。</p><p>这是因为开机时，systemd只执行&#x2F;etc&#x2F;systemd&#x2F;system目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。</p><p>设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行<code>systemctl start</code>命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start nginx</span><br></pre></td></tr></table></figure><p>执行上面的命令以后，有可能启动失败，因此要用systemctl status命令查看一下该服务的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status nginx</span><br><span class="line">● nginx.service - A high performance web server and a reverse proxy server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2023-08-18 15:33:59 UTC; 44s ago</span><br><span class="line">     Docs: man:nginx(8)</span><br><span class="line"> Main PID: 27882 (nginx)</span><br><span class="line">    Tasks: 9 (limit: 4915)</span><br><span class="line">   CGroup: /system.slice/nginx.service</span><br><span class="line">           ├─27882 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">           ├─27885 nginx: worker process</span><br><span class="line">           ├─27887 nginx: worker process</span><br><span class="line">           ├─27889 nginx: worker process</span><br><span class="line">           ├─27890 nginx: worker process</span><br><span class="line">           ├─27892 nginx: worker process</span><br><span class="line">           ├─27893 nginx: worker process</span><br><span class="line">           ├─27894 nginx: worker process</span><br><span class="line">           └─27895 nginx: worker process</span><br><span class="line"></span><br><span class="line">Aug 18 15:33:59 ubuntu systemd[1]: Starting A high performance web server and a reverse proxy server...</span><br><span class="line">Aug 18 15:33:59 ubuntu systemd[1]: Started A high performance web server and a reverse proxy server.</span><br></pre></td></tr></table></figure><p>上面的输出结果含义如下。</p><ul><li>Loaded行：配置文件的位置，是否设为开机启动</li><li>Active行：表示正在运行</li><li>Main PID行：主进程ID</li><li>Status行：由应用本身（这里是 nginx ）提供的软件当前状态</li><li>CGroup块：应用的所有子进程</li><li>日志块：应用的日志</li></ul><h2 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h2><p>终止正在运行的服务，需要执行systemctl stop命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop nginx.service</span><br></pre></td></tr></table></figure><p>有时候，该命令可能没有响应，服务停不下来。这时候就不得不”杀进程”了，向正在运行的进程发出kill信号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl kill nginx.service</span><br></pre></td></tr></table></figure><p>此外，重启服务要执行systemctl restart命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nginx.service</span><br></pre></td></tr></table></figure><h1 id="service文件"><a href="#service文件" class="headerlink" title="service文件"></a>service文件</h1><p>一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。</p><p>第三方软件编写的配置文件主要放在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录，我们自己写的配置文件最好放在&#x2F;etc&#x2F;systemd&#x2F;system目录。</p><p>systemctl cat命令可以用来查看配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl cat sshd</span><br><span class="line"># /lib/systemd/system/ssh.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=OpenBSD Secure Shell server</span><br><span class="line">After=network.target auditd.service</span><br><span class="line">ConditionPathExists=!/etc/ssh/sshd_not_to_be_run</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/etc/default/ssh</span><br><span class="line">ExecStartPre=/usr/sbin/sshd -t</span><br><span class="line">ExecStart=/usr/sbin/sshd -D $SSHD_OPTS</span><br><span class="line">ExecReload=/usr/sbin/sshd -t</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartPreventExitStatus=255</span><br><span class="line">Type=notify</span><br><span class="line">RuntimeDirectory=sshd</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=sshd.service</span><br><span class="line"></span><br><span class="line">$ sudo systemctl cat nginx</span><br><span class="line"># /lib/systemd/system/nginx.service</span><br><span class="line"># Stop dance for nginx</span><br><span class="line"># =======================</span><br><span class="line">#</span><br><span class="line"># ExecStop sends SIGSTOP (graceful stop) to the nginx process.</span><br><span class="line"># If, after 5s (--retry QUIT/5) nginx is still running, systemd takes control</span><br><span class="line"># and sends SIGTERM (fast shutdown) to the main process.</span><br><span class="line"># After another 5s (TimeoutStopSec=5), and if nginx is alive, systemd sends</span><br><span class="line"># SIGKILL to all the remaining processes in the process group (KillMode=mixed).</span><br><span class="line">#</span><br><span class="line"># nginx signals reference doc:</span><br><span class="line"># http://nginx.org/en/docs/control.html</span><br><span class="line">#</span><br><span class="line">[Unit]</span><br><span class="line">Description=A high performance web server and a reverse proxy server</span><br><span class="line">Documentation=man:nginx(8)</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">ExecStartPre=/usr/sbin/nginx -t -q -g &#x27;daemon on; master_process on;&#x27;</span><br><span class="line">ExecStart=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27;</span><br><span class="line">ExecReload=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27; -s reload</span><br><span class="line">ExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid</span><br><span class="line">TimeoutStopSec=5</span><br><span class="line">KillMode=mixed</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>上面我们查看了sshd和nginx的配置文件，可以看到，配置文件主要分为3个区块，每个区块包含若干条键值对。</p><p>接下来我们看看这些区块的含义，这里以sshd.service为例。</p><h2 id="Unit-区块：启动顺序与依赖关系。"><a href="#Unit-区块：启动顺序与依赖关系。" class="headerlink" title="[Unit] 区块：启动顺序与依赖关系。"></a><code>[Unit]</code> 区块：启动顺序与依赖关系。</h2><p><code>[Unit]</code>部分：指定服务描述、启动顺序、依赖关系，包括 Description、Documentation、After、Before、Wants、Requires</p><h3 id="Description字段"><a href="#Description字段" class="headerlink" title="Description字段"></a>Description字段</h3><p>给出当前服务的简单描述</p><h3 id="Documentation字段"><a href="#Documentation字段" class="headerlink" title="Documentation字段"></a>Documentation字段</h3><p>指定服务的文档，可以是一个或多个文档的URL，可选，一般不用配置该项。</p><h3 id="After字段"><a href="#After字段" class="headerlink" title="After字段"></a>After字段</h3><p>接下来的设置是启动顺序和依赖关系，都比较重要。</p><p>After字段表示如果network.target或auditd.service需要启动，那么sshd.service应该在它们之后启动。可以指定多个服务，以空格隔开。</p><h3 id="Before字段"><a href="#Before字段" class="headerlink" title="Before字段"></a>Before字段</h3><p>相应地，还有一个Before字段，定义sshd.service应该在哪些服务之前启动。可以设置多个，以空格隔开，可选，根据实际需要配置。</p><p>注意，After和Before字段只涉及启动顺序，不涉及依赖关系。</p><p>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</p><h3 id="Wants字段和Requires字段"><a href="#Wants字段和Requires字段" class="headerlink" title="Wants字段和Requires字段"></a>Wants字段和Requires字段</h3><p>设置依赖关系，需要使用Wants字段和Requires字段。想要添加多个服务，可以多次使用此选项，也可以设置一个空格分隔的服务列表。</p><ol><li><p>Wants字段</p><p> 比如 <code>Wants=sshd-keygen.service</code> 就表示当前服务与sshd-keygen.service之间存在”弱依赖”关系，即如果”sshd-keygen.service”启动失败或停止运行，不影响sshd.service继续执行。</p></li><li><p>Requires字段则表示”强依赖”关系，比如 <code>Requires=sshd-keygen.service</code> ，即如果sshd-keygen.service启动失败或异常退出，那么当前服务也必须退出。</p></li></ol><p>注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p><h2 id="Service-区块：启动行为"><a href="#Service-区块：启动行为" class="headerlink" title="[Service] 区块：启动行为"></a><code>[Service]</code> 区块：启动行为</h2><p>Service区块定义如何启动当前服务。</p><h3 id="EnvironmentFile字段"><a href="#EnvironmentFile字段" class="headerlink" title="EnvironmentFile字段"></a>EnvironmentFile字段</h3><p>许多软件都有自己的环境参数文件，该文件可以用EnvironmentFile字段读取。 该文件内部的key&#x3D;value键值对，可以用$key的形式，在当前配置文件中获取。</p><h3 id="ExecStart字段"><a href="#ExecStart字段" class="headerlink" title="ExecStart字段"></a>ExecStart字段</h3><p>配置文件里面最重要的字段是ExecStart，它定义启动进程时执行的命令。</p><p>在ssh.service中，启动sshd执行的命令是<code>/usr/sbin/sshd -D $SSHD_OPTS</code>，其中的变量$SSHD_OPTS就来自EnvironmentFile字段指定的环境参数文件。</p><p>与之作用相似的，还有如下这些字段。</p><ol><li>ExecReload字段：重启服务时执行的命令。还有一个特殊的环境变量 $MAINPID 可用于表示主进程的PID，例如可以这样使用：<code>/bin/kill -HUP $MAINPID</code>。强烈建议将 <code>ExecReload=</code> 设为一个能够确保重新加载配置文件的操作同步完成的命令行。</li><li>ExecStop字段：停止服务时执行的命令</li><li>ExecStartPre字段：启动服务之前执行的命令</li><li>ExecStartPost字段：启动服务之后执行的命令</li><li>ExecStopPost字段：停止服务之后执行的命令</li></ol><p>请看下面的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=/bin/echo execstart1</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/bin/echo execstart2</span><br><span class="line">ExecStartPost=/bin/echo post1</span><br><span class="line">ExecStartPost=/bin/echo post2</span><br></pre></td></tr></table></figure><p>上面这个配置文件，第二行ExecStart设为空值，等于取消了第一行的设置，运行结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execstart2</span><br><span class="line">post1</span><br><span class="line">post2</span><br></pre></td></tr></table></figure><p>所有的启动设置之前，都可以加上一个连词号（-），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile&#x3D;-&#x2F;etc&#x2F;default&#x2F;ssh（注意等号后面的那个连词号），就表示即使&#x2F;etc&#x2F;default&#x2F;ssh文件不存在，也不会抛出错误。</p><h3 id="Type字段"><a href="#Type字段" class="headerlink" title="Type字段"></a>Type字段</h3><p>Type字段定义启动类型。它可以设置的值如下。</p><ul><li>simple（默认值）：ExecStart字段启动的进程为主进程</li><li>exec：exec与simple类似，不同之处在于，只有在该服务的主服务进程执行完成之后，systemd才会认为该服务启动完成。 其他后继单元必须一直阻塞到这个时间点之后才能继续启动。</li><li>forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程</li><li>oneshot：类似于simple，但只执行一次，只有在该服务的主服务进程退出之后，systemd才会认为该服务启动完成，才会开始启动后继单元。此种类型的服务通常需要设置RemainAfterExit&#x3D;选项。当Type&#x3D; 与 ExecStart&#x3D;都没有设置时，Type&#x3D;oneshot 就是默认值。</li><li>dbus：类似于simple，但会等待 D-Bus 信号后启动</li><li>notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li><li>idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li></ul><p>建议对长时间持续运行的服务尽可能使用Type&#x3D;simple(这是最简单和速度最快的选择)。</p><blockquote><p>注意，因为simple类型的服务无法报告启动失败，也无法在服务完成初始化后对其他单元进行排序，所以，当客户端需要通过仅由该服务本身创建的IPC通道(而非由systemd创建的套接字或D-bus之类)连接到该服务的时候，simple类型并不是最佳选择。<br>在这种情况下， notify或dbus(该服务必须提供D-Bus接口)才是最佳选择， 因为这两种类型都允许服务进程精确的安排何时算是服务启动成功、何时可以继续启动后继单元。<br>notify类型需要服务进程明确使用sd_notify()函数或类似的API，否则，可以使用forking作为替代(它支持传统的UNIX服务启动协议)。<br>最后，如果能够确保服务进程调用成功、服务进程自身不做或只做很少的初始化工作(且不大可能初始化失败)，那么exec将是最佳选择。</p><p>注意，因为使用任何 simple 之外的类型都需要等待服务完成初始化，所以可能会减慢系统启动速度。 因此，应该尽可能避免使用 simple 之外的类型(除非必须)。<br>另外，也不建议对长时间持续运行的服务使用 idle 或 oneshot 类型。</p></blockquote><p>下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>上面的配置文件，启动类型设为oneshot，就表明这个服务只要运行一次就够了，不需要长期运行。</p><p>如果关闭以后，将来某个时候还想打开，配置文件修改如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off start</span><br><span class="line">ExecStop=/usr/bin/touchpad-off stop</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>上面配置文件中，RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用systemctl stop命令停止服务，ExecStop指定的命令就会执行，从而重新开启触摸板。</p><h3 id="KillMode字段、Restart字段和RestartSec字段"><a href="#KillMode字段、Restart字段和RestartSec字段" class="headerlink" title="KillMode字段、Restart字段和RestartSec字段"></a>KillMode字段、Restart字段和RestartSec字段</h3><p>Service区块有一些字段，定义了重启行为。</p><ol><li><p>KillMode字段：定义 Systemd 如何停止 sshd 服务。</p><p> 在ssh.service定义中，将KillMode设为process，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。</p><p> KillMode字段可以设置的值如下。</p><ul><li>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</li><li>process：只杀主进程</li><li>mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li><li>none：没有进程会被杀掉，只是执行服务的 stop 命令。</li></ul></li><li><p>Restart字段：定义了 sshd 退出后，systemd 的重启方式。</p><p> 在ssh.service定义中，Restart设为on-failure，表示任何意外的失败，都将重启sshd。如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。</p><p> Restart字段可以设置的值如下。</p><ul><li>no（默认值）：退出后不会重启</li><li>on-success：只有正常退出时（退出状态码为0），才会重启</li><li>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</li><li>on-abnormal：只有被信号终止和超时，才会重启</li><li>on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li><li>on-watchdog：超时退出，才会重启</li><li>always：不管是什么退出原因，总是重启</li></ul><p> 对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal。</p></li><li><p>RestartSec字段</p></li></ol><p>最后是RestartSec字段。</p><p>RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。</p><h2 id="Install-区块"><a href="#Install-区块" class="headerlink" title="[Install] 区块"></a><code>[Install]</code> 区块</h2><p>Install区块，定义如何安装这个配置文件，即怎样做到开机启动。只有在systemctl的enable与disable命令在启用&#x2F;停用单元时才会使用此部分。</p><h3 id="WantedBy字段"><a href="#WantedBy字段" class="headerlink" title="WantedBy字段"></a>WantedBy字段</h3><p>表示该服务所在的 Target。</p><p>Target的含义是服务组，表示一组服务。WantedBy&#x3D;multi-user.target指的是 sshd 所在的 Target 是multi-user.target。</p><p>这个设置非常重要，因为执行<code>systemctl enable sshd.service</code>命令时，<code>sshd.service</code>的一个符号链接，就会放在<code>/etc/systemd/system</code>目录下面的<code>multi-user.target.wants</code>子目录之中。</p><p>Systemd 有默认的启动 Target。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl get-default</span><br><span class="line">multi-user.target</span><br></pre></td></tr></table></figure><p>上面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么systemctl enable命令能设置开机启动的原因。</p><p>使用 Target 的时候，<code>systemctl list-dependencies</code>命令和<code>systemctl isolate</code>命令也很有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看 multi-user.target 包含的所有服务</span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"># 切换到另一个 target</span><br><span class="line"># shutdown.target 就是关机状态</span><br><span class="line">$ sudo systemctl isolate shutdown.target</span><br></pre></td></tr></table></figure><p>一般来说，常用的 Target 有两个：一个是multi-user.target，表示多用户命令行状态；另一个是graphical.target，表示图形用户状态，它依赖于multi-user.target。官方文档有一张非常清晰的 Target 依赖关系图。</p><h2 id="修改配置文件后重启"><a href="#修改配置文件后重启" class="headerlink" title="修改配置文件后重启"></a>修改配置文件后重启</h2><p>修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重新加载配置文件</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 重启相关服务</span><br><span class="line">$ sudo systemctl restart foobar</span><br></pre></td></tr></table></figure><h1 id="Target-的配置文件"><a href="#Target-的配置文件" class="headerlink" title="Target 的配置文件"></a>Target 的配置文件</h1><p>Target 也有自己的配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl cat multi-user.target</span><br><span class="line"># /lib/systemd/system/multi-user.target</span><br><span class="line">#  SPDX-License-Identifier: LGPL-2.1+</span><br><span class="line">#</span><br><span class="line">#  This file is part of systemd.</span><br><span class="line">#</span><br><span class="line">#  systemd is free software; you can redistribute it and/or modify it</span><br><span class="line">#  under the terms of the GNU Lesser General Public License as published by</span><br><span class="line">#  the Free Software Foundation; either version 2.1 of the License, or</span><br><span class="line">#  (at your option) any later version.</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Multi-User System</span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line">Requires=basic.target</span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line">After=basic.target rescue.service rescue.target</span><br><span class="line">AllowIsolate=yes</span><br></pre></td></tr></table></figure><blockquote><p>注意，Target 配置文件里面没有启动命令。</p></blockquote><p>上面输出结果中，主要字段含义如下。</p><ul><li>Requires字段：要求basic.target一起运行。</li><li>Conflicts字段：冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。</li><li>After：表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。</li><li>AllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 信号介绍</title>
      <link href="/linux-signals/"/>
      <url>/linux-signals/</url>
      
        <content type="html"><![CDATA[<p>Linux中有许多处于不同状态的进程。这些进程属于用户应用程序或操作系统。我们需要一种机制让内核和这些进程协调它们的活动。其中一种方式是在一个进程有重大改变时通知其他进程，因此我们有了 <strong>信号</strong> 的概念。</p><span id="more"></span><p>Linux 信号的常见来源如图所示：<br><img src="/post/linux/signal.png" alt="signal"></p><p>信号基本上是一种单向通知。信号可以由内核发送给一个进程，或由一个进程发送给另一个进程，或者一个进程发送给它自己。</p><p>Linux信号的概念来源于Unix。在后来的Linux版本中，加入了实时（real-time）信号。信号是一种简单和轻量级的进程间通信形式，因此适用于嵌入式系统。</p><p>总共有 31 个标准信号，编号为 1-31。每个信号命名为“SIG”开头，后跟一个后缀（如INT、HUP、KILL等）。从 2.2 版开始，Linux 内核支持 33 种不同的实时信号，编号为 32-64，但应用程序应改为使用 SIGRTMIN + n 表示法。标准信号有特定用途，但 SIGUSR1 和 SIGUSR2 的使用可以由程序自定义。实时信号也可由程序定义。</p><p>Linux 信号的列表如下：</p><table><thead><tr><th>信号编号</th><th>信号名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>控制终端挂起或者断开连接</td></tr><tr><td>2</td><td>SIGINT</td><td>中断信号，通常由 Ctrl+C 发送</td></tr><tr><td>3</td><td>SIGQUIT</td><td>退出信号，通常由 Ctrl+\ 发送</td></tr><tr><td>4</td><td>SIGILL</td><td>非法指令信号</td></tr><tr><td>5</td><td>SIGTRAP</td><td>跟踪异常信号</td></tr><tr><td>6</td><td>SIGABRT</td><td>中止信号</td></tr><tr><td>7</td><td>SIGBUS</td><td>总线错误信号</td></tr><tr><td>8</td><td>SIGFPE</td><td>浮点错误信号</td></tr><tr><td>9</td><td>SIGKILL</td><td>强制退出信号（无法忽略或捕获）</td></tr><tr><td>10</td><td>SIGUSR1</td><td>用户定义信号1</td></tr><tr><td>11</td><td>SIGSEGV</td><td>段错误信号</td></tr><tr><td>12</td><td>SIGUSR2</td><td>用户定义信号2</td></tr><tr><td>13</td><td>SIGPIPE</td><td>管道破裂信号</td></tr><tr><td>14</td><td>SIGALRM</td><td>闹钟信号</td></tr><tr><td>15</td><td>SIGTERM</td><td>终止信号（无法忽略或捕获）</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>协处理器栈错误信号</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程状态改变信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>继续执行信号</td></tr><tr><td>19</td><td>SIGSTOP</td><td>暂停进程信号（无法忽略或捕获）</td></tr><tr><td>20</td><td>SIGTSTP</td><td>终端停止信号，通常由 Ctrl+Z 发送</td></tr><tr><td>21</td><td>SIGTTIN</td><td>后台进程尝试读取终端输入信号</td></tr><tr><td>22</td><td>SIGTTOU</td><td>后台进程尝试写入终端输出信号</td></tr><tr><td>23</td><td>SIGURG</td><td>套接字上的紧急数据可读信号</td></tr><tr><td>24</td><td>SIGXCPU</td><td>超时信号</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>文件大小限制超出信号</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>虚拟定时器信号</td></tr><tr><td>27</td><td>SIGPROF</td><td>分析器定时器信号</td></tr><tr><td>28</td><td>SIGWINCH</td><td>窗口大小变化信号</td></tr><tr><td>29</td><td>SIGIO</td><td>文件描述符上就绪信号</td></tr><tr><td>30</td><td>SIGPWR</td><td>电源失效信号</td></tr><tr><td>31</td><td>SIGSYS</td><td>非法系统调用信号</td></tr><tr><td>32</td><td>SIGRTMIN</td><td>实时信号最小编号</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>64</td><td>SIGRTMAX</td><td>实时信号最大编号</td></tr></tbody></table><p>0号信号，即 POSIX.1 标准中所说的null信号，一般不使用，但在 kill 函数中有个特殊的用途。使用时没有信号被发送，但可以用来（相当不可靠）检查进程是否仍然存在。</p><p>Linux中的信号实现完全符合 POSIX 标准。最新的实现应该倾向于使用 sigaction 而不是传统的信号接口。</p><p>正如硬件子系统可以中断处理器一样，信号可以中断进程的执行。因此，它们被看作是软件中断。一般来说，中断处理程序(interrupt handlers)处理硬件中断，而信号处理程序(signal handlers)则处理信号导致的中断。</p><p>通常信号被映射到特定的按键输入，比如，SIGINT代表ctrl+c，SIGSTOP代表ctrl+z，SIGQUIT代表ctrl+\。</p><h1 id="信号如何影响进程的状态？"><a href="#信号如何影响进程的状态？" class="headerlink" title="信号如何影响进程的状态？"></a>信号如何影响进程的状态？</h1><p><img src="/post/linux/signal-affect.png" alt="signal affect"></p><p>一些信号会终止正在接受信号的进程：SIGHUP、SIGINT、SIGTERM、SIGKILL。有一些信号不仅可以终止进程还会输出一些内核信息，以帮助程序员调试出错的地方，如SIGABRT（abort）、SIGBUS（bus error）、SIGILL（illegal instruction）、SIGSEGV（invalid memory reference无效内存引用）、SIGSYS（bad system call错误的系统调用） ）。用于停止进程的信号有：SIGSTOP、SIGTSTP。 SIGCONT 是恢复已停止的进程。</p><p>一个程序可以覆盖信号的默认行为。例如，一个交互式程序可以忽略SIGINT（由ctrl+c输入产生）。不过有两个例外需要注意，SIGKILL和SIGSTOP，它们不能被忽略、阻止或用这种方式覆盖。</p><p>让我们看一个父进程和其子进程的例子。假设子进程向自己发送了SIGSTOP，子进程将被停止。这反过来又会触发SIGCHLD到父进程。然后，父进程可以使用SIGCONT向子进程发出继续运行的信号。当子进程从停止状态重新运行时，另一个SIGCHLD被发送到父进程。如果后来，子进程退出了，最后的SIGCHLD会被发送到父进程。</p><h1 id="信号类似于异常-exception-吗？"><a href="#信号类似于异常-exception-吗？" class="headerlink" title="信号类似于异常(exception)吗？"></a>信号类似于异常(exception)吗？</h1><p>一些编程语言能够使用诸如try-throw-catch这样的结构进行异常处理。<br>但信号与异常并不类似。相反，失败的系统或库调用会返回非零的退出代码。当一个进程被终止时，它的退出代码是128加信号编号。例如，一个被SIGKILL杀死的进程将返回137（128+9）。</p><h1 id="信号是同步还是异步的？"><a href="#信号是同步还是异步的？" class="headerlink" title="信号是同步还是异步的？"></a>信号是同步还是异步的？</h1><p>信号既可以是同步，也可以是异步。</p><p>同步信号的出现是由于指令导致了一个无法恢复的错误，如非法地址访问。这些信号被发送到导致它的线程。这些信号也被称为陷阱(trap)，因为它们也会导致陷阱进入内核的陷阱处理程序(trap handler)。</p><p>异步信号是对当前执行环境的外部信号。从另一个进程中发送 SIGKILL 就是这样一个例子。这些也被称为软件中断。</p><h1 id="信号的生命周期是什么？"><a href="#信号的生命周期是什么？" class="headerlink" title="信号的生命周期是什么？"></a>信号的生命周期是什么？</h1><p><img src="/post/linux/signal-life-cycle.png" alt="signal life cycle"></p><p>一个信号经历三个阶段：</p><ul><li>Generation（生成）：信号可以由内核或任何进程生成，生成后会将其发送给特定的进程。信号由其编号表示，没有额外的数据或参数。因此，信号是轻量级的。但是，POSIX 实时信号传递额外的数据。可以生成信号的系统调用和函数包括 raise、kill、killpg、pthread_kill、tgkill 和 sigqueue。</li><li>Delivery（传递）：信号在传递之前一直处于待处理状态。通常，内核会尽快将信号传递给进程。但是，如果对应的进程阻塞了信号，它将保持未处理状态直到解除阻塞。</li><li>Processing（处理）：一旦信号被传递到，就会以多种方式中其中一种进行处理。每个信号都有一个默认的行为：忽略信号；或终止进程，有时使用核心转储(core dump)；或停止&#x2F;继续该过程。对于非默认行为，对应的处理函数会被调用。通过 sigaction 函数指定究竟采用哪一种处理方式。</li></ul><h1 id="什么是信号阻塞和解除阻塞？"><a href="#什么是信号阻塞和解除阻塞？" class="headerlink" title="什么是信号阻塞和解除阻塞？"></a>什么是信号阻塞和解除阻塞？</h1><p><img src="/post/linux/signal-block.gif" alt="signal block"></p><p>信号打断了程序执行的正常流程。当进程正在执行一些关键代码或更新与信号处理程序共享的数据时，这是不希望看到的。阻断的引入解决了这个问题。不过代价是，信号处理被延迟了。</p><p>每个进程都可以指定它是否要阻塞一个特定的信号。如果被阻断，而信号确实发生了，操作系统将把该信号作为待处理信号。一旦进程解除阻断，该信号将被传递。当前被屏蔽的信号集合被称为信号屏蔽(signal mask)。</p><p>无限期地阻断一个信号是没有意义的。为了这个目的，进程可以在接受到信号后选择忽略它，被一个进程屏蔽的信号不会影响其他进程，他们可以正常接收信号。</p><p>信号屏蔽(Signal mask)可以用 sigprocmask（单线程）或 pthread_sigmask（多线程）来设置。 当一个进程有多个线程时，信号可以针对每个线程分别设置是否屏蔽。信号将被传递给任何一个没有阻断它的线程。从本质上讲，信号处理程序是针对某个进程的，信号掩码是针对某个线程的。</p><h1 id="一个进程可以有多个待处理的信号吗？"><a href="#一个进程可以有多个待处理的信号吗？" class="headerlink" title="一个进程可以有多个待处理的信号吗？"></a>一个进程可以有多个待处理的信号吗？</h1><p>是的，许多标准信号可以在进程中被挂起。然而，一个给定的信号类型只能有一个实例被挂起。这是因为信号的挂起和阻塞是作为位掩码(bitmask)实现的，每个信号类型只有一个位。例如，我们可以让 SIGALRM 和 SIGTERM 同时挂起，但我们不能有两个 SIGALRM<br>信号挂起。进程将只收到一个SIGALRM信号，即使是多次抛出。</p><p>通过实时信号，信号可以和数据一起排队，这样每个信号的实例都可以单独传递和处理。</p><p>POSIX没有规定标准信号的传递顺序，也没有规定如果标准信号和实时信号都在等待中会如何处理。然而在Linux中，会优先处理标准信号。对于实时信号，编号较低的信号首先被传递，如果一个信号类型有很多在排队，最早的一个会被首先传递。</p><h1 id="信号历史发展"><a href="#信号历史发展" class="headerlink" title="信号历史发展"></a>信号历史发展</h1><ol><li>1990 信号在 POSIX.1-1990 标准中得到了描述。可以追溯至 IEEE标准1003.1-1988。</li><li>1993 实时扩展作为 POSIX.1b 发布。其中包含实时信号。</li><li>1999 随着内核版本 2.2 的发布，Linux 开始支持实时信号。</li><li>2001 POSIX.1-2001 标准中增加了更多信号：SIGBUS、SIGPOLL、SIGPROF、SIGSYS、SIGTRAP、SIGURG、SIGVTALRM、SIGXCPU、SIGXFSZ。<br>  <img src="/post/linux/list-linux-signals.png" alt="list linux signals"></li></ol><h1 id="简单-C-语言信号处理程序"><a href="#简单-C-语言信号处理程序" class="headerlink" title="简单 C 语言信号处理程序"></a>简单 C 语言信号处理程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example shows a custom handler for SIGINT</span></span><br><span class="line"><span class="comment">// but the handler reverts to default action for future signals.</span></span><br><span class="line"><span class="comment">// Thus, first ctrl+c will allow program to continue </span></span><br><span class="line"><span class="comment">// and second ctrl+c will terminate the program.</span></span><br><span class="line"><span class="comment">// 以下示例展示了对SIGINT信号的自定义处理程序</span></span><br><span class="line"><span class="comment">// 但是，处理程序会恢复为将来信号的默认操作。</span></span><br><span class="line"><span class="comment">// 因此，第一次按下Ctrl+C将允许程序继续执行</span></span><br><span class="line"><span class="comment">// 而第二次按下Ctrl+C将终止程序。</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler1</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You are here becoz of signal: %d\n&quot;</span>, num);</span><br><span class="line">signal(SIGINT, SIG_DFL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">signal(SIGINT, sig_handler1);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 学习笔记</title>
      <link href="/k8s-learning/"/>
      <url>/k8s-learning/</url>
      
        <content type="html"><![CDATA[<p>这里总结了一些k8s的学习笔记，主要是从docker开始，到k8s的一些基础知识，以及k8s的一些基础组件的介绍，以及k8s的一些基础资源的使用。</p><span id="more"></span><ol><li>认识docker<ol><li><a href="https://realtiger.github.io/docker-introduction/">docker介绍</a></li><li><a href="https://realtiger.github.io/docker-file/">docker file</a></li><li><a href="https://realtiger.github.io/docker-service-running-principle/">docker运行原理</a></li><li><a href="https://realtiger.github.io/docker-network/">docker网络</a></li><li><a href="https://realtiger.github.io/containerd-introduction/">containerd介绍与docker总结</a></li></ol></li><li>认识k8s<ol><li><a href="https://realtiger.github.io/k8s-introduction/">k8s 介绍</a></li><li><a href="https://realtiger.github.io/pod-settings-and-config/">pod 常用设置和配置</a></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 介绍</title>
      <link href="/k8s-introduction/"/>
      <url>/k8s-introduction/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>接下来学习kubernetes的架构及工作流程，重点介绍如何使用Workload管理业务应用的生命周期，实现服务不中断的滚动更新，通过服务发现和集群内负载均衡来实现集群内部的服务间访问，并通过ingress实现外部使用域名访问集群内部的服务。</p><span id="more"></span><h1 id="k8s-介绍"><a href="#k8s-介绍" class="headerlink" title="k8s 介绍"></a>k8s 介绍</h1><ol><li><p>纯容器模式的问题</p><ol><li>业务容器数量庞大，哪些容器部署在哪些节点，使用了哪些端口，如何记录、管理，需要登录到每台机器去管理？</li><li>跨主机通信，多个机器中的容器之间相互调用如何做，iptables规则手动维护？</li><li>跨主机容器间互相调用，配置如何写？写死固定IP+端口？</li><li>如何实现业务高可用？多个容器对外提供服务如何实现负载均衡？</li><li>容器的业务中断了，如何可以感知到，感知到以后，如何自动启动新的容器?</li><li>如何实现滚动升级保证业务的连续性？</li><li>……</li></ol></li><li><p>容器调度管理平台</p><ul><li>Docker Swarm</li><li>Mesos</li><li>Google Kubernetes</li></ul><p>2017年开始Kubernetes凭借强大的容器集群管理功能, 逐步占据市场,目前在容器编排领域一枝独秀 <a href="https://kubernetes.io/">https://kubernetes.io/</a></p></li></ol><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>如何设计一个容器管理平台？需要满足以下几个需求：</p><ul><li>集群架构，管理节点分发容器到数据节点</li><li>如何部署业务容器到各数据节点</li><li>N个数据节点，业务容器如何选择部署在最合理的节点</li><li>容器如何实现多副本，如何满足每个机器部署一个容器的模型</li><li>多副本如何实现集群内负载均衡</li></ul><p>分布式系统，一般包含两类角色：管理节点和工作节点</p><p><img src="/post/docker/architecture.png" alt="architecture"></p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>k8s核心主要包括以下几个组件：</p><ul><li>ETCD：分布式高性能键值数据库,存储整个集群的所有元数据</li><li>ApiServer:  API服务器,集群资源访问控制入口,提供restAPI及安全访问控制</li><li>Scheduler：调度器,负责把业务容器调度到最合适的Node节点</li><li>Controller Manager：控制器管理,确保集群资源按照期望的方式运行<ul><li>Replication Controller</li><li>Node controller</li><li>ResourceQuota Controller</li><li>Namespace Controller</li><li>ServiceAccount Controller</li><li>Token Controller</li><li>Service Controller</li><li>Endpoints Controller</li><li>……</li></ul></li><li>kubelet：运行在每个节点上的主要的“节点代理”，主要干脏活累活<ul><li>pod 管理：kubelet 定期从所监听的数据源获取节点上 pod&#x2F;container<br>的期望状态（运行什么容器、运行的副本数量、网络或者存储如何配置等等），并调用对应的容器平台接口达到这个状态。</li><li>容器健康检查：kubelet 创建了容器之后还要查看容器是否正常运行，如果容器运行出错，就要根据 pod 设置的重启策略进行处理.</li><li>容器监控：kubelet 会监控所在节点的资源使用情况，并定时向 master 报告，资源使用数据都是通过 cAdvisor<br>获取的。知道整个集群所有节点的资源情况，对于 pod 的调度和正常运行至关重要</li></ul></li><li>kube-proxy：维护节点中的iptables或者ipvs规则</li><li>kubectl: 命令行接口，用于对 Kubernetes 集群运行命令  <a href="https://kubernetes.io/zh/docs/reference/kubectl/">https://kubernetes.io/zh/docs/reference/kubectl/</a></li></ul><p>根据k8s部署的方式不同，组件的运行方式也是不同的。</p><ol><li>如果是通过kubeadmin方式部署的，组件运行方式是以静态Pod的方式运行的，静态Pod是通过kubelet启动的，kubelet会定期检查&#x2F;etc&#x2F;kubernetes&#x2F;manifests目录下的yaml文件，如果有新的yaml文件，kubelet会启动一个Pod，如果yaml文件被删除，kubelet会删除对应的Pod。</li></ol> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## etcd、apiserver、controller-manager、kube-scheduler</span></span><br><span class="line"><span class="comment"># kubectl 是一个二进制的命令行工具，用于与 Kubernetes 集群进行通信。kubectl 通过 RESTful API 与 Kubernetes API Server 交互，从而管理集群。</span></span><br><span class="line"><span class="comment"># k8s 安装完成后，kubectl 会被主动安装到 /usr/local/bin 目录下，可以直接使用。</span></span><br><span class="line">$ kubectl -n kube-system get po</span><br></pre></td></tr></table></figure><ol start="2"><li><p>如果是二进制方式部署的，组件运行方式通常是以systemd服务的方式运行的，systemd服务的配置文件在&#x2F;etc&#x2F;systemd&#x2F;system目录下，可以通过systemctl命令查看服务的运行状态。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## etcd、apiserver、controller-manager、kube-scheduler</span></span><br><span class="line">$ systemctl status etcd</span><br><span class="line">$ systemctl status kube-apiserver</span><br><span class="line">$ systemctl status kube-controller-manager</span><br><span class="line">$ systemctl status kube-scheduler</span><br><span class="line">$ systemctl status kubelet</span><br></pre></td></tr></table></figure></li></ol><h2 id="集群资源"><a href="#集群资源" class="headerlink" title="集群资源"></a>集群资源</h2><p>组件是为了支撑k8s平台的运行，安装好的软件。资源是如何去使用k8s的能力的定义。</p><p>比如，k8s可以使用Pod来管理业务应用，那么Pod就是k8s集群中的一类资源，集群中的所有资源可以提供如下方式查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl api-resources</span><br></pre></td></tr></table></figure><p>namespace 也是 k8s 的一类资源，那么该如何理解 namespace 呢？</p><p>namespace 就是 k8s 的命名空间，是集群内一个虚拟的概念，类似于资源池的概念，一个池子里可以有各种资源类型，绝大多数的资源都必须属于某一个 namespace 。集群初始化安装好之后，会默认有如下几个 namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get namespaces</span><br><span class="line">NAME                   STATUS   AGE</span><br><span class="line">default                Active   84m</span><br><span class="line">kube-node-lease        Active   84m</span><br><span class="line">kube-public            Active   84m</span><br><span class="line">kube-system            Active   84m</span><br><span class="line">kubernetes-dashboard   Active   71m</span><br></pre></td></tr></table></figure><ul><li>所有 NAMESPACED 的资源，在创建的时候都需要指定 namespace ，若不指定，默认会在 default 命名空间下</li><li>相同 namespace 下的同类资源不可以重名，不同类型的资源可以重名</li><li>不同 namespace 下的同类资源可以重名</li><li>通常在项目使用的时候，我们会创建带有业务含义的 namespace 来做逻辑上的整合</li></ul><h2 id="kubectl的使用"><a href="#kubectl的使用" class="headerlink" title="kubectl的使用"></a>kubectl的使用</h2><p>类似于docker，kubectl是命令行工具，用于与APIServer交互，内置了丰富的子命令，功能极其强大。 <a href="https://kubernetes.io/docs/reference/kubectl/overview/">https://kubernetes.io/docs/reference/kubectl/overview/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -h</span><br><span class="line">$ kubectl get -h</span><br><span class="line">$ kubectl create -h</span><br><span class="line">$ kubectl create namespace -h</span><br></pre></td></tr></table></figure><h1 id="最小调度单元-Pod"><a href="#最小调度单元-Pod" class="headerlink" title="最小调度单元 Pod"></a>最小调度单元 Pod</h1><p>docker调度的是容器，在k8s集群中，最小的调度单元是Pod（豆荚）</p><p><img src="/post/docker/pod-demo.png" alt="pod-demo"></p><h2 id="为什么引入Pod"><a href="#为什么引入Pod" class="headerlink" title="为什么引入Pod"></a>为什么引入Pod</h2><ul><li>与容器引擎解耦。平台设计与引擎的具体的实现解耦。</li><li>多容器共享网络|存储|进程 空间, 支持的业务场景更加灵活。</li></ul><h2 id="pod-定义"><a href="#pod-定义" class="headerlink" title="pod 定义"></a>pod 定义</h2><h3 id="使用yaml格式定义Pod"><a href="#使用yaml格式定义Pod" class="headerlink" title="使用yaml格式定义Pod"></a>使用yaml格式定义Pod</h3><p>k8s中定义pod的方式一种是通过yaml文件。</p><p>下面是一个 mariadb 数据库的 yaml 文档的示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">blog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">blog</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/blog:v1</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span>   <span class="comment">#  指定root用户的用户名</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;blog&quot;</span></span><br></pre></td></tr></table></figure><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>k8s创建的 pod 等都成为一种资源，资源有对应的种类和版本信息。</p><table><thead><tr><th align="left">apiVersion</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">alpha</td><td align="left">进入K8s功能的早期候选版本，可能包含Bug，最终不一定进入K8s</td></tr><tr><td align="left">beta</td><td align="left">已经过测试的版本，最终会进入K8s，但功能、对象定义可能会发生变更。</td></tr><tr><td align="left">stable</td><td align="left">可安全使用的稳定版本</td></tr><tr><td align="left">v1</td><td align="left">stable 版本之后的首个版本，包含了更多的核心对象</td></tr><tr><td align="left">apps&#x2F;v1</td><td align="left">使用最广泛的版本，像Deployment、ReplicaSets都已进入该版本</td></tr></tbody></table><p>资源类型与apiVersion对照表</p><table><thead><tr><th align="left">Kind</th><th align="left">apiVersion</th></tr></thead><tbody><tr><td align="left">ClusterRoleBinding</td><td align="left">rbac.authorization.k8s.io&#x2F;v1</td></tr><tr><td align="left">ClusterRole</td><td align="left">rbac.authorization.k8s.io&#x2F;v1</td></tr><tr><td align="left">ConfigMap</td><td align="left">v1</td></tr><tr><td align="left">CronJob</td><td align="left">batch&#x2F;v1beta1</td></tr><tr><td align="left">DaemonSet</td><td align="left">extensions&#x2F;v1beta1</td></tr><tr><td align="left">Node</td><td align="left">v1</td></tr><tr><td align="left">Namespace</td><td align="left">v1</td></tr><tr><td align="left">Secret</td><td align="left">v1</td></tr><tr><td align="left">PersistentVolume</td><td align="left">v1</td></tr><tr><td align="left">PersistentVolumeClaim</td><td align="left">v1</td></tr><tr><td align="left">Pod</td><td align="left">v1</td></tr><tr><td align="left">Deployment</td><td align="left">v1、apps&#x2F;v1、apps&#x2F;v1beta1、apps&#x2F;v1beta2</td></tr><tr><td align="left">Service</td><td align="left">v1</td></tr><tr><td align="left">Ingress</td><td align="left">extensions&#x2F;v1beta1</td></tr><tr><td align="left">ReplicaSet</td><td align="left">apps&#x2F;v1、apps&#x2F;v1beta2</td></tr><tr><td align="left">Job</td><td align="left">batch&#x2F;v1</td></tr><tr><td align="left">StatefulSet</td><td align="left">apps&#x2F;v1、apps&#x2F;v1beta1、apps&#x2F;v1beta2</td></tr></tbody></table><p>快速获得资源和版本可以在终端通过命令行获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl explain pod</span><br><span class="line">$ kubectl explain Pod.apiVersion</span><br></pre></td></tr></table></figure><h2 id="pod对外暴露服务"><a href="#pod对外暴露服务" class="headerlink" title="pod对外暴露服务"></a>pod对外暴露服务</h2><h3 id="创建和访问Pod"><a href="#创建和访问Pod" class="headerlink" title="创建和访问Pod"></a>创建和访问Pod</h3><p>我们创建pod的最终目的是为了访问pod中的服务，所以我们需要将pod中的服务暴露出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建namespace, namespace是逻辑上的资源池</span></span><br><span class="line">$ kubectl create namespace <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用指定文件创建Pod</span></span><br><span class="line">$ kubectl create -f pod.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看pod，可以简写po</span></span><br><span class="line"><span class="comment">## 所有的操作都需要指定namespace，如果是在default命名空间下，则可以省略</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get pods -o wide</span><br><span class="line">NAME     READY   STATUS    RESTARTS   AGE    IP             NODE</span><br><span class="line">blog   2/2     Running   0          3m     10.244.1.146   k8s-slave1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 回顾流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用 Pod Ip 访问服务 3306 和 8002，此时因为是新启动的环境，所以还无法正常访问</span></span><br><span class="line">$ curl 10.244.1.120:8002/blog/index/</span><br><span class="line"></span><br><span class="line"><span class="comment">## 进入容器,执行初始化, 不必到对应的主机执行 docker exec</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c mysql bash</span><br><span class="line">/ <span class="comment"># mysql -p123456</span></span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c blog bash</span><br><span class="line">/ <span class="comment"># env</span></span><br><span class="line">/ <span class="comment"># python3 manage.py migrate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 再次访问服务 3306 和 8002</span></span><br><span class="line">$ curl 10.244.1.120:8002/blog/index/</span><br></pre></td></tr></table></figure><h2 id="Infra容器"><a href="#Infra容器" class="headerlink" title="Infra容器"></a>Infra容器</h2><p>登录<code>k8s-slave1</code>节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a | grep blog  <span class="comment">## 发现有三个容器</span></span><br><span class="line"><span class="comment">## 其中包含 mysql 和 blog 程序以及 Infra 容器</span></span><br><span class="line"><span class="comment">## 为了实现 Pod 内部的容器可以通过 localhost 通信，每个 Pod 都会启动 Infra 容器，然后 Pod 内部的其他容器的网络空间会共享该 Infra 容器的网络空间(Docker网络的container模式)， Infra 容器只需要 hang 住网络空间，不需要额外的功能，因此资源消耗极低。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 登录 master 节点，查看 pod 内部的容器 ip 均相同，为 pod ip</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c blog bash</span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c mysql bash</span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br></pre></td></tr></table></figure><h2 id="pod-操作"><a href="#pod-操作" class="headerlink" title="pod 操作"></a>pod 操作</h2><p>k8s 中 pod 容器的命名有一套固定的规则：<code>k8s_&lt;container_name&gt;_&lt;pod_name&gt;_&lt;namespace&gt;_&lt;random_string&gt;</code></p><h3 id="查看pod详细信息"><a href="#查看pod详细信息" class="headerlink" title="查看pod详细信息"></a>查看pod详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看 pod 调度节点及 pod_ip</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get pods -o wide</span><br><span class="line"><span class="comment">## 查看完整的 yaml</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po blog -o yaml</span><br><span class="line"><span class="comment">## 查看 pod 的明细信息及事件</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> describe pod blog</span><br></pre></td></tr></table></figure><h3 id="Troubleshooting-and-Debugging"><a href="#Troubleshooting-and-Debugging" class="headerlink" title="Troubleshooting and Debugging"></a>Troubleshooting and Debugging</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入Pod内的容器</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; <span class="built_in">exec</span> &lt;pod_name&gt; -c &lt;container_name&gt; -it /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pod内容器日志,显示标准或者错误输出日志</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; logs -f &lt;pod_name&gt; -c &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h3 id="更新服务版本"><a href="#更新服务版本" class="headerlink" title="更新服务版本"></a>更新服务版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f demo-pod.yaml</span><br></pre></td></tr></table></figure><h3 id="删除Pod服务"><a href="#删除Pod服务" class="headerlink" title="删除Pod服务"></a>删除Pod服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据文件删除</span></span><br><span class="line">$ kubectl delete -f demo-pod.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据 pod_name 删除</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; delete pod &lt;pod_name&gt;</span><br></pre></td></tr></table></figure><h2 id="Pod-启动多容器"><a href="#Pod-启动多容器" class="headerlink" title="Pod 启动多容器"></a>Pod 启动多容器</h2><p>这里我们使用一个 pod 启动两个容器，并且将镜像仓库设置为私有，需要登录才能拉取镜像，我们使用 secret 来管理镜像仓库的登录信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建 secret</span></span><br><span class="line"><span class="comment">## 注意：这种方式创建的 secret 只能在当前 namespace 下使用，跨 namespace 无法使用</span></span><br><span class="line">$ kubectl create secret docker-registry harbor-registry --docker-server=harbor.mydomain.com:10443 --docker-username=admin --docker-password=Harbor12345 --docker-email=admin@mydomain.com</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看 secret</span></span><br><span class="line">$ kubectl get secret harbor-registry -o yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 编写多个 pod 的 yaml 文件</span></span><br><span class="line">$ <span class="built_in">cat</span> &gt; pods.yaml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: blog</span></span><br><span class="line"><span class="string">  namespace: test</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    component: blog</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  containers:</span></span><br><span class="line"><span class="string">    - name: blog-api</span></span><br><span class="line"><span class="string">      image: harbor.mydomain.com:10443/test/blog-backend:v1</span></span><br><span class="line"><span class="string">      env:</span></span><br><span class="line"><span class="string">          - name: DB_HOST</span></span><br><span class="line"><span class="string">            value: &quot;my-mysql&quot;</span></span><br><span class="line"><span class="string">          - name: DB_USER</span></span><br><span class="line"><span class="string">            value: &quot;root&quot;</span></span><br><span class="line"><span class="string">          - name: DB_PASSWD</span></span><br><span class="line"><span class="string">            value: &quot;123456&quot;</span></span><br><span class="line"><span class="string">      ports:</span></span><br><span class="line"><span class="string">          - containerPort: 8000   </span></span><br><span class="line"><span class="string">    - name: blog-web</span></span><br><span class="line"><span class="string">        image: harbor.mydomain.com:10443/test/blog-frontend:v1</span></span><br><span class="line"><span class="string">        ports:</span></span><br><span class="line"><span class="string">            - containerPort: 80</span></span><br><span class="line"><span class="string">  imagePullSecrets:   </span></span><br><span class="line"><span class="string">    - name: harbor-registry</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建 pod</span></span><br><span class="line">$ kubectl create -f pods.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看 pod</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get pods -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment">## 访问服务</span></span><br><span class="line">$ curl http://&lt;pod_ip&gt;:80</span><br><span class="line"></span><br><span class="line"><span class="comment">## 进入指定容器需要添加 -c 参数指定容器名称，如果不指定，默认进入第一个容器</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c blog-web -- bash</span><br></pre></td></tr></table></figure><h1 id="k8s-工作流程"><a href="#k8s-工作流程" class="headerlink" title="k8s 工作流程"></a>k8s 工作流程</h1><h2 id="流程图与过程描述"><a href="#流程图与过程描述" class="headerlink" title="流程图与过程描述"></a>流程图与过程描述</h2><p><img src="/post/docker/process.png" alt="process"></p><ol><li>用户准备一个资源文件（记录了业务应用的名称、镜像地址等信息），通过调用APIServer执行创建Pod</li><li>APIServer收到用户的Pod创建请求，将Pod信息写入到etcd中</li><li>调度器通过list-watch的方式，发现有新的pod数据，但是这个pod还没有绑定到某一个节点中</li><li>调度器通过调度算法，计算出最适合该pod运行的节点，并调用APIServer，把信息更新到etcd中</li><li>kubelet同样通过list-watch方式，发现有新的pod调度到本机的节点了，因此调用容器运行时，去根据pod的描述信息，拉取镜像，启动容器，同时生成事件信息</li><li>同时，把容器的信息、事件及状态也通过APIServer写入到etcd中</li></ol><h2 id="架构设计的思考"><a href="#架构设计的思考" class="headerlink" title="架构设计的思考"></a>架构设计的思考</h2><ol><li>系统各个组件分工明确(APIServer是所有请求入口，CM是控制中枢，Scheduler主管调度，而Kubelet负责运行)，配合流畅，整个运行机制一气呵成。</li><li>除了配置管理和持久化组件ETCD，其他组件并不保存数据。意味 <strong>除ETCD外</strong> 其他组件都是无状态的。因此从架构设计上对kubernetes系统高可用部署提供了支撑。</li><li>同时因为组件无状态，组件的升级，重启，故障等并不影响集群最终状态，只要组件恢复后就可以从中断处继续运行。</li><li>各个组件和kube-apiserver之间的数据推送都是通过list-watch机制来实现。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>containerd 介绍 与 docker 总结</title>
      <link href="/containerd-introduction/"/>
      <url>/containerd-introduction/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>本节主要介绍containerd的基本概念，以及docker的一些总结。</p><span id="more"></span><h1 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h1><p>容器运行时（ContainerRuntime），运行于 kubernetes（k8s）集群的每个节点中，负责容器的整个生命周期，其中 docker 是目前应用最广的。</p><p>随着容器云的发展，越来越多的容器运行时涌现。为了解决这些容器运行时和 k8s 的集成问题，在 k8s 1.5 版本中，社区推出了<br>CRI（ContainerRuntimeInterface,容器运行时接口），以支持更多的容器运行时。</p><p>Kubelet 通过 CRI 和容器运行时进行通信，使得容器运行时能够像插件一样单独运行。可以说每个容器运行时都有自己的优势，这就允许用户更容易选择和替换自己的容器运行时。</p><p><img src="/post/docker/cri-k8s.drawio.svg" alt="cri-k8s"></p><h2 id="CRI-amp-OCI"><a href="#CRI-amp-OCI" class="headerlink" title="CRI &amp; OCI"></a>CRI &amp; OCI</h2><p>OCI（OpenContainerInitiative，开放容器计划）定义了创建容器的格式和运行时的开源行业标准，包括镜像规范（ImageSpecification）和运行时规范(<br>RuntimeSpecification)。</p><p>镜像规范定义了 OCI 镜像的标准。高层级运行时将会下载一个 OCI 镜像，并把它解压成 OCI 运行时文件系统包（filesystembundle）。</p><p><img src="/post/docker/oci+cri.drawio.svg" alt="oci+cri"></p><p>运行时规范则描述了如何从 OCI 运行时文件系统包运行容器程序，并且定义它的配置、运行环境和生命周期。如何为新容器设置命名空间(<br>namepsaces)和控制组(cgroups)，以及挂载根文件系统等等操作，都是在这里定义的。它的一个参考实现是runC。我们称其为低层级运行时（Low-levelRuntime）。除<br>runC 以外，也有很多其他的运行时遵循 OCI 标准，例如 kata-runtime。</p><h2 id="为什么弃用Docker"><a href="#为什么弃用Docker" class="headerlink" title="为什么弃用Docker"></a>为什么弃用Docker</h2><p>目前 docker 仍是 kubernetes 默认的容器运行时。那为什么会选择换掉 docker 呢？主要的原因是它的复杂性。</p><p>我们总结了 docker,containerd 以及 cri-o 的详细调用层级。Docker<br>的多层封装和调用，导致其在可维护性上略逊一筹，增加了线上问题的定位难度（貌似除了重启docker，我们就毫无他法了）。Containerd 和<br>cri-o 的方案比起 docker 简洁很多。因此我们更偏向于选用更加简单和纯粹的 containerd 和 cri-o 作为我们的容器运行时。</p><p><img src="/post/docker/kubelet-cri.drawio.svg" alt="kubelet-cri"></p><p>我们对 containerd 和 cri-o 进行了一组性能测试，包括创建、启动、停止和删除容器，以比较它们所耗的时间。containerd<br>在各个方面都表现良好，除了启动容器这项。从总用时来看，containerd 的用时还是要比 cri-o 要短的。</p><p><img src="/post/docker/runcPerformance.webp" alt="runcPerformance"></p><p>从功能性来讲，containerd 和 cri-o 都符合 CRI 和 OCI 的标准。从稳定性来说，单独使用 containerd 和 cri-o<br>都没有足够的生产环境经验。但庆幸的是，containerd 一直在 docker 里使用，而 docker 的生产环境经验可以说比较充足。可见在稳定性上<br>containerd 略胜一筹。所以我们最终选用了 containerd</p><h1 id="containerd操作"><a href="#containerd操作" class="headerlink" title="containerd操作"></a>containerd操作</h1><p>更换 containerd 后，常用的 docker 命令也不再有用，containerd 命令行客户端如下图所示：</p><p><img src="/post/docker/containerd-client.drawio.svg" alt="containerd"></p><ul><li>ctr -v 输出的是 containerd 的版本，crictl -v 输出的是当前 k8s 的版本，从结果显而易见你可以认为 crictl 是用于 k8s 的。</li><li>一般来说你某个主机安装了 k8s 后，命令行才会有 crictl 命令。而 ctr 是跟 k8s 无关的，你主机安装了 containerd 服务后就可以操作<br>ctr 命令。</li><li>用 crictl 运行 Pod 沙盒对容器运行时排错很有帮助。 在运行的 Kubernetes 集群中，沙盒会随机地被 kubelet 停止和删除。因此<br>crictl 尽量不要在单独起容器的情况下使用，因为容器会被停止和删除。</li></ul><p>先提前放出docker&#x2F;ctr&#x2F;crictl之间命令的对比，后面会详细介绍。</p><table><thead><tr><th>命令</th><th>docker</th><th>ctr（containerd）</th><th>crictl（kubernetes）</th></tr></thead><tbody><tr><td>查看运行的容器</td><td>docker ps</td><td>ctr task ls&#x2F;ctr container ls</td><td>crictl ps</td></tr><tr><td>查看镜像</td><td>docker images</td><td>ctr image ls</td><td>crictl images</td></tr><tr><td>查看容器日志</td><td>docker logs</td><td>无</td><td>crictl logs</td></tr><tr><td>查看容器数据信息</td><td>docker inspect</td><td>ctr container info</td><td>crictl inspect</td></tr><tr><td>查看容器资源</td><td>docker stats</td><td>无</td><td>crictl stats</td></tr><tr><td>启动&#x2F;关闭已有的容器</td><td>docker start&#x2F;stop</td><td>ctr task start&#x2F;kill</td><td>crictl start&#x2F;stop</td></tr><tr><td>运行一个新的容器</td><td>docker run</td><td>ctr run</td><td>无（最小单元为pod）</td></tr><tr><td>打标签</td><td>docker tag</td><td>ctr image tag</td><td>无</td></tr><tr><td>创建一个新的容器</td><td>docker create</td><td>ctr container create</td><td>crictl create</td></tr><tr><td>导入镜像</td><td>docker load</td><td>ctr image import</td><td>无</td></tr><tr><td>导出镜像</td><td>docker save</td><td>ctr image export</td><td>无</td></tr><tr><td>删除容器</td><td>docker rm</td><td>ctr container rm</td><td>crictl rm</td></tr><tr><td>删除镜像</td><td>docker rmi</td><td>ctr image rm</td><td>crictl rmi</td></tr><tr><td>拉取镜像</td><td>docker pull</td><td>ctr image pull</td><td>ctictl pull</td></tr><tr><td>推送镜像</td><td>docker push</td><td>ctr image push</td><td>无</td></tr><tr><td>登录或在容器内部执行命令</td><td>docker exec</td><td>无</td><td>crictl exec</td></tr><tr><td>清空不用的容器</td><td>docker image prune</td><td>无</td><td>crictl rmi –prune</td></tr></tbody></table><p>更多命令操作，可以直接在命令行输入命令查看帮助。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br><span class="line">ctr --help</span><br><span class="line">crictl --help</span><br></pre></td></tr></table></figure><p>以下是各种客户端操作 containerd 的命令，因为之后会安装 k8s，很多操作通过 k8s 直接就完成了，所以对应命令可以先做了解即可。</p><h2 id="containerd-客户端-ctr"><a href="#containerd-客户端-ctr" class="headerlink" title="containerd 客户端 ctr"></a>containerd 客户端 ctr</h2><p>ctr 是 containerd 项目的一部分提供的命令行客户端。如果一台机器上运行了 containerd，那么ctr二进制文件也一般会进行安装。</p><p>由于 containerd 有 namespaces 的概念，对于上层编排系统的支持，ctr 客户端主要区分了3个命名空间分别是k8s.io、moby和default，以上我们用<br>crictl 操作的均在 k8s.io 命名空间，使用 ctr 看镜像列表就需要加上 -n 参数。crictl 只有一个 k8s.io 命名空间，但是没有 -n 参数。</p><p>我们知道 Docker 也是默认调用的 containerd， Docker 使用的命名空间默认是 moby，而不是 default，所以假如我们用 docker<br>启动容器，那么我们也可以通过 ctr -n moby 来定位容器信息。</p><blockquote><p>【温馨提示】ctr images pull 拉取的镜像默认放在default，而 crictl pull 和 kubelet 默认拉取的镜像都在 k8s.io 命名空间下。所以通过<br>ctr 导入镜像的时候特别注意一点，最好指定命名空间。</p></blockquote><h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 注意 -n 不能放在命令最后面，下面查看的镜像是一样的</span><br><span class="line">ctr -n=k8s.io image ls</span><br><span class="line">ctr -n k8s.io image ls</span><br><span class="line"></span><br><span class="line"># 使用ctr命令指定命名空间导入镜像</span><br><span class="line">ctr -n=k8s.io image import dashboard.tar</span><br></pre></td></tr></table></figure><h3 id="ctr-命令"><a href="#ctr-命令" class="headerlink" title="ctr 命令"></a>ctr 命令</h3><p>ctr 命令的参数和全局参数如下。</p><p>参数命令的格式为：<code>ctr [global options] command [command options] [arguments...]</code></p><p>全局参数可以在任何命令后面使用，并且可以多个参数组合使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS:</span><br><span class="line">   plugins, plugin            provides information about containerd plugins</span><br><span class="line">   version                    print the client and server versions</span><br><span class="line">   containers, c, container   manage containers</span><br><span class="line">   content                    manage content</span><br><span class="line">   events, event              display containerd events</span><br><span class="line">   images, image, i           manage images</span><br><span class="line">   leases                     manage leases</span><br><span class="line">   namespaces, namespace, ns  manage namespaces</span><br><span class="line">   pprof                      provide golang pprof outputs for containerd</span><br><span class="line">   run                        run a container</span><br><span class="line">   snapshots, snapshot        manage snapshots</span><br><span class="line">   tasks, t, task             manage tasks</span><br><span class="line">   install                    install a new package</span><br><span class="line">   oci                        OCI tools</span><br><span class="line">   shim                       interact with a shim directly</span><br><span class="line">   help, h                    Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">--debug                      enable debug output in logs</span><br><span class="line">--address value, -a value    address for containerd&#x27;s GRPC server (default: &quot;/run/containerd/containerd.sock&quot;) [$CONTAINERD_ADDRESS]</span><br><span class="line">--timeout value              total timeout for ctr commands (default: 0s)</span><br><span class="line">--connect-timeout value      timeout for connecting to containerd (default: 0s)</span><br><span class="line">--namespace value, -n value  namespace to use with commands (default: &quot;default&quot;) [$CONTAINERD_NAMESPACE]</span><br><span class="line">--help, -h                   show help</span><br><span class="line">--version, -v                print the version</span><br></pre></td></tr></table></figure><ol><li><p>查看版本</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr -v</span><br><span class="line">ctr --version</span><br></pre></td></tr></table></figure></li><li><p>指定空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr -n k8s.io image ls</span><br></pre></td></tr></table></figure></li></ol><h3 id="namespace-相关操作"><a href="#namespace-相关操作" class="headerlink" title="namespace 相关操作"></a>namespace 相关操作</h3><p>ctr 所有的命令都支持 -n 参数，用于指定命名空间，如果不指定命名空间，默认为default命名空间。命名空间的概念类似于 docker<br>的仓库，但是不同的是，docker 的仓库是一个集中的仓库，而 ctr 的命名空间是分布式的，每个命名空间都是一个独立的仓库。</p><p>命令 <code>ctr namespace</code> 用于管理命名空间，包括查看、创建和删除命名空间。可以简化为 <code>ctr ns</code>。</p><ol><li><p>查看命名空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr namespace ls</span><br></pre></td></tr></table></figure></li><li><p>创建命名空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr namespace create k8s.io</span><br></pre></td></tr></table></figure></li><li><p>删除命名空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr namespace rm k8s.io</span><br></pre></td></tr></table></figure></li></ol><h3 id="镜像相关操作"><a href="#镜像相关操作" class="headerlink" title="镜像相关操作"></a>镜像相关操作</h3><p>镜像相关命令如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># ctr image -h</span><br><span class="line">NAME:</span><br><span class="line">   ctr images - manage images</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr images command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line"></span><br><span class="line">   check       check existing images to ensure all content is available locally</span><br><span class="line">   export      export images</span><br><span class="line">   import      import images</span><br><span class="line">   list, ls    list images known to containerd</span><br><span class="line">   mount       mount an image to a target path</span><br><span class="line">   unmount     unmount the image from the target</span><br><span class="line">   pull        pull an image from a remote</span><br><span class="line">   push        push an image to a remote</span><br><span class="line">   remove, rm  remove one or more images by reference</span><br><span class="line">   tag         tag an image</span><br><span class="line">   label       set and clear labels for an image</span><br><span class="line">   convert     convert an image</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br></pre></td></tr></table></figure><ol><li><p>拉取推送镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 拉取镜像</span><br><span class="line"># docker默认是docker.io官网去找镜像，所以docker拉去镜像可以这样写：docker pull nginx:alpine，而containerd没有默认仓库，所以必须写完整的镜像名字才能拉去镜像</span><br><span class="line">ctr i pull docker.io/library/nginx:alpine</span><br><span class="line">   </span><br><span class="line"># 推送镜像到harbor</span><br><span class="line">#</span><br><span class="line"># --namespace=k8s.io 指定命名空间，不是必须，根据环境而定</span><br><span class="line"># --skip-verify 跳过认证</span><br><span class="line"># --user 指定harbor用户名及密码</span><br><span class="line">ctr --namespace=k8s.io images push harbor.mydomain.com/k8s/pause:1.25.1 --skip-verify --user admin:Harbor12345</span><br><span class="line"></span><br><span class="line"># 不想 -u user:password 可以在配置文件进行配置，也可以使用 nerdctl ，下面有介绍</span><br><span class="line">   </span><br><span class="line"># 拉取带认证的镜像</span><br><span class="line">ctr images pull --user admin:Harbor12345 --tlscacert=/etc/containerd/harbor.mydomain.com/ca.crt harbor.mydomain.com/k8s/pause:1.25.1</span><br></pre></td></tr></table></figure></li><li><p>检查镜像列表，确认镜像是否存在以及镜像的完整性，主要查看其中的 <code>STATUS</code>，<code>complete</code> 表示镜像是完整可用的状态。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr image check</span><br><span class="line">ctr i check</span><br></pre></td></tr></table></figure></li><li><p>导入&#x2F;导出镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr i export nginx.tar.gz docker.io/library/nginx:alpine</span><br><span class="line">ctr i import nginx.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>查看镜像列表</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctr i ls</span><br><span class="line">ctr i list</span><br><span class="line"># 只查看镜像名称</span><br><span class="line">ctr i ls -q</span><br></pre></td></tr></table></figure></li><li><p>挂载&#x2F;卸载镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ctr 支持将镜像挂载到指定目录，这样就可以直接访问镜像中的文件了，而不需要启动容器，可以确认镜像中的文件是否正确</span><br><span class="line">ctr i mount docker.io/library/nginx:alpine /tmp/nginx</span><br><span class="line">ctr i unmount /tmp/nginx</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr i rm nginx:alpine</span><br><span class="line">ctr i remove nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>打标签</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># crictl 没有 tag 命令，只能使用 nerdctl 和 ctr，必须指定命名空间，要不然 kubelet 无法使用。</span><br><span class="line">ctr -n k8s.io i tag my-nginx:v1 harbor.mydomain.com/my-nginx:v1</span><br></pre></td></tr></table></figure></li><li><p>镜像转换</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ctr 支持将镜像转换为 OCI 格式，这样就可以使用其他容器运行时运行镜像了，比如 runc</span><br><span class="line">ctr i convert --oci nginx:alpine nginx:alpine-oci</span><br><span class="line"># 也支持将 OCI 格式的镜像转换为 docker 格式</span><br><span class="line">ctr i convert nginx:alpine nginx:alpine-docker</span><br></pre></td></tr></table></figure></li><li><p>镜像构建</p><p>containerd 不提供开箱即用的镜像构建支持。一般使用更高级别的工具用来构建镜像，比如 docker。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile &lt;&lt;EOF</span><br><span class="line">FROM nginx:alpine</span><br><span class="line">RUN echo &#x27;Build Image From Containerd&#x27; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 可以使用docker构建镜像，然后导出到本地，再使用ctr导入到containerd</span><br><span class="line">docker build -t my-nginx:v1 .</span><br><span class="line">docker save -o my-nginx.tar my-nginx:v1</span><br><span class="line"> </span><br><span class="line">ctr images import my-nginx.tar</span><br><span class="line"></span><br><span class="line"># 或者使用nerdctl进行构建，与docker功能一样</span><br><span class="line"># 不加-n指定命名空间，crictl看不到，kubelet也不能使用它，默认在default命名空间下</span><br><span class="line">nerdctl -n k8s.io build -t nginx:nerctl -f ./Dockerfile .</span><br><span class="line"></span><br><span class="line"># 参数解释：(下一节会有 nerctl 介绍)</span><br><span class="line"># -t：指定镜像名称</span><br><span class="line"># . ：当前目录Dockerfile</span><br><span class="line"># -f：指定Dockerfile路径</span><br><span class="line">#  --no-cache：不缓存</span><br></pre></td></tr></table></figure></li></ol><h3 id="容器相关操作"><a href="#容器相关操作" class="headerlink" title="容器相关操作"></a>容器相关操作</h3><p>容器相关操作，包括创建、启动、停止、删除等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">:~# ctr container --help</span><br><span class="line">NAME:</span><br><span class="line">   ctr containers - manage containers</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr containers command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   create           create container</span><br><span class="line">   delete, del, rm  delete one or more existing containers</span><br><span class="line">   info             get info about a container</span><br><span class="line">   list, ls         list containers</span><br><span class="line">   label            set and clear labels for a container</span><br><span class="line">   checkpoint       checkpoint a container</span><br><span class="line">   restore          restore a container from checkpoint</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br></pre></td></tr></table></figure><ol><li><p>创建容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># container 只是创建了静态容器，此时容器还未启动运行。如果要启动容器，需要使用 task start 命令。</span><br><span class="line">ctr c create docker.io/library/nginx:alpine my-nginx</span><br></pre></td></tr></table></figure></li><li><p>删除容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctr c rm my-nginx</span><br><span class="line">ctr c delete my-nginx</span><br><span class="line">ctr c del my-nginx</span><br></pre></td></tr></table></figure></li><li><p>查看指定容器的信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr c info my-nginx</span><br></pre></td></tr></table></figure></li><li><p>查看所有容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr c ls</span><br><span class="line">ctr c list</span><br></pre></td></tr></table></figure></li><li><p>容器标签</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 容器标签可以用来标记容器，方便管理（只能通过 ctr c info 查看， ctr ls 不会显示）</span><br><span class="line">ctr c label my-nginx mylabel=nginx</span><br></pre></td></tr></table></figure></li><li><p>容器检查点</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 容器检查点可以用来备份容器，方便恢复 （没有测试）</span><br><span class="line">ctr c checkpoint my-nginx mycheckpoint</span><br><span class="line">ctr c restore my-nginx mycheckpoint</span><br></pre></td></tr></table></figure></li></ol><h3 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h3><p>管理任务，包括创建、启动、停止、删除等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># ctr task --help</span><br><span class="line">NAME:</span><br><span class="line">   ctr tasks - manage tasks</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr tasks command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   attach           attach to the IO of a running container</span><br><span class="line">   checkpoint       checkpoint a container</span><br><span class="line">   delete, rm       delete one or more tasks</span><br><span class="line">   exec             execute additional processes in an existing container</span><br><span class="line">   list, ls         list tasks</span><br><span class="line">   kill             signal a container (default: SIGTERM)</span><br><span class="line">   pause            pause an existing container</span><br><span class="line">   ps               list processes for container</span><br><span class="line">   resume           resume a paused container</span><br><span class="line">   start            start a container that has been created</span><br><span class="line">   metrics, metric  get a single data point of metrics for a task with the built-in Linux runtime</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br></pre></td></tr></table></figure><ol><li><p>启动已经创建的容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr t start my-nginx</span><br><span class="line">ctr t start -d my-nginx</span><br></pre></td></tr></table></figure></li><li><p>查看任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr t ls</span><br><span class="line">ctr t list</span><br></pre></td></tr></table></figure></li><li><p>查看任务中的进程</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意：这里的进程是指容器中进程在宿主机上的进程号。</span><br><span class="line">ctr t ps my-nginx</span><br></pre></td></tr></table></figure></li><li><p>任务中执行命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctr t exec my-nginx ls /</span><br><span class="line"># 进入容器内部终端，997，是随便指定的，只要不重复就行</span><br><span class="line">ctr t exec --exec-id 997 -t my-nginx /bin/sh</span><br></pre></td></tr></table></figure></li><li><p>暂停&#x2F;回复任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr t pause my-nginx</span><br><span class="line">ctr t resume my-nginx</span><br></pre></td></tr></table></figure></li><li><p>杀死&#x2F;删除任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 只是给任务发送了 SIGTERM 信号，任务还是存在的，状态为 stopped</span><br><span class="line">ctr t kill my-nginx</span><br><span class="line"># 删除任务，任务必须是 stopped 状态</span><br><span class="line">ctr t rm my-nginx</span><br><span class="line">ctr t delete my-nginx</span><br><span class="line">   </span><br><span class="line"># 给特定进程发送信号，这里是把刚刚创建的进程强制杀死</span><br><span class="line">ctr t kill --exec-id 999 -s SIGTERM my-nginx</span><br></pre></td></tr></table></figure><p>关于信号量相关的内容，可以参考这篇文章 <a href="https://realtiger.github.io/linux-signals/">Linux 信号量详解</a>。</p></li><li><p>获取任务的指标</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 我们可以通过metric命令获取容器关于cgroup相关的信息，包括CPU、内存、PID的限额和使用情况等。</span><br><span class="line">ctr t metric my-nginx</span><br></pre></td></tr></table></figure></li></ol><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>容器运行需要进行两步，第一步是创建容器，第二步是启动容器。</p><p>使用 <code>ctr run</code> 命令可以一步到位，创建并启动容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># ctr run --help</span><br><span class="line">NAME:</span><br><span class="line">   ctr run - run a container</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr run [command options] [flags] Image|RootFS ID [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --rm                                    remove the container after running</span><br><span class="line">   --null-io                               send all IO to /dev/null</span><br><span class="line">   --log-uri value                         log uri</span><br><span class="line">   --detach, -d                            detach from the task after it has started execution</span><br><span class="line">   --fifo-dir value                        directory used for storing IO FIFOs</span><br><span class="line">   --cgroup value                          cgroup path (To disable use of cgroup, set to &quot;&quot; explicitly)</span><br><span class="line">   --platform value                        run image for specific platform</span><br><span class="line">   --runc-binary value                     specify runc-compatible binary</span><br><span class="line">   --runc-root value                       specify runc-compatible root</span><br><span class="line">   --runc-systemd-cgroup                   start runc with systemd cgroup manager</span><br><span class="line">   --uidmap container-uid:host-uid:length  run inside a user namespace with the specified UID mapping range; specified with the format container-uid:host-uid:length</span><br><span class="line">   --gidmap container-gid:host-gid:length  run inside a user namespace with the specified GID mapping range; specified with the format container-gid:host-gid:length</span><br><span class="line">   --remap-labels                          provide the user namespace ID remapping to the snapshotter via label options; requires snapshotter support</span><br><span class="line">   --cpus value                            set the CFS cpu quota (default: 0)</span><br><span class="line">   --cni                                   enable cni networking for the container</span><br><span class="line">   --snapshotter value                     snapshotter name. Empty value stands for the default value. [$CONTAINERD_SNAPSHOTTER]</span><br><span class="line">   --config value, -c value                path to the runtime-specific spec config file</span><br><span class="line">   --cwd value                             specify the working directory of the process</span><br><span class="line">   --env value                             specify additional container environment variables (e.g. FOO=bar)</span><br><span class="line">   --env-file value                        specify additional container environment variables in a file(e.g. FOO=bar, one per line)</span><br><span class="line">   --label value                           specify additional labels (e.g. foo=bar)</span><br><span class="line">   --mount value                           specify additional container mount (e.g. type=bind,src=/tmp,dst=/host,options=rbind:ro)</span><br><span class="line">   --net-host                              enable host networking for the container</span><br><span class="line">   --privileged                            run privileged container</span><br><span class="line">   --read-only                             set the containers filesystem as readonly</span><br><span class="line">   --runtime value                         runtime name (default: &quot;io.containerd.runc.v2&quot;)</span><br><span class="line">   --runtime-config-path value             optional runtime config path</span><br><span class="line">   --tty, -t                               allocate a TTY for the container</span><br><span class="line">   --with-ns value                         specify existing Linux namespaces to join at container runtime (format &#x27;&lt;nstype&gt;:&lt;path&gt;&#x27;)</span><br><span class="line">   --pid-file value                        file path to write the task&#x27;s pid</span><br><span class="line">   --gpus value                            add gpus to the container (default: 0)</span><br><span class="line">   --allow-new-privs                       turn off OCI spec&#x27;s NoNewPrivileges feature flag</span><br><span class="line">   --memory-limit value                    memory limit (in bytes) for the container (default: 0)</span><br><span class="line">   --device value                          file path to a device to add to the container; or a path to a directory tree of devices to add to the container</span><br><span class="line">   --seccomp                               enable the default seccomp profile</span><br><span class="line">   --seccomp-profile value                 file path to custom seccomp profile. seccomp must be set to true, before using seccomp-profile</span><br><span class="line">   --apparmor-default-profile value        enable AppArmor with the default profile with the specified name, e.g. &quot;cri-containerd.apparmor.d&quot;</span><br><span class="line">   --apparmor-profile value                enable AppArmor with an existing custom profile</span><br><span class="line">   --rootfs                                use custom rootfs that is not managed by containerd snapshotter</span><br><span class="line">   --no-pivot                              disable use of pivot-root (linux only)</span><br><span class="line">   --cpu-quota value                       Limit CPU CFS quota (default: -1)</span><br><span class="line">   --cpu-period value                      Limit CPU CFS period (default: 0)</span><br></pre></td></tr></table></figure><p>创建并启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr run -d -t --net-host docker.io/library/nginx:alpine my-nginx</span><br></pre></td></tr></table></figure><h2 id="containerd-客户端-nerdctl"><a href="#containerd-客户端-nerdctl" class="headerlink" title="containerd 客户端 nerdctl"></a>containerd 客户端 nerdctl</h2><p>推荐使用 nerdctl，使用效果与 docker 命令的语法一致<br>二进制包的 github 下载链接：<a href="https://github.com/containerd/nerdctl/releases">https://github.com/containerd/nerdctl/releases</a></p><ul><li>精简 (nerdctl-{version}-linux-amd64.tar.gz): 只包含nerdctl</li><li>完整 (nerdctl-full-{version}-linux-amd64.tar.gz): 包含 containerd, runc, and CNI等依赖</li></ul><p>nerdctl 的目标并不是单纯地复制 docker 的功能，它还实现了很多 docker 不具备的功能，例如延迟拉取镜像（lazy-pulling）、镜像加密（imgcrypt）等。</p><p><img src="/post/docker/nerdctl.png" alt="nerdctl"></p><h3 id="安装-nerdctl"><a href="#安装-nerdctl" class="headerlink" title="安装 nerdctl"></a>安装 nerdctl</h3><p>精简版只包含nerdctl，完整版包含nerdctl和CNI插件等依赖，k8s的网络插件会在&#x2F;opt&#x2F;cni&#x2F;bin&#x2F;下会生成cni插件目录。这里选择完整版进行安装，因为启动容器的时候配置网络需要cni网络插件的支持。</p><ol><li><p>精简版 nerdctl 安装</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/containerd/nerdctl/releases/download/v0.22.2/nerdctl-0.22.2-linux-amd64.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar -xf nerdctl-0.22.2-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 查看解压后的文件，可以看见除了nerdctl还有containerd-rootless-setuptool.sh、containerd-rootless.sh，另外两个文件是用来在非root用户下使用nerdctl的</span><br><span class="line">ls -l</span><br><span class="line"></span><br><span class="line">total 37624</span><br><span class="line">-rwxr-xr-x 1 root root    21562 Aug  1  2022 containerd-rootless-setuptool.sh</span><br><span class="line">-rwxr-xr-x 1 root root     7032 Aug  1  2022 containerd-rootless.sh</span><br><span class="line">-rwxr-xr-x 1 root root 27807744 Aug  1  2022 nerdctl</span><br><span class="line">-rw-r--r-- 1 root root 10685899 Aug  1  2022 nerdctl-0.22.2-linux-amd64.tar.gz</span><br><span class="line">   </span><br><span class="line"># 将nerdctl复制到/usr/local/bin/目录下，这样就可以直接使用nerdctl命令了。具体目录根据机器上的PATH环境变量来定。</span><br><span class="line">cp nerdctl /usr/local/bin/</span><br></pre></td></tr></table></figure></li><li><p>完整版 nerdctl 安装</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/containerd/nerdctl/releases/download/v0.22.2/nerdctl-full-0.22.2-linux-amd64.tar.gz</span><br><span class="line"># 解压后还有如下4个目录 </span><br><span class="line"># 1. bin（二进制模式，包括 nerdctl buildkitd runc tini等）</span><br><span class="line"># 2. lib（systemctl 的 service 文件）</span><br><span class="line"># 3. libexec（cni组件）</span><br><span class="line"># 4. share（说明文档）</span><br><span class="line">tar -xf nerdctl-full-0.22.2-linux-amd64.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line"># 将service文件复制到/etc/systemd/system/目录下</span><br><span class="line">cp /usr/local/lib/systemd/system/*.service /etc/systemd/system/</span><br><span class="line"></span><br><span class="line"># 启动服务buildkit</span><br><span class="line">systemctl enable buildkit containerd --now</span><br><span class="line">systemctl status buildkit containerd</span><br></pre></td></tr></table></figure></li><li><p>安装 buildkit 支持构建镜像</p><p>buildkit GitHub地址： <a href="https://github.com/moby/buildkit">https://github.com/moby/buildkit</a></p><p>使用精简版 nerdctl 无法直接通过 containerd 构建镜像，需要与 buildkit 组全使用以实现镜像构建。当然你也可以安装上面的完整<br>nerdctl，完整版可以直接使用 nerdctl build 命令构建镜像，是因为完整版已经有现成的 buildkit.service 服务了。</p><p>buildkit项目是Docker公司开源出来的一个构建工具包，支持OCI标准的镜像构建。它主要包含以下部分:</p><ul><li>服务端buildkitd，当前支持runc和containerd作为worker，默认是runc；</li><li>客户端buildctl，负责解析Dockerfile，并向服务端buildkitd发出构建请求。</li><li>buildkit是典型的C&#x2F;S架构，client和server可以不在一台服务器上。而nerdctl在构建镜像方面也可以作为buildkitd的客户端。</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 下载地址 https://github.com/moby/buildkit/releases</span><br><span class="line">wget https://github.com/moby/buildkit/releases/download/v0.10.4/buildkit-v0.10.4.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压之后只有一个bin目录，里面有buildkit所需要的二进制文件</span><br><span class="line"># 以下的命令会将buildkit的二进制文件合并到/usr/local/bin/目录下</span><br><span class="line">tar -xf buildkit-v0.10.4.linux-amd64.tar.gz  -C /usr/local/</span><br><span class="line"></span><br><span class="line"># buildkit需要配置两个文件:</span><br><span class="line"># 1. /usr/lib/systemd/system/buildkit.socket</span><br><span class="line"># 2. /usr/lib/systemd/system/buildkit.service</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/systemd/system/buildkit.socket &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=BuildKit</span><br><span class="line">Documentation=https://github.com/moby/buildkit</span><br><span class="line">[Socket]</span><br><span class="line">ListenStream=%t/buildkit/buildkitd.sock</span><br><span class="line">SocketMode=0660</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sockets.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/systemd/system/buildkit.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=BuildKit</span><br><span class="line">Requires=buildkit.socket</span><br><span class="line">After=buildkit.socket</span><br><span class="line">Documentation=https://github.com/moby/buildkit</span><br><span class="line">[Service]</span><br><span class="line"># Replace runc builds with containerd builds  </span><br><span class="line">ExecStart=/usr/local/bin/buildkitd --addr fd://</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 启动buildkit</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable buildkit --now</span><br></pre></td></tr></table></figure></li><li><p>设置nerdctl自动补全</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编辑文件</span><br><span class="line">vim /etc/profile</span><br><span class="line">source &lt;(nerdctl completion bash)</span><br><span class="line"># 让其生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><h3 id="namespace-相关操作-1"><a href="#namespace-相关操作-1" class="headerlink" title="namespace 相关操作"></a>namespace 相关操作</h3><ol><li><p>创建 namespace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl namespace create mynamespace</span><br></pre></td></tr></table></figure></li><li><p>列出 namespace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl namespace ls</span><br></pre></td></tr></table></figure></li><li><p>删除 namespace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl namespace rm mynamespace</span><br></pre></td></tr></table></figure></li></ol><h3 id="镜像相关操作-1"><a href="#镜像相关操作-1" class="headerlink" title="镜像相关操作"></a>镜像相关操作</h3><ol><li><p>拉取镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl pull nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>列出镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl image ls</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl image rm nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>拉取推送镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 拉取镜像</span><br><span class="line">nerdctl pull nginx:alpine</span><br><span class="line"># 重命名镜像</span><br><span class="line">nerdctl image tag nginx:alpine harbor.mydomain.com/library/nginx:alpine</span><br><span class="line"># 推送镜像</span><br><span class="line">nerdctl push harbor.mydomain.com/library/nginx:alpine</span><br></pre></td></tr></table></figure><p>更详细的镜像拉取操作请参考下面的内容：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># http方式，配置如下：</span><br><span class="line">mkdir -p /etc/containerd/harbor.mydomain.com</span><br><span class="line">cat &gt; /etc/containerd/certs.d/harbor.mydomain.com/hosts.toml &lt;&lt;EOF</span><br><span class="line">server = &quot;https://docker.io&quot;</span><br><span class="line"></span><br><span class="line">[host.&quot;http://myharbor-minio.com&quot;]</span><br><span class="line">capabilities = [&quot;pull&quot;, &quot;resolve&quot;,&quot;push&quot;]</span><br><span class="line"># skip_verify = true</span><br><span class="line"># ca = &quot;ca.crt&quot; #相对路径</span><br><span class="line"># ca = &quot;/opt/auth/ca.crt&quot; #绝对路径</span><br><span class="line"># ca = [&quot;/opt/auth/ca.crt&quot;]</span><br><span class="line"># ca = [&quot;ca.crt&quot;]</span><br><span class="line"># client = [[&quot;/opt/auth/nginx.cclinux.cn.crt&quot;, &quot;/opt/auth/nginx.cclinux.cn.key&quot;]]</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"># https方式，配置如下：</span><br><span class="line">mkdir -p /etc/containerd/certs.d/harbor.secure.mydomain.com:443</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/containerd/certs.d/harbor.secure.mydomain.com\:443/hosts.toml &lt;&lt;EOF</span><br><span class="line">server = &quot;https://docker.io&quot;</span><br><span class="line"></span><br><span class="line">[host.&quot;https://harbor.secure.mydomain.com:443&quot;]</span><br><span class="line">capabilities = [&quot;pull&quot;, &quot;resolve&quot;,&quot;push&quot;]</span><br><span class="line">skip_verify = true</span><br><span class="line"># ca = &quot;ca.crt&quot; #相对路径</span><br><span class="line"># ca = &quot;/opt/auth/ca.crt&quot; #绝对路径</span><br><span class="line"># ca = [&quot;/opt/auth/ca.crt&quot;]</span><br><span class="line">ca = [&quot;/etc/containerd/harbor.secure.mydomain.com/ca.crt&quot;]</span><br><span class="line"># client = [[&quot;/opt/auth/nginx.cclinux.cn.crt&quot;, &quot;/opt/auth/nginx.cclinux.cn.key&quot;]]</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"># 可以通过 nerdctl 登录</span><br><span class="line">echo Harbor12345 | nerdctl login --username &quot;admin&quot; --password-stdin harbor.secure.mydomain.com:443</span><br><span class="line">   </span><br><span class="line"># 登出命令</span><br><span class="line"># nerdctl logout harbor.secure.mydomain.com:443</span><br><span class="line">   </span><br><span class="line"># 推送到私有仓库</span><br><span class="line">nerdctl --insecure-registry --namespace=k8s.io push harbor.secure.mydomain.com:443/k8s/pause:1.25.1</span><br></pre></td></tr></table></figure></li><li><p>镜像构建</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 从Dockerfile构建镜像</span><br><span class="line">nerdctl build -t nginx:my-alpine -f Dockerfile .</span><br><span class="line"># 从Dockerfile构建镜像并推送到私有仓库</span><br><span class="line">nerdctl build -t harbor.secure.mydomain.com:443/k8s/nginx:alpine -f Dockerfile .</span><br></pre></td></tr></table></figure></li></ol><h3 id="容器相关操作-1"><a href="#容器相关操作-1" class="headerlink" title="容器相关操作"></a>容器相关操作</h3><ol><li><p>创建容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl run -d --name mynginx -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>列出容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nerdctl ps -a</span><br><span class="line">nerdctl container ls -a</span><br></pre></td></tr></table></figure></li><li><p>删除容器(停止容器后才能删除)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nerdctl stop mynginx</span><br><span class="line">nerdctl rm mynginx</span><br><span class="line">   </span><br><span class="line">nerdctl container stop mynginx</span><br><span class="line">nerdctl container rm mynginx</span><br></pre></td></tr></table></figure></li><li><p>进入容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nerdctl exec -it mynginx sh</span><br><span class="line"></span><br><span class="line">nerdcrl container exec -it mynginx sh</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nerdctl logs mynginx</span><br><span class="line">   </span><br><span class="line">nerdctl container logs mynginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器详细信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nerdctl inspect mynginx</span><br><span class="line">   </span><br><span class="line">nerdctl container inspect mynginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器内进程</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl top mynginx</span><br></pre></td></tr></table></figure></li></ol><h2 id="k8s-操作-containerd-的客户端-crictl"><a href="#k8s-操作-containerd-的客户端-crictl" class="headerlink" title="k8s 操作 containerd 的客户端 crictl"></a>k8s 操作 containerd 的客户端 crictl</h2><h3 id="crictl-命令"><a href="#crictl-命令" class="headerlink" title="crictl 命令"></a>crictl 命令</h3><p>这里我使用的是 crictl v1.26.0 版本，命令里面有些是与 pod 相关的，暂时略过，这里只介绍与 container 相关的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">crictl -h</span><br><span class="line">NAME:</span><br><span class="line">   crictl - client for CRI</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   crictl [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   v1.26.0</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   attach              Attach to a running container</span><br><span class="line">   create              Create a new container</span><br><span class="line">   exec                Run a command in a running container</span><br><span class="line">   version             Display runtime version information</span><br><span class="line">   images, image, img  List images</span><br><span class="line">   inspect             Display the status of one or more containers</span><br><span class="line">   inspecti            Return the status of one or more images</span><br><span class="line">   imagefsinfo         Return image filesystem info</span><br><span class="line">   inspectp            Display the status of one or more pods</span><br><span class="line">   logs                Fetch the logs of a container</span><br><span class="line">   port-forward        Forward local port to a pod</span><br><span class="line">   ps                  List containers</span><br><span class="line">   pull                Pull an image from a registry</span><br><span class="line">   run                 Run a new container inside a sandbox</span><br><span class="line">   runp                Run a new pod</span><br><span class="line">   rm                  Remove one or more containers</span><br><span class="line">   rmi                 Remove one or more images</span><br><span class="line">   rmp                 Remove one or more pods</span><br><span class="line">   pods                List pods</span><br><span class="line">   start               Start one or more created containers</span><br><span class="line">   info                Display information of the container runtime</span><br><span class="line">   stop                Stop one or more running containers</span><br><span class="line">   stopp               Stop one or more running pods</span><br><span class="line">   update              Update one or more running containers</span><br><span class="line">   config              Get and set crictl client configuration options</span><br><span class="line">   stats               List container(s) resource usage statistics</span><br><span class="line">   statsp              List pod resource usage statistics</span><br><span class="line">   completion          Output shell completion code</span><br><span class="line">   checkpoint          Checkpoint one or more running containers</span><br><span class="line">   help, h             Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --config value, -c value            Location of the client config file. If not specified and the default does not exist, the program&#x27;s directory is searched as well (default: &quot;/etc/crictl.yaml&quot;) [$CRI_CONFIG_FILE]</span><br><span class="line">   --debug, -D                         Enable debug mode (default: false)</span><br><span class="line">   --image-endpoint value, -i value    Endpoint of CRI image manager service (default: uses &#x27;runtime-endpoint&#x27; setting) [$IMAGE_SERVICE_ENDPOINT]</span><br><span class="line">   --runtime-endpoint value, -r value  Endpoint of CRI container runtime service (default: uses in order the first successful one of [unix:///var/run/dockershim.sock unix:///run/containerd/containerd.sock unix:///run/crio/crio.sock unix:///var/run/cri-dockerd.sock]). Default is now deprecated and the endpoint should be set instead. [$CONTAINER_RUNTIME_ENDPOINT]</span><br><span class="line">   --timeout value, -t value           Timeout of connecting to the server in seconds (e.g. 2s, 20s.). 0 or less is set to default (default: 2s)</span><br><span class="line">   --help, -h                          show help (default: false)</span><br><span class="line">   --version, -v                       print the version (default: false)</span><br></pre></td></tr></table></figure><h3 id="命令示例-1"><a href="#命令示例-1" class="headerlink" title="命令示例"></a>命令示例</h3><p>使用 crictl 命令之前，需要先配置 <code>/etc/crictl.yaml</code> 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/crictl.yaml</span><br><span class="line"></span><br><span class="line">runtime-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">timeout: 10</span><br><span class="line">debug: false</span><br><span class="line"></span><br><span class="line"># 也可以通过命令进行设置</span><br><span class="line">crictl config runtime-endpoint unix:///run/containerd/containerd.sock</span><br><span class="line">crictl config image-endpoint unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>命令行示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># crictl 没有 -n 参数，操作都在 k8s.io 命名空间下。</span><br><span class="line">crictl image ls</span><br><span class="line">crictl images</span><br><span class="line"># crictl image list = ctr -n k8s.io image list</span><br><span class="line"># crictl image ls = ctr -n k8s.io image ls</span><br><span class="line"># crictl images = ctr -n k8s.io image list</span><br><span class="line"># crictl images = ctr -n k8s.io image ls</span><br></pre></td></tr></table></figure><h3 id="image-相关操作"><a href="#image-相关操作" class="headerlink" title="image 相关操作"></a>image 相关操作</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的 image</span><br><span class="line">crictl image list</span><br><span class="line"># 拉取 image</span><br><span class="line"># 注意：回车之后屏幕会卡住，不要着急，正常现象。crictl 没有进度条，拉取镜像的过程中，会一直卡在这里，直到拉取完成，只能耐心等待完成。</span><br><span class="line">crictl pull nginx:1.25</span><br><span class="line"># 删除 image</span><br><span class="line">crictl rmi nginx:1.25</span><br></pre></td></tr></table></figure></code></pre><h3 id="container-相关操作"><a href="#container-相关操作" class="headerlink" title="container 相关操作"></a>container 相关操作</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的 container</span><br><span class="line">crictl ps -a</span><br></pre></td></tr></table></figure>crictl 运行一个容器比较复杂，需要书写两个 json 文件比如以下两个文件，一个是 pod-config.json，一个是 container-config.json，其中 pod-config.json 是 pod 的配置，container-config.json 是 container 的配置。pod 的概念是 k8s 中有的，这里先知道即可。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cat pod-config.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;metadata&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;nginx-sandbox&quot;,</span><br><span class="line">        &quot;namespace&quot;: &quot;default&quot;,</span><br><span class="line">        &quot;attempt&quot;: 1,</span><br><span class="line">        &quot;uid&quot;: &quot;hdishd83djaidwnduwk28bcsb&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;log_directory&quot;: &quot;/tmp&quot;,</span><br><span class="line">    &quot;linux&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat container-config.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;metadata&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;busybox&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;image&quot;:&#123;</span><br><span class="line">        &quot;image&quot;: &quot;busybox&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;command&quot;: [</span><br><span class="line">        &quot;top&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;log_path&quot;:&quot;busybox.0.log&quot;,</span><br><span class="line">    &quot;linux&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 根据以上两个文件创建 container， 注意如果 k8s 没有安装好可能会报错，因为 crictl 是 k8s 的客户端，需要 k8s 的环境。</span><br><span class="line">crictl run container-config.json pod-config.json</span><br><span class="line"># 删除 container</span><br><span class="line">crictl rm mynginx</span><br><span class="line"># 进入 container，注意这里的 container id 是 crictl ps -a 查看到的</span><br><span class="line">crictl exec -it &lt;container id&gt; sh</span><br><span class="line"># 查看 container 日志</span><br><span class="line">crictl logs &lt;container id&gt;</span><br><span class="line"># 查看 container 详细信息</span><br><span class="line">crictl inspect &lt;container id&gt;</span><br></pre></td></tr></table></figure></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 k8s 后，对于容器的操作，基本上都是通过 kubelet 完成，这个之后会使用到。</li><li>镜像的构建推荐使用 <code>docker build</code> 等方式，推送到镜像仓库后，再通过 containerd 进行使用。</li><li>查看容器中的日志，使用 <code>crictl logs</code> 命令。</li><li>常规的对于 containerd 的操作，推荐使用 <code>nerdctl</code> 命令，使用效果与 docker 命令的语法一致。</li></ul><h1 id="docker-总结"><a href="#docker-总结" class="headerlink" title="docker 总结"></a>docker 总结</h1><h2 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h2><ol><li><p>清理主机上所有退出的容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">rm</span>  $(docker ps -aq)</span><br></pre></td></tr></table></figure></li><li><p>调试或者排查容器启动错误</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 若有时遇到容器启动失败的情况，可以先使用相同的镜像启动一个临时容器，先进入容器</span></span><br><span class="line">$ docker run --<span class="built_in">rm</span> -ti &lt;image_id&gt; sh</span><br><span class="line"><span class="comment">## 进入容器后，手动执行该容器对应的ENTRYPOINT或者CMD命令，这样即使出错，容器也不会退出，因为bash作为1号进程，我们只要不退出容器，该容器就不会自动退出</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="docker总结"><a href="#docker总结" class="headerlink" title="docker总结"></a>docker总结</h2><p><img src="/post/docker/Docker.png" alt="Docker"></p><ol><li>为了解决软件交付过程中的环境依赖，同时提供一种更加轻量的虚拟化技术，Docker出现了。</li><li>2013年诞生，15年开始迅速发展，从17.03月开始，使用时间日期管理版本，稳定版以每季度为准。</li><li>Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理。</li><li>使用yum部署docker，启动后通过操作docker这个命令行，自动调用docker daemon完成容器相关操作。</li><li>常用操作，围绕<code>镜像|容器|仓库</code>三大核心要素<ul><li>systemctl start|stop|restart docker</li><li>docker build | pull -&gt; docker tag -&gt; docker push</li><li>docker run –name my-demo -d -p 8080:80 -v &#x2F;opt&#x2F;data:&#x2F;data demo:v20200327 ping xx.com</li><li>docker cp &#x2F;path&#x2F;a.txt mycontainer:&#x2F;opt</li><li>docker exec -ti mycontainer &#x2F;bin&#x2F;sh</li><li>docker logs -f –tail&#x3D;100 mycontainer</li></ul></li><li>通过dockerfile构建业务镜像，先使用基础镜像，然后通过一系列的指令把我们的业务应用所需要的运行环境和依赖都打包到镜像中，然后通过CMD或者ENTRYPOINT指令把镜像启动时的入口制定好，完成封装即可。有点类似于，先找来一个集装箱模板(<br>基础镜像)，然后把项目依赖的服务都扔到集装箱中，然后设置好服务的启动入口，关闭箱门，即完成了业务镜像的制作。</li><li>容器的实现依赖于内核模块提供的namespace和control-group的功能，通过namespace创建一块虚拟空间，空间内实现了各类资源(<br>进程、网络、文件系统)的隔离，提供control-group实现了对隔离的空间的资源使用的限制。</li><li>docker镜像使用分层的方式进行存储，根据主机的存储驱动的不同，实现方式会不同，kernel在3.10.0-514以上自动支持overlay2存储驱动，也是目前Docker推荐的方式。</li><li>得益于分层存储的模式，多个容器可以通过copy-on-write的策略，在镜像的最上层加一个可写层，同时利用存储驱动的UnionFS的能力，实现一个镜像快速启动多个容器的场景。</li><li>docker的网络模式分为4种，最常用的为bridge和host模式。bridge模式通过docker0网桥，启动容器的时候通过创建一对虚拟网卡，将容器连接在桥上，同时维护了虚拟网卡与网桥端口的关系，实现容器间的通信。容器与宿主机之间的通信通过iptables端口映射的方式，docker利用iptables的PREROUTING和POSTROUTING的nat功能，实现了SNAT与DNAT，使得容器内部的服务被完美的保护起来。</li><li>本章重点内容是docker的核心要素及基础的操作，实现原理以及docker的网络模式为选修包，目的为了帮助有docker基础及经验的同学更好的进一步理解docker。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> containerd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络</title>
      <link href="/docker-network/"/>
      <url>/docker-network/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间，</p><ul><li>多个容器之间是如何实现通信的呢？</li><li>容器和宿主机之间又是如何实现的通信呢？</li><li>使用-p参数是怎么实现的端口映射?</li></ul><p>带着这些问题，我们来学习一下docker的网络模型，最后我会通过抓包的方式，给大家演示一下数据包在容器和宿主机之间的转换过程。</p><span id="more"></span><h1 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h1><p>我们在使用 docker run 创建 Docker 容器时，可以用 –net 选项指定容器的网络模式，Docker 有以下4种网络模式：</p><ul><li>bridge模式，使用 –net&#x3D;bridge 指定，默认设置</li><li>host模式，使用 –net&#x3D;host 指定，容器内部网络空间共享宿主机的空间，效果类似直接在宿主机上启动一个进程，端口信息和宿主机共用</li><li>container模式，使用 –net&#x3D;container:NAME_or_ID 指定，指定容器与特定容器共享网络命名空间</li><li>none模式，使用 –net&#x3D;none 指定，网络模式为空，即仅保留网络命名空间，但是不做任何网络相关的配置(网卡、IP、路由等)</li></ul><h2 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h2><p>那我们之前在演示创建docker容器的时候其实是没有指定的网络模式的，如果不指定的话默认就会使用bridge模式，bridge本意是桥的意思，其实就是网桥模式。</p><p>那我们怎么理解网桥，如果需要做类比的话，我们可以把网桥看成一个二层的交换机设备。网桥模式示意图：</p><p><img src="/post/docker/docker-network-bridge.jpeg" alt="docker 网桥示意图"></p><p>Linux 中，能够起到<strong>虚拟交换机作用</strong>的网络设备，是网桥（Bridge）。它是一个工作在<strong>数据链路层</strong>（Data Link）的设备，主要功能是<strong>根据 MAC 地址将数据包转发到网桥的不同端口上</strong>。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y bridge-utils</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge <span class="built_in">id</span>               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242b5fbe57b       no              veth3a496ed</span><br></pre></td></tr></table></figure><p>有了网桥之后，那我们看下docker在启动一个容器的时候做了哪些事情才能实现容器间的互联互通</p><p>Docker 创建一个容器的时候，会执行如下操作：</p><ul><li>创建一对虚拟接口&#x2F;网卡，也就是veth pair网卡对；</li><li>veth pair的一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxxx；</li><li>veth pair的另一端放到新启动的容器内部，并修改名字作为 eth0，这个网卡&#x2F;接口只在容器的命名空间可见；</li><li>从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0</li><li>配置容器的默认路由</li></ul><p>那整个过程其实是docker自动帮我们完成的，清理掉所有容器，来验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 清掉所有容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f `docker ps -aq`</span><br><span class="line">$ docker ps</span><br><span class="line">$ brctl show <span class="comment"># 查看网桥中的接口，目前没有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建测试容器test1</span></span><br><span class="line">$ docker run -d --name test1 nginx:alpine</span><br><span class="line">$ brctl show <span class="comment"># 查看网桥中的接口，已经把test1的veth端接入到网桥中</span></span><br><span class="line">$ ip a |grep veth <span class="comment"># 已在宿主机中可以查看到</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test1 sh </span><br><span class="line">/ <span class="comment"># ifconfig  # 查看容器的eth0网卡及分配的容器ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再来启动一个测试容器，测试容器间的通信</span></span><br><span class="line">$ docker run -d --name test2 nginx:alpine</span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test2 sh</span><br><span class="line">/ <span class="comment"># sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apk/repositories</span></span><br><span class="line">/ <span class="comment"># apk add curl</span></span><br><span class="line">/ <span class="comment"># curl 172.17.0.8:80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为啥可以通信？</span></span><br><span class="line">/ <span class="comment"># route -n  # </span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. eth0 网卡是这个容器里的默认路由设备；所有对 172.17.0.0/16 网段的请求，也会被交给 eth0 来处理（第二条 172.17.0.0 路由规则），这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：凡是匹配到这条规则的 IP 包，应该经过本机的 eth0 网卡，通过二层网络(数据链路层)直接发往目的主机。</span></span><br><span class="line"><span class="comment"># 2. 而要通过二层网络到达 test1 容器，就需要有 172.17.0.8 这个 IP 地址对应的 MAC 地址。所以test2容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过 IP 地址查找对应的 MAC 地址。</span></span><br><span class="line"><span class="comment"># 3. 这个 eth0 网卡，是一个 Veth Pair，它的一端在这个 test2 容器的 Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上。网桥设备的一个特点是插在桥上的网卡都会被当成桥上的一个端口来处理，而端口的唯一作用就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥设备处理。</span></span><br><span class="line"><span class="comment"># 4. 因此ARP的广播请求也会由docker0来负责转发，这样网桥就维护了一份端口与mac的信息表，因此针对test2的eth0拿到mac地址后发出的各类请求，同样走到docker0网桥中由网桥负责转发到对应的容器中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网桥会维护一份mac映射表，我们可以在宿主机大概通过命令来看一下</span></span><br><span class="line">$ brctl showmacs docker0</span><br><span class="line"><span class="comment">## 这些mac地址是主机端的veth网卡对应的mac，可以查看一下</span></span><br><span class="line">$ ip a</span><br></pre></td></tr></table></figure><p><img src="/post/docker/bridge-network.png" alt="网桥网络"></p><p>我们如何知道网桥上的这些虚拟网卡与容器端是如何对应？</p><p>通过ifindex，网卡索引号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看test1容器的网卡索引</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test1 <span class="built_in">cat</span> /sys/class/net/eth0/ifindex</span><br><span class="line"></span><br><span class="line"><span class="comment">## 主机中找到虚拟网卡后面这个@ifxx的值，如果是同一个值，说明这个虚拟网卡和这个容器的eth0网卡是配对的。</span></span><br><span class="line">$ ip a |grep @<span class="keyword">if</span></span><br></pre></td></tr></table></figure><p>整理脚本，快速查看对应：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> container <span class="keyword">in</span> $(docker ps -q); <span class="keyword">do</span></span><br><span class="line">    iflink=`docker <span class="built_in">exec</span> -it <span class="variable">$container</span> sh -c <span class="string">&#x27;cat /sys/class/net/eth0/iflink&#x27;</span>`</span><br><span class="line">    iflink=`<span class="built_in">echo</span> <span class="variable">$iflink</span>|<span class="built_in">tr</span> -d <span class="string">&#x27;\r&#x27;</span>`</span><br><span class="line">    veth=`grep -l <span class="variable">$iflink</span> /sys/class/net/veth*/ifindex`</span><br><span class="line">    veth=`<span class="built_in">echo</span> <span class="variable">$veth</span>|sed -e <span class="string">&#x27;s;^.*net/\(.*\)/ifindex$;\1;&#x27;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$container</span>:<span class="variable">$veth</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上面我们讲解了容器之间的通信，那么容器与宿主机的通信是如何做的？</p><p>添加端口映射：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动容器的时候通过-p参数添加宿主机端口与容器内部服务端口的映射</span></span><br><span class="line">$ docker run --name <span class="built_in">test</span> -d -p 8088:80 nginx:alpine</span><br><span class="line">$ curl localhost:8088</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>端口映射如何实现的？先来回顾iptables链表图</p><p><img src="/post/docker/iptables.png" alt="iptables"></p><blockquote><p>iptables运维 <a href="https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables">https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables</a></p></blockquote><p>访问本机的8088端口，数据包会从流入方向进入本机，因此涉及到PREROUTING和INPUT链，我们是通过做宿主机与容器之间加的端口映射，所以肯定会涉及到端口转换，那哪个表是负责存储端口转换信息的呢，就是nat表，负责维护网络地址转换信息的。因此我们来查看一下PREROUTING链的nat表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL PREROUTING</span><br><span class="line">Chain PREROUTING (policy ACCEPT 159 packets, 20790 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    3   156 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><p>规则利用了iptables的addrtype拓展，匹配网络类型为本地的包，如何确定哪些是匹配本地，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show table <span class="built_in">local</span> <span class="built_in">type</span> <span class="built_in">local</span></span><br><span class="line">127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1</span><br><span class="line">127.0.0.1 dev lo proto kernel scope host src 127.0.0.1</span><br><span class="line">172.17.0.1 dev docker0 proto kernel scope host src 172.17.0.1</span><br><span class="line">172.21.51.143 dev eth0 proto kernel scope host src 172.21.51.143</span><br></pre></td></tr></table></figure><p>也就是说目标地址类型匹配到这些的，会转发到我们的TARGET中，TARGET是动作，意味着对符合要求的数据包执行什么样的操作，最常见的为ACCEPT或者DROP，此处的TARGET为DOCKER，很明显DOCKER不是标准的动作，那DOCKER是什么呢？我们通常会定义自定义的链，这样把某类对应的规则放在自定义链中，然后把自定义的链绑定到标准的链路中，因此此处DOCKER 是自定义的链。那我们现在就来看一下DOCKER这个自定义链上的规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL DOCKER</span><br><span class="line">Chain DOCKER (2 references)                                                                                                </span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination                                            </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0                                             </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8088 to:172.17.0.2:80 </span><br></pre></td></tr></table></figure><p>此条规则就是对主机收到的目的端口为8088的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，172.17.0.2地址是不是就是我们上面创建的Docker容器的ip地址，流量走到网桥上了，后面就走网桥的转发就ok了。<br>所以，外界只需访问172.21.51.143:8088就可以访问到容器中的服务了。</p><p><img src="/post/docker/docker-network-request.drawio.png" alt="docker网络访问"></p><p>数据包在出口方向走POSTROUTING链，我们查看一下规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL POSTROUTING</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 1099 packets, 67268 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">   86  5438 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       172.17.0.4           172.17.0.4           tcp dpt:80</span><br></pre></td></tr></table></figure><p>大家注意MASQUERADE这个动作是什么意思，其实是一种更灵活的SNAT，把源地址转换成主机的出口ip地址，那解释一下这条规则的意思:</p><p>这条规则会将源地址为172.17.0.0&#x2F;16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。大概的过程就是ACK的包在容器里面发出来，会路由到网桥docker0，网桥根据宿主机的路由规则会转给宿主机网卡eth0，这时候包就从docker0网卡转到eth0网卡了，并从eth0网卡发出去，这时候这条规则就会生效了，把源地址换成了eth0的ip地址。</p><blockquote><p>注意一下，刚才这个过程涉及到了网卡间包的传递，那一定要打开主机的ip_forward转发服务，要不然包转不了，服务肯定访问不到。</p></blockquote><h3 id="抓包演示"><a href="#抓包演示" class="headerlink" title="抓包演示"></a>抓包演示</h3><p>我们先想一下，我们要抓哪个网卡的包</p><ul><li><p>首先访问宿主机的8088端口，我们抓一下宿主机的eth0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i eth0 port 8088 -w host.cap</span><br></pre></td></tr></table></figure></li><li><p>然后最终包会流入容器内，那我们抓一下容器内的eth0网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器内安装一下tcpdump</span></span><br><span class="line">$ sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27;</span> /etc/apk/repositories</span><br><span class="line">$ apk add tcpdump</span><br><span class="line">$ tcpdump -i eth0 port 80 -w container.cap</span><br></pre></td></tr></table></figure></li></ul><p>到另一台机器访问一下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl 172.21.51.143:8088/</span><br></pre></td></tr></table></figure><p>停止抓包，拷贝容器内的包到宿主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">cp</span> <span class="built_in">test</span>:/root/container.cap /root/</span><br></pre></td></tr></table></figure><p>把抓到的内容拷贝到本地，使用wireshark进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp root@172.21.51.143:/root/*.<span class="built_in">cap</span> /d/packages</span><br></pre></td></tr></table></figure><p>（wireshark合并包进行分析）</p><p><img src="/post/docker/docker-dnat.jpeg" alt="docker dnat"></p><p><img src="/post/docker/docker-snat.jpeg" alt="docker snat"></p><p>进到容器内的包做DNAT，出去的包做SNAT，这样对外面来讲，根本就不知道机器内部是谁提供服务，其实这就和一个内网多个机器公用一个外网IP地址上网的效果是一样的，那这也属于NAT功能的一个常见的应用场景。</p><h2 id="Host模式"><a href="#Host模式" class="headerlink" title="Host模式"></a>Host模式</h2><p>容器内部不会创建网络空间，共享宿主机的网络空间。比如直接通过host模式创建mysql容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --net host -d --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure><p>容器启动后，会默认监听3306端口，由于网络模式是host，因为可以直接通过宿主机的3306端口进行访问服务，效果等同于在宿主机中直接启动mysqld的进程。</p><h2 id="Conatiner模式"><a href="#Conatiner模式" class="headerlink" title="Conatiner模式"></a>Conatiner模式</h2><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p><img src="/post/docker/docker-network-container.jpeg" alt="docker container网络"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动测试容器，共享mysql的网络空间</span></span><br><span class="line">$ docker run -ti --<span class="built_in">rm</span> --net=container:mysql busybox sh</span><br><span class="line">/ <span class="comment"># ip a</span></span><br><span class="line">/ <span class="comment"># netstat -tlp|grep 3306</span></span><br><span class="line">/ <span class="comment"># telnet localhost 3306</span></span><br></pre></td></tr></table></figure><p>在一些特殊的场景中非常有用，例如，kubernetes的pod，kubernetes为pod创建一个基础设施容器，同一pod下的其他容器都以container模式共享这个基础设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。</p><h2 id="None模式"><a href="#None模式" class="headerlink" title="None模式"></a>None模式</h2><p>只会创建对应的网络空间，不会配置网络堆栈（网卡、路由等）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建none的容器</span></span><br><span class="line">$ docker run -it  --name=network-none --net=none nginx:alpine sh</span><br><span class="line"><span class="comment"># ifconfig</span></span><br></pre></td></tr></table></figure><p>为了能让这个模式的docker容器能够访问外部网络，我们需要手动的创建虚拟网卡对，并将一端插入到docker0网桥中，另一端插入到容器的网络空间中。其本质就是bridge模式的实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟网卡对</span></span><br><span class="line">$ ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line"><span class="comment"># A端插入到docker0网桥</span></span><br><span class="line">$ brctl addif docker0 A</span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br><span class="line"></span><br><span class="line"><span class="comment"># B端插入到network-none容器中，需要借助ip netns,因此需要显示的创建命名network namespace</span></span><br><span class="line">$ PID=$(docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> network-none)</span><br><span class="line">$ <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ <span class="built_in">ln</span> -s /proc/<span class="variable">$PID</span>/ns/net /var/run/netns/<span class="variable">$PID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># B端放到容器的命名空间</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> B netns <span class="variable">$PID</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev B name eth0  <span class="comment"># 修改设备名称为eth0，和docker默认行为一致</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置ip</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip addr add 172.17.0.100/16 dev eth0</span><br><span class="line"><span class="comment"># 添加默认路由，指定给docker0网桥</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip route add default via 172.17.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试容器间通信</span></span><br></pre></td></tr></table></figure><p>前置知识：</p><ul><li>ip netns 命令用来管理 network namespace。它可以创建命名的 network namespace，然后通过名字来引用 network namespace</li><li>network namespace 在逻辑上是网络堆栈的一个副本，它有自己的路由、防火墙规则和网络设备。<br>默认情况下，子进程继承其父进程的 network namespace。也就是说，如果不显式创建新的 network namespace，所有进程都从 init 进程继承相同的默认 network namespace。</li><li>根据约定，命名的 network namespace 是可以打开的 <strong>&#x2F;var&#x2F;run&#x2F;netns&#x2F;</strong> 目录下的一个对象。比如有一个名称为 net1 的 network namespace 对象，则可以由打开 &#x2F;var&#x2F;run&#x2F;netns&#x2F;net1 对象产生的文件描述符引用 network namespace net1。通过引用该文件描述符，可以修改进程的 network namespace。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 运行原理</title>
      <link href="/docker-service-running-principle/"/>
      <url>/docker-service-running-principle/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>docker优势主要是轻量级的虚拟化以及容器快速启停。</p><p>而虚拟化核心需要解决两个问题：资源隔离与资源限制</p><ul><li>虚拟机硬件虚拟化技术， 通过一个 hypervisor 层实现对资源的彻底隔离。</li><li>容器则是操作系统级别的虚拟化，利用的是内核的 Cgroup 和 Namespace 特性，此功能完全通过软件实现。</li></ul><span id="more"></span><h2 id="Namespace-资源隔离"><a href="#Namespace-资源隔离" class="headerlink" title="Namespace 资源隔离"></a>Namespace 资源隔离</h2><p>命名空间是全局资源的一种抽象，将资源放到不同的命名空间中，各个命名空间中的资源是相互隔离的。</p><table><thead><tr><th><strong>分类</strong></th><th><strong>系统调用参数</strong></th><th><strong>相关内核版本</strong></th></tr></thead><tbody><tr><td>Mount namespaces</td><td>CLONE_NEWNS</td><td><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux 2.4.19</a></td></tr><tr><td>UTS namespaces</td><td>CLONE_NEWUTS</td><td><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td></tr><tr><td>IPC namespaces</td><td>CLONE_NEWIPC</td><td><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td></tr><tr><td>PID namespaces</td><td>CLONE_NEWPID</td><td><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td></tr><tr><td>Network namespaces</td><td>CLONE_NEWNET</td><td><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td></tr><tr><td>User namespaces</td><td>CLONE_NEWUSER</td><td><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于 Linux 3.8</a></td></tr></tbody></table><p>我们知道，docker容器对于操作系统来讲其实是一个进程，我们可以通过原始的方式来模拟一下容器实现资源隔离的基本原理：</p><p>linux系统中，通常可以通过<code>clone()</code>实现进程创建的系统调用 ，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*child_func)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>child_func</strong> : 传入子进程运行的程序主函数。</li><li><strong>child_stack</strong> : 传入子进程使用的栈空间。</li><li><strong>flags</strong> : 表示使用哪些 <code>CLONE_*</code> 标志位。</li><li><strong>args</strong> : 用于传入用户参数。</li></ul><p>示例一：实现进程独立的UTS空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">  <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">  sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">  execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD , <span class="literal">NULL</span>);</span><br><span class="line">  waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行编译并测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o ns_uts ns_uts.c</span><br><span class="line">$ ./ns_uts</span><br><span class="line">$ hostname</span><br></pre></td></tr></table></figure><p>示例二：实现容器独立的进程空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">  <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line">  sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">  execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">  <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD , <span class="literal">NULL</span>);</span><br><span class="line">  waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行编译并测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o ns_pid ns_pid.c</span><br><span class="line">$ ./ns_pid</span><br><span class="line">$ <span class="built_in">echo</span> $$</span><br></pre></td></tr></table></figure><p>如何确定进程是否属于同一个namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ./ns_pid</span><br><span class="line">Parent [ 8061] - start a container!</span><br><span class="line">$ pstree -p 8061</span><br><span class="line">pid1(8061)───bash(8062)───pstree(8816)</span><br><span class="line">$ <span class="built_in">ls</span> -l /proc/8061/ns</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 net -&gt; net:[4026531968]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 uts -&gt; uts:[4026531838]</span><br><span class="line">$ <span class="built_in">ls</span> -l /proc/8062/ns</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 net -&gt; net:[4026531968]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 pid -&gt; pid:[4026534845]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 uts -&gt; uts:[4026534844]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 发现pid和uts是和父进程使用了不同的ns，其他的则是继承了父进程的命名空间</span></span><br></pre></td></tr></table></figure><p>综上：通俗来讲，docker在启动一个容器的时候，会调用Linux Kernel<br>Namespace的接口，来创建一块虚拟空间，创建的时候，可以支持设置下面这几种（可以随意选择）,docker默认都设置。</p><ul><li>pid：用于进程隔离（PID：进程ID）</li><li>net：管理网络接口（NET：网络）</li><li>ipc：管理对 IPC 资源的访问（IPC：进程间通信（信号量、消息队列和共享内存））</li><li>mnt：管理文件系统挂载点（MNT：挂载）</li><li>uts：隔离主机名和域名</li><li>user：隔离用户和用户组</li></ul><blockquote><p>linux namespace 可以支持创建进程的时候，通过参数传递（CLONE_NEW*）来确定这个新启动的进程以及进程衍生的子进程是否拥有独立的进程空间，网络空间，文件系统空间，用户空间等等。<br>docker容器对于宿主机来说，其实就是一个进程，创建容器时，给这个容器进程指定了独立的进程空间，网络空间，文件系统空间，用户空间等等，这样就实现了容器的资源隔离。</p></blockquote><h2 id="CGroup-资源限制"><a href="#CGroup-资源限制" class="headerlink" title="CGroup 资源限制"></a>CGroup 资源限制</h2><p>通过namespace可以保证容器之间的隔离，但是无法控制每个容器可以占用多少资源， 如果其中的某一个容器正在执行 CPU<br>密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题。</p><p><img src="/post/docker/cgroup.png" alt="cgroup"></p><p>Control Groups（简称 CGroups）</p><blockquote><p>cgroups是Linux内核提供的一种机制，这种机制可以根据需求吧一系列系统任务及其子任务整合(或分隔)<br>到按资源划分等级的不同组中，从而为系统资源管理提供一个统一的框架。</p></blockquote><p>CGroups能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I&#x2F;O 。每一个 CGroup<br>都是一组被相同的标准和参数限制的进程。而我们需要做的，其实就是把容器这个进程加入到指定的Cgroup中。</p><p>验证cgroup的内存限制：</p><ul><li><p>准备一个程序，每秒钟申请1MB的内存, <code>mem-allocate.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MB (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MB);</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, MB);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dM memory allocated\n&quot;</span>, ++i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建cgroup文件及脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/fs/cgroup/memory/</span><br><span class="line"><span class="built_in">mkdir</span> -p memory-process &amp;&amp; <span class="built_in">cd</span> memory-process</span><br><span class="line"><span class="built_in">echo</span> 30M &gt; memory.limit_in_bytes </span><br><span class="line">gcc mem-allocate.c -o mem-allocate</span><br></pre></td></tr></table></figure></li><li><p>准备脚本<code>cgroup-test.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> 30</span><br><span class="line">./mem-allocate</span><br></pre></td></tr></table></figure></li><li><p>用cgroup限制进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动程序</span></span><br><span class="line">./cgroup-test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看程序进程</span></span><br><span class="line">ps aux|grep cgroup-test</span><br><span class="line"><span class="built_in">echo</span> 16079 &gt; /sys/fs/cgroup/memory/memory-process/cgroup.procs</span><br></pre></td></tr></table></figure></li></ul><h2 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS 联合文件系统"></a>UnionFS 联合文件系统</h2><p>Linux namespace和cgroup分别解决了容器的资源隔离与资源限制，那么容器是很轻量的，通常每台机器中可以运行几十上百个容器，<br>这些个容器是共用一个image，还是各自将这个image复制了一份，然后各自独立运行呢？</p><p>如果每个容器之间都是全量的文件系统拷贝，那么会导致至少如下问题：</p><ul><li>运行容器的速度会变慢</li><li>容器和镜像对宿主机的磁盘空间的压力</li></ul><p>怎么解决这个问题呢？这就需要联合文件系统（UnionFS）了。</p><p>Docker使用了UnionFS的存储驱动。</p><ul><li>镜像分层存储 + 写时复制</li><li>UnionFS</li></ul><p>Docker 镜像是由一系列的层组成的，每层代表 Dockerfile 中的一条指令，比如下面的 Dockerfile 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">15.04</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> python /app/app.py</span></span><br></pre></td></tr></table></figure><p>这里的 Dockerfile 包含4条命令，其中每一行就创建了一层，下面显示了上述Dockerfile构建出来的镜像运行的容器层的结构。</p><p><img src="/post/docker/container-layers.jpg" alt="container-layers"></p><p>镜像就是由这些层一层一层堆叠起来的，镜像中的这些层都是只读的，当我们运行容器的时候，就可以在这些基础层至上添加新的可写层，也就是我们通常说的<code>容器层</code><br>，对于运行中的容器所做的所有更改（比如写入新文件、修改现有文件、删除文件）都将写入这个容器层。</p><p>对容器层的操作，主要利用了写时复制（CoW）技术。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景。<br>CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论有多少个容器共享同一个image，所做的写操作都是对从image中复制到自己的文件系统中的复本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离，相互不影响。使用CoW可以有效的提高磁盘的利用率。</p><p><img src="/post/docker/sharing-layers.jpg" alt="sharing-layers"></p><p><strong>镜像中每一层的文件都是分散在不同的目录中的，如何把这些不同目录的文件整合到一起呢？</strong></p><p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统联合到同一个挂载点的文件系统服务。它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，整个联合的过程被称为联合挂载（Union<br>Mount）。</p><p><img src="/post/docker/aufs.png" alt="aufs"></p><p>上图是AUFS的实现，AUFS是作为Docker存储驱动的一种实现，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和<br>Btrfs 等等，在最新的 Docker 中，overlay2 取代了 aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs<br>作为 Docker 的默认驱动。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sphinx - python文档生成器</title>
      <link href="/sphinx-python-documentation-generator/"/>
      <url>/sphinx-python-documentation-generator/</url>
      
        <content type="html"><![CDATA[<h1 id="Sphinx"><a href="#Sphinx" class="headerlink" title="Sphinx"></a>Sphinx</h1><p>Sphinx 是一个python第三方库，它将一组纯文本源文件转换为各种输出格式的工具，自动生成交叉引用、索引等，也就是说，如果您有一个包含 reStructuredText 或 Markdown 的源代码注释等，Sphinx可以生成一系列HTML文件、PDF文件（通过LaTeX）、手册页等等。</p><p>Sphinx专注于文档，特别是手写文档，然而，Sphinx也可以用来生成博客、主页甚至书籍。Sphinx的大部分功能来自其默认纯文本标记格式（reStructuredText）的丰富性。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先我们先安装它，使用pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sphinx</span><br></pre></td></tr></table></figure><p>安装之后可以替换主题，如果你有一个特定的主题，你可以使用pip安装它，例如，我们使用sphinx_rtd_theme主题，主题会主动安装sphinx，所以如果我们直接安装主题，上一步的安装可以省略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install sphinx_rtd_theme</span><br></pre></td></tr></table></figure><p>安装完成后可以使用命令sphinx-build查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-build --version</span><br><span class="line">sphinx-build 6.2.1</span><br></pre></td></tr></table></figure><h2 id="设置文档源"><a href="#设置文档源" class="headerlink" title="设置文档源"></a>设置文档源</h2><p>Sphinx纯文本文档源集合的根目录称为 source directory . 此目录还包含sphinx配置文件 conf.py ，在这里您可以配置Sphinx如何读取源代码和构建文档的所有方面。 </p><p>Sphinx有一个命令叫 sphinx-quickstart 设置源目录并创建默认 conf.py 从几个问题中配置最有用的配置值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sphinx-quickstart docs</span><br></pre></td></tr></table></figure><p>以下是我创建的时候的信息，其中 &gt; 表示输入，[] 表示默认值。这里可以根据需要进行设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-quickstart docs</span><br><span class="line">欢迎使用 Sphinx 6.2.1 快速配置工具。</span><br><span class="line"></span><br><span class="line">请输入接下来各项设定的值（如果方括号中指定了默认值，直接</span><br><span class="line">按回车即可使用默认值）。</span><br><span class="line"></span><br><span class="line">已选择根路径：docs</span><br><span class="line"></span><br><span class="line">有两种方式来设置用于放置 Sphinx 输出的构建目录：</span><br><span class="line">一是在根路径下创建“_build”目录，二是在根路径下创建“<span class="built_in">source</span>”</span><br><span class="line">和“build”两个独立的目录。</span><br><span class="line">&gt; 独立的源文件和构建目录（y/n） [n]: y</span><br><span class="line"></span><br><span class="line">项目名称将会出现在文档的许多地方。</span><br><span class="line">&gt; 项目名称: Lumache</span><br><span class="line">&gt; 作者名称: aaron</span><br><span class="line">&gt; 项目发行版本 []: 1.0</span><br><span class="line"></span><br><span class="line">如果用英语以外的语言编写文档，</span><br><span class="line">你可以在此按语言代码选择语种。</span><br><span class="line">Sphinx 会把内置文本翻译成相应语言的版本。</span><br><span class="line"></span><br><span class="line">支持的语言代码列表见：</span><br><span class="line">https://www.sphinx-doc.org/en/master/usage/configuration.html<span class="comment">#confval-language。</span></span><br><span class="line">&gt; 项目语种 [en]:</span><br><span class="line"></span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/source/conf.py。</span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/source/index.rst。</span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/Makefile。</span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/make.bat。</span><br><span class="line"></span><br><span class="line">完成：已创建初始目录结构。</span><br><span class="line"></span><br><span class="line">你现在可以填写主文档文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/source/index.rst 然后创建其他文档源文件了。 像这样用 Makefile 构建文档：</span><br><span class="line">  make builder</span><br><span class="line">此处的“builder”代指支持的构建器名称，比如 html、latex 或 linkcheck。</span><br></pre></td></tr></table></figure><p>全部完成之后，我们可以看到docs目录下的文件结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docs</span><br><span class="line">├── build</span><br><span class="line">├── make.bat</span><br><span class="line">├── Makefile</span><br><span class="line">└── <span class="built_in">source</span></span><br><span class="line">    ├── conf.py</span><br><span class="line">    ├── index.rst</span><br><span class="line">    ├── _static</span><br><span class="line">    └── _templates</span><br></pre></td></tr></table></figure><p>这些文件中的每个文件的目的是：</p><ul><li>build&#x2F; 一个空目录(目前)，它将保存呈现的文档。</li><li>make.bat and Makefile 方便的脚本可以简化一些常见的Sphinx操作，比如呈现内容。</li><li>source&#x2F;conf.py 保存Sphinx项目配置的一个Python脚本。它包含您为指定的项目名称和版本 sphinx-quickstart ，以及一些额外的配置密钥。</li><li>source&#x2F;index.rst 这个 root document 作为欢迎页面，并包含“目录树”的根(或 toctree )。</li></ul><p>现在运行以下命令，这样我们就可以得到一个空白的HTML文档了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-build -b html docs/source/ docs/build/html</span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在创建输出目录... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 1 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[新配置] 有 1 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] index                                                     </span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[100%] index                                                       </span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 docs/build/html 目录。</span><br></pre></td></tr></table></figure><p>然后在浏览器中打开 docs&#x2F;build&#x2F;html&#x2F;index.html ，你就可以看到一个简单的欢迎页面了。</p><p><img src="/post/sphinx/sphinx-first-show.png" alt="sphinx简单欢迎页"></p><h2 id="构建文档"><a href="#构建文档" class="headerlink" title="构建文档"></a>构建文档</h2><p>这里显示的首页就是docs&#x2F;source&#x2F;index.rst中的内容，我们可以在这里添加一些内容，然后重新构建文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.. Lumache documentation master file, created by</span><br><span class="line">   sphinx-quickstart on Mon May 22 23:33:09 2023.</span><br><span class="line">   You can adapt this file completely to your liking, but it should at least</span><br><span class="line">   contain the root `toctree` directive.</span><br><span class="line"></span><br><span class="line">Welcome to Lumache<span class="string">&#x27;s documentation!</span></span><br><span class="line"><span class="string">===================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.. toctree::</span></span><br><span class="line"><span class="string">   :maxdepth: 2</span></span><br><span class="line"><span class="string">   :caption: Contents:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**Lumache** (/lu&#x27;</span>make/) is a Python library <span class="keyword">for</span> cooks and food lovers that</span><br><span class="line">creates recipes mixing random ingredients.  It pulls data from the `Open Food</span><br><span class="line">Facts database &lt;https://world.openfoodfacts.org/&gt;`_ and offers a *simple* and</span><br><span class="line">*intuitive* API.</span><br><span class="line"></span><br><span class="line">.. note::</span><br><span class="line"></span><br><span class="line">   This project is under active development.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>它展示了reStrutiredText语法的几个功能，包括：</p><pre><code>- 使用 === 标记了一个标题- 以下两个示例的内联标记：**strong emphasis** (通常为粗体)和 *emphasis* (通常为斜体)- 一个行内的链接 (用于链接到 Open Food Facts)- 一个 note 提示</code></pre><p>现在，要使用新内容，可以使用刚才用过的 sphinx-build 命令，或者按如下方式利用make脚本生成，注意，这种方式需要系统中安装有make程序：、</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> docs</span><br><span class="line">$ make html</span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 1 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[新配置] 有 1 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] index                                                                                                                                                          </span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[100%] index                                                                                                                                                            </span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 build/html 目录。</span><br></pre></td></tr></table></figure><p>运行完成之后，再次打开docs&#x2F;build&#x2F;html&#x2F;index.html，你就可以看到新的内容了。</p><p><img src="/post/sphinx/index-new-content.png" alt="欢迎页新内容"></p><p>当然，sphinx还支持其他的文档格式，比如PDF，ePub等，这里就不再赘述了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># epub 格式生成方式</span><br><span class="line">$ make epub</span><br></pre></td></tr></table></figure><h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><p>sphinx还有很多内置的扩展来定制化功能。</p><h3 id="内置扩展"><a href="#内置扩展" class="headerlink" title="内置扩展"></a>内置扩展</h3><p>比如我们找到 docs&#x2F;source&#x2F;conf.py 添加一个扩展，这个扩展可以显示页面集成的时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docs/source/conf.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add any Sphinx extension module names here, as strings. They can be</span></span><br><span class="line"><span class="comment"># extensions coming with Sphinx (named &#x27;sphinx.ext.*&#x27;) or your custom</span></span><br><span class="line"><span class="comment"># ones.</span></span><br><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>添加扩展之后，就能在控制台输出的末尾看到页面生成的时间了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ make html</span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 0 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[扩展发生了变化 (<span class="string">&#x27;sphinx.ext.duration&#x27;</span>)] 有 1 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] index</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[100%] index</span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line"></span><br><span class="line">====================== 最长读取耗时 =======================</span><br><span class="line">0.030 index</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 build/html 目录。</span><br></pre></td></tr></table></figure><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>还记得我们在刚开始创建项目的时候，我们安装一个第三方的主题吗？这里我们可以修改 conf.py 来更换主题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The theme to use for HTML and HTML Help pages.  See the documentation for</span></span><br><span class="line"><span class="comment"># a list of builtin themes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">html_theme = <span class="string">&#x27;sphinx_rtd_theme&#x27;</span></span><br></pre></td></tr></table></figure><p>更改后，我们重新生成页面，就能看到新的主题了。</p><p>!(new theme)[&#x2F;post&#x2F;sphinx&#x2F;new-theme.png]</p><h2 id="叙事性文档"><a href="#叙事性文档" class="headerlink" title="叙事性文档"></a>叙事性文档</h2><h3 id="跨多页组织文档"><a href="#跨多页组织文档" class="headerlink" title="跨多页组织文档"></a>跨多页组织文档</h3><p>终于开始写文档了，我们可以在 docs&#x2F;source 目录下创建一个新的文件，比如 usage.rst ，然后在 index.rst 中添加一个链接到这个文件。</p><p>首先编写 usage.rst 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>这个新文件包含两个 section 页眉、普通段落文本和 code-block 指令</p><p>code-block 指令将内容块呈现为源代码，并使用适当的语法突出显示(在本例中为泛型 console 文本)。</p><p>文档的结构由一系列标题样式决定，这意味着通过使用 — 的 “Installation” 以及之后的部分，对于使用 &#x3D;&#x3D;&#x3D; 的 “Usage” 部分，您已经将 “Installation” 声明为 subsection “用法”的概念。</p><p>要为了完成显示，您还需要在 index.rst 添加一个 usage.rst 的链接，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Lumache&#x27;s documentation!</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   usage</span><br><span class="line">   </span><br><span class="line">**Lumache** (/lu&#x27;make/) is a Python library for cooks and food lovers that</span><br><span class="line">creates recipes mixing random ingredients.  It pulls data from the `Open Food</span><br><span class="line">Facts database &lt;https://world.openfoodfacts.org/&gt;`_ and offers a *simple* and</span><br><span class="line">*intuitive* API.</span><br><span class="line"></span><br><span class="line">.. note::</span><br><span class="line"></span><br><span class="line">   This project is under active development.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>更新页面，就能看到新的内容了。</p><blockquote><p>警告</p><p>外部文档 toctree 将导致 WARNING: document isn’t included in any toctree 消息，并且用户将无法访问。</p></blockquote><p><img src="/post/sphinx/doc-link01.png" alt="跨多页组织链接01"></p><p><img src="/post/sphinx/doc-link02.png" alt="跨多页组织链接02"></p><h3 id="添加交叉引用"><a href="#添加交叉引用" class="headerlink" title="添加交叉引用"></a>添加交叉引用</h3><p>Sphinx的一个强大功能是能够无缝地添加 cross-references 文档的特定部分：文档、章节、图形、代码对象等。</p><p>要添加交叉引用，请将这句话添加到 index.rst 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.. Lumache documentation master file, created by</span><br><span class="line">   sphinx-quickstart on Mon May 22 23:33:09 2023.</span><br><span class="line">   You can adapt this file completely to your liking, but it should at least</span><br><span class="line">   contain the root `toctree` directive.</span><br><span class="line"></span><br><span class="line">Welcome to Lumache&#x27;s documentation!</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   usage</span><br><span class="line"></span><br><span class="line">Check out the :doc:`usage` section for further information.</span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>这个 doc 会自动引用项目中的特定文档，在本例中为 usage.rst 。</p><p>当然也可以添加对项目任意部分的交叉引用。为此，需要使用 ref 角色，并添加显式 label ，它的作用就是 a target 。</p><p>例如，修改 usage.rst 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br></pre></td></tr></table></figure><p>并且将 label 添加到 index.rst 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.. Lumache documentation master file, created by</span><br><span class="line">   sphinx-quickstart on Mon May 22 23:33:09 2023.</span><br><span class="line">   You can adapt this file completely to your liking, but it should at least</span><br><span class="line">   contain the root `toctree` directive.</span><br><span class="line"></span><br><span class="line">Welcome to Lumache&#x27;s documentation!</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   usage</span><br><span class="line"></span><br><span class="line">Check out the :doc:`usage` section for further information, including how to</span><br><span class="line">:ref:`install &lt;installation&gt;` the project.</span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>重新生成页面，就能看到新的内容了。</p><h2 id="使用Sphinx描述代码"><a href="#使用Sphinx描述代码" class="headerlink" title="使用Sphinx描述代码"></a>使用Sphinx描述代码</h2><h3 id="记录Python对象"><a href="#记录Python对象" class="headerlink" title="记录Python对象"></a>记录Python对象</h3><p>Sphinx提供了几个角色和指令来记录Python对象，所有这些对象都集中在 <a href="https://www.osgeo.cn/sphinx/usage/restructuredtext/domains.html#python-domain">the Python domain</a> 。例如，可以使用 py:function 指令来记录一个Python函数，这里我们修改usage.rst，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br></pre></td></tr></table></figure><p><img src="/post/sphinx/describing-code01.png" alt="python对象描述"></p><p>请注意以下几点：</p><ul><li>Sphinx解析了 .. py:function 指令，并相应地突出显示模块、函数名和参数。</li><li>指令内容包括对该函数的一行描述，以及 info field list 包含函数参数、其预期类型、返回值和返回类型。</li></ul><blockquote><p>备注</p><p>这个 py: 前缀指定 domain 。您可以配置默认域，以便可以省略前缀，或者全局使用 primary_domain 配置，或使用 default-domain 指令将其从被调用的位置更改到文件的末尾。例如，如果将其设置为 py (默认设置)，您可以编写 .. function:: 直接去吧。</p></blockquote><h3 id="交叉引用Python对象"><a href="#交叉引用Python对象" class="headerlink" title="交叉引用Python对象"></a>交叉引用Python对象</h3><p>默认情况下，这些指令中的大多数生成可以从文档的任何部分交叉引用的实体 (a corresponding role)[<a href="https://www.osgeo.cn/sphinx/usage/restructuredtext/domains.html#python-roles]">https://www.osgeo.cn/sphinx/usage/restructuredtext/domains.html#python-roles]</a> 。对于函数，可以使用 py:func，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br></pre></td></tr></table></figure><p>在生成代码文档时，Sphinx只使用对象的名称自动生成交叉引用，而不必显式使用角色，页面表现为一个链接跳转。</p><p>我们也可以使用属性来描述函数引发的自定义异常，比如py:exception 指令：</p><p>首先定义一个异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.. py:exception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">   Raised if the kind is invalid.</span><br></pre></td></tr></table></figure><p>然后在函数的原始描述中引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :raise lumache.InvalidKindError: If the kind is invalid.</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br></pre></td></tr></table></figure><p>usage.rst 完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :raise lumache.InvalidKindError: If the kind is invalid.</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br><span class="line"></span><br><span class="line">.. py:exception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">   Raised if the kind is invalid.</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br></pre></td></tr></table></figure><p>重新更新页面，等待构建完成，就可以看到新的效果了，效果如下所示。</p><p><img src="/post/sphinx/describing-code02.png" alt="python异常描述"></p><h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><p>Sphinx 不仅提供了一种在文档中编写代码示例的方法，还提供了在文档中编写测试的方法。</p><p>这些测试可以在构建文档时运行，以确保文档中的示例代码仍然有效。这些测试称为文档测试，它们使用 <a href="https://docs.python.org/3/library/doctest.html">doctest</a> 模块。</p><p>对于代码描述和正常的代码实现逻辑保持一致是很重要的。在Sphinx中实现这一点的方法之一是在文档中包含代码片段，称为 doctests ，在构建文档时执行。</p><p>要显示这个功能，需要 Sphinx 需要能够导入代码。为了要做到这一点，请在 conf.py 中头部添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If extensions (or modules to document with autodoc) are in another directory,</span></span><br><span class="line"><span class="comment"># add these directories to sys.path here.</span></span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, pathlib.Path(__file__).parents[<span class="number">2</span>].resolve().as_posix())</span><br></pre></td></tr></table></figure><p>这句话的意思是，将项目的根目录添加到 sys.path 中，这样就可以将项目根目录添加到 python 的查找路径，以便在 Sphinx 中执行 Python 命令可以导入项目中的任何模块。</p><blockquote><p>备注</p><p>一种替代更改 sys.path 变量的目的是创建一个 pyproject.toml 文件，并使代码可安装，这样它的行为就像任何其他的Python库一样。然而， sys.path 方法更简单。</p></blockquote><p>然后，再启用 doctest 功能，需要在 conf.py 中添加扩展：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>整体的 conf.py 文件内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ cat source/conf.py</span><br><span class="line"><span class="comment"># Configuration file for the Sphinx documentation builder.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For the full list of built-in configuration values, see the documentation:</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If extensions (or modules to document with autodoc) are in another directory,</span></span><br><span class="line"><span class="comment"># add these directories to sys.path here.</span></span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, pathlib.Path(__file__).parents[<span class="number">2</span>].resolve().as_posix())</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Project information -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information</span></span><br><span class="line"></span><br><span class="line">project = <span class="string">&#x27;Lumache&#x27;</span></span><br><span class="line">copyright = <span class="string">&#x27;2023, aaron&#x27;</span></span><br><span class="line">author = <span class="string">&#x27;aaron&#x27;</span></span><br><span class="line">release = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- General configuration ---------------------------------------------------</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration</span></span><br><span class="line"></span><br><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">templates_path = [<span class="string">&#x27;_templates&#x27;</span>]</span><br><span class="line">exclude_patterns = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Options for HTML output -------------------------------------------------</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output</span></span><br><span class="line"></span><br><span class="line">html_theme = <span class="string">&#x27;sphinx_rtd_theme&#x27;</span></span><br><span class="line">html_static_path = [<span class="string">&#x27;_static&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在 source&#x2F;usage.rst 文件中添加一个 doctest 块，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import lumache</span><br><span class="line">&gt;&gt;&gt; lumache.get_random_ingredients()</span><br><span class="line">[&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br></pre></td></tr></table></figure><p>这里我将测试块添加到最后，你也可以根据需要在对应的位置进行添加，整体的 usage.rst 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :raise lumache.InvalidKindError: If the kind is invalid.</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br><span class="line"></span><br><span class="line">.. py:exception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">   Raised if the kind is invalid.</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import lumache</span><br><span class="line">&gt;&gt;&gt; lumache.get_random_ingredients()</span><br><span class="line">[&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br></pre></td></tr></table></figure><p>doctest 包括要运行的 Python 指令，前面有 &gt;&gt;&gt; 标准的 Python 解释器提示符，以及每条指令的预期输出。通过这种方式，Sphinx 可以检查实际输出是否与预期输出匹配。</p><p>为了观察 doctest 失败是什么样子(而不是上面的代码错误)，让我们首先不正确地编写返回值。在项目根目录（也就是docs的上级目录）中创建一个 lumache.py 文件，文件内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_ingredients</span>(<span class="params">kind=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a list of random ingredients as strings.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;bacon&quot;</span>, <span class="string">&quot;spam&quot;</span>]</span><br></pre></td></tr></table></figure><p>现在可以运行测试语句来执行文档的测试，显然，这个测试会失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有make程序也可以使用这个语句进行测试 sphinx-build -b doctest <span class="built_in">source</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make doctest</span></span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在创建输出目录... 完成</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [doctest]： 2 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[扩展发生了变化 (&#x27;sphinx.ext.doctest&#x27;)] 有 2 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[ 50%] index</span><br><span class="line">正在读取源文件……[100%] usage</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">running tests...</span><br><span class="line"></span><br><span class="line">Document: usage</span><br><span class="line">---------------</span><br><span class="line">**********************************************************************</span><br><span class="line">File &quot;usage.rst&quot;, line 42, in default</span><br><span class="line">Failed example:</span><br><span class="line">    lumache.get_random_ingredients()</span><br><span class="line">Expected:</span><br><span class="line">    [&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br><span class="line">Got:</span><br><span class="line">    [&#x27;eggs&#x27;, &#x27;bacon&#x27;, &#x27;spam&#x27;]</span><br><span class="line">**********************************************************************</span><br><span class="line">1 items had failures:</span><br><span class="line">   1 of   2 in default</span><br><span class="line">2 tests in 1 items.</span><br><span class="line">1 passed and 1 failed.</span><br><span class="line">***Test Failed*** 1 failures.</span><br><span class="line"></span><br><span class="line">Doctest summary</span><br><span class="line">===============</span><br><span class="line">    2 tests</span><br><span class="line">    1 failure in tests</span><br><span class="line">    0 failures in setup code</span><br><span class="line">    0 failures in cleanup code</span><br><span class="line"></span><br><span class="line">====================== 最长读取耗时 =======================</span><br><span class="line">0.030 usage</span><br><span class="line">0.027 index</span><br><span class="line">构建完成但存在问题。</span><br><span class="line">make: *** [Makefile:20：doctest] 错误 1</span><br></pre></td></tr></table></figure><p>现在，我们将代码进行修改，使其通过测试，修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_ingredients</span>(<span class="params">kind=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a list of random ingredients as strings.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;shells&quot;</span>, <span class="string">&quot;gorgonzola&quot;</span>, <span class="string">&quot;parsley&quot;</span>]</span><br></pre></td></tr></table></figure><p>再次运行测试，可以看到测试通过了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [doctest]： 2 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：有 0 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">running tests...</span><br><span class="line"></span><br><span class="line">Document: usage</span><br><span class="line">---------------</span><br><span class="line">1 items passed all tests:</span><br><span class="line">   2 tests in default</span><br><span class="line">2 tests in 1 items.</span><br><span class="line">2 passed and 0 failed.</span><br><span class="line">Test passed.</span><br><span class="line"></span><br><span class="line">Doctest summary</span><br><span class="line">===============</span><br><span class="line">    2 tests</span><br><span class="line">    0 failures in tests</span><br><span class="line">    0 failures in setup code</span><br><span class="line">    0 failures in cleanup code</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">已完成源文件的文档测试，结果保存在 build/doctest/output.txt 中，请查阅。</span><br></pre></td></tr></table></figure><h2 id="自动生成文档"><a href="#自动生成文档" class="headerlink" title="自动生成文档"></a>自动生成文档</h2><p>Sphinx 可以根据代码中的 docstring 自动生成文档，这样可以减少文档的编写工作量，同时也可以保证文档与代码的一致性。</p><h3 id="文档字符串自动生成文档"><a href="#文档字符串自动生成文档" class="headerlink" title="文档字符串自动生成文档"></a>文档字符串自动生成文档</h3><p>要使用这个功能，需要先启动 Sphinx 的 autodoc 扩展。在 conf.py 文件中添加如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.autodoc&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接下来我们先将 lumache.py 文件中的代码进行修改，添加一个异常类以及函数的docstring，修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InvalidKindError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Raised if the kind is invalid.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_ingredients</span>(<span class="params">kind=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return a list of random ingredients as strings.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param kind: Optional &quot;kind&quot; of ingredients.</span></span><br><span class="line"><span class="string">    :type kind: list[str] or None</span></span><br><span class="line"><span class="string">    :raise lumache.InvalidKindError: If the kind is invalid.</span></span><br><span class="line"><span class="string">    :return: The ingredients list.</span></span><br><span class="line"><span class="string">    :rtype: list[str]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;shells&quot;</span>, <span class="string">&quot;gorgonzola&quot;</span>, <span class="string">&quot;parsley&quot;</span>]</span><br></pre></td></tr></table></figure><p>然后，将 .. py:function 和 .. py:exception 标记指向原始的 python 文件，使用自动生成字段 autofunction 、 autoexception 添加到文档中，这样 Sphinx 就会自动将这些内容添加到文档中。</p><p>修改后的 usage.rst 文档如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. autofunction:: lumache.get_random_ingredients</span><br><span class="line"></span><br><span class="line">.. autoexception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import lumache</span><br><span class="line">&gt;&gt;&gt; lumache.get_random_ingredients()</span><br><span class="line">[&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br></pre></td></tr></table></figure><p>现在，运行 make html 命令，可以看到文档中已经包含了我们添加的内容，和之前手写的文档没有什么不同：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make html</span></span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 0 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：有 0 个新增文件，有 1 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] usage</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[ 50%] index</span><br><span class="line">正在写入输出……[100%] usage</span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line"></span><br><span class="line">====================== 最长读取耗时 =======================</span><br><span class="line">0.049 usage</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 build/html 目录。</span><br></pre></td></tr></table></figure><p><img src="/post/sphinx/autodoc.png" alt="使用签名和文档字符串自动生成文档"></p><h3 id="生成全面的API参考"><a href="#生成全面的API参考" class="headerlink" title="生成全面的API参考"></a>生成全面的API参考</h3><p>在使用时 sphinx.ext.autodoc 使代码和文档保持同步变得容易得多，但它仍然需要您编写 auto* 指令为您要记录的每个对象指定。Sphinx提供了另一个级别的自动化： autosummary 。</p><p>这个 autosummary 指令生成的文档包含所有使用 autodoc 指令的地方。</p><p>要使用它，需要先启用扩展：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.autodoc&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.autosummary&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着，创建一个新的 rst 文件，命名为 api.rst ，并添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">API reference</span><br><span class="line">=============</span><br><span class="line">.. autosummary::</span><br><span class="line">   :toctree: _autosummary</span><br><span class="line"></span><br><span class="line">   lumache.get_random_ingredients</span><br><span class="line">   lumache.InvalidKindError</span><br></pre></td></tr></table></figure><p>别忘了将 api.rst 文件添加到 index.rst 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   installation</span><br><span class="line">   usage</span><br><span class="line">   api</span><br></pre></td></tr></table></figure><p>最后，在构建完运行 make html ，它将包含两个新页面：</p><ul><li>api.html ，对应于 docs&#x2F;source&#x2F;api.rst 并包含一个表，其中包含您在 autosummary 指令(在本例中，只有一个)。</li><li>generated&#x2F;lumache.html ，对应于自动创建的文件 generated&#x2F;lumache.rst 并包含模块成员的摘要，在本例中为一个函数和一个异常。</li></ul><p>摘要页面中的每个链接都会将您带到您最初使用相应 autodoc 指令，在本例中为 usage.rst 文件。</p><p><img src="/post/sphinx/autosummary.png" alt="自动生成摘要首页"></p><p><img src="/post/sphinx/autosummary_api.png" alt="自动生成摘要api"></p><p><img src="/post/sphinx/autosummary_lumache.png" alt="自动生成摘要lumache"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了 Sphinx 的基本用法，包括安装、配置、使用、自定义主题、自动化文档生成等。Sphinx 是一个非常强大的文档生成工具，可以帮助我们快速生成文档，提高文档的质量，减少文档的维护成本。</p><p>主要的内容均来自于 Sphinx 官方文档中的 《使用sphinx》一节，本文只是对官方文档的一个简单翻译和总结，希望能够帮助到大家。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.sphinx-doc.org/en/master/">Sphinx官方文档</a></li><li><a href="https://www.sphinx-doc.org/zh_CN/master/">Sphinx官方文档中文版</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos8 升级 python 版本</title>
      <link href="/centos8-python-upgrade/"/>
      <url>/centos8-python-upgrade/</url>
      
        <content type="html"><![CDATA[<p>经常遇到给linux升级python的需求，这里记录一下</p><p>linux版本：centos8</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"># init</span><br><span class="line"># 修改centos8的yum源</span><br><span class="line">find /etc/yum.repos.d/ -type f | xargs -i sed -i &#x27;s#http://mirror.centos.org/$contentdir/$releasever/#https://mirrors.aliyun.com/centos/8-stream/#g&#x27; &#123;&#125;</span><br><span class="line"></span><br><span class="line">sudo sed -i &#x27;s/SELINUX=\w*/SELINUX=disabled/&#x27; /etc/selinux/config</span><br><span class="line">sudo dnf -y install epel-release</span><br><span class="line">sudo dnf install -y bash-com* bzip2-devel bind-utils cmake dkms dos2unix drpm expect gcc gcc-c++ gdb gdm git kernel-devel kernel-headers libffi libffi-devel lrzsz make ncurses-devel nfs-utils nmap openssl-devel rsync sqlite-devel sysstat tar telnet tmux traceroute tree unzip vim wget yum-utils zlib-devel xz-devel</span><br><span class="line">sudo touch /etc/profile.d/custom.sh</span><br><span class="line"></span><br><span class="line"># 安装rust</span><br><span class="line">sudo curl https://sh.rustup.rs -sSf | sh</span><br><span class="line"></span><br><span class="line"># 安装python</span><br><span class="line">python_version=&quot;3.9.1&quot;</span><br><span class="line">wget https://www.python.org/ftp/python/$&#123;python_version&#125;/Python-$&#123;python_version&#125;.tar.xz</span><br><span class="line">sudo dnf install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel gcc libffi make libffi-devel -y</span><br><span class="line">tar Jxvf Python-$&#123;python_version&#125;.tar.xz</span><br><span class="line">cd Python-$&#123;python_version&#125;/</span><br><span class="line">sudo ./configure --prefix=/usr/local/python3 --enable-shared  --enable-optimizations --with-ssl</span><br><span class="line">sudo make</span><br><span class="line">sudo make altinstall</span><br><span class="line"></span><br><span class="line">sudo bash -c &#x27;echo &quot;/usr/local/python3/lib&quot; &gt; /etc/ld.so.conf.d/python3.conf&#x27;</span><br><span class="line">sudo ldconfig</span><br><span class="line">sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python</span><br><span class="line">sudo ln -s /usr/local/python3/bin/pip3 /usr/bin/pip</span><br><span class="line">python -V</span><br><span class="line">pip -V</span><br><span class="line"></span><br><span class="line">user=&quot;aaron&quot;</span><br><span class="line">home_path=&quot;/home/$&#123;user&#125;/&quot;</span><br><span class="line">root_path=&quot;/root/&quot;</span><br><span class="line"></span><br><span class="line">sudo bash -c &#x27;echo -e &quot;[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n&quot; &gt; /etc/pip.conf&#x27;</span><br><span class="line">sudo pip install --upgrade pip</span><br><span class="line">sudo pip install ipython</span><br><span class="line">sudo ln -s /usr/local/python3/bin/ipython /usr/bin/</span><br><span class="line">sudo pip install virtualenv</span><br><span class="line">sudo ln -s /usr/local/python3/bin/virtualenv /usr/bin/</span><br><span class="line">sudo pip install virtualenvwrapper</span><br><span class="line">sudo ln -s /usr/local/python3/bin/virtualenvwrapper /usr/bin/</span><br><span class="line">sudo mkdir $&#123;home_path&#125;.virtualenvs $&#123;root_path&#125;.virtualenvs</span><br><span class="line">grep -q &#x27;^if \[ ! -d &quot;$HOME/.virtualenvs&quot; ];then$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;if [ ! -d \&quot;\$HOME/.virtualenvs\&quot; ];then\n  mkdir \$HOME/.virtualenvs\nfi&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^export WORKON_HOME=$HOME/.virtualenvs$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;export WORKON_HOME=\$HOME/.virtualenvs&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^export PROJECT_HOME=$HOME/.workspaces$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;export PROJECT_HOME=\$HOME/.workspaces&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^source /usr/local/python3/bin/virtualenvwrapper.sh$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;source /usr/local/python3/bin/virtualenvwrapper.sh&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line"></span><br><span class="line"># vimrc</span><br><span class="line">sudo mkdir -p $&#123;home_path&#125;.undodir $&#123;root_path&#125;.undodir $&#123;home_path&#125;.vim $&#123;root_path&#125;.vim</span><br><span class="line">sudo chown -R $&#123;user&#125;: $&#123;home_path&#125;</span><br><span class="line"># 参考vimrc</span><br><span class="line">vim  $&#123;home_path&#125;.vim/vimrc</span><br><span class="line">sudo cp  $&#123;home_path&#125;.vim/vimrc $&#123;root_path&#125;.vim/</span><br><span class="line">grep -q &#x27;^export EDITOR=/usr/bin/vim$&#x27; /etc/profile.d/custom.sh &amp;&amp; sudo sed -i &#x27;s/^export EDITOR.*$/export EDITOR=/usr/bin/vim/&#x27; /etc/profile.d/custom.sh || sudo bash -c &#x27;echo &quot;EDITOR=/usr/bin/vim/&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^if \[ ! -d &quot;$HOME/.undodir&quot; ];then$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;if [ ! -d \&quot;\$HOME/.undodir\&quot; ];then\n  mkdir \$HOME/.undodir\nfi\n&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line"># 参考init.sh</span><br><span class="line">sudo vim /etc/init.sh</span><br><span class="line">ln -s /etc/init.sh $&#123;home_path&#125;.init.sh</span><br><span class="line">sudo ln -s /etc/init.sh $&#123;root_path&#125;.init.sh</span><br><span class="line">grep -q &#x27;^if \[ -f ~/.init.sh ]; then$&#x27; $&#123;home_path&#125;.bash_profile || sh -c &#x27;echo -e &quot;if [ -f ~/.init.sh ]; then\n    . ~/.init.sh login\nfi\n&quot; &gt;&gt; $&#123;home_path&#125;.bash_profile&#x27;</span><br><span class="line">sudo grep -q &#x27;^if \[ -f ~/.init.sh ]; then$&#x27; $&#123;root_path&#125;.bash_profile || sudo sh -c &#x27;echo -e &quot;if [ -f ~/.init.sh ]; then\n    . ~/.init.sh login\nfi\n&quot; &gt;&gt; $&#123;root_path&#125;.bash_profile&#x27;</span><br><span class="line"># 参考ssh_banner</span><br><span class="line">sudo vim /etc/ssh_banner</span><br><span class="line">sudo grep -q &#x27;^Banner .*$&#x27; /etc/ssh/sshd_config || sudo sh -c &#x27;echo -e &quot;Banner /etc/ssh_banner&quot; &gt;&gt; /etc/ssh/sshd_config&#x27;</span><br><span class="line"></span><br><span class="line"># docker</span><br><span class="line">sudo dnf remove docker docker-common docker-selinux docker-engine -y</span><br><span class="line">sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo dnf install device-mapper-persistent-data lvm2 -y</span><br><span class="line">sudo dnf install docker-ce --nobest -y</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo usermod -aG docker $&#123;user&#125;</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"># 注意修改权限</span><br><span class="line">sudo chown -R $&#123;user&#125;: $&#123;home_path&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo pip install jupyter</span><br><span class="line">ll $&#123;home_path&#125;.jupyter/jupyter_notebook_config.py</span><br><span class="line">sudo ln -s /usr/local/python3/bin/jupyter-notebook /usr/bin/</span><br><span class="line">jupyter-notebook --generate-config</span><br><span class="line">mkdir -p $&#123;home_path&#125;project/ipython</span><br><span class="line">vim $&#123;home_path&#125;.jupyter/jupyter_notebook_config.py</span><br><span class="line">    c.NotebookApp.ip = &#x27;192.168.100.10&#x27;</span><br><span class="line">    c.NotebookApp.notebook_dir = &#x27;/home/aaron/project/ipython&#x27;</span><br><span class="line">    c.NotebookApp.open_browser = False</span><br><span class="line">    # jupyter</span><br><span class="line">    c.NotebookApp.password = &#x27;argon2:$argon2id$v=19$m=10240,t=10,p=8$ZyZnmpT3p/nmdXpgVV3mQw$JWkHVEJos0t/XQNix9uwvQ&#x27;</span><br><span class="line">    c.NotebookApp.password_required = True</span><br><span class="line">    c.NotebookApp.port = 8880</span><br><span class="line">    </span><br><span class="line"># 添加系统systemd</span><br><span class="line">sudo vim /usr/lib/systemd/system/jupyter-notebook.service</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker file</title>
      <link href="/docker-file/"/>
      <url>/docker-file/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><h1 id="Dockerfile介绍"><a href="#Dockerfile介绍" class="headerlink" title="Dockerfile介绍"></a>Dockerfile介绍</h1><p>Dockerfile是一堆指令，在docker build的时候，按照该指令进行操作，最终生成我们期望的镜像</p><span id="more"></span><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><ul><li><p>FROM 指定基础镜像，必须为第一个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  FROM &lt;image&gt;</span><br><span class="line">  FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">示例：</span><br><span class="line">  FROM mysql:5.7</span><br><span class="line">注意：</span><br><span class="line">  tag是可选的，如果不使用tag时，会使用latest版本的基础镜像</span><br></pre></td></tr></table></figure></li><li><p>MAINTAINER 镜像维护者的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  MAINTAINER &lt;name&gt;</span><br><span class="line">示例：</span><br><span class="line">  MAINTAINER Yongxin Li</span><br><span class="line">  MAINTAINER inspur_lyx@hotmail.com</span><br><span class="line">  MAINTAINER Yongxin Li &lt;inspur_lyx@hotmail.com&gt;</span><br></pre></td></tr></table></figure><p>查看镜像的MAINTAINER</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 通过docker inspect命令查看镜像Author的值。</span><br><span class="line"></span><br><span class="line">docker inspect -f &#123;&#123;&quot;.Author&quot;&#125;&#125; &lt;镜像ID&gt;</span><br></pre></td></tr></table></figure></li><li><p>LABEL 镜像元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line">示例：</span><br><span class="line">  LABEL &quot;email&quot;=&quot;Securitit@13.com&quot;</span><br><span class="line">  LABEL email-host=&quot;www.host.com&quot;</span><br><span class="line">  LABEL email-version=&quot;1.0&quot;</span><br><span class="line">  LABEL email-description=&quot;This is my \</span><br><span class="line">        persional email.&quot;</span><br><span class="line">  LABEL multi.label-1=&quot;value-1&quot; multi.label-2=&quot;value-2&quot; multi.label-3=&quot;value-3&quot;</span><br><span class="line">  LABEL multi.label-4=&quot;value-4&quot; \</span><br><span class="line">        multi.label-5=&quot;value-5&quot; \</span><br><span class="line">        multi.label-6=&quot;value-6&quot;</span><br></pre></td></tr></table></figure><ul><li>基础镜像或父镜像中包含的元数据由当前镜像继承。如果元数据已经存在，但具有不同的值，则最近应用的值将覆盖以前设置的任何值。</li><li>可以使用LABEL maintainer&#x3D;”xxx”代替MAINTAINER xxx，两者设置的值，在镜像的描述文件中所处位置是不一样的。<ul><li>MAINTAINER xxx位于顶层Author属性中。</li><li>LABEL maintainer&#x3D;”xxx”位于Config.Labels.maintainer属性中，查看镜像的 LABEL <code>docker inspect -f &#123;&#123;".Config.Labels"&#125;&#125; &lt;镜像ID&gt;</code></li></ul></li><li>MAINTAINER已经过时，在新版本已不推荐使用，推荐使用LABEL完成元数据设置。</li></ul></li><li><p>COPY|ADD 添加本地文件到镜像中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">示例：</span><br><span class="line">  ADD hom* /mydir/          # 添加所有以&quot;hom&quot;开头的文件</span><br><span class="line">  ADD test relativeDir/     # 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/</span><br><span class="line">  ADD test /absoluteDir/    # 添加 &quot;test&quot; 到 /absoluteDir/</span><br></pre></td></tr></table></figure></li><li><p>WORKDIR 工作目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  WORKDIR /path/to/workdir</span><br><span class="line">示例：</span><br><span class="line">  WORKDIR /a  (这时工作目录为/a)</span><br><span class="line">注意：</span><br><span class="line">  通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行</span><br></pre></td></tr></table></figure></li><li><p>RUN 构建镜像过程中执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  RUN &lt;command&gt;</span><br><span class="line">示例：</span><br><span class="line">  RUN yum install nginx</span><br><span class="line">  RUN pip install django</span><br><span class="line">  RUN mkdir test &amp;&amp; rm -rf /var/lib/unusedfiles</span><br><span class="line">注意：</span><br><span class="line">  RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</span><br></pre></td></tr></table></figure></li><li><p>CMD 构建容器后调用，也就是在容器启动时才进行调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (执行可执行文件，优先)</span><br><span class="line">  CMD [&quot;param1&quot;,&quot;param2&quot;] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)</span><br><span class="line">  CMD command param1 param2 (执行shell内部命令)</span><br><span class="line">示例：</span><br><span class="line">  CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</span><br><span class="line">  CMD ping www.baidu.com</span><br><span class="line">注意：</span><br><span class="line">  CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</span><br></pre></td></tr></table></figure></li><li><p>ENTRYPOINT 设置容器初始化命令，使其可执行化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (可执行文件, 优先)</span><br><span class="line">  ENTRYPOINT command param1 param2 (shell内部命令)</span><br><span class="line">示例：</span><br><span class="line">  ENTRYPOINT [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</span><br><span class="line">注意：</span><br><span class="line">  ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令</span><br></pre></td></tr></table></figure></li><li><p>ENV</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">  ENV &lt;key&gt;=&lt;value&gt;</span><br><span class="line">示例：</span><br><span class="line">  ENV myName John</span><br><span class="line">  ENV myCat=fluffy</span><br></pre></td></tr></table></figure></li><li><p>EXPOSE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line">示例：</span><br><span class="line">  EXPOSE 80 443</span><br><span class="line">  EXPOSE 8080</span><br><span class="line">  EXPOSE 11211/tcp 11211/udp</span><br><span class="line">注意：</span><br><span class="line">  EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口</span><br></pre></td></tr></table></figure></li></ul><h2 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h2><ul><li><p>基础环境镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --update ca-certificates &amp;&amp; <span class="built_in">rm</span> -rf /var/cache/apk/* &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  find /usr/share/ca-certificates/mozilla/ -name <span class="string">&quot;*.crt&quot;</span> -<span class="built_in">exec</span> keytool -import -trustcacerts \</span></span><br><span class="line"><span class="language-bash">  -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts -storepass changeit -noprompt \</span></span><br><span class="line"><span class="language-bash">  -file &#123;&#125; -<span class="built_in">alias</span> &#123;&#125; \; &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  keytool -list -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts --storepass changeit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> MAVEN_VERSION <span class="number">3.5</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">ENV</span> MAVEN_HOME /usr/lib/mvn</span><br><span class="line"><span class="keyword">ENV</span> PATH $MAVEN_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget http://archive.apache.org/dist/maven/maven-3/<span class="variable">$MAVEN_VERSION</span>/binaries/apache-maven-<span class="variable">$MAVEN_VERSION</span>-bin.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  tar -zxvf apache-maven-<span class="variable">$MAVEN_VERSION</span>-bin.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  <span class="built_in">rm</span> apache-maven-<span class="variable">$MAVEN_VERSION</span>-bin.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  <span class="built_in">mv</span> apache-maven-<span class="variable">$MAVEN_VERSION</span> /usr/lib/mvn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span></span><br></pre></td></tr></table></figure></li><li><p>前端镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.19</span>.<span class="number">0</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;mritd &lt;mritd@linux.com&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> TZ=<span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="keyword">ENV</span> TZ $&#123;TZ&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk upgrade --update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add bash tzdata curl wget ca-certificates \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">ln</span> -sf /usr/share/zoneinfo/<span class="variable">$&#123;TZ&#125;</span> /etc/localtime \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;TZ&#125;</span> &gt; /etc/timezone \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /usr/share/nginx/html /var/cache/apk/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> dist /usr/share/nginx/html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">443</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>java镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>u111</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS <span class="string">&quot;\</span></span><br><span class="line"><span class="string">-Xmx4096m \</span></span><br><span class="line"><span class="string">-XX:MetaspaceSize=256m \</span></span><br><span class="line"><span class="string">-XX:MaxMetaspaceSize=256m&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/java/jdk</span><br><span class="line"><span class="keyword">ENV</span> PATH $&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/myapp.jar myapp.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> java <span class="variable">$&#123;JAVA_OPTS&#125;</span> -jar myapp.jar</span></span><br></pre></td></tr></table></figure></li><li><p>golang镜像</p><p>使用多阶段构建，请查看本文下面出现的《多阶段构建》章节。</p></li></ul><h2 id="1号进程"><a href="#1号进程" class="headerlink" title="1号进程"></a>1号进程</h2><p>接下来通过1号进程理解容器的本质</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it nginx:1.19.0-alpine /bin/sh</span><br><span class="line"><span class="comment">#/ ps aux</span></span><br></pre></td></tr></table></figure><p>容器启动的时候可以通过命令去覆盖默认的CMD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name xxx nginx:alpine &lt;自定义命令&gt;</span><br><span class="line"><span class="comment"># &lt;自定义命令&gt;会覆盖镜像中指定的CMD指令，作为容器的1号进程启动。</span></span><br><span class="line"></span><br><span class="line">$ docker run -d --name test-3 nginx:alpine <span class="built_in">echo</span> 123</span><br><span class="line"></span><br><span class="line">$ docker run -d --name test-4 nginx:alpine ping www.baidu.com</span><br></pre></td></tr></table></figure><p>本质上讲容器是利用namespace和cgroup等技术在宿主机中创建的独立的虚拟空间，这个空间内的网络、进程、挂载等资源都是隔离的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it nginx:1.19.0-alpine /bin/sh</span><br><span class="line"><span class="comment">#/ ip addr</span></span><br><span class="line"><span class="comment">#/ ls -l /</span></span><br><span class="line"><span class="comment">#/ apt install xxx</span></span><br><span class="line"><span class="comment">#/ #安装的软件对宿主机和其他容器没有任何影响，和虚拟机不同的是，容器间共享一个内核，所以容器内没法升级内核</span></span><br></pre></td></tr></table></figure><h2 id="多阶构建"><a href="#多阶构建" class="headerlink" title="多阶构建"></a>多阶构建</h2><h3 id="java项目"><a href="#java项目" class="headerlink" title="java项目"></a>java项目</h3><p>这里先使用java镜像为例，介绍多阶构建的使用。</p><p>项目地址：(springboot-app)[<a href="https://gitee.com/agagin/springboot-app.git]">https://gitee.com/agagin/springboot-app.git]</a></p><h4 id="原始构建："><a href="#原始构建：" class="headerlink" title="原始构建："></a>原始构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> srinivasansekar/javamvn</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/springboot-app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">  . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -jar /opt/springboot-app/target/sample.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t sample:v1 -f Dockerfile</span><br></pre></td></tr></table></figure><h4 id="多阶构建："><a href="#多阶构建：" class="headerlink" title="多阶构建："></a>多阶构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> maven as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/springboot-app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">  . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /opt/springboot-app/target/sample.jar sample.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -jar /sample.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t sample:v2 -f Dockerfile.multi</span><br></pre></td></tr></table></figure><h3 id="golang项目"><a href="#golang项目" class="headerlink" title="golang项目"></a>golang项目</h3><p>项目地址：(href-counter)[<a href="https://gitee.com/agagin/href-counter.git]">https://gitee.com/agagin/href-counter.git]</a></p><h4 id="原始构建：-1"><a href="#原始构建：-1" class="headerlink" title="原始构建："></a>原始构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> vendor vendor</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"><span class="keyword">ENV</span> GOPROXY https://goproxy.cn</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t href-counter:v1 -f Dockerfile</span><br></pre></td></tr></table></figure><h4 id="多阶构建：-1"><a href="#多阶构建：-1" class="headerlink" title="多阶构建："></a>多阶构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span> AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> vendor vendor</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go.</span></span><br><span class="line"><span class="keyword">ENV</span> GOPROXY https://goproxy.cn</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.10</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder  /go/src/github.com/alexellis/href-counter/app    .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t href-counter:v2 -f Dockerfile.multi</span><br></pre></td></tr></table></figure><h3 id="虚悬镜像-dangling-image"><a href="#虚悬镜像-dangling-image" class="headerlink" title="虚悬镜像 dangling image"></a>虚悬镜像 dangling image</h3><p>我们多阶构建完成后，通过 docker image ls (与 docker images相同)查看镜像时会发现一个或多个镜像ID和标签都为 none 关键字的镜像，这称为虚悬镜像(dangling image)，也就是我们多阶构建的中间镜像。再构建同名且同tag的镜像的时候，原本的镜像也会变为虚悬镜像。</p><p>虚悬镜像，我们并不需要它们，但是它们还占用存储空间。该如何删除呢？可以查找出镜像id进行删除，也可以通过docker命令删除。</p><ol><li>列出虚悬镜像 <code>docker image ls -f dangling=true</code></li><li>删除虚悬镜像 <code>docker image prune</code></li></ol><h3 id="多阶构建原则"><a href="#多阶构建原则" class="headerlink" title="多阶构建原则"></a>多阶构建原则</h3><ul><li>不必要的内容不要放在镜像中</li><li>减少不必要的层文件</li><li>减少网络传输操作</li><li>可以适当的包含一些调试命令</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yaml 入门</title>
      <link href="/yaml-introduction/"/>
      <url>/yaml-introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="yaml介绍"><a href="#yaml介绍" class="headerlink" title="yaml介绍"></a>yaml介绍</h1><p>官网介绍如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%YAML 1.2</span><br><span class="line">---</span><br><span class="line">YAML: YAML Ain&#x27;t Markup Language™</span><br><span class="line"></span><br><span class="line">What It Is:</span><br><span class="line">  YAML is a human-friendly data serialization</span><br><span class="line">  language for all programming languages.</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>这里的语法使用python举例，python使用的库是PyYAML</p><p>所有的 YAML 文件开始行都应该是 —。这是 YAML 格式的一部分, 表明一个文件的开始。</p><p>基本语法规则如下:</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li># 表示注释，从这个字符一直到行尾，都会被解析器忽略。</li></ul><p>YAML 支持的数据结构有三种:</p><ol><li>对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hashes） &#x2F; 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</li><li>纯量（scalars）：单个的、不可再分的值</li></ol><h2 id="对象-key-value键值对"><a href="#对象-key-value键值对" class="headerlink" title="对象 key-value键值对"></a>对象 key-value键值对</h2><p>使用格式为key: value。冒号后面要加一个空格。</p><h3 id="简单展示"><a href="#简单展示" class="headerlink" title="简单展示"></a>简单展示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 表示url属性值</span></span><br><span class="line"><span class="string">url: https://www.iluvatar.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 yaml 文件</span></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(value))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;url&#x27;: &#x27;https://www.iluvatar.com&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用缩进代表层级结构"><a href="#使用缩进代表层级结构" class="headerlink" title="使用缩进代表层级结构"></a>使用缩进代表层级结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 可以使用缩进表示层级结构</span></span><br><span class="line"><span class="string">host:</span></span><br><span class="line"><span class="string">    # 这样没有层级结构，所以解析的时候会报错</span></span><br><span class="line"><span class="string">    # ip:</span></span><br><span class="line"><span class="string">    # 172.16.0.1</span></span><br><span class="line"><span class="string">    ip:</span></span><br><span class="line"><span class="string">        172.16.0.1</span></span><br><span class="line"><span class="string">    # 定义相同的key并不报错，而是覆盖之前的相同key中的value</span></span><br><span class="line"><span class="string">    ip:</span></span><br><span class="line"><span class="string">        172.16.0.2</span></span><br><span class="line"><span class="string">    # 没有空格的话会被认为是一个键，并且报错没有检测到: 以及value</span></span><br><span class="line"><span class="string">    # ip:172.16.0.3</span></span><br><span class="line"><span class="string">    mask: 255.255.255.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 yaml 文件</span></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(value))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;host&#x27;: &#123;&#x27;ip&#x27;: &#x27;172.16.0.2&#x27;, &#x27;mask&#x27;: &#x27;255.255.255.0&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="一行显示"><a href="#一行显示" class="headerlink" title="一行显示"></a>一行显示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># yaml 也支持将所有的对象写在一行的写法</span></span><br><span class="line"><span class="string"># 注意： 如果键值对没有使用空格分开会被认为是一个键</span></span><br><span class="line"><span class="string">host: &#123;ip: 172.16.0.1,ip: 172.16.0.2, ip:172.16.0.3 ,mask: 255.255.255.0&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 yaml 文件</span></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(value))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;host&#x27;: &#123;&#x27;ip&#x27;: &#x27;172.16.0.2&#x27;, &#x27;ip:172.16.0.3&#x27;: None, &#x27;mask&#x27;: &#x27;255.255.255.0&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="数组-Array-x2F-List"><a href="#数组-Array-x2F-List" class="headerlink" title="数组 Array&#x2F;List"></a>数组 Array&#x2F;List</h2><h3 id="简单展示-1"><a href="#简单展示-1" class="headerlink" title="简单展示"></a>简单展示</h3><p>列表中的所有成员都开始于相同的缩进级别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">ipaddr:</span></span><br><span class="line"><span class="string"># IP地址列表</span></span><br><span class="line"><span class="string">- 192.168.10.1</span></span><br><span class="line"><span class="string">- 192.168.10.2</span></span><br><span class="line"><span class="string">- 192.168.10.3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;ipaddr&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;</span><br></pre></td></tr></table></figure><h3 id="缩进显示"><a href="#缩进显示" class="headerlink" title="缩进显示"></a>缩进显示</h3><p>子成员是一个数组，则可以在该项下面缩进一个空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line">import yaml</span><br><span class="line"></span><br><span class="line"># yaml 文件内容</span><br><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">ipaddr:</span><br><span class="line">- ens192:</span><br><span class="line">  # 下一级的定义要空两个空格以上</span><br><span class="line">  - 192.168.10.1</span><br><span class="line">  - 192.168.10.2</span><br><span class="line">  - 192.168.10.3</span><br><span class="line">file:</span><br><span class="line">  # 数组的子成员还是一个数组，空一个空格即可</span><br><span class="line">  -</span><br><span class="line">   - etc</span><br><span class="line">   - sysconfig</span><br><span class="line">   - network-scripts</span><br><span class="line">   - ifcfg-ens192</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line">print(value)</span><br><span class="line"># 这里使用pprint打印稍微美观一些</span><br><span class="line">pprint(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;ipaddr&#x27;: [&#123;&#x27;ens192&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;], &#x27;file&#x27;: [[&#x27;etc&#x27;, &#x27;sysconfig&#x27;, &#x27;network-scripts&#x27;, &#x27;ifcfg-ens192&#x27;]]&#125;</span><br><span class="line">&#123;&#x27;file&#x27;: [[&#x27;etc&#x27;, &#x27;sysconfig&#x27;, &#x27;network-scripts&#x27;, &#x27;ifcfg-ens192&#x27;]],</span><br><span class="line"> &#x27;ipaddr&#x27;: [&#123;&#x27;ens192&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="行内表示"><a href="#行内表示" class="headerlink" title="行内表示"></a>行内表示</h3><p>因为程序差不多，之后只提供yaml文件内容以及pprint打印的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">ipaddr:</span><br><span class="line"># 行内表示格式正确就行，中间的空格位数不影响</span><br><span class="line">- ens192: [ 192.168.10.1, 192.168.10.2, 192.168.10.3 ]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;ipaddr&#x27;: [&#123;&#x27;ens192&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>yaml中的常量包含以下几种</p><ul><li>字符串</li><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul><p>具体看以下示例应该就清楚了，不过多解释了</p><p>其中字符串有几个规则需要注意</p><ul><li>字符串默认不使用引号表示，如：<code>str: 这是一行字符串</code></li><li>如果字符串之中包含空格或特殊字符，需要放在引号之中，如：<code>str: &#39;内容：字符串&#39;</code></li><li>单引号和双引号都可以使用，双引号不会对特殊字符转义，如：<code>str: &#123;s1: &#39;内容\n字符串&#39;, s2: &quot;内容\n字符串&quot;&#125;</code></li><li>单引号之中如果还有单引号，必须连续使用两个单引号转义，如：<code>str: &#39;labor&#39;&#39;s day&#39;</code></li><li>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格</li><li>多行字符串可以使用 | 保留换行符，也可以使用 &gt; 折叠换行，下一节会介绍</li><li><ul><li>表示保留文字块末尾的换行，- 表示删除字符串末尾的换行，下一节会介绍</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">boolean:</span><br><span class="line">    # true,True都可以</span><br><span class="line">    - TRUE</span><br><span class="line">    # false，False都可以</span><br><span class="line">    - FALSE</span><br><span class="line">float:</span><br><span class="line">    - 3.14</span><br><span class="line">    # 可以使用科学计数法</span><br><span class="line">    - 6.8523015e+5</span><br><span class="line">int:</span><br><span class="line">    - 123</span><br><span class="line">    # 二进制表示</span><br><span class="line">    - 0b1010_0111_0100_1010_1110</span><br><span class="line">null:</span><br><span class="line">    nodeName: &#x27;node&#x27;</span><br><span class="line">    # 使用~表示null</span><br><span class="line">    parent: ~</span><br><span class="line">string:</span><br><span class="line">    - 字符串行</span><br><span class="line">    - newline</span><br><span class="line">    # 可以使用双引号或者单引号包裹特殊字符</span><br><span class="line">    - &#x27;Hello world&#x27;</span><br><span class="line">    # 字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="line">    - one_line</span><br><span class="line">      two_line</span><br><span class="line">date:</span><br><span class="line">    # 日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="line">    - 2018-02-17</span><br><span class="line">datetime:</span><br><span class="line">    # 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br><span class="line">    -  2018-02-17T15:02:31+08:00</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;None: &#123;&#x27;nodeName&#x27;: &#x27;node&#x27;, &#x27;parent&#x27;: None&#125;,</span><br><span class="line"> &#x27;boolean&#x27;: [True, False],</span><br><span class="line"> &#x27;date&#x27;: [datetime.date(2018, 2, 17)],</span><br><span class="line"> &#x27;datetime&#x27;: [datetime.datetime(2018, 2, 17, 15, 2, 31, tzinfo=datetime.timezone(datetime.timedelta(seconds=28800)))],</span><br><span class="line"> &#x27;float&#x27;: [3.14, 685230.15],</span><br><span class="line"> &#x27;int&#x27;: [123, 685230],</span><br><span class="line"> &#x27;string&#x27;: [&#x27;字符串行&#x27;, &#x27;newline&#x27;, &#x27;Hello world&#x27;, &#x27;one_line two_line&#x27;]&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><h3 id="类型强转"><a href="#类型强转" class="headerlink" title="!! 类型强转"></a>!! 类型强转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">int2string: !!str 123</span><br><span class="line">boolean2string: !!str true</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;boolean2string&#x27;: &#x27;true&#x27;, &#x27;int2string&#x27;: &#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="…-和-—"><a href="#…-和-—" class="headerlink" title="… 和 —"></a>… 和 —</h3><p>… 和—配合使用，在一个配置文件中代表一个文件的结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line">import yaml</span><br><span class="line"></span><br><span class="line"># yaml 文件内容</span><br><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">---</span><br><span class="line">time: 10:05:07</span><br><span class="line">user: userA</span><br><span class="line">action: &#x27;delete job (id: 13579)&#x27;</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">time: 11:13:45</span><br><span class="line">user: userB</span><br><span class="line">action: download dataset A</span><br><span class="line">...</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">values = yaml.safe_load_all(yaml_context)</span><br><span class="line"></span><br><span class="line">print(values)</span><br><span class="line">for value in values:</span><br><span class="line">    pprint(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object load_all at 0x000001C786A58C80&gt;</span><br><span class="line">&#123;&#x27;action&#x27;: &#x27;delete job (id: 13579)&#x27;, &#x27;time&#x27;: 36307, &#x27;user&#x27;: &#x27;userA&#x27;&#125;</span><br><span class="line">&#123;&#x27;action&#x27;: &#x27;download dataset A&#x27;, &#x27;time&#x27;: 40425, &#x27;user&#x27;: &#x27;userB&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="控制符-和-gt-控制符"><a href="#控制符-和-gt-控制符" class="headerlink" title="| 控制符 和 &gt; 控制符"></a>| 控制符 和 &gt; 控制符</h3><p>这两个符号是YAML中字符串经常使用的符号</p><h4 id="控制符"><a href="#控制符" class="headerlink" title="| 控制符"></a>| 控制符</h4><p>这个控制符的作用是保留文本每一行尾部的换行符。</p><ul><li>| 保证整段文本最后有且只有一个换行符</li><li>|+ 保留整段文本最后的所有换行符</li><li>|- 删除整段文本最后的所有换行符</li></ul><ol><li><p>最后有且只有一个换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: |</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash\n-c \n\n\nsleep 3600\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>保留整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: |+</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash\n-c \n\n\nsleep 3600\n\n\n\n\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: |-</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash\n-c \n\n\nsleep 3600&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="gt-控制符"><a href="#gt-控制符" class="headerlink" title="&gt; 控制符"></a>&gt; 控制符</h4><p>这个控制符的作用是将每一行尾部的换行符替换为空格，也就是将多行文本视为一行</p><ul><li><blockquote><p>保证文本最后有且只有一个换行符</p></blockquote></li><li><blockquote><ul><li>保留文本最后的所有换行符</li></ul></blockquote></li><li><blockquote><ul><li>删除文本最后的所有换行符</li></ul></blockquote></li></ul><ol><li><p>最后有且只有一个换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: &gt;</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash -c \n\nsleep 3600\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>保留整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: &gt;+</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash -c \n\nsleep 3600\n\n\n\n\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: &gt;-</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash -c \n\nsleep 3600&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="引用-amp-和"><a href="#引用-amp-和" class="headerlink" title="引用 &amp; 和 *"></a>引用 &amp; 和 *</h3><p>重复的内容在YAML中可以使用&amp;来完成锚点定义，使用*来完成锚点引用，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">defaults: &amp;defaults</span><br><span class="line">  host: localhost</span><br><span class="line">  db: postgres</span><br><span class="line"></span><br><span class="line">production:</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line">  host: 10.10.10.123</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  db: mysql</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">staging:</span><br><span class="line">  env: *defaults</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;defaults&#x27;: &#123;&#x27;db&#x27;: &#x27;postgres&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;&#125;,</span><br><span class="line"> &#x27;development&#x27;: &#123;&#x27;db&#x27;: &#x27;mysql&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;&#125;,</span><br><span class="line"> &#x27;production&#x27;: &#123;&#x27;db&#x27;: &#x27;postgres&#x27;, &#x27;host&#x27;: &#x27;10.10.10.123&#x27;&#125;,</span><br><span class="line"> &#x27;staging&#x27;: &#123;&#x27;env&#x27;: &#123;&#x27;db&#x27;: &#x27;postgres&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>CentOS 搭建 nfs server</p><h1 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h1><ol><li><p>安装软件包</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y rpcbind nfs-utils</span><br></pre></td></tr></table></figure></li><li><p>创建共享目录</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir -p /srv/data/nfs_data</span><br><span class="line"># chmod 777 /srv/data/nfs_data</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><p>将配置文件exports填写以下内容</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/exports</span><br><span class="line"></span><br><span class="line">/data/nfs_data/data *(insecure,rw,sync,no_root_squash,fsid=0)</span><br></pre></td></tr></table></figure></li><li><p>启动 nfs 服务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rpcbind</span><br><span class="line">systemctl enable nfs-server</span><br><span class="line"></span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs-server</span><br></pre></td></tr></table></figure></li><li><p>检查配置是否生效</p><p>使用 exportfs 命令，会显示共享的目录</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># exportfs</span><br><span class="line">/srv/data/nfs_data</span><br><span class="line">                &lt;world&gt;</span><br></pre></td></tr></table></figure></li><li><p>开发防火墙</p><p>服务器端开放 111、662、875、892、2049 的 tcp &#x2F; udp 端口即可</p></li></ol><h1 id="客户端挂载"><a href="#客户端挂载" class="headerlink" title="客户端挂载"></a>客户端挂载</h1><ol><li><p>客户端安装软件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br></pre></td></tr></table></figure></li><li><p>执行命令检查共享目录</p><p>使用命令 showmount 进行显示，注意替换成当前的服务器地址，这里是 10.6.70.4</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># showmount -e 10.6.70.4</span><br><span class="line">Export list for 10.6.70.4:</span><br><span class="line">/srv/data/nfs_data *</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>挂载并测试</p><p>客户端挂载并创建测试文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ls /mnt/</span><br><span class="line"># mount -t nfs 10.6.70.4:/ /mnt/</span><br><span class="line"># ls /mnt/</span><br><span class="line"># echo &#x27;aaa&#x27; &gt; /mnt/a.txt</span><br></pre></td></tr></table></figure><p>服务器端查看目录，可以看到已经生成文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /srv/data/nfs_data/a.txt</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 介绍</title>
      <link href="/docker-introduction/"/>
      <url>/docker-introduction/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><h1 id="认识docker"><a href="#认识docker" class="headerlink" title="认识docker"></a>认识docker</h1><p>Docker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。</p><p>Hypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。</p><p>Container Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。Docker是其中最知名的一种容器Container Runtime，其他的还有 CoreOS 容器 Rkt ，Podman。</p><span id="more"></span><p><img src="/post/docker/docker-different.svg" alt="docker-different"></p><p>docker能做什么呢？ 它主要基于轻量的特性，解决软件交付过程中的环境依赖</p><ul><li>可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署</li><li>可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删）</li><li>container容器之间相互隔离，且每个容器可以设置资源限额</li><li>提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立</li></ul><h1 id="docker的发展史"><a href="#docker的发展史" class="headerlink" title="docker的发展史"></a>docker的发展史</h1><p>13年成立，15年开始，迎来了飞速发展。</p><p>Docker 1.8 之前，使用<a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，Docker在上层做了封装， 把LXC复杂的容器创建与使用方式简化为自己的一套命令体系。</p><p>之后，为了实现跨平台等复杂的场景，Docker抽出了libcontainer项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。</p><p>2015年6月，Docker牵头成立了 OCI（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。</p><p>OCI成立后，libcontainer 交给OCI组织来维护，但是libcontainer中只包含了与kernel交互的库，因此基于libcontainer项目，后面又加入了一个CLI工具，并且项目改名为runC (<a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a> )， 目前runC已经成为一个功能强大的runtime工具。</p><p>Docker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了<strong>containerd</strong>。containerd向上为Docker Daemon提供了<code>gRPC接口</code>，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过<code>containerd-shim</code>结合<code>runC</code>，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。</p><p><img src="/post/docker/containerd.png" alt="containerd"></p><ul><li>runC（libcontainer）是符合OCI标准的一个实现，与底层系统交互</li><li>containerd是实现了OCI之上的容器的高级功能，比如镜像管理、容器执行的调用等</li><li>Dockerd目前是最上层与CLI交互的进程，接收cli的请求并与containerd协作</li></ul><h1 id="docker总结"><a href="#docker总结" class="headerlink" title="docker总结"></a>docker总结</h1><ol><li>为了提供一种更加轻量的虚拟化技术，docker出现了</li><li>借助于docker容器的轻、快等特性，解决了软件交付过程中的环境依赖问题，使得docker得以快速发展</li><li>Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理</li><li>docker-ce，每季度发布stable版本。18.06，18.09，19.03</li><li>发展至今，docker已经通过制定OCI标准对最初的项目做了拆分，其中runC和containerd是docker的核心项目，理解docker整个请求的流程，对我们深入理解docker有很大的帮助</li></ol><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>docker安装查看这篇文章 <a href="http://www.ganchangde.com/article/cc0cb74b891f731e4f37c683b3f7362b5481e0f1_Vc1tfQHK_0">docker安装（Centos8版本）</a></p><h1 id="核心要素"><a href="#核心要素" class="headerlink" title="核心要素"></a>核心要素</h1><p>docker中的三大核心要素：镜像(Image)、容器(Container)、仓库(Registry)</p><ol><li>镜像（Image）:打包了业务代码及运行环境的包，是静态的文件，不能直接对外提供服务。</li><li>容器（Container）: 镜像的运行时，可以对外提供服务。</li><li>仓库（Registry）: 存放镜像的地方<ul><li>公有仓库，Docker Hub，阿里仓库，网易仓库…</li><li>私有仓库，企业内部搭建<ul><li>Docker Registry，Docker官方提供的镜像仓库存储服务</li><li>Harbor, 是Docker Registry的更高级封装，它除了提供友好的Web UI界面，角色和用户权限管理，用户操作审计等功能</li></ul></li><li>镜像访问地址形式 registry.devops.com&#x2F;demo&#x2F;hello:latest,若没有前面的url地址，则默认寻找Docker Hub中的镜像，若没有tag标签，则使用latest作为标签。 比如，docker pull nginx，会被解析成docker.io&#x2F;library&#x2F;nginx:latest</li><li>公有的仓库中，一般存在这么几类镜像<ul><li>操作系统基础镜像（centos，ubuntu，suse，alpine）</li><li>中间件（nginx，redis，mysql，tomcat）</li><li>语言编译环境（python，java，golang）</li><li>业务镜像（django-demo…）</li></ul></li></ul></li></ol><p>容器和仓库不会直接交互，都是以镜像为载体来操作。</p><h1 id="docker基本命令"><a href="#docker基本命令" class="headerlink" title="docker基本命令"></a>docker基本命令</h1><p><img src="/post/docker/docker-command.jpg" alt="docker-command"></p><ol><li><p>查看镜像列表</p><p>根据以下指标确定唯一镜像</p><ul><li>image_id</li><li>repository:tag</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx         alpine              377c0837328f        2 weeks ago         19.7MB</span><br></pre></td></tr></table></figure></li><li><p>如何获取镜像</p><ul><li><p>从远程仓库拉取</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐alpine</span></span><br><span class="line">$ docker pull nginx:alpine</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure></li><li><p>使用tag命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure></li><li><p>本地构建（通过Dockerfile）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t my-nginx:ubuntu -f Dockerfile</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如何通过镜像启动容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name my-nginx-alpine -d nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>如何知道容器内部运行了什么程序？</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部,分配一个tty终端</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti my-nginx-alpine /bin/sh</span><br><span class="line"><span class="comment"># ps aux</span></span><br></pre></td></tr></table></figure></li><li><p>docker怎么知道容器启动后该执行什么命令？</p><p> 通过docker build来模拟构建一个nginx的镜像，</p><ul><li><p>创建Dockerfile</p>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告诉docker使用哪个基础镜像作为模板，后续命令都以这个镜像为基础 </span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list &amp;&amp; sed -i <span class="string">&#x27;s/security.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN命令会在上面指定的镜像里执行命令 </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt install -y nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#告诉docker，启动容器时执行如下命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>构建本地镜像</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t my-nginx:ubuntu -f Dockerfile</span><br></pre></td></tr></table></figure></li><li><p>使用新镜像启动容器</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name my-nginx-ubuntu -d my-nginx:ubuntu</span><br></pre></td></tr></table></figure></li><li><p>进入容器查看进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -ti my-nginx-ubuntu /bin/sh</span><br><span class="line"><span class="comment"># ps aux</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如何访问容器内服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti my-nginx-alpine /bin/sh</span><br><span class="line"><span class="comment"># ps aux|grep nginx</span></span><br><span class="line"><span class="comment"># curl localhost:80</span></span><br></pre></td></tr></table></figure></li><li><p>宿主机中如何访问容器服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删掉旧服务,重新启动</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f my-nginx-alpine</span><br><span class="line">$ docker run --name my-nginx-alpine -d -p 8080:80 nginx:alpine</span><br><span class="line">$ curl 172.21.51.143:8080</span><br></pre></td></tr></table></figure></li><li><p>docker client如何与daemon通信</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /var/run/docker.sock</span></span><br><span class="line">$ docker run --name portainer -d -p 9001:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span><br></pre></td></tr></table></figure></li><li><p>导出镜像到文件中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save -o nginx-alpine.tar nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>从文件中加载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i nginx-alpine.tar</span><br></pre></td></tr></table></figure></li><li><p>部署带认证的镜像仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Docker Registry 认证文件目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /var/lib/registry_auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 htpasswd 来创建加密文件</span></span><br><span class="line">yum install -y httpd-tools</span><br><span class="line">htpasswd -Bbn admin admin &gt; /var/lib/registry_auth/htpasswd</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用docker镜像启动镜像仓库服务</span></span><br><span class="line">docker run -p 5000:5000 \</span><br><span class="line">--restart=always \</span><br><span class="line">--name registry \</span><br><span class="line">-v /var/lib/registry:/var/lib/registry \</span><br><span class="line">-v /var/lib/registry_auth/:/auth/ \</span><br><span class="line">-e <span class="string">&quot;REGISTRY_AUTH=htpasswd&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd&quot;</span> \</span><br><span class="line">-d registry</span><br></pre></td></tr></table></figure></li><li><p>推送本地镜像到镜像仓库中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 镜像仓库给外部访问，不能通过localhost，尝试使用内网地址172.21.51.143:5000/nginx:alpine</span></span><br><span class="line">docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine</span><br><span class="line">docker push 172.21.51.143:5000/nginx:alpine</span><br><span class="line">The push refers to repository [172.21.51.143:5000/nginx]</span><br><span class="line">Get https://172.21.51.143:5000/v2/: http: server gave HTTP response to HTTPS client</span><br><span class="line"><span class="comment">## docker默认不允许向http的仓库地址推送，如何做成https的，参考：https://docs.docker.com/registry/deploying/#run-an-externally-accessible-registry</span></span><br><span class="line"><span class="comment">## 我们没有可信证书机构颁发的证书和域名，自签名证书需要在每个节点中拷贝证书文件，比较麻烦，因此我们通过配置daemon的方式，来跳过证书的验证：</span></span><br><span class="line"><span class="built_in">cat</span> /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://8xpk5wnt.mirror.aliyuncs.com&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;172.21.51.143:5000&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">systemctl restart docker</span><br><span class="line">docker push 172.21.51.143:5000/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会提示认证失败 ，no basic auth credentials,需要登录</span></span><br><span class="line">docker login 172.21.51.143:5000</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看仓库内元数据</span></span><br><span class="line">curl -u admin:admin -X GET http://172.21.51.143:5000/v2/_catalog</span><br><span class="line">curl -u admin:admin  -X GET http://172.21.51.143:5000/v2/nginx/tags/list</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>查看容器列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看运行状态的容器列表</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看全部状态的容器列表</span></span><br><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 后台启动</span></span><br><span class="line">$ docker run --name nginx -d nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">## 映射端口,把容器的端口映射到宿主机中,-p &lt;host_port&gt;:&lt;container_port&gt;</span></span><br><span class="line">$ docker run --name nginx -d -p 8080:80 nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">## 资源限制,最大可用内存500M</span></span><br><span class="line">$ docker run --memory=500m nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>容器数据持久化</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 挂载主机目录</span></span><br><span class="line">$ docker run --name nginx -d -v /opt:/opt nginx:alpine</span><br><span class="line">$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d -v /opt/mysql/:/var/lib/mysql mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>进入容器或者执行容器内的命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -ti &lt;container_id_or_name&gt; /bin/sh</span><br><span class="line">$ docker <span class="built_in">exec</span> &lt;container_id_or_name&gt; hostname</span><br></pre></td></tr></table></figure></li><li><p>主机与容器之间拷贝数据</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 主机拷贝到容器</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;data&#x27;</span>&gt;/tmp/test.txt</span><br><span class="line">$ docker <span class="built_in">cp</span> /tmp/test.txt nginx:/tmp</span><br><span class="line">$ docker <span class="built_in">exec</span> nginx <span class="built_in">cat</span> /tmp/test.txt</span><br><span class="line">data</span><br><span class="line"></span><br><span class="line"><span class="comment">## 容器拷贝到主机</span></span><br><span class="line">$ docker <span class="built_in">cp</span> nginx:/tmp/test.txt ./</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看全部日志</span></span><br><span class="line">$ docker logs nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 实时查看最新日志</span></span><br><span class="line">$ docker logs -f nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从最新的100条开始查看</span></span><br><span class="line">$ docker logs --<span class="built_in">tail</span>=100 -f nginx</span><br></pre></td></tr></table></figure></li><li><p>停止或者删除容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 停止运行中的容器</span></span><br><span class="line">$ docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动退出容器</span></span><br><span class="line">$ docker start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除非运行中状态的容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除运行中的容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f nginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器或者镜像的明细</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看容器详细信息，包括容器IP地址等</span></span><br><span class="line">$ docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看镜像的明细信息</span></span><br><span class="line">$ docker inspect nginx:alpine</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 设计模式 03</title>
      <link href="/python-design-patterns-03/"/>
      <url>/python-design-patterns-03/</url>
      
        <content type="html"><![CDATA[<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><span id="more"></span><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>给定一个语言，定义它的文法、语法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p>主要是解释器使用，这里省略</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>责任链模式，将多个处理方法连接成一条链条，请求将在这条链条上流动直到该链条中有一个节点可以处理该请求。通常这条链条是一个对象包含对另一个对象的引用而形成链条，每个节点有对请求的条件，当不满足条件将传递给下一个节点处理。</p><p>责任链模式就是种“推卸”责任的模式，你的问题在我这里能解决我就解决，不行就把你推给另一个对象。至于到底谁解决了这个问题了呢?我管呢!</p><h3 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象处理者(Handler)：定义了处理请求的抽象方法和一个设置责任链的下一个处理者的方法。</li><li>具体处理者(ConcreteHandler)：实现处理请求的方法，判断自己能否处理本次请求，如果能，则处理，如果不能，则把请求转发给责任链的下一个处理者。</li><li>客户类(Client)：创建处理链，对链头提交请求，并不需要关心处理细节。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>若某个请求可以由多个对象进行处理，但具体由哪个对象处理该请求则是由请求内容和对象处理权限确定。</li><li>在请求处理者不明确的情况下，对多个处理者中的一个提交请求。</li><li>需要动态处理一组对象处理请求，比如新增新的处理者。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Request(Enum):</span><br><span class="line">    VACATION = 1</span><br><span class="line">    SALARY_RAISE = 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Handler(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def set_next(self, handler):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def handle(self, request: Request, number: int):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteHandler(Handler):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._next = None</span><br><span class="line"></span><br><span class="line">    def set_next(self, handler):</span><br><span class="line">        self._next = handler</span><br><span class="line">        return handler</span><br><span class="line"></span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if self._next:</span><br><span class="line">            return self._next.handle(request, number)</span><br><span class="line">        print(&quot;No handler found for request: &#123;&#125;&quot;.format(request))</span><br><span class="line"></span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            print(&quot;You can&#x27;t take a vacation.&quot;)</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            print(&quot;You can&#x27;t get a raise.&quot;)</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GeneralManager(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 10:</span><br><span class="line">                print(&quot;General Manager: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 1000:</span><br><span class="line">                print(&quot;General Manager: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DepartmentManager(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 5:</span><br><span class="line">                print(&quot;Department Manager: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 500:</span><br><span class="line">                print(&quot;Department Manager: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        print(&quot;Department Manager: My permissions are insufficient. I&#x27;ll pass this request to next one.&quot;)</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Supervisor(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 3:</span><br><span class="line">                print(&quot;Supervisor: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 300:</span><br><span class="line">                print(&quot;Supervisor: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        print(&quot;Supervisor: My permissions are insufficient. I&#x27;ll pass this request to next one.&quot;)</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Employee(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 1:</span><br><span class="line">                print(&quot;Employee: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 100:</span><br><span class="line">                print(&quot;Employee: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        print(&quot;Employee: My permissions are insufficient. I&#x27;ll pass this request to next one.&quot;)</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Client:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._employee = Employee()</span><br><span class="line">        self._supervisor = Supervisor()</span><br><span class="line">        self._department_manager = DepartmentManager()</span><br><span class="line">        self._general_manager = GeneralManager()</span><br><span class="line"></span><br><span class="line">        self._employee.set_next(self._supervisor).set_next(self._department_manager).set_next(self._general_manager)</span><br><span class="line"></span><br><span class="line">    def make_request(self, request, number):</span><br><span class="line">        self._employee.handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    client = Client()</span><br><span class="line">    print(&quot;######## Client: I want to take a vacation for 2 days.&quot;)</span><br><span class="line">    client.make_request(Request.VACATION, 2)</span><br><span class="line">    print(&quot;######## Client: I want to raise my salary for 200.&quot;)</span><br><span class="line">    client.make_request(Request.SALARY_RAISE, 200)</span><br><span class="line">    print(&quot;######## Client: I want to take a vacation for 7 days.&quot;)</span><br><span class="line">    client.make_request(Request.VACATION, 7)</span><br><span class="line">    print(&quot;######## Client: I want to raise my salary for 600.&quot;)</span><br><span class="line">    client.make_request(Request.SALARY_RAISE, 600)</span><br><span class="line">    print(&quot;######## Client: I want to take a vacation for 12 days.&quot;)</span><br><span class="line">    client.make_request(Request.VACATION, 12)</span><br><span class="line">    print(&quot;######## Client: I want to raise my salary for 1200.&quot;)</span><br><span class="line">    client.make_request(Request.SALARY_RAISE, 1200)</span><br></pre></td></tr></table></figure><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>命令模式可将请求转换为一个包含与请求相关的所有信息的独立对象，这个独立对象实现了调用者与接收者之间的解耦，命令模式最大的杀手锏是它能非常轻松的实现撤销操作。</p><p>主要的应用场景就是GUI，将每一个具体命令封装称为一个类，使用不同的命令则调用不同的类，参数通过类进行传递。</p><p>这里省略</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来，放入一个独立的迭代器对象中。迭代器类定义了访问该列表元素的接口。迭代器类提供的方法负责跟踪当前的元素，即它知道哪些元素已经遍历过了，哪些元素还没有被遍历。</p><p>迭代器模式能够提供一种方法按照顺序访问一个聚合对象中的所有元素，而又不需要暴露该对象的内部表示。</p><p>python中提供了iter()方法实现，这里略过</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p><p>主要使用在多个类相互耦合，形成了网状结构时，将上述网状结构分离为星型结构。</p><h3 id="角色：-1"><a href="#角色：-1" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li><li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li><li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>如机场调度系统（多个跑道、飞机、指挥塔之间的调度）</li><li>路由系统；著名的MVC框架中，其中的C（Controller）就是M（Model）和V（View）的中介者。</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象中介者</span><br><span class="line">class Mediator(ABC):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.x = 0</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def register(self, colleague):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象同事类</span><br><span class="line">class Colleague:</span><br><span class="line">    def __init__(self, name, x):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体同事类 汽车</span><br><span class="line">class ConcreteColleagueCar(Colleague):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体同事类 鸟</span><br><span class="line">class ConcreteColleagueBird(Colleague):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体中介类</span><br><span class="line">class ConcreteMediator(Mediator):</span><br><span class="line">    collections = []</span><br><span class="line"></span><br><span class="line">    def register(self, colleague):</span><br><span class="line">        self.collections.append(colleague)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        for colleague in self.collections:</span><br><span class="line">            print(colleague.name, colleague.x)</span><br><span class="line">            print(f&#x27;place x is &#123;self.x&#125; - &#123;self.x + colleague.x&#125;&#x27;)</span><br><span class="line">            self.x = self.x + colleague.x + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mediator = ConcreteMediator()</span><br><span class="line">    car1 = ConcreteColleagueCar(&#x27;car1&#x27;, 1)</span><br><span class="line">    car2 = ConcreteColleagueCar(&#x27;car2&#x27;, 1)</span><br><span class="line">    bird1 = ConcreteColleagueBird(&#x27;bird1&#x27;, 2)</span><br><span class="line">    bird2 = ConcreteColleagueBird(&#x27;bird2&#x27;, 2)</span><br><span class="line">    mediator.register(car1)</span><br><span class="line">    mediator.register(car2)</span><br><span class="line">    mediator.register(bird1)</span><br><span class="line">    mediator.register(bird2)</span><br><span class="line"></span><br><span class="line">    mediator.show()</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>通过让对象彼此解耦，增加对象的复用性</li><li>通过将控制逻辑集中，可以简化系统维护</li><li>通过中介者使一对多变成了一对一，便于理解</li><li>符合迪米特原则</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>在具体中介者类中包含了同事之间的交互细节，如果设计不好，引入中介者会使程序变的复杂</li><li>中介者承担过多责任，是中心化模式，若中介者出现了问题，整个系统将会崩溃</li></ol><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.bilibili.com/video/BV1Y8411V7gR/">一个被Eclipse，NetBean等项目使用的设计模式</a></p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><p>备忘录模式（Memento Pattern）用于保存一个对象的某个状态，以便在适当的时候恢复对象。特点是不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br>跟原型模式很像，不过在原型模式中保存对象的一切，而备忘录模式中只保存恢复时需要的数据。</p><h3 id="角色：-2"><a href="#角色：-2" class="headerlink" title="角色："></a>角色：</h3><ul><li>Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。</li><li>Memento(备忘录)<br>：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。</li><li>Caretaker(管理者): 负责备忘录Memento，不能对Memento的内容进行访问或者操作。</li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>需要保存和恢复数据的相关状态场景。如保存游戏状态的场景；撤销场景，如Ctrl-Z操作；事务回滚的应用。一般情况下事务回滚有两种方式：一是把从恢复点开始的操作都反向执行一遍；二是直接恢复到恢复点的各种状态。两种方式各有优缺点，要结合业务场景，决定使用哪种模式；</li><li>副本监控场景。备忘录可以当作一个临时的副本监控，实现非实时和准实时的监控。</li></ol><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Originator(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def save(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def restore(self, memento):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def set(self, state):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def get(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteOriginator(Originator):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._state = None</span><br><span class="line"></span><br><span class="line">    def save(self):</span><br><span class="line">        return ConcreteMemento(self._state)</span><br><span class="line"></span><br><span class="line">    def restore(self, memento):</span><br><span class="line">        self._state = memento.get_state()</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        print(f&quot;State: &#123;self._state&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def set(self, state):</span><br><span class="line">        self._state = state</span><br><span class="line"></span><br><span class="line">    def get(self):</span><br><span class="line">        return self._state</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Memento(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def get_name(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def get_date(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteMemento(Memento):</span><br><span class="line">    def __init__(self, state):</span><br><span class="line">        self._state = state</span><br><span class="line">        self._date = str(datetime.now())[:19]</span><br><span class="line"></span><br><span class="line">    def get_state(self):</span><br><span class="line">        return self._state</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        return f&quot;&#123;self._date&#125; / (&#123;self._state[0:9]&#125;...)&quot;</span><br><span class="line"></span><br><span class="line">    def get_date(self):</span><br><span class="line">        return self._date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Caretaker:</span><br><span class="line">    def __init__(self, originator):</span><br><span class="line">        self._mementos = []</span><br><span class="line">        self._originator = originator</span><br><span class="line"></span><br><span class="line">    def backup(self):</span><br><span class="line">        print(&quot;Caretaker: Saving Originator&#x27;s state...&quot;)</span><br><span class="line">        self._mementos.append(self._originator.save())</span><br><span class="line"></span><br><span class="line">    def undo(self):</span><br><span class="line">        if not len(self._mementos):</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        memento = self._mementos.pop()</span><br><span class="line">        print(f&quot;Caretaker: Restoring state to: &#123;memento.get_name()&#125;&quot;)</span><br><span class="line">        try:</span><br><span class="line">            self._originator.restore(memento)</span><br><span class="line">        except Exception:</span><br><span class="line">            self.undo()</span><br><span class="line"></span><br><span class="line">    def show_history(self):</span><br><span class="line">        print(&quot;Caretaker: Here&#x27;s the list of mementos:&quot;)</span><br><span class="line">        for memento in self._mementos:</span><br><span class="line">            print(memento.get_name())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    originator = ConcreteOriginator()</span><br><span class="line">    caretaker = Caretaker(originator)</span><br><span class="line"></span><br><span class="line">    originator.set(&quot;State #1&quot;)</span><br><span class="line">    originator.set(&quot;State #2&quot;)</span><br><span class="line">    caretaker.backup()</span><br><span class="line"></span><br><span class="line">    originator.set(&quot;State #3&quot;)</span><br><span class="line">    caretaker.backup()</span><br><span class="line"></span><br><span class="line">    originator.set(&quot;State #4&quot;)</span><br><span class="line">    caretaker.backup()</span><br><span class="line"></span><br><span class="line">    caretaker.undo()</span><br><span class="line">    caretaker.undo()</span><br><span class="line"></span><br><span class="line">    caretaker.show_history()</span><br><span class="line"></span><br><span class="line">    print(&quot;\nClient: Now, let&#x27;s rollback!\n&quot;)</span><br><span class="line">    caretaker.undo()</span><br><span class="line"></span><br><span class="line">    originator.show()</span><br><span class="line"></span><br><span class="line">    # Output:</span><br><span class="line">    # Caretaker: Saving Originator&#x27;s state...</span><br><span class="line">    # Caretaker: Saving Originator&#x27;s state...</span><br><span class="line">    # Caretaker: Restoring state to: 2020-07-07 22:07:54 / (State #4...)</span><br><span class="line">    # Caretaker: Restoring state to: 2020-07-07 22:07:54 / (State #3...)</span><br><span class="line">    # Caretaker: Here&#x27;s the list of mementos:</span><br><span class="line">    # 2020-07-07 22:07:54 / (State #2...)</span><br><span class="line">    #</span><br><span class="line">    # Client: Now, let&#x27;s rollback!</span><br><span class="line">    #</span><br><span class="line">    # Caretaker: Restoring state to: 2020-07-07 22:07:54 / (State #2...)</span><br><span class="line">    # State: State #2</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，<br>使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</li><li>本模式简化了发起人的类。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需<br>要的这些状态的版本。</li><li>当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。</li><li>当负责人角色将一个备忘录存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。</li><li>当发起人角色的状态改变的时候，有可能这个协议无效。</li></ol><h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.bilibili.com/video/BV1Za4113734">用Java实现Redis的RDB机制 离不开这个设计模式</a></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="内容-6"><a href="#内容-6" class="headerlink" title="内容"></a>内容</h3><p>观察者模式应用比较广泛，又被称为“发布-订阅”模式。它用来定义对象间一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都得到通知并被自动更新。</p><h3 id="角色：-3"><a href="#角色：-3" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象主题(Subject)</li><li>具体主题（ConcreteSubject）– 发布者</li><li>抽象观察者(Observer)</li><li>具体观察者（ConcreteObserver）– 订阅者</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当一个抽象模型有两个方面，其中一个方面依赖另一个方面。将这两者封装在独立对象中以使它们可以各自独立地改变和复用</li><li>当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象待改变</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧耦合的。</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象主题</span><br><span class="line">class Subject(object):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def register(self, observer):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def unregister(self, observer):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def notify(self, notice):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象的订阅者</span><br><span class="line">class Observer(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def update(self, notice):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param notice: Notice类的对象</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体主题， 微信服务号</span><br><span class="line">class ConcreteSubject(Subject):</span><br><span class="line">    def __init__(self, service_name):</span><br><span class="line">        self._users = []</span><br><span class="line"></span><br><span class="line">        # 服务号名称</span><br><span class="line">        self.service_name = service_name</span><br><span class="line"></span><br><span class="line">    # 添加订阅者信息</span><br><span class="line">    def register(self, observer):</span><br><span class="line">        if observer not in self._users:</span><br><span class="line">            self._users.append(observer)</span><br><span class="line"></span><br><span class="line">    # 用户取消关注，取消订阅者</span><br><span class="line">    def unregister(self, observer):</span><br><span class="line">        self._users.remove(observer)</span><br><span class="line"></span><br><span class="line">    # 通知所有订阅者</span><br><span class="line">    def notify(self, notice):</span><br><span class="line">        for observer in self._users:</span><br><span class="line">            observer.update(notice)</span><br><span class="line"></span><br><span class="line">    # 发布消息</span><br><span class="line">    def write_new_post(self, post_name):</span><br><span class="line">        print(&#x27;微信服务号&#123;&#125;：&#123;&#125;&#x27;.format(self.service_name, post_name))</span><br><span class="line">        self.notify(post_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体订阅者，微信用户</span><br><span class="line">class ConcreteObserver(Observer):</span><br><span class="line">    def __init__(self, username):</span><br><span class="line">        self.username = username</span><br><span class="line"></span><br><span class="line">    def update(self, post_name):</span><br><span class="line">        print(f&#x27;微信用户&#123;self.username&#125;接收到消息，公众号发布了新帖子：&#123;post_name&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 程序入口</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 微信服务号</span><br><span class="line">    python_service = ConcreteSubject(&quot;Python论坛&quot;)</span><br><span class="line">    # 用户对象</span><br><span class="line">    user1 = ConcreteObserver(&#x27;cd&#x27;)</span><br><span class="line">    user2 = ConcreteObserver(&#x27;yx&#x27;)</span><br><span class="line">    user3 = ConcreteObserver(&#x27;xl&#x27;)</span><br><span class="line">    # 订阅Python论坛公帐号</span><br><span class="line">    python_service.register(user1)</span><br><span class="line">    python_service.register(user2)</span><br><span class="line">    python_service.register(user3)</span><br><span class="line">    # 公众号发布文章通知所有订阅</span><br><span class="line">    python_service.write_new_post(&quot;python设计模式01&quot;)</span><br><span class="line">    # 用户2取消订阅旅游知识号</span><br><span class="line">    python_service.unregister(user2)</span><br><span class="line">    # 取消订阅的用户接收不到通知</span><br><span class="line">    python_service.write_new_post(&quot;python设计模式02&quot;)</span><br><span class="line"></span><br><span class="line"># Output</span><br><span class="line"># 微信服务号Python论坛：python设计模式01</span><br><span class="line"># 微信用户cd接收到消息，公众号发布了新帖子：python设计模式01</span><br><span class="line"># 微信用户yx接收到消息，公众号发布了新帖子：python设计模式01</span><br><span class="line"># 微信用户xl接收到消息，公众号发布了新帖子：python设计模式01</span><br><span class="line"># 微信服务号Python论坛：python设计模式02</span><br><span class="line"># 微信用户cd接收到消息，公众号发布了新帖子：python设计模式02</span><br><span class="line"># 微信用户xl接收到消息，公众号发布了新帖子：python设计模式02</span><br></pre></td></tr></table></figure><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol><li>目标和观察者之间的抽象耦合最小</li><li>支持广播通信。</li></ol><h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><ul><li>中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。</li><li>中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接，<br>使得部分对象可作为其他对象的附属发挥作用。</li><li>有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。<br>当中介者以这种方式实现时， 它可能看上去与观察者非常相似。</li><li>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同，<br>但这仍是一种中介者模式。</li><li>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象，<br>而只有一些分布式的观察者。</li></ul><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="内容-7"><a href="#内容-7" class="headerlink" title="内容"></a>内容</h3><p>行为模式关注的是对象的响应性。它们通过对象之间的交互以实现更强大的功能。状态设计模式是一种行为设计模式，有时也被称为状态模式对象。在此模式中，一个对象可以基于其内部状态封装多个行为。状态模式也可以看作是在运行时改变对象行为的一种方式。</p><p>状态设计模式允许对象在其内部状态变化时改变其行为。这看起来就像对象本身已经改变了它的类一样。状态设计模式常用于开发有限状态机，并帮助协调状态处理操作。</p><h3 id="角色：-4"><a href="#角色：-4" class="headerlink" title="角色："></a>角色：</h3><ul><li>State：这被认为是封装对象行为的接口。这个行为与对象的状态相关联。</li><li>ConcreteState：这是实现State接口的子类。ConcreteState实现对象的特定状态相关联的实际行为</li><li>Context：这定义了客户感兴趣的接口。Context还维护一个ConcreteState子类的实例，该子类在内部定义了对象的特定状态的实现</li></ul><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class State(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def handle(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteStateA(State):</span><br><span class="line">    def handle(self):</span><br><span class="line">        print(&quot;ConcreteStateA&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteStateB(State):</span><br><span class="line">    def handle(self):</span><br><span class="line">        print(&quot;ConcreteStateB&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Context(State):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.state = None</span><br><span class="line"></span><br><span class="line">    def get_state(self):</span><br><span class="line">        return self.state</span><br><span class="line"></span><br><span class="line">    def set_state(self, state):</span><br><span class="line">        self.state = state</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        self.state.handle()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context = Context()</span><br><span class="line">state = ConcreteStateA()</span><br><span class="line">stateB = ConcreteStateB()</span><br><span class="line">context.set_state(state)</span><br><span class="line">context.handle()</span><br><span class="line">state = ConcreteStateB()</span><br><span class="line">context.set_state(state)</span><br><span class="line">context.handle()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算机开关机状态</span><br><span class="line">class ComputerState:</span><br><span class="line">    name = &#x27;state&#x27;</span><br><span class="line">    allowed = []</span><br><span class="line"></span><br><span class="line">    def switch(self, state):</span><br><span class="line">        if state.name in self.allowed:</span><br><span class="line">            print(&#x27;Current:&#x27;, self, &#x27;=&gt;switched to new state&#x27;, state.name)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;Current:&#x27;, self, &#x27;=&gt;switched to&#x27;, state.name, &#x27;not possible&#x27;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Off(ComputerState):</span><br><span class="line">    name = &#x27;off&#x27;</span><br><span class="line">    allowed = [&#x27;on&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class On(ComputerState):</span><br><span class="line">    name = &#x27;on&#x27;</span><br><span class="line">    allowed = [&#x27;off&#x27;, &#x27;suspend&#x27;, &#x27;hibernate&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Suspend(ComputerState):</span><br><span class="line">    name = &#x27;suspend&#x27;</span><br><span class="line">    allowed = [&#x27;on&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Hibernate(ComputerState):</span><br><span class="line">    name = &#x27;hibernate&#x27;</span><br><span class="line">    allowed = [&#x27;on&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Computer(object):</span><br><span class="line">    def __init__(self, model=&#x27;HP&#x27;):</span><br><span class="line">        self.model = model</span><br><span class="line">        self.state = Off()</span><br><span class="line"></span><br><span class="line">    def change(self, state):</span><br><span class="line">        self.state.switch(state)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    comp = Computer()</span><br><span class="line">    comp.change(On)</span><br><span class="line">    comp.change(Off)</span><br><span class="line">    comp.change(On)</span><br><span class="line">    comp.change(Suspend)</span><br><span class="line">    comp.change(Hibernate)</span><br><span class="line">    comp.change(On)</span><br><span class="line">    comp.change(Off)</span><br></pre></td></tr></table></figure><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>在状态设计模式中，对象的行为是其状态的函数结果，并且行为在运动时根据状态而改变。这消除了if&#x2F;else或switch&#x2F;case条件逻辑的依赖。</li><li>使用状态模式，实现多态行为的好处显而易见的，并且更易于添加状态来支持额外的行为</li><li>状态设计还提高了聚合性，因为特定于状态的行为被聚合到ConcreteState类中，并且放置在代码中的同一个地方</li><li>使用状态设计模式，通过只添加一个ConcreteState类来添加行为是非常容易的。因此，状态模式不仅改善了扩展应用程序行为时的灵活性，而且全面提高了代码的可维护性。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>类爆炸：由于每个状态都需要在ConcreteState的帮助下定义，因此我们可能导致创建了太多功能比较单一的类。我们不妨考虑有限状态机的情况——如果有许多状态，但是每个状态与另一个状态没有太大的不同，我们仍然需要将它们写成单独的ConcreteState类。这即增加了代码量，又使得状态机构更加难以审查。</li><li>随着每个新行为的引入，Context类都需要进行相应的更新处理每个行为。这使得上下文行为更容易受到每个新的行为的影响。</li></ul><h3 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.bilibili.com/video/BV1oi4y1g7Nn/">五分钟学设计模式.09.状态模式</a></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="内容-8"><a href="#内容-8" class="headerlink" title="内容"></a>内容</h3><p>定义一系列的算法，把它们封装起来，并且使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化。</p><h3 id="角色：-5"><a href="#角色：-5" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象策略 Strategy：定义了一个共同的接口。所有具体的算法类实现这个接口。环境（上下文）类 Context 使用这个接口调用具体的算法类。</li><li>具体策略 ConcreteStrategy：封装了具体的算法，实现同一个接口。</li><li>上下文 Context：环境（上下文）类。用于配置一个具体的算法策略对象，维持一个策略接口类型的参考（Reference），并且可以定义一个让接口<br>Strategy 的具体对象访问的接口。在简单情况下，Context 类可以省略。</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>在以下情况之一发生时可以使用策略模式。</p><ul><li>当有多个仅在行为上不同但是相关的类存在时，策略模式提供了一个为一个类配置多种行为之一的方法。</li><li>当一个算法使用用户不应该知道的数据时，使用策略模式可以将算法的实现细节隐藏起来，避免暴露与算法相关的复杂细节。注意，虽然可以将算法的实现细节封装起来，但是客户程序必须知道各个策略子类的接口。</li><li>当一个类有多种行为，这些行为以大块的条件语句实现时可以使用策略模式，这时可以将条件块移入它们自己的 Strategy 类。</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象策略</span><br><span class="line">class Strategy(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def execute(self, data):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体策略</span><br><span class="line">class CStrategy(Strategy):</span><br><span class="line">    def execute(self, data):</span><br><span class="line">        print(f&quot;使用C算法处理&#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体策略</span><br><span class="line">class NStrategy(Strategy):</span><br><span class="line">    def execute(self, data):</span><br><span class="line">        print(F&quot;使用N算法处理&#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 上下文</span><br><span class="line">class Context:</span><br><span class="line">    def __init__(self, strategy, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.strategy = strategy</span><br><span class="line">        # 可以定义用户不知道的东西</span><br><span class="line">        self.date = datetime.now()</span><br><span class="line"></span><br><span class="line">    def set_strategy(self, strategy):</span><br><span class="line">        self.strategy = strategy</span><br><span class="line"></span><br><span class="line">    def do_strategy(self):</span><br><span class="line">        self.strategy.execute(self.data)</span><br><span class="line"></span><br><span class="line"># Client</span><br><span class="line">data = &quot;Hello!&quot;</span><br><span class="line">context = Context(None, data)</span><br><span class="line"></span><br><span class="line"># 使用C算法处理</span><br><span class="line">context.set_strategy(CStrategy())</span><br><span class="line">context.do_strategy()</span><br><span class="line"># 使用N算法处理</span><br><span class="line">context.set_strategy(NStrategy())</span><br><span class="line">context.do_strategy()</span><br></pre></td></tr></table></figure><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ol><li>得到一系列可以复用的算法，这些算法继承一个共同的抽象类，因此共有的功能可以放到超类中。</li><li>将不同的算法封装在不同的策略子类中，使逻辑更加清晰，各个算法可以独立地变化，消除了大量的 if…else 语句。</li><li>提供了相同行为的不同实现。客户可以根据不同时间或空间要求选择不同的策略。</li><li>使功能改变或者扩展更容易。具体地说，修改一个算法不必重新编译“Client”与“Context”类。增加一个新算法时，在应用程序暂时还不想使用该新算法的情况下，不必重新编译“Client”与“Context”类。</li></ol><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这与“依赖倒置原则”是背道而驰的。</li><li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</li><li>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</li><li>在客户类中通常存在许多与策略类各个分支相关的条件语句，用于选择产生策略子类对象，然后将这些对象传递给 Context 类，而<br>Context 类则直接使用此对象调用策略模式的策略子类的方法。</li></ol><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="内容-9"><a href="#内容-9" class="headerlink" title="内容"></a>内容</h3><p>访问者模式是指作用于一个对象结构体上的元素的操作。访问者可以使用户在不改变该结构体中的类的基础上定义一个新的操作。</p><h3 id="角色：-6"><a href="#角色：-6" class="headerlink" title="角色："></a>角色：</h3><ul><li>Visitor：为每个 Element 的对象声明一个访问操作。该访问操作的名字最好要包含被访问的类的名字，以便确认该访问操作是专门针对哪个具体的类，如 visitFamilyNoChildren 是专门为了服务类 FamilyNoChildren 的。</li><li>ConcreteVisitor：实现 Visitor 声明的运算。每个运算实现为对应的类的对象定义的算法的一部分。ConcreteVisitor 提供算法的环境并且存储其局部状态。</li><li>Element：定义了一些基本的方法，其中包含提供基本数据的方法，例如一些 get()与 set()方法。重要的是，每个 Element 子类都必须定义一个接收者方法，该方法以 Visitor 为参数类型：Accept(Visitor)，其作用是为被访问者对象和访问者对象之间的交互提供接口。</li><li>ConcreteElement：具体的 Element 的子类，例如 ElementA，该类包含一个 accept 方法接收访问者对象。另外，该类还可能定义一些其他的方法以帮助访问者实现一些功能。</li><li>ObjectStructure：提供一个高层接口，允许访问者访问 Element 的子类。在该类中可以包含一个结构，例如 ArrayList、Vector 等，提供所要访问的 element 的列表。</li></ul><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当一个对象的结构中，包含有多种类型的具有不同接口的对象，且用户要在这些对象上进行依赖于具体的类的运算时，需要用到访问者模式。这就是为什么访问者模式要针对每个被访问的子类都设计一个不同的接口的原因。事实上，如果每个被访问的子类都有相同的接口，包括构造方法、其他方法、参数都一致，则访问者类只需要设计一个访问方法，在该方法中含有一个用于区别不同的被访问的子类的参数即可，例如可以使用被访问者基类作为参数类型。在对象的结构中包含有多种类型的有不同接口的对象时，各个不同的访问方法可能为访问所对应的类提供不同的参数类型。</li><li>当有多个不同的并且互不相关的运算将作用到这些对象上，而用户不希望这些运算混淆这些类时，可以使用访问者模式将相关的操作放到独立的类中，例如为了实现每个结点类中的计算价格方法，可以将所有的计算价格方法放到一个 VisitPrice 类中。</li><li>在对象的数据类型很少改变，但是需要经常改变操作或者增加新的操作的情况下，可以使用访问者模式。反之，如果 Element 的子类经常改变结构，例如需要增加一个新的税种，这就需要在访问者类中增加新的访问方法，因此，在这种情况下使用访问者模式代价较高，尽量不要使用访问者模式。</li></ul><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Visitor(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def visit_element_a(self, element_a):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def visit_element_b(self, element_b):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteVisitor1(Visitor):</span><br><span class="line">    def visit_element_a(self, element_a):</span><br><span class="line">        print(&#x27;ConcreteVisitor1&#x27;, &#x27;element_a&#x27;)</span><br><span class="line"></span><br><span class="line">    def visit_element_b(self, element_b):</span><br><span class="line">        print(&#x27;ConcreteVisitor1&#x27;, &#x27;element_b&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteVisitor2(Visitor):</span><br><span class="line">    def visit_element_a(self, element_a):</span><br><span class="line">        print(&#x27;ConcreteVisitor2&#x27;, &#x27;element_a&#x27;)</span><br><span class="line"></span><br><span class="line">    def visit_element_b(self, element_b):</span><br><span class="line">        print(&#x27;ConcreteVisitor2&#x27;, &#x27;element_b&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Element(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def accept(self, visitor):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ElementA(Element):</span><br><span class="line">    def accept(self, visitor):</span><br><span class="line">        visitor.visit_element_a(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ElementB(Element):</span><br><span class="line">    def accept(self, visitor):</span><br><span class="line">        visitor.visit_element_b(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ObjectStructure:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.elements = [ElementA(), ElementB()]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Client:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def main():</span><br><span class="line">        object_structure = ObjectStructure()</span><br><span class="line">        visitor = ConcreteVisitor1()</span><br><span class="line">        for element in object_structure.elements:</span><br><span class="line">            element.accept(visitor)</span><br><span class="line">        visitor = ConcreteVisitor2()</span><br><span class="line">        for element in object_structure.elements:</span><br><span class="line">            element.accept(visitor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    Client.main()</span><br></pre></td></tr></table></figure><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ol><li>使得在访问者类中针对复杂类结构中的某个类添加新方法较为容易，即只需要简单地添加一个新的访问者方法即可。如果不采用访问者模式，这需要在每个类中添加一个新的方法。</li><li>访问者将相关的方法集中在一个具体的访问者类中，而其他相关的方法集中在另外一个具体的访问者类中。也就是说，访问者子类是按照方法的类型来分类的。</li></ol><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>在增加新的元素类的时候比较困难。每增加一个新的元素类，所有的访问者类都要增加一个新的方法，这违背了“开闭原则”。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="内容-10"><a href="#内容-10" class="headerlink" title="内容"></a>内容</h3><p>定义一个操作中的算法骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h3 id="角色：-7"><a href="#角色：-7" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象类 AbstractClass：声明一个定义算法步骤的接口，作用是定义抽象类（钩子操作），实现一个模板方法作为算法的骨架</li><li>具体类 ConcreteClass：定义子类特定的步骤，作用是实现原子操作。</li></ul><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一次性实现一个算法的不变部分，各个子类中的公共行为应该被提取出来并集中到一个公共父类中以避免代码重复</li><li>控制子类扩展</li><li>当多个算法或类实现类似或相同逻辑的时候</li><li>在子类中实现算法有助于减少重复代码的时候</li><li>可以让子类利用覆盖实现行为来定义多个算法的时候</li></ul><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AbstractClass(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def parse(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def allocate(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def preprocessing(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def training(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def inference(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def saving_result(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def template_method(self):</span><br><span class="line">        print(&quot;算法流程&quot;)</span><br><span class="line">        print(&quot;1. 解析数据&quot;)</span><br><span class="line">        self.parse()</span><br><span class="line">        print(&quot;2. 分配资源&quot;)</span><br><span class="line">        self.allocate()</span><br><span class="line">        print(&quot;3. 预处理&quot;)</span><br><span class="line">        self.preprocessing()</span><br><span class="line">        print(&quot;4. 训练&quot;)</span><br><span class="line">        self.training()</span><br><span class="line">        print(&quot;5. 推理&quot;)</span><br><span class="line">        self.inference()</span><br><span class="line">        print(&quot;6. 保存结果&quot;)</span><br><span class="line">        self.saving_result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteClass(AbstractClass):</span><br><span class="line">    def parse(self):</span><br><span class="line">        print(&quot;解析数据&quot;)</span><br><span class="line"></span><br><span class="line">    def allocate(self):</span><br><span class="line">        print(&quot;分配资源&quot;)</span><br><span class="line"></span><br><span class="line">    def preprocessing(self):</span><br><span class="line">        print(&quot;预处理&quot;)</span><br><span class="line"></span><br><span class="line">    def training(self):</span><br><span class="line">        print(&quot;训练&quot;)</span><br><span class="line"></span><br><span class="line">    def inference(self):</span><br><span class="line">        print(&quot;推理&quot;)</span><br><span class="line"></span><br><span class="line">    def saving_result(self):</span><br><span class="line">        print(&quot;保存结果&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Client(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 应该通过命令、参数等可配置不同的具体的类，这里为了简单直接实例化</span><br><span class="line">        self.concreate = ConcreteClass()</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        self.concreate.template_method()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client = Client()</span><br><span class="line">client.main()</span><br></pre></td></tr></table></figure><h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ol><li>没有重复代码</li><li>由于模板方法模式使用继承而不是合成，因此能够对代码进行重用。所以，只有为数不多的几个方法需要重写。</li><li>灵活性允许子类决定如何实现算法中的步骤。</li></ol><h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ol><li>调试和理解模板方法模式中的流程序列有时会令人困惑。你最终实现的方法可能是一个不应该实现的方法，或根本没有实现抽象方法。文档和严格的错误处理必须由程序员完成。</li><li>模板框架的维护可能是一个问题，因为任何层次（低层或高层）的变更都可能对现实造成干扰。因此使用模板方法模式可能使维护变得异常痛苦。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 设计模式 02</title>
      <link href="/python-design-patterns-02/"/>
      <url>/python-design-patterns-02/</url>
      
        <content type="html"><![CDATA[<h1 id="重载（Overload）和重写（Override）"><a href="#重载（Overload）和重写（Override）" class="headerlink" title="重载（Overload）和重写（Override）"></a>重载（Overload）和重写（Override）</h1><span id="more"></span><h2 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>方法重载的好处就是让类以统一的方式处理不同类型的一种手段，调用方法时通过传递给他们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性。</p><p>它的特点是：重载发生在本类，方法名相同，参数列表不同，与返回值无关，只和方法名，参数的类型相关。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>没有重载前，不同的参数的方法需要定义不同的名字防止冲突（JAVA示例）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestMath &#123;</span><br><span class="line"></span><br><span class="line">    public int sumWithTwoNum(int num1, int num2) &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int sumWithThreeNum(int num1, int num2, int num3) &#123;</span><br><span class="line">        return num1 + num2 + num3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sumWithFourNum(int num1, int num2, int num3, int num4) &#123;</span><br><span class="line">        return num1 + num2 + num3 + num4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载后可以定义为同一个名字的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestMath &#123;</span><br><span class="line"></span><br><span class="line">    public int sum(int num1, int num2) &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int sum(int num1, int num2, int num3) &#123;</span><br><span class="line">        return num1 + num2 + num3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sum(int num1, int num2, int num3, int num4) &#123;</span><br><span class="line">        return num1 + num2 + num3 + num4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java重载有一些规则，比如仅仅是返回值类型不同和修饰符不同都不构成方法的重载，仅仅是方法参数的名称不同也不构成重载。</p><p>主要是介绍python，只介绍重载定义，具体重载规则请自行百度学习。</p><h2 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h2><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写。</p><p>重写是发生在类的继承关系，或者类的实现关系中的，重写后的方法和原方法需要保持完全相同的返回值类型、方法名、参数个数以及参数类型，简单来说，就是子类重写的方法必须和父类保持完全一致，说白了就是多态。</p><p>比如：定义了一个动物类，其中有一个进食的方法，动物类有两个子类：猫类和狗类，猫类应该对这个进食的方法重写，具体为：猫吃鱼，而狗类则应重写为：狗啃骨头。因为猫和狗进食的具体内容都不同，所以需要重写。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>不同对象调用父类的同一方法产生不同的结果。调用不同的子类将会产生不同的行为，而无须明确知道这个子类实际上是什么，这是多态的重要应用场景。多态的表现形式之一就是继承，先抽象，再继承。</p><p>鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。</p><p>鸭子类型这一名字出自美国James Whitcomb Riley(有的材料说他是诗人，有的说他是测试人员)提出的如下的表述：</p><p>When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.</p><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Duck:</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&quot;Walk like a duck&quot;)</span><br><span class="line"></span><br><span class="line">    def quack(self):</span><br><span class="line">        print(&quot;Quack like a duck&quot;)</span><br><span class="line"></span><br><span class="line">    def attack(self):</span><br><span class="line">        print(&quot;Attack like a duck&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 可达鸭</span><br><span class="line">class MallardDuck(Duck):</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&quot;MallardDuck walking&quot;)</span><br><span class="line"></span><br><span class="line">    def quack(self):</span><br><span class="line">        print(&quot;MallardDuck quacking&quot;)</span><br><span class="line"></span><br><span class="line">    def attack(self):</span><br><span class="line">        print(&quot;MallardDuck attacking&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 大葱鸭</span><br><span class="line">class FarfetchdDuck(Duck):</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&quot;FarfetchdDuck walking&quot;)</span><br><span class="line"></span><br><span class="line">    def quack(self):</span><br><span class="line">        print(&quot;FarfetchdDuck quacking&quot;)</span><br><span class="line"></span><br><span class="line">    def attack(self):</span><br><span class="line">        print(&quot;FarfetchdDuck attacking&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 和火箭队战斗</span><br><span class="line">def fight_with_team_rocket(duck: Duck):</span><br><span class="line">    duck.walk()</span><br><span class="line">    duck.quack()</span><br><span class="line">    duck.attack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mallard_duck = MallardDuck()</span><br><span class="line">    fight_with_team_rocket(mallard_duck)</span><br><span class="line">    farfetchd_duck = FarfetchdDuck()</span><br><span class="line">    fight_with_team_rocket(farfetchd_duck)</span><br></pre></td></tr></table></figure><h1 id="C-设计模式"><a href="#C-设计模式" class="headerlink" title="C# 设计模式"></a>C# 设计模式</h1><p>继承分为「接口继承」和「实现继承」。在编程语言或者 framework 中实现「接口继承」比较容易，一般保证一定的二进制接口兼容，或者一定的命名规范即可（比如 SICP 中的查表 data-driven）。著名的 Microsoft Component Object Model 和 CORBA 只有接口继承。实现「实现继承」则相对复杂。一般需要在编译级别支持，所以多为语言本身支持。拥有「实现继承」的语言可以通过通过自限的方式模拟「接口继承」。C++ 实现了完全的「多实现继承」，所以它可以完全通过自限的方式模拟「多接口继承」。Java 和 C# 只有「单实现继承」，如果通过自限的方式只能支持「单接口继承」，所以 Java 和 C# 引入了特别的 interface。</p><p>作者：冯东<br>链接：<a href="https://www.zhihu.com/question/20685467/answer/15848984">https://www.zhihu.com/question/20685467/answer/15848984</a><br>来源：知乎</p><p>根据以上信息可以知道，再Java或者C#中，实现设计模式都是通过接口的方式进行设计。</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>两种实现方式：</p><ol><li>类适配器：使用多继承</li><li>对象适配器：使用组合</li></ol><h3 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h3><ul><li>目标接口（Target）</li><li>待适配的类（Adaptee）</li><li>适配器（Adapter）</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>想使用一个已经存在的类，而它的接口不符合你的要求<br>2.（对象适配器）想使用一些已经存在的子类，但不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>类适配器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ColMap(AlgorithmInterface):</span><br><span class="line">    def __init__(self, params):</span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(f&quot;I am running with params: &#123;self.params&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TorchNgp:</span><br><span class="line">    def view(self):</span><br><span class="line">        print(&quot;I am running with no params&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类适配器</span><br><span class="line">class TorchNgpAdapter(AlgorithmInterface, TorchNgp):</span><br><span class="line">    def run(self):</span><br><span class="line">        self.view()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># web点击算法发起任务</span><br><span class="line">def web_show_and_click(algorithm):</span><br><span class="line">    algorithm.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    colmap = ColMap(&quot;params&quot;)</span><br><span class="line">    web_show_and_click(colmap)</span><br><span class="line"></span><br><span class="line">    torch_ngp = TorchNgpAdapter()</span><br><span class="line">    web_show_and_click(torch_ngp)</span><br></pre></td></tr></table></figure><p>对象适配器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ColMap(AlgorithmInterface):</span><br><span class="line">    def __init__(self, params):</span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(f&quot;I am running with params: &#123;self.params&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TorchNgp:</span><br><span class="line">    def view(self):</span><br><span class="line">        print(&quot;I am running with no params&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类适配器</span><br><span class="line">class AlgorithmAdapter(AlgorithmInterface):</span><br><span class="line">    def __init__(self, algorithm):</span><br><span class="line">        self.algorithm = algorithm</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        if hasattr(self.algorithm, &quot;run&quot;):</span><br><span class="line">            self.algorithm.run()</span><br><span class="line">        elif hasattr(self.algorithm, &quot;view&quot;):</span><br><span class="line">            self.algorithm.view()</span><br><span class="line">        else:</span><br><span class="line">            raise NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># web点击算法发起任务</span><br><span class="line">def web_show_and_click(algorithm):</span><br><span class="line">    algorithm.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    col_map = ColMap(&quot;params&quot;)</span><br><span class="line">    torch_ngp = TorchNgp()</span><br><span class="line">    web_show_and_click(AlgorithmAdapter(col_map))</span><br><span class="line">    web_show_and_click(AlgorithmAdapter(torch_ngp))</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>聚合(aggregation)：指的是整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构。从而找出一些组成类，该整体类和组成类之间就形成了聚合关系。需求描述中“包含”、“组成”、“分为…部分”等词常意味着聚合关系。</p><p>简单的说就是类中使用的实例是外部传入的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Cpu:</span><br><span class="line">    def show(self):</span><br><span class="line">        print(&quot;I am cpu&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Computer:</span><br><span class="line">    def __init__(self, cpu):</span><br><span class="line">        self.cpu = cpu</span><br><span class="line"></span><br><span class="line">    def has_cpu(self):</span><br><span class="line">        self.cpu.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cpu = Cpu()</span><br><span class="line">computer = Computer(cpu)</span><br><span class="line">computer.has_cpu()</span><br></pre></td></tr></table></figure><p>组合(composition)：也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在。部分对象与整体对象之间具有共生死的关系。</p><p>简单的说就是使用的实例是类中生成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Cpu:</span><br><span class="line">    def show(self):</span><br><span class="line">        print(&quot;I am cpu&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Computer:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.cpu = Cpu()</span><br><span class="line"></span><br><span class="line">    def has_cpu(self):</span><br><span class="line">        self.cpu.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">computer = Computer()</span><br><span class="line">computer.has_cpu()</span><br></pre></td></tr></table></figure><h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>将一个事物的两个维度分离，使其都可以独立地变化</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象（Abstraction）</li><li>细化抽象（RefinedAbstraction）</li><li>实现者（Implementor）</li><li>具体实现者（ConcreteImplementor</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 实现者</span><br><span class="line">class GL(ABC):</span><br><span class="line">    def __init__(self, loader):</span><br><span class="line">        self.loader = loader</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def screen(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象</span><br><span class="line">class Loader(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def loader(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 细化抽象</span><br><span class="line">class PlyLoader(Loader):</span><br><span class="line">    def loader(self):</span><br><span class="line">        print(&quot;ply loader&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ObjLoader(Loader):</span><br><span class="line">    def loader(self):</span><br><span class="line">        print(&quot;obj loader&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体实现者</span><br><span class="line">class WebGL(GL):</span><br><span class="line">    def screen(self):</span><br><span class="line">        self.loader.loader()</span><br><span class="line">        print(&quot;call webgl screen method&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OpenGL(GL):</span><br><span class="line">    def screen(self):</span><br><span class="line">        self.loader.loader()</span><br><span class="line">        print(&quot;call opengl screen method&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    webgl = WebGL(PlyLoader())</span><br><span class="line">    webgl.screen()</span><br><span class="line">    opengl = OpenGL(ObjLoader())</span><br><span class="line">    opengl.screen()</span><br></pre></td></tr></table></figure><p>这样之后即使再增加其他模型的加在类或者其他类型的GL方式都可以方便的添加。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当事物有两个维度上的表现，两个维度都可能扩展时。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>抽象和实现相分离</li><li>优秀的扩展能力</li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象组件（Component）</li><li>叶子组件（Leaf）</li><li>复合组件（Composite）</li><li>客户端（Client）</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def train_model(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ColMapApp(AlgorithmInterface):</span><br><span class="line">    def __init__(self, params):</span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    def train_model(self):</span><br><span class="line">        print(f&quot;ColMapApp am training with params: &#123;self.params&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TorchNgpApp(AlgorithmInterface):</span><br><span class="line">    def train_model(self):</span><br><span class="line">        print(f&quot;TorchNgpApp am training with no params&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class NewBeeApp(AlgorithmInterface):</span><br><span class="line">    def __init__(self, algorithms):</span><br><span class="line">        self.algorithms = []</span><br><span class="line"></span><br><span class="line">        for algorithm in algorithms:</span><br><span class="line">            self.add_algorithm(algorithm)</span><br><span class="line"></span><br><span class="line">    def add_algorithm(self, algorithm):</span><br><span class="line">        self.algorithms.append(algorithm)</span><br><span class="line"></span><br><span class="line">    def train_model(self):</span><br><span class="line">        print(&quot;###### NewBeeApp Training ######&quot;)</span><br><span class="line">        for algorithm in self.algorithms:</span><br><span class="line">            algorithm.train_model()</span><br><span class="line">        print(&quot;###### NewBeeApp Trained ######&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># web点击算法发起任务</span><br><span class="line">def web_show_and_click(algorithm):</span><br><span class="line">    algorithm.train_model()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    colmap_app = ColMapApp(params=&quot;colmap_params&quot;)</span><br><span class="line">    torch_ngp_app = TorchNgpApp()</span><br><span class="line">    new_bee_app = NewBeeApp(algorithms=[colmap_app, torch_ngp_app])</span><br><span class="line"></span><br><span class="line">    # 单个算法发起任务</span><br><span class="line">    web_show_and_click(colmap_app)</span><br><span class="line">    # 组合算法发起任务，调用方式相同</span><br><span class="line">    web_show_and_click(new_bee_app)</span><br></pre></td></tr></table></figure><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>表示对象的“部分-整体”层次结构（特别是结构是递归的）</li><li>希望用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中的所有对象</li></ol><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>定义了包含基本对象和组合对象的类层次结构</li><li>简化客户端代码，即客户端可以一致地使用组合对象和单个对象</li><li>更容易增加新类型的组件</li></ul><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>装饰模式是在原有对象的基础上，动态增加一个新的特性。与继承的最大区别是，这种新增特性是比较泛化的，可以被多种对象增加。</p><p>python中通常用的是通过函数装饰器或者类装饰器，直接对对象所属的类进行装饰，语言特性已包含，因此此设计模式略过。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>外观模式又被称为门面模式，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><h3 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h3><ul><li>外观（facade）</li><li>子系统类（subsystem classes）</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class LoaderModel:</span><br><span class="line">    def loader(self):</span><br><span class="line">        print(&quot;loader model&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DrawScreen:</span><br><span class="line">    def draw(self):</span><br><span class="line">        print(&quot;draw screen&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LoadAnimation:</span><br><span class="line">    def animation(self):</span><br><span class="line">        print(&quot;load animation&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Page:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.loader = LoaderModel()</span><br><span class="line">        self.draw = DrawScreen()</span><br><span class="line">        self.animation = LoadAnimation()</span><br><span class="line"></span><br><span class="line">    def load(self):</span><br><span class="line">        self.loader.loader()</span><br><span class="line">        self.draw.draw()</span><br><span class="line">        self.animation.animation()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    page = Page()</span><br><span class="line">    page.load()</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个例子是比如维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展，但是它包含很重要的功能，新的开发必须依赖于它，这样增加外观Facade类，为系统封装一个比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>减少系统相互依赖</li><li>提高了灵活性</li><li>提高了安全性</li></ul><h2 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式(Flyweight)"></a>享元模式(Flyweight)</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><ul><li>图形图像处理软件：在图形图像处理软件中，可能需要创建大量的形状对象，如矩形、圆形等。通过使用享元模式，可以共享形状对象的属性，从而减少内存使用和提高性能。</li><li>游戏开发：在游戏开发中，可能需要创建大量的游戏角色、武器等对象。通过使用享元模式，可以共享游戏对象的属性，从而减少内存使用和提高性能。</li><li>网络服务器：在网络服务器中，可能需要创建大量的网络连接对象。通过使用享元模式，可以共享网络连接对象的属性，从而减少内存使用和提高性能。</li><li>数据库连接池：在数据库连接池中，可能需要创建大量的数据库连接对象。通过使用享元模式，可以共享数据库连接对象的属性，从而减少内存使用和提高性能。</li></ul><h3 id="角色：-1"><a href="#角色：-1" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象享元角色（Flyweight）</li><li>具体享元角色（Concrete Flyweight）</li><li>非享元角色（Unsharable Flyweight)</li><li>享元工厂角色（Flyweight Factory）</li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>想使用一个已经存在的类，而它的接口不符合你的要求<br>2.（对象适配器）想使用一些已经存在的子类，但不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ol><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Flyweight(ABC):</span><br><span class="line">    def __init__(self, shared_state):</span><br><span class="line">        self.shared_state = shared_state</span><br><span class="line">        print(f&quot;Flyweight: (&#123;self.shared_state&#125;)&quot;)</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self, unique_state):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteFlyweight(Flyweight):</span><br><span class="line">    def show(self, unique_state):</span><br><span class="line">        print(f&quot;ConcreteFlyweight: (&#123;self.shared_state&#125;, &#123;unique_state&#125;)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FlyweightFactory:</span><br><span class="line">    _flyweights = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def __init__(self, shared_states):</span><br><span class="line">        for shared_state in shared_states:</span><br><span class="line">            self._flyweights[str(shared_state)] = ConcreteFlyweight(shared_state)</span><br><span class="line"></span><br><span class="line">    def get_flyweight(self, shared_state):</span><br><span class="line">        key = str(shared_state)</span><br><span class="line">        if key not in self._flyweights:</span><br><span class="line">            self._flyweights[key] = ConcreteFlyweight(shared_state)</span><br><span class="line">        return self._flyweights[key]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示模型的客户端代码</span><br><span class="line">class Client:</span><br><span class="line">    def __init__(self, factory):</span><br><span class="line">        self.factory = factory</span><br><span class="line"></span><br><span class="line">    def screen(self, model, position):</span><br><span class="line">        flyweight = self.factory.get_flyweight(model)</span><br><span class="line">        flyweight.show(position)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这里定义模型类，load_model在FlyweightFactory中的初始化时调用</span><br><span class="line">class Model:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 初始化模型</span><br><span class="line">    roma = Model(&quot;罗马斗兽场&quot;)</span><br><span class="line">    lion = Model(&quot;狮子&quot;)</span><br><span class="line">    wolf = Model(&quot;狼&quot;)</span><br><span class="line">    bird = Model(&quot;鸟&quot;)</span><br><span class="line">    car = Model(&quot;汽车&quot;)</span><br><span class="line"></span><br><span class="line">    # 客户端代码, 初始化时加载模型</span><br><span class="line">    client = Client(FlyweightFactory([roma, lion, bird, car]))</span><br><span class="line"></span><br><span class="line">    # 显示模型</span><br><span class="line">    client.screen(roma, (0, 0, 0))</span><br><span class="line">    client.screen(lion, (1, 1, 1))</span><br><span class="line">    client.screen(wolf, (2, 2, 2))</span><br><span class="line">    client.screen(bird, (3, 3, 3))</span><br><span class="line">    client.screen(car, (4, 4, 4))</span><br><span class="line">    client.screen(lion, (5, 5, 5))</span><br><span class="line">    client.screen(wolf, (6, 6, 6))</span><br><span class="line">    client.screen(bird, (7, 7, 7))</span><br></pre></td></tr></table></figure><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.为了共享对象，需要将不能共享的状态外部化，会增加程序的复杂性</p><p>2.对享元模式的外部状态会增长运行时间</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="内容-6"><a href="#内容-6" class="headerlink" title="内容"></a>内容</h3><p>为其他对象提供一种代理，以此控制一个对象的访问方式。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><h3 id="角色：-2"><a href="#角色：-2" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象角色（Subject）</li><li>真实角色（Real Subject）</li><li>代理角色（Proxy）</li></ul><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>远程代理：隐藏对象位于远程地址空间的事实。例如写入数据，而数据库不在本地，需要远程访问。隐藏数据库不在本地的事实，使用代理进行远程存储。</li><li>虚代理：为了节省资源开销，在功能没有被真正调用时，就不运行。例如浏览器中的无图模式，不显示图片，等你真正需要查看某张时，点击才会真正加载图像，不点击时，只会告诉你，此处是一张图像，并不显示</li><li>保护代理：访问一个对象时有一些附加的内务处理。例如为了区分用户权限而设置的代理，普通用户只有访问权限，而开发人员有写入权限。</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Subject(ABC):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.model = None</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RealSubject(Subject):</span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        if not self.model:</span><br><span class="line">            print(f&quot;本地模型 &#123;model&#125; 加载中...&quot;)</span><br><span class="line">            self.model = model</span><br><span class="line">        print(f&quot;&#123;model&#125; 模型加载完成！&quot;)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        print(f&quot;&#123;self.model&#125; 模型展示！&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RemoteProxy(Subject):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.subject = RealSubject()</span><br><span class="line"></span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        print(&quot;远程模型加载中...&quot;)</span><br><span class="line">        self.subject.model = model</span><br><span class="line">        self.subject.load(model)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        return self.subject.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class VirtualProxy(Subject):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.subject = RemoteProxy()</span><br><span class="line"></span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        self.model = model</span><br><span class="line">        print(&quot;虚拟模型已经记录...&quot;)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        if not self.model:</span><br><span class="line">            print(&quot;虚拟模型未记录！&quot;)</span><br><span class="line">            return</span><br><span class="line">        print(&quot;虚拟模型展示！&quot;)</span><br><span class="line">        self.subject.load(self.model)</span><br><span class="line">        self.subject.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ProtectionProxy(Subject):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.subject = VirtualProxy()</span><br><span class="line"></span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        user = args[0]</span><br><span class="line">        if user == &quot;admin&quot;:</span><br><span class="line">            self.subject.load(model)</span><br><span class="line">            self.model = model</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;权限不足！&quot;)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        if not self.model:</span><br><span class="line">            print(&quot;模型未加载！&quot;)</span><br><span class="line">            return</span><br><span class="line">        self.subject.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def client_code(models_and_users):</span><br><span class="line">    proxy_list = []</span><br><span class="line"></span><br><span class="line">    for user, model in models_and_users:</span><br><span class="line">        # proxy = RealSubject()</span><br><span class="line">        # proxy = RemoteProxy()</span><br><span class="line">        # proxy = VirtualProxy()</span><br><span class="line">        proxy = ProtectionProxy()</span><br><span class="line">        proxy.load(model, user)</span><br><span class="line">        proxy_list.append(proxy)</span><br><span class="line"></span><br><span class="line">    for proxy in proxy_list:</span><br><span class="line">        proxy.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    model_and_user = [</span><br><span class="line">        (&quot;admin&quot;, &quot;roma&quot;),</span><br><span class="line">        (&quot;user&quot;, &quot;bird&quot;),</span><br><span class="line">        (&quot;admin&quot;, &quot;car&quot;)</span><br><span class="line">    ]</span><br><span class="line">    client_code(model_and_user)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 设计模式 01</title>
      <link href="/python-design-patterns-01/"/>
      <url>/python-design-patterns-01/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式（Design pattern）是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</p><p>每一个设计模式系统地命名、解释和评价了面向对象系统中一个重要的和重复出现的设计。</p><p>这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。</p><p>我们使用设计模式最终的目的是实现代码的高内聚和低耦合。</p><p>设计模式中有一些重要的人物如，“四人帮”（Gang of Four， GoF）：Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides，他们写了一本书在设计模式中影响比较大《设计模式：可复用面向对象软件的基础》</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>这里的设计模式特指OOP中的设计模式，说明之前需要明确几个概念。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象的三大特性：</p><ul><li>封装：将数据、方法封装到一个类里；具有公有和私有属性。</li><li>继承：多个类之间复用代码使用继承。</li><li>多态：python本身就是一门多态语言，不用程序员去考虑多态，语言特性自己做了。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口：若干抽象方法的集合。<br>作用：限制实现接口的类必须按照接口给定的调用方式实现这些方法；对高层模块隐藏了类的内部实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@abstractmethod：抽象方法，含abstractmethod方法的类不能实例化，继承了含abstractmethod方法的子类必须复写所有abstractmethod装饰的方法，未被装饰的可以不重写</span><br><span class="line">@property：方法伪装属性，方法返回值及属性值，被装饰方法不能有参数，必须实例化后调用，类不能调用</span><br><span class="line">@classmethod：类方法，可以通过实例对象和类对象调用，被该函数修饰的方法第一个参数代表类本身常用cls，被修饰函数内可调用类属性，不能调用实例属性</span><br><span class="line">@staticmethod：静态方法，可以通过实例对象和类对象调用，被装饰函数可无参数，被装饰函数内部通过类名.属性引用 类属性或类方法，不能引用实例属性</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># abstract class 有抽象方法就是抽象类：抽象类不可被实例化</span><br><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># class BaseAlgorithmInterface:</span><br><span class="line">#     def run(self):</span><br><span class="line">#         raise NotImplementedError</span><br><span class="line">#</span><br><span class="line">class BaseAlgorithmInterface(ABC):</span><br><span class="line">    # 该类被子类继承时必须实现被abstractmethod装饰的方法</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Colmap(BaseAlgorithmInterface):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;do something with Colmap&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerf(BaseAlgorithmInterface):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;do something with HashNert&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = Colmap()</span><br><span class="line">c.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="面向对象设计SOLID原则"><a href="#面向对象设计SOLID原则" class="headerlink" title="面向对象设计SOLID原则"></a>面向对象设计SOLID原则</h1><ol><li><p>单一职责原则</p><p>就一个类而言，应该仅有一个引起它变化的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱他的设计，当变化发生时，设计会遭受到意想不到的破坏；软件设计真正要做的许多内容就是发现职责并把那些职责相互分离。</p></li><li><p>开放-封闭原则</p><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p><p>该原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的可维护、可扩展、可复用、灵活性好。</p><p>设计人员必须对于他设计的模块应该对哪种变化封闭做出选择，必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。最初编写程序时假设变化不会发生，当变化发生时，就创建抽象来隔离以后发生的同类变化，拒绝不成熟的抽象。</p></li><li><p>里氏替换原则</p><p>所有引用父类的地方必须能透明地使用其子类的对象。</p><p>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</p></li><li><p>依赖倒置原则</p><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p><p>要针对接口编程，而不是针对实现编程。该原则可以说是面向对象设计的标志，编写时考虑的是如何对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口。</p></li><li><p>迪迷特原则（最少知识原则）</p><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>该原则其根本思想，是强调了类之间的松耦合；类之间的耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</p></li><li><p>接口隔离原则</p><p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></li><li><p>合成&#x2F;聚合复用原则</p><p>尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p><p>聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p><p>优先使用对象的合成&#x2F;聚合将有助于你保持每个类被封装，并被击中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p></li></ol><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ol><li><p>创建型模式（5种）</p><p>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p><ul><li>工厂方法模式</li><li>抽象工厂模式</li><li>创建者模式</li><li>原型模式</li><li>单例模式</li></ul></li><li><p>结构型模式（7种）</p><p>把类或对象结合在一起形成一个更大的结构。</p><ul><li>适配器模式</li><li>桥模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul></li><li><p>行为型模式（11种）</p><p>类和对象如何交互，及划分责任和算法。</p><ul><li>解释器模式</li><li>责任链模式</li><li>命令模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>访问者模式</li><li>模板方法模式</li></ul></li></ol><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>工厂角色（Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseAlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Colmap(BaseAlgorithmInterface):</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with Colmap&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerf(BaseAlgorithmInterface):</span><br><span class="line">    def __init__(self, application=None):</span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        if self.application:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with &#123;self.application&#125; base on HashNerf&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with HashNerf&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmFactory:</span><br><span class="line">    def create_algorithm(self, name):</span><br><span class="line">        match name:</span><br><span class="line">            case &#x27;colmap&#x27;:</span><br><span class="line">                return Colmap()</span><br><span class="line">            case &#x27;hashnerf&#x27;:</span><br><span class="line">                return HashNerf()</span><br><span class="line">            case &#x27;slam&#x27;:</span><br><span class="line">                return HashNerf(application=&#x27;slam&#x27;)</span><br><span class="line">            case _:</span><br><span class="line">                raise ValueError(f&#x27;Algorithm &#123;name&#125; is not supported&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line"># 算法应用创建工厂</span><br><span class="line">algorithm_factory = AlgorithmFactory()</span><br><span class="line"></span><br><span class="line">nerf = algorithm_factory.create_algorithm(&#x27;hashnerf&#x27;)</span><br><span class="line">nerf.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br><span class="line"></span><br><span class="line"># 隐藏类的内部实现</span><br><span class="line">slam = algorithm_factory.create_algorithm(&#x27;slam&#x27;)</span><br><span class="line">slam.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>隐藏了对象创建的实现细节</li><li>客户端不需要修改代码</li></ul><p>缺点：</p><ul><li>违反了单一职责原则，将创建逻辑几种到一个工厂类里</li><li>当添加新产品时，需要修改工厂类代码，违反了开闭原则</li></ul><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>定义一个用于创建对象的接口（工厂接口），让子类决定实例化哪一个产品类。</p><h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象工厂角色（Creator）</li><li>具体工厂角色（Concrete Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseAlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Colmap(BaseAlgorithmInterface):</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with Colmap&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerf(BaseAlgorithmInterface):</span><br><span class="line">    def __init__(self, application=None):</span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        if self.application:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with &#123;self.application&#125; base on HashNerf&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with HashNerf&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体工厂 #####</span><br><span class="line">class ColmapFactory:</span><br><span class="line">    def create_algorithm(self):</span><br><span class="line">        return Colmap()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerfFactory:</span><br><span class="line">    def create_algorithm(self):</span><br><span class="line">        return HashNerf()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SlamFactory:</span><br><span class="line">    def create_algorithm(self):</span><br><span class="line">        return HashNerf(application=&#x27;slam&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line">nerf = HashNerfFactory().create_algorithm()</span><br><span class="line">nerf.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br><span class="line"></span><br><span class="line">slam = SlamFactory().create_algorithm()</span><br><span class="line">slam.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>每个具体产品都对应一个具体工厂类，不需要修改工厂类代码</li><li>隐藏了对象创建的实现细节</li></ul><p>缺点：</p><ul><li>每增加一个具体产品类，就必须增加一个相应的具体工厂类</li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象。</p><p>例：生产一部手机，需要手机壳、CPU、操作系统三类对象进行组装，其中每类对象都有不同的种类。对每个具体工厂，分别生产一部手机所需要的三个对象。</p><p>相比工厂方法模式，抽象工厂模式中的每个具体工厂都生产一套产品。</p><h3 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象工厂角色（Creator）</li><li>具体工厂角色（Concrete Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li><li>客户端（Client）</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 抽象产品 #####</span><br><span class="line">class PhoneShell(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CPU(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OS(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show_os(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 抽象工厂 #####</span><br><span class="line">class PhoneFactory(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def make_shell(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def make_os(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体产品 #####</span><br><span class="line">class SmallShell(PhoneShell):</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        print(&quot;普通手机小手机壳&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BigShell(PhoneShell):</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        print(&quot;普通手机大手机壳&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AppleShell(PhoneShell):</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        print(&quot;苹果手机壳&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SnapDragonCPU(CPU):</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        print(&quot;骁龙CPU&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MediaTekCPU(CPU):</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        print(&quot;联发科CPU&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AppleCPU(CPU):</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        print(&quot;苹果CPU&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Android(OS):</span><br><span class="line">    def show_os(self):</span><br><span class="line">        print(&quot;Android系统&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IOS(OS):</span><br><span class="line">    def show_os(self):</span><br><span class="line">        print(&quot;iOS系统&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体工厂 #####</span><br><span class="line">class MiFactory(PhoneFactory):</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        return SnapDragonCPU()</span><br><span class="line"></span><br><span class="line">    def make_os(self):</span><br><span class="line">        return Android()</span><br><span class="line"></span><br><span class="line">    def make_shell(self):</span><br><span class="line">        return BigShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HuaweiFactory(PhoneFactory):</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        return MediaTekCPU()</span><br><span class="line"></span><br><span class="line">    def make_os(self):</span><br><span class="line">        return Android()</span><br><span class="line"></span><br><span class="line">    def make_shell(self):</span><br><span class="line">        return SmallShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IPhoneFactory(PhoneFactory):</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        return AppleCPU()</span><br><span class="line"></span><br><span class="line">    def make_os(self):</span><br><span class="line">        return IOS()</span><br><span class="line"></span><br><span class="line">    def make_shell(self):</span><br><span class="line">        return AppleShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line">class Phone:</span><br><span class="line">    def __init__(self, cpu, os, shell):</span><br><span class="line">        self.cpu = cpu</span><br><span class="line">        self.os = os</span><br><span class="line">        self.shell = shell</span><br><span class="line"></span><br><span class="line">    def show_info(self):</span><br><span class="line">        print(&quot;手机信息:&quot;)</span><br><span class="line">        self.cpu.show_cpu()</span><br><span class="line">        self.os.show_os()</span><br><span class="line">        self.shell.show_shell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def make_phone(factory):</span><br><span class="line">    cpu = factory.make_cpu()</span><br><span class="line">    os = factory.make_os()</span><br><span class="line">    shell = factory.make_shell()</span><br><span class="line">    return Phone(cpu, os, shell)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = make_phone(IPhoneFactory())</span><br><span class="line">p1.show_info()</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>将客户端与类的具体实现相分离</li><li>每个工厂创建了一个完整的产品系列，使得易于交换产品系列</li><li>有利于产品的一致性（即产品之间的约束关系）</li></ul><p>缺点：</p><ul><li>难以支持新种类的（抽象）产品</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="角色-3"><a href="#角色-3" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象建造者（Builder）</li><li>具体建造者（Concrete Builder）</li><li>指挥者（Director）</li><li>产品（Product）</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 产品 #####</span><br><span class="line">class Player:</span><br><span class="line">    def __init__(self, face=None, body=None, arm=None, leg=None):</span><br><span class="line">        self.face = face</span><br><span class="line">        self.body = body</span><br><span class="line">        self.arm = arm</span><br><span class="line">        self.leg = leg</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;%s, %s, %s, %s&quot; % (self.face, self.body, self.arm, self.leg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 抽象建造者 #####</span><br><span class="line">class PlayerBuilder(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_face(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_body(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_arm(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_leg(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体建造者 #####</span><br><span class="line">class SexyGirlBuilder(PlayerBuilder):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.player = Player()</span><br><span class="line"></span><br><span class="line">    def build_face(self):</span><br><span class="line">        self.player.face = &quot;漂亮脸蛋&quot;</span><br><span class="line"></span><br><span class="line">    def build_body(self):</span><br><span class="line">        self.player.body = &quot;苗条&quot;</span><br><span class="line"></span><br><span class="line">    def build_arm(self):</span><br><span class="line">        self.player.arm = &quot;漂亮胳膊&quot;</span><br><span class="line"></span><br><span class="line">    def build_leg(self):</span><br><span class="line">        self.player.leg = &quot;大长腿&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Monster(PlayerBuilder):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.player = Player()</span><br><span class="line"></span><br><span class="line">    def build_face(self):</span><br><span class="line">        self.player.face = &quot;怪兽脸&quot;</span><br><span class="line"></span><br><span class="line">    def build_body(self):</span><br><span class="line">        self.player.body = &quot;怪兽身材&quot;</span><br><span class="line"></span><br><span class="line">    def build_arm(self):</span><br><span class="line">        self.player.arm = &quot;长毛的胳膊&quot;</span><br><span class="line"></span><br><span class="line">    def build_leg(self):</span><br><span class="line">        self.player.leg = &quot;长毛的腿&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 指挥者 #####</span><br><span class="line">class PlayerDirector:  # 控制组装顺序</span><br><span class="line">    def build_player(self, builder):</span><br><span class="line">        builder.build_body()</span><br><span class="line">        builder.build_face()</span><br><span class="line">        builder.build_arm()</span><br><span class="line">        builder.build_leg()</span><br><span class="line">        return builder.player</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line">builder = Monster()</span><br><span class="line">director = PlayerDirector()</span><br><span class="line">player = director.build_player(builder)</span><br><span class="line">print(player)</span><br></pre></td></tr></table></figure><p>建造者模式与抽象工厂模式相似，也用来创建复杂对象。</p><p>主要区别是建造者模式着重一步步构造一个复杂对象，而抽象工厂模式着重于多个系列的产品对象。</p><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>隐藏了一个产品的内部结构和装配过程</li><li>将构造代码与表示代码分开，构造顺序修改不影响表示代码</li><li>可以对构造过程进行更精细的控制</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>保证一个类只有一个实例，并提供一个访问它的全局访问点。</p><h3 id="角色-4"><a href="#角色-4" class="headerlink" title="角色"></a>角色</h3><p>单例（Singleton）</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>在 Python 中，我们可以用多种方法来实现单例模式：</p><ul><li>使用模块</li><li>使用装饰器</li><li>使用类</li><li>基于 <strong>new</strong> 方法实现</li><li>基于 metaclass 方式实现</li></ul><h4 id="1-使用模块"><a href="#1-使用模块" class="headerlink" title="1. 使用模块"></a>1. 使用模块</h4><p>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。</p><p>因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p><p>单独定义一个文件，保存为 singleton.py 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Singleton:</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;I am running&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">singleton = Singleton()</span><br></pre></td></tr></table></figure><p>使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from singleton import singleton</span><br><span class="line"></span><br><span class="line"># Now, we can call the run method on the singleton object:</span><br><span class="line">singleton.run()</span><br></pre></td></tr></table></figure><h4 id="2-使用装饰器"><a href="#2-使用装饰器" class="headerlink" title="2. 使用装饰器"></a>2. 使用装饰器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls):</span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def _singleton(*args, **kwargs):</span><br><span class="line">        if cls not in _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        return _instance[cls]</span><br><span class="line"></span><br><span class="line">    return _singleton</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class SingletonObject:</span><br><span class="line">    a = 1</span><br><span class="line"></span><br><span class="line">    def __init__(self, x=0):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = SingletonObject(2)</span><br><span class="line">a2 = SingletonObject(3)</span><br><span class="line"></span><br><span class="line">print(a1.x)</span><br><span class="line">print(a2.x)</span><br></pre></td></tr></table></figure><h4 id="3-使用类"><a href="#3-使用类" class="headerlink" title="3. 使用类"></a>3. 使用类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">            with Singleton._instance_lock:</span><br><span class="line">                if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">                    Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        return Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    singleton_obj = Singleton.instance()</span><br><span class="line">    print(singleton_obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    t = threading.Thread(target=task, args=[i, ])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(20)</span><br><span class="line">obj = Singleton.instance()</span><br><span class="line">print(obj)</span><br></pre></td></tr></table></figure><p>这种方式实现的单例模式，使用时会有限制，以后实例化必须通过 obj &#x3D; Singleton.instance()</p><p>如果用 obj &#x3D; Singleton()，这种方式得到的不是单例。</p><h4 id="4-基于-new-方法实现"><a href="#4-基于-new-方法实现" class="headerlink" title="4. 基于 new 方法实现"></a>4. 基于 <strong>new</strong> 方法实现</h4><p>当我们实例化一个对象时，先执行类的 <strong>new</strong> 方法（我们没写时，默认调用 object.__new__），实例化对象；然后再执行类的 <strong>init</strong> 方法，对这个对象进行初始化，所有可以基于此，实现单例模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">            with Singleton._instance_lock:</span><br><span class="line">                if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">                    Singleton._instance = object.__new__(cls)</span><br><span class="line">        return Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    obj = Singleton()</span><br><span class="line">    print(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    t = threading.Thread(target=task, args=[i, ])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">obj1 = Singleton()</span><br><span class="line">obj2 = Singleton()</span><br><span class="line">print(obj1, obj2)</span><br></pre></td></tr></table></figure><p>采用这种方式的单例模式，以后实例化对象时，和平时实例化对象的方法一样 obj &#x3D; Singleton()</p><h4 id="5-基于-metaclass-方式实现"><a href="#5-基于-metaclass-方式实现" class="headerlink" title="5. 基于 metaclass 方式实现"></a>5. 基于 metaclass 方式实现</h4><p>相关知识:</p><ul><li>类由 type 创建，创建类时，type 的 <strong>init</strong> 方法自动执行，类() 执行 type 的 <strong>call</strong> 方法(类的 <strong>new</strong> 方法，类的 <strong>init</strong> 方法)</li><li>对象由类创建，创建对象时，类的 <strong>init</strong> 方法自动执行，对象()执行类的 <strong>call</strong> 方法</li></ul><p>元类使用例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class TestType(type):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;TestType.__new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __init__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;TestType.__init__&quot;)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;TestType.__call__&quot;)</span><br><span class="line">        return super().__call__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Test(metaclass=TestType):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;Test.__new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;Test.__init__&quot;)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;Test.__call__&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 1. 什么都不调用时输出 #####</span><br><span class="line"># TestType.__new__</span><br><span class="line"># TestType.__init__</span><br><span class="line"></span><br><span class="line"># ##### 2. 实例化类时输出 #####</span><br><span class="line"># TestType.__new__</span><br><span class="line"># TestType.__init__</span><br><span class="line"># TestType.__call__</span><br><span class="line"># Test.__new__</span><br><span class="line"># Test.__init__</span><br><span class="line">#</span><br><span class="line"># test = Test()</span><br><span class="line"></span><br><span class="line"># ##### 3. 调用实例时输出 #####</span><br><span class="line"># TestType.__new__</span><br><span class="line"># TestType.__init__</span><br><span class="line"># TestType.__call__</span><br><span class="line"># Test.__new__</span><br><span class="line"># Test.__init__</span><br><span class="line"># Test.__call__</span><br><span class="line">test = Test()</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>单例模式实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingletonType(type):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(cls, &quot;_instance&quot;):</span><br><span class="line">            with SingletonType._instance_lock:</span><br><span class="line">                if not hasattr(cls, &quot;_instance&quot;):</span><br><span class="line">                    cls._instance = super(SingletonType, cls).__call__(*args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(metaclass=SingletonType):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &#x27;_instance&#x27;))</span><br><span class="line">obj1 = Foo(&#x27;name&#x27;)</span><br><span class="line">print(hasattr(Foo, &#x27;_instance&#x27;))</span><br><span class="line">print(Foo._instance)</span><br><span class="line">obj2 = Foo(&#x27;name&#x27;)</span><br><span class="line">print(obj1, obj2)</span><br></pre></td></tr></table></figure><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>对唯一实例的受控访问</li><li>单例相当于全局变量，但防止了命名空间被污染</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><p>也可以称为复制模式。本质就是克隆对象，在对象初始化操作比较复杂的情况下，很实用，这既隐藏了对象创建的细节，又能大大降低耗时，提高性能。</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Book:</span><br><span class="line">    def __init__(self, name, authors, price, **rest):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        rest的例子有：出版商、长度、标签、出版日期</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.authors = authors</span><br><span class="line">        self.price = price</span><br><span class="line">        # 添加其他额外属性</span><br><span class="line">        self.__dict__.update(rest)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        format_string = &#x27;&#x27;</span><br><span class="line">        for key, value in self.__dict__.items():</span><br><span class="line">            format_string = f&#x27;&#123;format_string&#125;&#123;key&#125;: &#123;value&#125;, &#x27;</span><br><span class="line">        return format_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Prototype:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化一个原型列表</span><br><span class="line">        self.objects = dict()</span><br><span class="line"></span><br><span class="line">    def register(self, identifier, obj):</span><br><span class="line">        # 在原型列表中注册原型对象</span><br><span class="line">        self.objects[identifier] = obj</span><br><span class="line"></span><br><span class="line">    def unregister(self, identifier):</span><br><span class="line">        # 从原型列表中删除原型对象</span><br><span class="line">        del self.objects[identifier]</span><br><span class="line"></span><br><span class="line">    def clone(self, identifier, **attr):</span><br><span class="line">        # 根据 identifier 在原型列表中查找原型对象并克隆</span><br><span class="line">        found = self.objects.get(identifier)</span><br><span class="line">        if not found:</span><br><span class="line">            raise ValueError(&#x27;Incorrect object identifier: &#123;&#125;&#x27;.format(identifier))</span><br><span class="line">        obj = copy.deepcopy(found)</span><br><span class="line">        # 用新的属性值替换原型对象中的对应属性</span><br><span class="line">        obj.__dict__.update(attr)</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    book1 = Book(</span><br><span class="line">        &#x27;The C Programming Language&#x27;,</span><br><span class="line">        (&#x27;Brian W. Kernighan&#x27;, &#x27;Dennis M.Ritchie&#x27;),</span><br><span class="line">        price=118,</span><br><span class="line">        publisher=&#x27;Prentice Hall&#x27;,</span><br><span class="line">        length=228, publication_date=&#x27;1978-02-22&#x27;,</span><br><span class="line">        tags=(&#x27;C&#x27;, &#x27;programming&#x27;, &#x27;algorithms&#x27;, &#x27;data structures&#x27;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    prototype = Prototype()</span><br><span class="line">    register_id = &#x27;book1&#x27;</span><br><span class="line"></span><br><span class="line">    # 注册原型对象</span><br><span class="line">    prototype.register(register_id, book1)</span><br><span class="line">    book2 = prototype.clone(</span><br><span class="line">        register_id,</span><br><span class="line">        name=&#x27;The C Programming Language(ANSI)&#x27;,</span><br><span class="line">        price=48.99,</span><br><span class="line">        length=274,</span><br><span class="line">        publication_date=&#x27;1988-04-01&#x27;,</span><br><span class="line">        edition=2</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    print(book1)</span><br><span class="line">    print(book2)</span><br><span class="line">    print(f&quot;ID book1 : &#123;id(book1)&#125; != ID book2 : &#123;id(book2)&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>其实这段代码在 Python 中，要实现一样的效果，并没有这么复杂。以下代码除了原型模式类删除之外，只有 main 函数有些变更。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Book:</span><br><span class="line">    def __init__(self, name, authors, price, **rest):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        rest的例子有：出版商、长度、标签、出版日期</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.authors = authors</span><br><span class="line">        self.price = price</span><br><span class="line">        # 添加其他额外属性</span><br><span class="line">        self.__dict__.update(rest)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        format_string = &#x27;&#x27;</span><br><span class="line">        for key, value in self.__dict__.items():</span><br><span class="line">            format_string = f&#x27;&#123;format_string&#125;&#123;key&#125;: &#123;value&#125;, &#x27;</span><br><span class="line">        return format_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    book1 = Book(</span><br><span class="line">        &#x27;The C Programming Language&#x27;,</span><br><span class="line">        (&#x27;Brian W. Kernighan&#x27;, &#x27;Dennis M.Ritchie&#x27;),</span><br><span class="line">        price=118,</span><br><span class="line">        publisher=&#x27;Prentice Hall&#x27;,</span><br><span class="line">        length=228, publication_date=&#x27;1978-02-22&#x27;,</span><br><span class="line">        tags=(&#x27;C&#x27;, &#x27;programming&#x27;, &#x27;algorithms&#x27;, &#x27;data structures&#x27;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 这里我们彻底抛弃之前的原型设计模式的写法，同样的内容，经过不同的方式，可以得到同样的效果。</span><br><span class="line">    book2 = copy.deepcopy(book1)</span><br><span class="line">    book2.name = &#x27;The C Programming Language(ANSI)&#x27;</span><br><span class="line">    book2.price = 48.99</span><br><span class="line">    book2.length = 274</span><br><span class="line">    book2.publication_date = &#x27;1988-04-01&#x27;</span><br><span class="line">    book2.edition = 2</span><br><span class="line"></span><br><span class="line">    print(book1)</span><br><span class="line">    print(book2)</span><br><span class="line">    print(f&quot;ID book1 : &#123;id(book1)&#125; != ID book2 : &#123;id(book2)&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>原型模式用于创建复杂的和耗时的实例，复制一个已经存在的实例使程序运行更高效。</li></ul><p>缺点：</p><ul><li>每一个产品类都必须配置一个克隆方法，并且这个克隆方法需要对类的功能进行整体考虑。</li></ul><h2 id="创建型模式小结"><a href="#创建型模式小结" class="headerlink" title="创建型模式小结"></a>创建型模式小结</h2><p>抽象工厂模式和建造者模式相比于简单工厂模式和工厂方法模式而言更灵活也更复杂。</p><p>通常情况下，设计以简单工厂模式或工厂方法模式开始，当你发现设计需要更大的灵活性时，则向更复杂的设计模式演化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
