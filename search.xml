<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网站登录</title>
      <link href="/website-login/"/>
      <url>/website-login/</url>
      
        <content type="html"><![CDATA[<p>要想知道网站的登录方式为什么使用jwt还是得知道网站的发展历程来看。</p><span id="more"></span><p>为了方便叙事，年代记已经混淆，忽略即可，只是为了理清概念。</p><h2 id="1-0-时代"><a href="#1-0-时代" class="headerlink" title="1.0 时代"></a>1.0 时代</h2><p>最初的时候，网站都是纯粹的静态网站，基本上一台机器就能满足需求，每一次请求都会向后端请求新页面，此时用户的登录信息都是保存在cookie和session中的。</p><p>cookie是保存在客户端的，用户是可以篡改的，所以是不安全的。session是保存在服务器端的，用户是无法篡改的，所以是安全的。</p><p><img src="/post/web/weibo-cookie.png" alt="weibo-cookies"></p><p>可以看到这里面定义了一个<code>WBPSESS</code>的cookie，盲猜这个是<code>weibo security session</code>的缩写。</p><p>cookie是保存在客户端的，用户是可以篡改的。虽然session是保存在服务器端的，但是session的id是保存在cookie中的，我们可以替换成别人的session<br>id，这样就可以伪装成别人登录了。</p><p>session只是能保证存储信息是安全合法的，但是不保证传输过程是安全的。</p><p>cookie和session的传输都是浏览器自带的行为，不需要特殊处理，只要有cookie就会自动带上，所以这两种方式都是无感知的。</p><h2 id="2-0-时代"><a href="#2-0-时代" class="headerlink" title="2.0 时代"></a>2.0 时代</h2><p>后来，随着网站的发展，一台机器一个进程已经扛不住了，因此出现了一台机器多个进程，这样的话，session信息如果存储在内存中就无法共享了，用户的登录信息就无法共享了。</p><p>因此出现了分布式session，用户的登录信息都是保存在数据库中的，这样的话，用户的登录信息是安全的，因为数据库是保存在服务器端的，用户是无法篡改的。</p><p>但是这样的话，每次请求都需要向数据库请求用户的登录信息，这样的话，性能就会下降，时间耗费在io上。换成redis的话，情况是一样的。</p><p>同样的时期，ajax出现了。ajax是一种异步请求，可以不刷新页面就请求数据，web的访问方式就发生了变化，不再是每次请求都向后端请求新页面，而是向后端请求数据，然后前端自己渲染页面。</p><p>前端自己渲染页面的话，灵活性就会提高，用户体验就会提高，但是问题随之而来，比如CSRF(跨站请求伪造 cross-site request forgery)<br>攻击和XSS(跨站脚本攻击 cross-site scripting)攻击。</p><h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3><p>CSRF攻击是一种利用用户身份的攻击方式，攻击者可以伪造用户的请求，这样的话，用户的登录信息就会被盗取。</p><p><img src="/post/web/csrf.jpg" alt="csrf"></p><p>比如：</p><ol><li>user登录了工商银行，工商银行给user分配了一个session id，保存在cookie中，然后user看了一下自己的账户余额，工资已经发下来了。</li><li>user访问了不合法的网站，这个网站里面有一个img标签，src是工商银行的转账接口，这个接口是一个get请求，参数是转账金额和转账账户。</li><li>user想放大图片，不断点击图片，这样的话，就会不断的向工商银行发送转账请求，因为已经登录了，所以cookie是会自动带上的，这样的话，就会不断的转账。</li><li>第二天，user再看自己的账户余额，发现自己的钱不见了。</li></ol><p>整个过程十分隐秘，银行没有预警的情况下，user完全无法察觉。</p><h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><p>XSS攻击是一种利用用户身份的攻击方式，攻击者可以在网页中插入恶意脚本，这样的话，用户的登录信息就会被盗取。</p><p>比如：</p><ol><li>user看到勇哥直播，想给勇哥打赏，于是点击了礼物。</li><li>但是评论区有人发了一个恶意评论，这个评论是一段js代码，这段代码直接修改了礼物充值的接口，把user的钱转到了攻击者的账户。</li><li>user充值了1000元，但是发现自己的账户余额没有增加，而攻击者的账户余额增加了1000元。</li></ol><p>为了应对这些情况，人们有了各种各样的解决方案，这不是今天的重点。</p><h2 id="3-0-时代"><a href="#3-0-时代" class="headerlink" title="3.0 时代"></a>3.0 时代</h2><p>为了应对各种问题，浏览器设置了同源策略，这样的话，不同域名的网站就无法访问对方的cookie了，这样的话，CSRF攻击就无法进行了。</p><p>什么是同源策略呢？</p><p>一个域名地址由协议、域名、端口、请求路径、查询参数组成。</p><p><img src="/post/web/same-origin.webp" alt="same-origin"></p><p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。</p><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作DOM，那么会有⼀套基础的安全策略的制约，我们把这称为同源策略。</p><p>它的存在可以保护用户隐私信息，防止身份伪造等(读取Cookie)。</p><p>同源策略主要表现在 DOM、web数据 和 网络 这三个层面。</p><ul><li>DOM 层面：页面嵌页面（iframe）无法进行相互操作。</li><li>web数据层面：限制cookie、localStorage和indexDB的读取，不同源的网站无法读取对方的cookie、localStorage和indexDB。</li><li>网络层面：限制跨域请求。</li></ul><h3 id="跨域过程"><a href="#跨域过程" class="headerlink" title="跨域过程"></a>跨域过程</h3><p>注意跨域过程：</p><ol><li>浏览器向服务器发送请求。</li><li>服务器返回响应。</li><li>浏览器解析响应。</li><li>发现不是同源，拦截请求。</li></ol><p>所以可以知道，跨域不是请求发不出去，而是请求发出去了，服务器正常接收请求并返回，但是浏览器拦截了响应。</p><h3 id="跨域行为"><a href="#跨域行为" class="headerlink" title="跨域行为"></a>跨域行为</h3><p>同源策略是浏览器的行为，不是HTTP的规范。</p><p>但是有三个标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=&#39;&#39;&gt;</code></li><li><code>&lt;link href=&#39;&#39;&gt;</code></li><li><code>&lt;script src=&#39;&#39;&gt;</code></li></ul><p>因为以上内容允许跨域加载资源，所以一般优化的时候，会把静态资源放在cdn上，这样的话，用户访问网站的时候，就会向cdn请求资源，这样的话，用户的访问速度就会提高。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>什么时候会遇到跨域问题呢？比如”今日头条”。头条不可能所有的新闻都是自己的，所以会有很多新闻是从其他网站转载过来的，这样的话，就会遇到跨域问题，因为不同的新闻来源的是不同源的。</p><p>怎么解决跨域问题呢？国内一般就三种。</p><ul><li>JSONP<ul><li>还记得有三种标签是允许跨域加载资源的吗？script标签就是其中之一，所以可以通过script标签加载资源，这样的话，就可以跨域了。</li><li>JSONP就是利用script标签动态加载资源，然后在资源的回调函数中处理数据。</li><li>但是缺点也很明显，首先JSONP只支持GET请求，不支持POST请求。其次JSONP需要前后端配合，后端需要返回一个回调函数，前端需要处理这个回调函数，类似gRPC的方式了</li></ul></li><li>CORS<ul><li>CORS(cross-origin resource sharing)是一种跨域资源共享的方式，服务器设置。</li><li>浏览器只要获取到Access-Control-Allow-Origin的响应头，判断合法，就会放行请求。实现了跨域。</li><li>这种方式的优点是只需要后端配合，前端不需要做任何处理。</li><li>面试题：Access-Control-Allow-Origin是谁设置的？怎么设置的？</li></ul></li><li>代理<ul><li>在前后端之间添加一个转发的代理服务器，这样的话，就可以实现跨域了。</li><li>这种方式的优点是完全不需要前后端有任何配合，只要都面向这个额外的服务器开发即可。</li><li>面试题：为什么要用代理解决跨域问题？代理上不会跨域吗？</li></ul></li></ul><h3 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h3><p>为啥要说到同源策略呢？还记得同源策略会限制什么吗？会限制cookie、localStorage和indexDB的读取。会导致什么问题呢？会导致session无法通过cookie传递，因为不同域名的网站无法访问对方的cookie了。</p><p>那怎么办？这时候jwt就出现了。（通过配置也能实现cookie传递，这里列举一般情况）</p><p>jwt（json web token）很早就有，但是在这个时候才开始大面积流行。jwt是 json web token 的缩写，是一种跨域传递非敏感信息的方式，它不存储在服务器端，而是存储在客户端。</p><p>一个典型的jwt长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.dyt0CoTl4WoVjAHI9Q_CwSKhl6d_9rhM3NrXuJttkao</span><br></pre></td></tr></table></figure><p>你可能会有疑问，不是json吗？怎么是一串字符呢？先不忙，先看看jwt的组成，它是由三部分组成的，分别是header（头部）、payload（载荷）和signature（签名）。</p><p>header和payload都是json格式数据然后使用base64编码得到，因此想要获得真正的数据，只需要解码即可。</p><p>比如这里的header是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他代表了这个jwt的加密方式和类型。</p><p>这里的payload是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他代表了这个jwt的载荷，也就是用户的信息。</p><p>理论上payload是可以存储任何信息的，但是官方其实也给出了建议，如果你使用开源库的话，就会发现开源库对这些字段都有一定的校验。</p><ol><li>iss (Issuer)：表示签发该 JWT 的发行者。</li><li>sub (Subject)：表示该 JWT 所面向的用户。</li><li>aud (Audience)：表示该 JWT 的预期接收者。</li><li>exp (Expiration Time)：表示该 JWT 的过期时间，UNIX 时间戳格式。</li><li>nbf (Not Before)：表示在该时间之前 JWT 不会被接受和处理，UNIX 时间戳格式。</li><li>iat (Issued At)：表示该 JWT 的签发时间，UNIX 时间戳格式。</li><li>jti (JWT ID)：表示该 JWT 的唯一标识符。</li><li>scope：表示用户的权限。字符串数组。</li><li>data：自定义字段。存放用户自定义的信息。</li></ol><p>从这里可以看到，jwt信息十分容易获取，因此jwt是不适合存储敏感信息的。</p><p>签名是由header、payload和盐加密得到的，具体过程略，这样的话，就可以保证jwt的完整性，如果有人篡改了jwt，那么签名就会不匹配。</p><p>和jwt一起经常出现的两个名词还有jws(json web signature)和jwe(json web encryption)。这两个都是开放标准，用于在jwt上进行签名和加密。</p><p>jws就是只对内容进行签名，内容本身不加密。与我们常见的jwt类似。jwe是对内容进行加密，然后再对加密后的内容进行签名。这样的话，就可以保证内容的机密性和完整性。当然成本也会提高。</p><p>至此，jwt开始崭露头角，但是查看它的过程就知道，从session到jwt，其实是将io的时间转移到了cpu上，因为每次请求都需要解码jwt，大量请求的话，cpu的负担就会很重。</p><p>面试题：</p><ol><li>session和jwt本质上就不同，为什么总是拿来比较？</li><li>为什么有些系统会选择jwt，有些系统会选择session？</li></ol><h3 id="题外话时间"><a href="#题外话时间" class="headerlink" title="题外话时间"></a>题外话时间</h3><blockquote><p>题外话01：jwt的签名安全吗？</p></blockquote><p>不断会有人说jwt替换了session是因为jwt更加安全，用户无法修改。然而，事实真的是这样吗？</p><p>我们也知道jwt的第三段是签名，那么我们不要这个签名行不行呢？答案是可以的，因为jwt的加密方法在header中，所以我们可以直接修改header，定义<br>alg 为 none，这样的话，就可以得到一个没有签名的jwt了。</p><p>如果组件是开源框架，不是自己写的，那么这个框架会通过header中的 alg 来判断是否需要签名，如果 alg 是 none，那么就不会进行签名。</p><p>此时，你修改的是哪个用户，你现在就是哪个用户了。</p><blockquote><p>题外话02：jwt真的简化了取数据的流程了吗？</p></blockquote><p>并没有，我们之前也说了，jwt只适合存储非敏感信息，而且数据量不能过大，否则每次传输也会占用网络带宽。</p><p>那么需要获取具体信息怎么办呢？</p><p>这时候就要根据jwt的载荷定义的用户标识，然后去数据库中查询对应用户表以及关联表等。本质上是查询延后了而已，并没有简化，而大多数视频只谈论前半部分步骤，貌似较少了io。</p><blockquote><p>题外话03：token 是什么？</p></blockquote><p>在手机app、小程序等场景中，我们没有办法直接使用cookie&#x2F;session，于是一些人定义了token，这个token是一串字符，用来代表用户的身份。这个token是保存在客户端的，每次请求的时候，都会带上这个token。</p><p>有没有似曾相识的感觉？</p><p>没错，这个token就是另外一种形式的session，只不过session浏览器会自动传递，而token还得自己维护。</p><blockquote><p>题外话04： API Key 是什么？</p></blockquote><p>API Key 是一种用于访问 API 的密钥，它是一串字符，用来代表用户的身份。这个 API Key 是保存在客户端的，每次请求的时候，都会带上这个<br>API Key。他已经被绝大多数开放API所使用。</p><p><img src="/post/web/wechat-api-key.png" alt="wechat-api-key"></p><p>jwt、cookie、API Key的对比如下：</p><table><thead><tr><th></th><th>jwt</th><th>cookie</th><th>API Key</th></tr></thead><tbody><tr><td>应用场景</td><td>前后端、后端服务</td><td>前后端</td><td>后端服务</td></tr><tr><td>认证对象</td><td>主要是用户</td><td>用户</td><td>系统、应用</td></tr><tr><td>撤销</td><td>不方便</td><td>方便</td><td>方便</td></tr><tr><td>生成方式</td><td>动态生成</td><td>动态生成</td><td>预先分配</td></tr></tbody></table><p>jwt 缺点如下：</p><ol><li>jwt无法实时退出所有client，因为jwt是保存在客户端的，用户是无法篡改的，所以只能等待jwt过期。</li><li>信息修改无法及时同步。比如jwt存储了用户的信息，而此时用户修改了信息，但是jwt是不会自动更新的，只能等待jwt过期。</li><li>jwt泄露无法马上将token无效。</li></ol><p>三种认证方式各有优劣，没有绝对的好坏之分，只有适合不适合。很多网站也会把jwt和cookie结合使用，jwt存储用户的信息，cookie存储jwt，简化开发，也防止乱存的jwt泄露。</p><h2 id="4-0-时代"><a href="#4-0-时代" class="headerlink" title="4.0 时代"></a>4.0 时代</h2><p>看起来网站已经和现在差不多了，还有什么发展呢？</p><p>其实也不算发展，只是起了一个名字，同一时代，jwt流行起来，还有个技术流行起来，就是分布式系统。</p><p>分布式系统和jwt一样，自古有之，但是认证问题还没有统一。此时一个用户可能会访问多个系统，每个系统都需要认证且认证系统不一样的话，不仅麻烦还不安全。</p><p>一种解决方案就是单点登录（SSO，single sign-on）。</p><p>SSO是一种认证机制，用户只需要登录一次，就可以访问多个系统，这样的话，用户的登录信息就是安全的，因为用户只需要登录一次。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>目前比较流行的就是CAS(Central Authentication Service 中央认证服务器)。CAS是一种开源的单点登录协议，它的原理是这样的：</p><ol><li>用户访问网站A，网站A发现用户没有登录，就会重定向到CAS服务器。</li><li>用户向CAS认证，然后CAS服务器会给用户一个ST(Service Ticket)，一个TGT(Ticket Granting Ticket)，并且重定向到网站A。</li><li>用户拿着ST去网站A，网站A获取到ST</li><li>网站A不知真假，拿着ST和自己的服务标识去CAS服务器验证，验证通过返回给网站A。</li><li>网站A得到验证通过的信息，就会给用户创建session或者jwt。</li><li>只要session或者jwt没有过期，用户就可以一直访问网站A。</li></ol><p>以上是用户访问网站A的过程，用户访问网站B的过程是一样的。</p><ol><li>用户继续访问网站B，网站B发现用户没有登录，就会重定向到CAS服务器。</li><li>但是此时用户已经有了TGT，所以不需要再次登录，CAS服务器会直接给用户一个ST，然后重定向到网站B。</li><li>用户拿着ST去网站B，网站B获取到ST……之后的步骤和网站A一样</li></ol><p>CAS的过程对于用户是透明的，用户的感受是只需要登录一次，就可以访问多个系统。当然上面的过程是简化的，实际上还有很多细节。</p><h3 id="OAuth2和OIDC介绍"><a href="#OAuth2和OIDC介绍" class="headerlink" title="OAuth2和OIDC介绍"></a>OAuth2和OIDC介绍</h3><p>OIDC(OpenID Connect)<br>是OpenID的升级版，OpenID是一种认证协议，OIDC是一种认证协议，它是基于OAuth2的，OAuth2是一种授权协议。OpenID的官网在这里：<a href="https://openid.net/">https://openid.net/</a></p><p>OAuth2是一种授权协议，现在一般都是使用OAuth2，OAuth1已经被淘汰了。OAuth2的文档在这里：<a href="https://oauth.net/2/">https://oauth.net/2/</a></p><p>在继续往下讲之前，我们先来认清两个概念：</p><ul><li>认证（authentication）：是确认用户的身份，比如用户名和密码、指纹、人脸识别等。</li><li>授权（authorization）：是确认用户的权限，比如用户有没有权限访问某个资源。</li></ul><p>OAuth2是一种授权协议，它的目的是让用户授权第三方应用访问自己的资源，比如用户授权第三方应用访问自己的微博、微信等。</p><p>为什么说OAuth2是一种授权协议呢？因为第三方仅需要用户的授权即可，它不关心用户是谁，有没有认证。</p><p>实际情况中只实现了OAuth2的应用是比较少的，还往往会实现OIDC，口语中将两者统称为OAuth2，实际上是有些不准确的。</p><p>OIDC &#x3D; OAuth2 + 认证机制，是一种OAuth2的升级版，经常用于联合登录或单点登录的场景。</p><p>为什么不迭代OAuth2，而是新定义了一个OIDC呢？正所谓一流企业做标准,二流企业做品牌,三流企业做产品，OpenID已经走上了从标准到品牌的道路，只能说利益驱动。</p><h3 id="OIDC过程"><a href="#OIDC过程" class="headerlink" title="OIDC过程"></a>OIDC过程</h3><p>这里我们通过腾讯会议通过微信登录的过程来了解一下OIDC的过程。</p><ol><li>我（用户）打开腾讯会议（客户端 client），然后点击微信登录。</li><li>腾讯会议（客户端 client）向微信平台（认证服务器 authorization server）发起请求，传入了自己的 client_id、scope和callback_url。</li><li>微信窗口提示我（用户）登录，同时提醒我账号将访问我的哪些信息。我（用户）点击屏幕进行了登录。</li><li>微信平台（认证服务器 authorization server）验证我（用户）的身份，然后通过callback_url重定向到腾讯会议（客户端<br>client）并返回了code（授权码）。</li><li>腾讯会议（客户端 client）拿着code（授权码）向微信平台（认证服务器 authorization server）发起请求，传入了自己的<br>client_id、client_secret、code</li><li>认证成功后返回了access_token（访问令牌）、refresh_token（刷新令牌）、openid（用户标识）和 unionid（用户统一标识）。</li><li>腾讯会议（客户端 client）会根据unionid去自己的数据库中查询用户信息，如果存在则返回登录状态。</li><li>如果不存在则会通过 openid 去微信平台（认证服务器 authorization server）获取用户信息，然后保存到自己的数据库中，然后返回登录状态。</li></ol><h3 id="OIDC和OAuth2的比较"><a href="#OIDC和OAuth2的比较" class="headerlink" title="OIDC和OAuth2的比较"></a>OIDC和OAuth2的比较</h3><blockquote><p>角色</p></blockquote><p>OAuth2中有四种角色：</p><ul><li>客户端（client），就是腾讯会议。</li><li>资源拥有者（resource owner），就是我。</li><li>授权服务器（authorization server），就是微信平台。</li><li>资源服务器（resource server），就是腾讯会议的数据库。</li></ul><p>OIDC聚焦在认证环节，所以没有资源服务器的角色，其他三种也有所变化：</p><ul><li>客户端称作 Relaying Party，就是腾讯会议。</li><li>资源所有者称作 终端用户（End-User），就是我。</li><li>认证服务器称作 OpenID Provider，就是微信平台。</li></ul><p>CAS 可以使 openid 的 provider，也就是 openid 的 provider 可以承担单点认证中的 CAS 的角色。</p><blockquote><p>授权方式</p></blockquote><p>OAuth2中有四种授权方式：</p><ul><li>授权码模式（authorization code），就是上面的过程，优点是不需要暴露用户的密码，就可以获取用户的授权，目前使用最多。</li><li>简化模式（implicit）</li><li>密码模式（password）</li><li>客户端模式（client credentials）</li></ul><blockquote><p>服务接口</p></blockquote><p>OAuth2中定义了两个服务接口：</p><ul><li>授权服务接口（authorization endpoint），用于获取授权码。</li><li>令牌服务接口（token endpoint），用于获取访问令牌。</li></ul><p>OIDC中新增了一个userinfo服务接口，用于获取用户信息。</p><blockquote><p>令牌</p></blockquote><p>scope定义了具体需要获取的权限，由服务实现方定义，没有统一的标准。OIDC中新增了openid的scope，令牌借口的返回响应中会包含openid属性，这个ID是一个jwt</p><p>OAuth2中定义了两种令牌：</p><ul><li>访问令牌（access token），用于访问资源。</li><li>刷新令牌（refresh token），用于刷新访问令牌。</li></ul><p>OIDC中新增了一种令牌 openid，当 scope 中指定 openid 时，就会获得 openid 令牌。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> SSO </tag>
            
            <tag> OAuth2 </tag>
            
            <tag> OIDC </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python私有pypi库搭建</title>
      <link href="/python-private-pypi/"/>
      <url>/python-private-pypi/</url>
      
        <content type="html"><![CDATA[<p>一般公司使用python开发的项目，都会有自己的私有pypi库，这样可以方便的管理自己的python包，也可以方便的管理自己的python包的版本，以及方便的管理自己的python包的依赖关系。</p><p>以下是搭建私有pypi库的步骤，以及使用私有pypi库的步骤。这里pypi库使用的是pypi-server，部署的方式是使用k8s部署的。</p><span id="more"></span><h1 id="一、-搭建私有pypi库"><a href="#一、-搭建私有pypi库" class="headerlink" title="一、 搭建私有pypi库"></a>一、 搭建私有pypi库</h1><p>首先配置资源配置清单，这里使用的是k8s的资源配置清单，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pypi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pypi-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">pypi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">pypi-server</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/instance:</span> <span class="string">pypi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pypi-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">pypi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="comment"># 这里我的环境中有storageClassName: nfs-client，如果没有，需要注释掉，手动创建pv</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs-client</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pypi-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">pypi</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">stringData:</span></span><br><span class="line">  <span class="attr">auth:</span> <span class="string">&quot;admin:admin&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pypi-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">pypi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">pypi-server</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/instance:</span> <span class="string">pypi</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">pypi-server</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/instance:</span> <span class="string">pypi</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pypi-server</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">pypiserver/pypiserver:v2.0.1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">command:</span> [ <span class="string">&quot;pypi-server&quot;</span> ]</span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--port=8080</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--passwords=/config/passwords</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--authenticate=list,update,download</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/data/packages</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">6</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">3</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">packages</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/data/packages</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/config</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">packages</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">pypi-server</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">          <span class="attr">secret:</span></span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">pypi-server</span></span><br><span class="line">            <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">            <span class="attr">items:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">auth</span></span><br><span class="line">                <span class="attr">path:</span> <span class="string">passwords</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pypi-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">pypi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">pypi-server.test.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">pypi-server</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br></pre></td></tr></table></figure><p>然后使用kubectl创建资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pypi-server.yaml</span><br></pre></td></tr></table></figure><p>创建完成后，可以使用kubectl查看资源状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get all -n pypi</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/pypi-server-7f9f9f9f9f-7f9f9    1/1     Running   0          2m</span><br><span class="line">    </span><br><span class="line">NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/pypi-server    ClusterIP</span><br></pre></td></tr></table></figure><p>然后就可以使用浏览器访问<code>http://pypi-server.test.com</code>了，这里需要注意的是，这里的域名需要配置到本地的hosts文件中，否则无法访问。</p><h1 id="二、-使用私有pypi库"><a href="#二、-使用私有pypi库" class="headerlink" title="二、 使用私有pypi库"></a>二、 使用私有pypi库</h1><h2 id="上传包"><a href="#上传包" class="headerlink" title="上传包"></a>上传包</h2><p>这里我们上传下载都是使用的poetry，怎么使用poetry创建项目以及简单使用，可以参考<a href="https://realtiger.github.io/python-poetry/">python依赖管理和打包工具poetry</a></p><p>首先需要配置poetry的源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry <span class="built_in">source</span> add pypi-server http://pypi-server.test.com --priority supplemental</span><br></pre></td></tr></table></figure><p>再将项目进行打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry build</span><br></pre></td></tr></table></figure><p>还需要配置poetry的认证信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry config http-basic.pypi-server admin admin</span><br></pre></td></tr></table></figure><p>然后使用poetry上传包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry publish -r pypi-server</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> devops </tag>
            
            <tag> pypi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python依赖管理和打包工具poetry</title>
      <link href="/python-poetry/"/>
      <url>/python-poetry/</url>
      
        <content type="html"><![CDATA[<p>poetry是一个python的依赖管理和打包工具，类似于nodejs的npm和java的maven，可以用来管理python项目的依赖和打包发布。</p><span id="more"></span><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="正常安装"><a href="#正常安装" class="headerlink" title="正常安装"></a>正常安装</h2><p>poetry需要python3.8以上的版本，这里实验使用官方安装程序安装，安装平台是ubuntu系统，其他安装方式可以参考<a href="https://python-poetry.org/docs/#installing-with-the-offcial-installer">官方文档</a></p><p>如果没有python3.8以上的版本，可以使用以下命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev wget libbz2-dev</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://www.python.org/ftp/python/3.12.1/Python-3.12.1.tar.xz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xf Python-3.12.1.tar.xz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> Python-3.12.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --enable-optimizations --prefix=/usr/local/python3.12</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make -j 8</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">ln</span> -s /usr/local/python3.12/bin/python3.12 /usr/bin/python3.12</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">ln</span> -s /usr/local/python3.12/bin/pip3.12 /usr/bin/pip3.12</span></span><br></pre></td></tr></table></figure><p>有了python环境后，就可以安装poetry了。我目前登录的用户是ubuntu，因此下面的用户家目录是<code>/home/ubuntu</code>，如果是其他用户，需要替换成对应的用户家目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过命令安装</span></span><br><span class="line">$ curl -sSL https://install.python-poetry.org | python3.12 -</span><br><span class="line"></span><br><span class="line">Retrieving Poetry metadata</span><br><span class="line"></span><br><span class="line"><span class="comment"># Welcome to Poetry!</span></span><br><span class="line"></span><br><span class="line">This will download and install the latest version of Poetry,</span><br><span class="line">a dependency and package manager <span class="keyword">for</span> Python.</span><br><span class="line"></span><br><span class="line">It will add the `poetry` <span class="built_in">command</span> to Poetry<span class="string">&#x27;s bin directory, located at:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/home/ubuntu/.local/bin</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You can uninstall at any time by executing this script with the --uninstall option,</span></span><br><span class="line"><span class="string">and these changes will be reverted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Installing Poetry (1.7.1): Done</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Poetry (1.7.1) is installed now. Great!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To get started you need Poetry&#x27;</span>s bin directory (/home/ubuntu/.local/bin) <span class="keyword">in</span> your `PATH`</span><br><span class="line">environment variable.</span><br><span class="line"></span><br><span class="line">Add `<span class="built_in">export</span> PATH=<span class="string">&quot;/home/ubuntu/.local/bin:<span class="variable">$PATH</span>&quot;</span>` to your shell configuration file.</span><br><span class="line"></span><br><span class="line">Alternatively, you can call Poetry explicitly with `/home/ubuntu/.local/bin/poetry`.</span><br><span class="line"></span><br><span class="line">You can <span class="built_in">test</span> that everything is <span class="built_in">set</span> up by executing:</span><br><span class="line"></span><br><span class="line">`poetry --version`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看poetry二进制命令的位置</span></span><br><span class="line">$ <span class="built_in">ls</span> -l ~/.local/bin/poetry</span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 50 Jan  4 14:08 /home/ubuntu/.local/bin/poetry -&gt; /home/ubuntu/.local/share/pypoetry/venv/bin/poetry</span><br><span class="line">$ <span class="built_in">ls</span> -l ~/.local/share/pypoetry/venv/bin/poetry</span><br><span class="line">-rwxrwxr-x 1 ubuntu ubuntu 259 Jan  4 14:08 /home/ubuntu/.local/share/pypoetry/venv/bin/poetry</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看poetry版本，因为路径已经添加到PATH中，因此可以直接执行poetry命令</span></span><br><span class="line">$ poetry --version</span><br><span class="line">Poetry (version 1.7.1)</span><br></pre></td></tr></table></figure><h2 id="指定安装目录"><a href="#指定安装目录" class="headerlink" title="指定安装目录"></a>指定安装目录</h2><p>默认情况下，Linux系统会安装到<code>~/.local/share/pypoetry</code>目录下，如果需要修改安装目录，可以使用<code>POETRY_HOME</code>环境变量，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://install.python-poetry.org | POETRY_HOME=/opt/poetry python3.12 -</span><br></pre></td></tr></table></figure><h2 id="指定发行版本"><a href="#指定发行版本" class="headerlink" title="指定发行版本"></a>指定发行版本</h2><p>如果安装预发行版本，可以使用<code>--preview</code>选项或者使用<code>POETRY_PREVIEW</code>环境变量，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://install.python-poetry.org | python3.12 - --preview</span><br><span class="line">$ curl -sSL https://install.python-poetry.org | POETRY_PREVIEW=1 python3.12 -</span><br></pre></td></tr></table></figure><p>如果安装特定版本，可以使用<code>--version</code>选项或者使用<code>POETRY_VERSION</code>环境变量，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://install.python-poetry.org | python3.12 - --version=1.2.0</span><br><span class="line">$ curl -sSL https://install.python-poetry.org | POETRY_VERSION=1.2.0 python3.12 -</span><br></pre></td></tr></table></figure><h2 id="从git仓库安装"><a href="#从git仓库安装" class="headerlink" title="从git仓库安装"></a>从git仓库安装</h2><p>还可以使用<code>git</code>从git仓库安装，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://install.python-poetry.org | python3.12 - --git https://github.com/python-poetry/poetry.git@master</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>使用<code>self update</code>命令可以更新poetry，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ poetry self update</span><br><span class="line">Updating Poetry version ...</span><br><span class="line"></span><br><span class="line">Using version ^1.7.1 <span class="keyword">for</span> poetry</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (270.5s)</span><br><span class="line"></span><br><span class="line">No dependencies to install or update</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br></pre></td></tr></table></figure><p>如果需要更新到预发行版本，可以使用<code>--preview</code>选项，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry self update --preview</span><br></pre></td></tr></table></figure><p>如果需要更新到特定版本，可以使用<code>--version</code>选项，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry self update --version=1.2.0</span><br></pre></td></tr></table></figure><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>如果不想要poetry了，可以使用<code>--uninstall</code>选项或者使用<code>POETRY_UNINSTALL</code>环境变量，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://install.python-poetry.org | python3.12 - --uninstall</span><br><span class="line">$ curl -sSL https://install.python-poetry.org | POETRY_UNINSTALL=1 python3.12 -</span><br></pre></td></tr></table></figure><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>poetry 支持为Bash、Fish和Zsh提供自动补全，获取更详细的信息可以使用<code>poetry help completions</code>命令，这里只说Bash的自动补全。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成自动补全脚本</span></span><br><span class="line">$ vim ~/.profile</span><br><span class="line">......</span><br><span class="line"><span class="built_in">source</span> &lt;(poetry completions bash)</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></table></figure><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>这里我们使用poetry创建一个fastapi的项目，然后添加依赖，最后打包发布。</p><p>fastapi是一个python的web库，可以用来快速构建web服务，使用starlette作为web框架，使用pydantic作为数据验证框架，使用uvicorn作为web服务器。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>我们先创建一个叫做<code>thousand-sunny</code>的项目，使用<code>poetry new</code>命令可以创建一个新的项目，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ poetry new thousand-sunny</span><br><span class="line">Created package thousand-sunny <span class="keyword">in</span> thousand-sunny</span><br></pre></td></tr></table></figure><p>创建的项目结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tree thousand-sunny/</span><br><span class="line">thousand-sunny/</span><br><span class="line">├── README.md</span><br><span class="line">├── pyproject.toml</span><br><span class="line">├── tests</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── thousand_sunny</span><br><span class="line">    └── __init__.py</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br></pre></td></tr></table></figure><p>其中<code>pyproject.toml</code>是项目的配置文件，<code>thousand_sunny</code>是项目的python包，<code>tests</code>是项目的测试目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> thousand-sunny/</span><br><span class="line">$ <span class="built_in">cat</span> README.md</span><br><span class="line">$ <span class="built_in">cat</span> pyproject.toml</span><br><span class="line">[tool.poetry]</span><br><span class="line">name = <span class="string">&quot;thousand-sunny&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">description = <span class="string">&quot;&quot;</span></span><br><span class="line">authors = [<span class="string">&quot;Your Name &lt;you@example.com&gt;&quot;</span>]</span><br><span class="line">readme = <span class="string">&quot;README.md&quot;</span></span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = <span class="string">&quot;^3.12&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line">build-backend = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>tool.poetry.name</code>是项目的名称</li><li><code>tool.poetry.version</code>是项目的版本</li><li><code>tool.poetry.description</code>是项目的描述</li><li><code>tool.poetry.authors</code>是项目的作者</li><li><code>tool.poetry.readme</code>是项目的README文件</li><li><code>tool.poetry.dependencies</code>是项目的依赖<ul><li><code>python</code>是python的版本，poetry要求显示的指定python的版本</li></ul></li><li><code>build-system</code>是项目的构建系统。</li></ul><h2 id="已存在项目初始化"><a href="#已存在项目初始化" class="headerlink" title="已存在项目初始化"></a>已存在项目初始化</h2><p>和git类似，如果已经有了一个项目，可以使用<code>poetry init</code>命令初始化，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> going-merry</span><br><span class="line">$ <span class="built_in">cd</span> going-merry/</span><br><span class="line">$ poetry init</span><br><span class="line">This <span class="built_in">command</span> will guide you through creating your pyproject.toml config.</span><br><span class="line"></span><br><span class="line">Package name [going-merry]:</span><br><span class="line">Version [0.1.0]:</span><br><span class="line">Description []:</span><br><span class="line">Author [None, n to skip]:  n</span><br><span class="line">License []:</span><br><span class="line">Compatible Python versions [^3.12]:</span><br><span class="line"></span><br><span class="line">Would you like to define your main dependencies interactively? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>]</span><br><span class="line">You can specify a package <span class="keyword">in</span> the following forms:</span><br><span class="line">  - A single name (requests): this will search <span class="keyword">for</span> matches on PyPI</span><br><span class="line">  - A name and a constraint (requests@^2.23.0)</span><br><span class="line">  - A git url (git+https://github.com/python-poetry/poetry.git)</span><br><span class="line">  - A git url with a revision (git+https://github.com/python-poetry/poetry.git<span class="comment">#develop)</span></span><br><span class="line">  - A file path (../my-package/my-package.whl)</span><br><span class="line">  - A directory (../my-package/)</span><br><span class="line">  - A url (https://example.com/packages/my-package-0.1.0.tar.gz)</span><br><span class="line"></span><br><span class="line">Package to add or search <span class="keyword">for</span> (leave blank to skip):</span><br><span class="line"></span><br><span class="line">Would you like to define your development dependencies interactively? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>]</span><br><span class="line">Package to add or search <span class="keyword">for</span> (leave blank to skip):</span><br><span class="line"></span><br><span class="line">Generated file</span><br><span class="line"></span><br><span class="line">[tool.poetry]</span><br><span class="line">name = <span class="string">&quot;going-merry&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">description = <span class="string">&quot;&quot;</span></span><br><span class="line">authors = [<span class="string">&quot;Your Name &lt;you@example.com&gt;&quot;</span>]</span><br><span class="line">readme = <span class="string">&quot;README.md&quot;</span></span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = <span class="string">&quot;^3.12&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line">build-backend = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Do you confirm generation? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录</span></span><br><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">└── pyproject.toml</span><br><span class="line"></span><br><span class="line">0 directories, 1 file</span><br></pre></td></tr></table></figure><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>如果向项目中添加依赖，可以使用两种方式，一种是直接编辑<code>pyproject.toml</code>文件，另一种是使用<code>poetry add</code>命令。</p><h3 id="直接编辑pyproject-toml"><a href="#直接编辑pyproject-toml" class="headerlink" title="直接编辑pyproject.toml"></a>直接编辑pyproject.toml</h3><p>编辑<code>pyproject.toml</code>文件，添加依赖，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim pyproject.toml</span><br><span class="line">......</span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = <span class="string">&quot;^3.12&quot;</span></span><br><span class="line">fastapi = <span class="string">&quot;^0.70.0&quot;</span></span><br><span class="line">uvicorn = <span class="string">&quot;^0.15.0&quot;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到，依赖项需要进行包名称和版本的指定，版本可以使用<code>^</code>、<code>~</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>等符号，也可以使用<code>*</code>表示任意版本。</p><p>poetry会根据<code>tool.poetry.dependencies</code>中的依赖项，在<code>tool.poetry.source</code>中的源或者PyPI中查找、安装。</p><h3 id="使用poetry-add命令"><a href="#使用poetry-add命令" class="headerlink" title="使用poetry add命令"></a>使用poetry add命令</h3><p>使用<code>poetry add</code>命令也可以添加依赖，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加fastapi依赖</span></span><br><span class="line">$ poetry add fastapi</span><br><span class="line">Creating virtualenv thousand-sunny-mMs6oAD9-py3.12 <span class="keyword">in</span> /home/ubuntu/.cache/pypoetry/virtualenvs</span><br><span class="line">Using version ^0.108.0 <span class="keyword">for</span> fastapi</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (3.3s)</span><br><span class="line"></span><br><span class="line">Package operations: 9 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing idna (3.6)</span><br><span class="line">  • Installing sniffio (1.3.0)</span><br><span class="line">  • Installing typing-extensions (4.9.0)</span><br><span class="line">  • Installing annotated-types (0.6.0)</span><br><span class="line">  • Installing anyio (4.2.0)</span><br><span class="line">  • Installing pydantic-core (2.14.6)</span><br><span class="line">  • Installing pydantic (2.5.3)</span><br><span class="line">  • Installing starlette (0.32.0.post1)</span><br><span class="line">  • Installing fastapi (0.108.0)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加uvicorn依赖</span></span><br><span class="line">$ poetry add <span class="string">&quot;uvicorn[standard]&quot;</span></span><br><span class="line">Using version ^0.25.0 <span class="keyword">for</span> uvicorn</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (3.1s)</span><br><span class="line"></span><br><span class="line">Package operations: 9 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing click (8.1.7)</span><br><span class="line">  • Installing h11 (0.14.0)</span><br><span class="line">  • Installing httptools (0.6.1)</span><br><span class="line">  • Installing python-dotenv (1.0.0)</span><br><span class="line">  • Installing pyyaml (6.0.1)</span><br><span class="line">  • Installing uvloop (0.19.0)</span><br><span class="line">  • Installing watchfiles (0.21.0)</span><br><span class="line">  • Installing websockets (12.0)</span><br><span class="line">  • Installing uvicorn (0.25.0)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加开发依赖</span></span><br><span class="line">$ poetry add pytest -G dev</span><br><span class="line">Using version ^7.4.4 <span class="keyword">for</span> pytest</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (2.9s)</span><br><span class="line"></span><br><span class="line">Package operations: 4 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing iniconfig (2.0.0)</span><br><span class="line">  • Installing packaging (23.2)</span><br><span class="line">  • Installing pluggy (1.3.0)</span><br><span class="line">  • Installing pytest (7.4.4)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pyproject.toml文件</span></span><br><span class="line">$ <span class="built_in">cat</span> pyproject.toml</span><br><span class="line">[tool.poetry]</span><br><span class="line">name = <span class="string">&quot;thousand-sunny&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">description = <span class="string">&quot;&quot;</span></span><br><span class="line">authors = [<span class="string">&quot;Your Name &lt;you@example.com&gt;&quot;</span>]</span><br><span class="line">readme = <span class="string">&quot;README.md&quot;</span></span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = <span class="string">&quot;^3.12&quot;</span></span><br><span class="line">fastapi = <span class="string">&quot;^0.108.0&quot;</span></span><br><span class="line">uvicorn = &#123;extras = [<span class="string">&quot;standard&quot;</span>], version = <span class="string">&quot;^0.25.0&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">[tool.poetry.group.dev.dependencies]</span><br><span class="line">pytest = <span class="string">&quot;^7.4.4&quot;</span></span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line">build-backend = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>poetry add</code>命令会自动更新<code>pyproject.toml</code>文件。同时，安装过后会创建一个<code>poetry.lock</code>文件，用来锁定依赖的版本。</p><h2 id="使用虚拟环境"><a href="#使用虚拟环境" class="headerlink" title="使用虚拟环境"></a>使用虚拟环境</h2><p>poetry会为每个项目创建一个虚拟环境，这样可以避免依赖冲突，也可以避免污染全局环境。</p><p>默认情况下，poetry会在<code>&#123;cache-dir&#125;/virtualenvs</code>中创建虚拟环境，可以通过修改<code>cache-dir</code>来修改虚拟环境的位置。另外，可以使用<code>virtualenvs.in-project</code>来指定虚拟环境是否在项目中，如果设置为<code>true</code>，则会在项目的<code>.venv</code>目录中创建虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ poetry config --list</span><br><span class="line">cache-dir = <span class="string">&quot;/home/ubuntu/.cache/pypoetry&quot;</span></span><br><span class="line">experimental.system-git-client = <span class="literal">false</span></span><br><span class="line">installer.max-workers = null</span><br><span class="line">installer.modern-installation = <span class="literal">true</span></span><br><span class="line">installer.no-binary = null</span><br><span class="line">installer.parallel = <span class="literal">true</span></span><br><span class="line">virtualenvs.create = <span class="literal">true</span></span><br><span class="line">virtualenvs.in-project = null</span><br><span class="line">virtualenvs.options.always-copy = <span class="literal">false</span></span><br><span class="line">virtualenvs.options.no-pip = <span class="literal">false</span></span><br><span class="line">virtualenvs.options.no-setuptools = <span class="literal">false</span></span><br><span class="line">virtualenvs.options.system-site-packages = <span class="literal">false</span></span><br><span class="line">virtualenvs.path = <span class="string">&quot;&#123;cache-dir&#125;/virtualenvs&quot;</span>  <span class="comment"># /home/ubuntu/.cache/pypoetry/virtualenvs</span></span><br><span class="line">virtualenvs.prefer-active-python = <span class="literal">false</span></span><br><span class="line">virtualenvs.prompt = <span class="string">&quot;&#123;project_name&#125;-py&#123;python_version&#125;&quot;</span></span><br><span class="line">warnings.export = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>virtualenvs.create</code>默认为<code>true</code>，<code>virtualenvs.in-project</code>默认为<code>null</code>，<code>virtualenvs.path</code>默认为<code>&#123;cache-dir&#125;/virtualenvs</code>。</p><p>要想运行Poetry创建的虚拟环境，可以有多种方式。</p><h3 id="run命令"><a href="#run命令" class="headerlink" title="run命令"></a>run命令</h3><p>使用<code>poetry run</code>命令可以在虚拟环境中运行命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ poetry run python --version</span><br><span class="line">Python 3.12.1</span><br><span class="line"></span><br><span class="line">$ vim main.py</span><br><span class="line">from fastapi import FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">@app.get(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">async def read_root():</span><br><span class="line">    <span class="built_in">return</span> &#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line">$ poetry run uvicorn main:app --reload</span><br></pre></td></tr></table></figure><h3 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h3><p>激活虚拟环境最简单的方式是使用<code>poetry shell</code>命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ poetry shell</span><br><span class="line">Spawning shell within /home/ubuntu/.cache/pypoetry/virtualenvs/thousand-sunny-mMs6oAD9-py3.12</span><br><span class="line"></span><br><span class="line">$ python --version</span><br><span class="line">Python 3.12.1</span><br></pre></td></tr></table></figure><p>如果要退出虚拟环境并退出shell，可以使用<code>exit</code>命令，如果只是退出虚拟环境，可以使用<code>deactivate</code>命令。</p><p>如果想要防止进入虚拟环境修改shell提示符，可以使用环境变量<code>VIRTUAL_ENV_DISABLE_PROMPT=1</code>。</p><p>如果不想要创建新shell，可以手动激活虚拟环境，激活命令为：<code>source &#123;path_to_venv&#125;-&#123;python_version&#125;/bin/activate</code>，停用命令相似，为：<code>deactivate</code>。获取虚拟环境的路径可以使用<code>poetry env info --path</code>命令</p><p>也可以使用一行命令<code>source &quot;$(poetry env info --path)/bin/activate&quot;</code>激活虚拟环境。</p><h2 id="为项目安装依赖"><a href="#为项目安装依赖" class="headerlink" title="为项目安装依赖"></a>为项目安装依赖</h2><h3 id="安装全部依赖"><a href="#安装全部依赖" class="headerlink" title="安装全部依赖"></a>安装全部依赖</h3><p>如果一个已经存在的项目，它是通过poetry创建的，那么可以使用<code>poetry install</code>命令安装依赖，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry install</span><br></pre></td></tr></table></figure><p>运行此命令的时候有两种情况：</p><ol><li><p>poetry.lock文件不存在</p><ul><li>如果您以前从未运行过该命令并且也不存在任何poetry.lock文件，Poetry只会解析pyproject.toml文件中列出的所有依赖项并下载其文件的最新版本。</li><li>当Poetry完成安装后，它将下载的所有包及其确切版本写入文件中poetry.lock，从而将项目锁定到这些特定版本。</li><li>Poetry建议应该将该poetry.lock文件提交到项目存储库，以便所有本项目的人员都被锁定到相同版本的依赖项。</li></ul></li><li><p>poetry.lock文件存在</p><ul><li>如果您以前运行过该命令并且存在poetry.lock文件，Poetry将使用该文件中列出的确切版本来安装依赖项，尽管依赖有可能不是最新版本。</li></ul></li></ol><h3 id="仅安装依赖"><a href="#仅安装依赖" class="headerlink" title="仅安装依赖"></a>仅安装依赖</h3><p>当你当前的项目是一个库，但是又不想安装项目本身，只想安装依赖时，可以使用<code>poetry install --no-root</code>命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry install --no-root</span><br></pre></td></tr></table></figure><h3 id="仅安装生产依赖"><a href="#仅安装生产依赖" class="headerlink" title="仅安装生产依赖"></a>仅安装生产依赖</h3><p>如果只想安装生产依赖，可以使用<code>--no-dev</code>选项，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry install --no-dev</span><br></pre></td></tr></table></figure><h3 id="仅安装开发依赖"><a href="#仅安装开发依赖" class="headerlink" title="仅安装开发依赖"></a>仅安装开发依赖</h3><p>如果只想安装开发依赖，可以使用<code>--dev</code>选项，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry install --dev</span><br></pre></td></tr></table></figure><h3 id="仅安装指定依赖"><a href="#仅安装指定依赖" class="headerlink" title="仅安装指定依赖"></a>仅安装指定依赖</h3><p>如果只想安装指定依赖，可以使用<code>--package</code>选项，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry install --package requests</span><br></pre></td></tr></table></figure><h2 id="依赖更新"><a href="#依赖更新" class="headerlink" title="依赖更新"></a>依赖更新</h2><p>如果想要更新依赖，可以使用<code>poetry update</code>命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry update</span><br></pre></td></tr></table></figure><p>这相当于删除<code>poetry.lock</code>文件并重新运行<code>poetry install</code>命令。</p><h2 id="删除依赖"><a href="#删除依赖" class="headerlink" title="删除依赖"></a>删除依赖</h2><p>如果想要删除依赖，则只需要执行命令<code>remove</code>，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry remove requests</span><br></pre></td></tr></table></figure><h2 id="依赖导出为其他格式"><a href="#依赖导出为其他格式" class="headerlink" title="依赖导出为其他格式"></a>依赖导出为其他格式</h2><p>如果想用其他格式的文件管理依赖，poetry提供了命令可以直接导出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">poetry <span class="built_in">export</span> -f requirements.txt --output requirements.txt</span></span><br></pre></td></tr></table></figure><p>命令的参数如下：</p><ul><li><code>-f</code>或<code>--format</code>：导出的文件格式，默认为<code>requirements.txt</code>，目前仅支持<code>requirements.txt</code>和<code>constraints.txt</code>两种格式。</li><li><code>--output</code>：导出的文件路径，默认为<code>stdout</code>。</li><li><code>--without-hashes</code>：不导出哈希值，默认为<code>false</code>。</li><li><code>--with-credentials</code>：导出私有仓库的凭证，默认为<code>false</code>。</li><li><code>--without</code>：不导出指定的依赖组</li><li><code>--with</code>：导出指定的依赖组</li></ul><h2 id="添加仓库源"><a href="#添加仓库源" class="headerlink" title="添加仓库源"></a>添加仓库源</h2><p>poetry默认使用PyPI作为仓库源，如果想要添加其他仓库源，可以使用<code>source add</code>命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry <span class="built_in">source</span> add aliyun https://mirrors.aliyun.com/pypi/simple --priority default</span><br></pre></td></tr></table></figure><p><code>priority</code>参数表示优先级，可接受的值为<code>default</code>、<code>secondary</code>、<code>supplementary</code>和<code>explicit</code>。</p><p>如果删除源可以使用<code>source remove</code>命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry <span class="built_in">source</span> remove aliyun</span><br></pre></td></tr></table></figure><h2 id="添加poetry自身的依赖"><a href="#添加poetry自身的依赖" class="headerlink" title="添加poetry自身的依赖"></a>添加poetry自身的依赖</h2><p>poetry自身也可以添加依赖和插件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry self add poetry-plugin-export</span><br></pre></td></tr></table></figure><h1 id="依赖关系管理"><a href="#依赖关系管理" class="headerlink" title="依赖关系管理"></a>依赖关系管理</h1><h2 id="依赖组"><a href="#依赖组" class="headerlink" title="依赖组"></a>依赖组</h2><p>Poetry提供了一种按组安装依赖关系的方法。例如，您可能具有仅测试项目或构建文档所需的依赖项。</p><p>要声明新的依赖项组，可以使用一个<code>tool.poetry.group.&lt;group&gt;</code>部分，其中<code>&lt;group&gt;</code>是依赖项组的名称（例如，<code>test</code>）：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry.group.test]</span>  <span class="comment"># This part can be left out</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.group.test.dependencies]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;^6.0.0&quot;</span></span><br><span class="line"><span class="attr">pytest-mock</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>所有依赖项必须跨组相互兼容，因为无论安装是否需要它们，它们都会被解析。</li><li><code>tool.poetry.dependencies</code>隐式组<code>main</code>的一部分</li><li>自poetry 1.2.0以后，<code>tool.poetry.dev-dependencies</code>已经修改为<code>tool.poetry.group.dev.dependencies</code>，<code>tool.poetry.dev-dependencies</code>仍然可以使用，但是会有警告。</li></ul></blockquote><h2 id="可选组"><a href="#可选组" class="headerlink" title="可选组"></a>可选组</h2><p>Poetry还提供了一种安装可选依赖项的方法。例如，您可能具有一个依赖项，它只能在某些平台上使用，或者您可能具有一个依赖项，它只能在某些Python版本上使用。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry.group.docs]</span></span><br><span class="line"><span class="attr">optional</span> = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line"><span class="section">[tool.poetry.group.docs.dependencies]</span></span><br><span class="line"><span class="attr">mkdocs</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>使用安装命令时，可以使用<code>--with</code>选项来安装可选组，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry install --with docs</span><br></pre></td></tr></table></figure><h2 id="使用命令向组内添加依赖"><a href="#使用命令向组内添加依赖" class="headerlink" title="使用命令向组内添加依赖"></a>使用命令向组内添加依赖</h2><p>通过使用<code>--group(-G)</code>选项，可以将依赖项添加到特定的组中，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry add pytest -G <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>如果该组不存在，会自动创建。</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>默认情况下，Poetry会安装所有非可选组的依赖项。</p><p>如果想要排除几个组，可以使用<code>--without</code>选项，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry install --without <span class="built_in">test</span>,docs</span><br></pre></td></tr></table></figure><blockquote><p>如果<code>--without</code>和<code>--with</code>选项同时使用，<code>--without</code>选项会优先<code>--with</code>选项。</p></blockquote><p>如果只是想安装特定的依赖组，可以使用<code>--only</code>选项，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry install --only <span class="built_in">test</span>,docs</span><br></pre></td></tr></table></figure><h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>实际发布库之前需要对项目进行打包，使用<code>poetry build</code>命令可以打包项目，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ poetry build</span><br><span class="line">$ poetry build</span><br><span class="line">Building thousand-sunny (0.1.0)</span><br><span class="line">  - Building sdist</span><br><span class="line">fatal: not a git repository (or any of the parent directories): .git</span><br><span class="line">  - Built thousand_sunny-0.1.0.tar.gz</span><br><span class="line">  - Building wheel</span><br><span class="line">fatal: not a git repository (or any of the parent directories): .git</span><br><span class="line">  - Built thousand_sunny-0.1.0-py3-none-any.whl</span><br></pre></td></tr></table></figure><p>打包完成后，会在<code>dist</code>目录下生成打包文件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tree dist/</span><br><span class="line">dist/</span><br><span class="line">├── thousand_sunny-0.1.0-py3-none-any.whl</span><br><span class="line">└── thousand_sunny-0.1.0.tar.gz</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br></pre></td></tr></table></figure><p>此命令将以两种不同的格式打包您的库：<code>sdist</code>这是源格式，<code>wheel</code>这是<code>compiled</code>包。</p><p>Poetry 在构建包时会自动包含一些元数据。</p><p>构建<code>wheel</code>时，以下文件会放到.dist-info目录中：</p><ul><li><code>LICENSE</code></li><li><code>LICENSE.*</code></li><li><code>COPYING</code></li><li><code>COPYING.*</code></li><li><code>LICENSES/**</code></li></ul><p>构建<code>sdist</code>时，根文件夹中将包含以下文件：</p><ul><li><code>LICENSE*</code></li></ul><p>构建完成后，就可以发布库了。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>默认情况下，Poetry会将库发布到PyPI，但是您可以配置它以发布到其他地方。</p><p>使用poetry发布十分简单，只需要使用<code>poetry publish</code>命令即可，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry publish</span><br></pre></td></tr></table></figure><p>注意：发布的包的名称和版本是通过<code>pyproject.toml</code>文件中的<code>name</code>和<code>version</code>字段来确定的。同时，<code>publish</code>命令不会自动执行<code>build</code>命令，如果想要一起执行，可以添加<code>--build</code>选项</p><p>但是，很多时候需要使用到私有仓库，这时候就需要配置私有仓库，然后指定发布到私有仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">poetry publish -r my-repository</span></span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>有时候需要在本地配置一些内容，例如，配置仓库源、配置虚拟环境的位置等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ poetry config virtualenvs.create <span class="literal">true</span> --<span class="built_in">local</span></span><br><span class="line">$ poetry config virtualenvs.in-project <span class="literal">true</span> --<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>此时，会在项目的根目录下生成一个<code>poetry.toml</code>文件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> poetry.toml</span><br><span class="line">[virtualenvs]</span><br><span class="line">create = <span class="literal">true</span></span><br><span class="line">in-project = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>有时，特别是在将Poetry与CI工具一起使用时，使用环境变量更容易，而不必执行配置命令。</p><p>Poetry支持这一点，任何设置都可以通过使用环境变量来设置。</p><p>环境变量必须以设置<code>POETRY_</code>的大写名称为前缀，并由下划线替换点和破折号组成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> POETRY_VIRTUALENVS_PATH=/path/to/virtualenvs/directory</span><br></pre></td></tr></table></figure><p>这也适用于secret设置，例如凭据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export POETRY_HTTP_BASIC_MY_REPOSITORY_PASSWORD=secret</span><br></pre></td></tr></table></figure><h2 id="可用配置"><a href="#可用配置" class="headerlink" title="可用配置"></a>可用配置</h2><p>Poetry支持的配置可以参考<a href="https://python-poetry.org/docs/configuration/#available-settings">官方文档</a></p><h1 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h1><p>poeotry提供了一些命令来管理环境，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有的虚拟环境</span></span><br><span class="line">$ poetry <span class="built_in">env</span> list</span><br><span class="line"><span class="comment"># 列出当前虚拟环境信息</span></span><br><span class="line">$ poetry <span class="built_in">env</span> info</span><br><span class="line"><span class="comment"># 删除虚拟环境</span></span><br><span class="line">$ poetry <span class="built_in">env</span> remove test-a test-b test-c</span><br></pre></td></tr></table></figure><h2 id="指定python版本"><a href="#指定python版本" class="headerlink" title="指定python版本"></a>指定python版本</h2><p>使用poetry可以直接指定你需要的python版本，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry <span class="built_in">env</span> use /usr/bin/python3.12</span><br></pre></td></tr></table></figure><p>如果要禁用虚拟环境，可以使用<code>system</code>选项查找默认行为，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry <span class="built_in">env</span> use system</span><br></pre></td></tr></table></figure><h2 id="显示环境信息"><a href="#显示环境信息" class="headerlink" title="显示环境信息"></a>显示环境信息</h2><p>使用<code>info</code>命令可以显示当前虚拟环境的信息，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ poetry <span class="built_in">env</span> info</span><br><span class="line"></span><br><span class="line">Virtualenv</span><br><span class="line">Python:         3.12.1</span><br><span class="line">Implementation: CPython</span><br><span class="line">Path:           /home/ubuntu/.cache/pypoetry/virtualenvs/thousand-sunny-mMs6oAD9-py3.12</span><br><span class="line">Executable:     /home/ubuntu/.cache/pypoetry/virtualenvs/thousand-sunny-mMs6oAD9-py3.12/bin/python</span><br><span class="line">Valid:          True</span><br><span class="line"></span><br><span class="line">System</span><br><span class="line">Platform:   linux</span><br><span class="line">OS:         posix</span><br><span class="line">Python:     3.12.1</span><br><span class="line">Path:       /opt/python312</span><br><span class="line">Executable: /opt/python312/bin/python3.12</span><br></pre></td></tr></table></figure><p>如果只想知道路径信息，可以使用<code>--path</code>选项，入股执行知道可执行文件的路径，可以使用<code>--executable</code>选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">poetry <span class="built_in">env</span> info --path</span></span><br><span class="line">/home/ubuntu/.cache/pypoetry/virtualenvs/thousand-sunny-mMs6oAD9-py3.12</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">poetry <span class="built_in">env</span> info --executable</span></span><br><span class="line">/home/ubuntu/.cache/pypoetry/virtualenvs/thousand-sunny-mMs6oAD9-py3.12/bin/python</span><br></pre></td></tr></table></figure><h1 id="依赖规范"><a href="#依赖规范" class="headerlink" title="依赖规范"></a>依赖规范</h1><p>项目的依赖项可以以各种形式指定，这取决于依赖项的类型以及安装它可能需要的可选约束。</p><p>具体的显示可以参考<a href="https://python-poetry.org/docs/dependency-specification/">官方文档 Dependency specification</a></p><h1 id="pyproject-toml-文件"><a href="#pyproject-toml-文件" class="headerlink" title="pyproject.toml 文件"></a>pyproject.toml 文件</h1><p><code>pyproject.toml</code>文件是Poetry项目的核心，它包含了项目的元数据和依赖项。</p><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p><code>name</code>字段是项目的名称，必需项。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p><code>version</code>字段是项目的版本，必需项。</p><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p><code>description</code>字段是项目的简短描述，必需项。</p><h2 id="license"><a href="#license" class="headerlink" title="license"></a>license</h2><p><code>license</code>字段是项目的许可证，可选项。</p><p>常见的许可证有以下几种：</p><ul><li>Apache-2.0</li><li>BSD-2-Clause</li><li>BSD-3-Clause</li><li>BSD-4-Clause</li><li>GPL-2.0-only</li><li>GPL-2.0-or-later</li><li>GPL-3.0-only</li><li>GPL-3.0-or-later</li><li>LGPL-2.1-only</li><li>LGPL-2.1-or-later</li><li>LGPL-3.0-only</li><li>LGPL-3.0-or-later</li><li>MIT</li></ul><p>强烈建议添加，更多的许可证可以参考<a href="https://spdx.org/licenses/">SPDX 开源许可证注册表</a></p><blockquote><p>如果项目是专有的并且不使用特定许可证，则可以将此值设置为<code>Proprietary</code>。</p></blockquote><h2 id="authors"><a href="#authors" class="headerlink" title="authors"></a>authors</h2><p><code>authors</code>字段是项目的作者，必需项。</p><p>是作者列表，应至少包含一名作者。作者必须采用<code>name &lt;email&gt;</code>的形式。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">authors</span> = [</span><br><span class="line">    <span class="string">&quot;Sébastien Eustace &lt;sebastien@eustace.io&gt;&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="maintainers"><a href="#maintainers" class="headerlink" title="maintainers"></a>maintainers</h2><p><code>maintainers</code>字段是项目的维护者，可选项。</p><p>这是维护者列表，应与作者区分开来。维护者可能包含电子邮件并采用表格形式<code>name &lt;email&gt;</code>。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maintainers</span> = [</span><br><span class="line">    <span class="string">&quot;John Smith &lt;johnsmith@example.org&gt;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Jane Smith &lt;janesmith@example.org&gt;&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="readme"><a href="#readme" class="headerlink" title="readme"></a>readme</h2><p>包的<code>readme</code>文件的路径，可选项。路径相对于<code>pyproject.toml</code>文件。</p><h2 id="homepage"><a href="#homepage" class="headerlink" title="homepage"></a>homepage</h2><p>项目的主页，可选项。</p><h2 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h2><p>项目的仓库，可选项。</p><h2 id="classifiers"><a href="#classifiers" class="headerlink" title="classifiers"></a>classifiers</h2><p>描述该项目的<a href="https://pypi.org/classifiers/">PyPI分类器</a>列表，可选项。</p><h2 id="packages"><a href="#packages" class="headerlink" title="packages"></a>packages</h2><p>最终发行版中包含的包和模块的列表，可选项。</p><h2 id="include-and-exclude"><a href="#include-and-exclude" class="headerlink" title="include and exclude"></a>include and exclude</h2><p>将包含在最终包中的模式列表。</p><h2 id="dependencies-and-dependency-groups"><a href="#dependencies-and-dependency-groups" class="headerlink" title="dependencies and dependency groups"></a>dependencies and dependency groups</h2><p>项目的依赖项，可选项。</p><h2 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h2><p>安装包时将安装的脚本或可执行文件，可选项。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry.scripts]</span></span><br><span class="line"><span class="attr">my_package_cli</span> = <span class="string">&#x27;my_package.console:run&#x27;</span></span><br></pre></td></tr></table></figure><p>在这里，我们将声明<code>my_package_cli</code>安装脚本，该脚本将执行<code>my_package</code>包中模块<code>console</code>中的函数<code>run</code>。</p><p>添加完本地脚本后，可以使用<code>poetry run</code>或者<code>poetry install</code>命令安装脚本。</p><h2 id="extras"><a href="#extras" class="headerlink" title="extras"></a>extras</h2><p>额外的依赖项，可选项。</p><ul><li>可选依赖项，可增强包，但不是必需的</li><li>可选依赖项的集群。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python第三方网络库httpx</title>
      <link href="/python-httpx/"/>
      <url>/python-httpx/</url>
      
        <content type="html"><![CDATA[<p>HTTPX是Python3的全功能HTTP客户端,它提供同步和异步API,并支持HTTP&#x2F;1.1和HTTP&#x2F;2。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>根据官网的描述，总结有如下特点:</p><ul><li>和使用 requests 一样方便,requests 有的它都有</li><li>加入 HTTP&#x2F;1.1 和 HTTP&#x2F;2 的支持。</li><li>能够直接向 WSGI 应用程序或 ASGI 应用程序发出请求。</li><li>到处都有严格的超时设置</li><li>全类型注释</li><li>100％ 的测试覆盖率</li></ul><p>github介绍:<a href="https://github.com/encode/httpx">https://github.com/encode/httpx</a></p><p>文档介绍:<a href="https://www.python-httpx.org/">https://www.python-httpx.org/</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>httpx安装很简单，直接使用pip安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install httpx</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>httpx的使用和requests类似，可以直接使用get&#x2F;post&#x2F;put&#x2F;delete等方法发送请求</p><p>下面就是简单实用httpx发送GET&#x2F;POST&#x2F;PUT&#x2F;DELETE&#x2F;PATCH&#x2F;HEAD&#x2F;OPTIONS请求的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地调试后端地址</span></span><br><span class="line">base_url = <span class="string">&quot;http://10.209.0.23:5100/api/model&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_get</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试get请求</span></span><br><span class="line"><span class="string">    get请求和requests差不多，也支持代理模式、重定向、证书认证等</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = base_url</span><br><span class="line">    response = httpx.get(url)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.json())</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_post</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试post请求</span></span><br><span class="line"><span class="string">    post请求，同样支持json、formdata、files等类型的数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = base_url</span><br><span class="line">    body = &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">        <span class="string">&quot;detail&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    response = httpx.post(url, json=body)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_put</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试put请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = <span class="string">f&quot;<span class="subst">&#123;base_url&#125;</span>/123687577743360&quot;</span></span><br><span class="line">    body = &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;test-update&quot;</span>,</span><br><span class="line">        <span class="string">&quot;detail&quot;</span>: <span class="string">&quot;test-update&quot;</span>,</span><br><span class="line">        <span class="string">&quot;level&quot;</span>: <span class="number">123123</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    response = httpx.put(url, json=body)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_delete</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试delete请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = <span class="string">f&quot;<span class="subst">&#123;base_url&#125;</span>/123687577743360&quot;</span></span><br><span class="line">    response = httpx.delete(url)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_patch</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试patch请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = <span class="string">f&quot;<span class="subst">&#123;base_url&#125;</span>/123687577743360&quot;</span></span><br><span class="line">    body = &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;test-patch&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    response = httpx.patch(url, json=body)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_head</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试head请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = base_url</span><br><span class="line">    response = httpx.head(url)</span><br><span class="line">    <span class="built_in">print</span>(response.headers)</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_options</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试options请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = base_url</span><br><span class="line">    response = httpx.options(url)</span><br><span class="line">    <span class="built_in">print</span>(response.headers)</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line">    <span class="built_in">print</span>(response.headers.get(<span class="string">&quot;allow&quot;</span>))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_get()</span><br><span class="line">    <span class="comment"># test_post()</span></span><br><span class="line">    <span class="comment"># test_put()</span></span><br><span class="line">    <span class="comment"># test_delete()</span></span><br><span class="line">    <span class="comment"># test_patch()</span></span><br><span class="line">    test_head()</span><br><span class="line">    test_options()</span><br></pre></td></tr></table></figure><h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><p>如果我们直接跳转上面的请求方法可以看到，httpx的请求方法最终都是通过使用Client类来实现的，所以我们可以直接使用Client类来实现更多的功能</p><p><code>httpx.Client</code>类支持同步和异步请求，支持tcp连接池、代理、重定向、证书认证、cookies等功能</p><h3 id="Client类使用方式"><a href="#Client类使用方式" class="headerlink" title="Client类使用方式"></a>Client类使用方式</h3><p>Client类的使用方式有两种，一种是作为上下文管理器，一种是直接实例化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作为上下文管理器使用，会自动关闭连接</span></span><br><span class="line"><span class="keyword">with</span> httpx.Client() <span class="keyword">as</span> client:</span><br><span class="line">    response = client.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 直接实例化，需要手动关闭连接</span></span><br><span class="line">client = httpx.Client()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = client.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    client.close()</span><br></pre></td></tr></table></figure><h3 id="base-url"><a href="#base-url" class="headerlink" title="base_url"></a>base_url</h3><p>设置base_url是一个比较基础的功能，可以在实例化Client类的时候设置base_url，这样在请求的时候就不需要每次都写完整的url了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> httpx <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_get</span>(<span class="params">httpx_client: Client, url: <span class="built_in">str</span> = <span class="string">&quot;/&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试get请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = httpx_client.get(url)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.json())</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> Client(base_url=<span class="string">&quot;http://10.209.0.23:5100/api/&quot;</span>) <span class="keyword">as</span> client:</span><br><span class="line">        <span class="comment"># 模拟三次请求</span></span><br><span class="line">        test_get(client, url=<span class="string">&quot;model&quot;</span>)</span><br><span class="line">        test_get(client, url=<span class="string">&quot;model&quot;</span>)</span><br><span class="line">        test_get(client, url=<span class="string">&quot;model&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>httpx支持异步请求，使用异步请求可以提高性能，但是需要注意的是，异步请求的时候，需要使用async with来作为上下文管理器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> httpx <span class="keyword">import</span> AsyncClient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_get</span>(<span class="params">httpx_client: AsyncClient, url: <span class="built_in">str</span> = <span class="string">&quot;/&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试get请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = <span class="keyword">await</span> httpx_client.get(url)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.json())</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncClient(base_url=<span class="string">&quot;http://10.209.0.23:5100/api/&quot;</span>) <span class="keyword">as</span> client:</span><br><span class="line">        <span class="keyword">await</span> test_get(client, url=<span class="string">&quot;model&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>httpx支持tcp连接池，可以提高性能，使用方式也很简单，只需要在实例化Client类的时候设置连接池的大小即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> httpx <span class="keyword">import</span> AsyncClient, Limits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_get</span>(<span class="params">httpx_client: AsyncClient, url: <span class="built_in">str</span> = <span class="string">&quot;/&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试get请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = <span class="keyword">await</span> httpx_client.get(url)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.json())</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建一个最大连接数为100，最大保持活动连接数为20的连接池</span></span><br><span class="line">    limits = Limits(max_connections=<span class="number">100</span>, max_keepalive_connections=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 应用连接池</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncClient(base_url=<span class="string">&quot;http://10.209.0.23:5100/api/&quot;</span>, limits=limits) <span class="keyword">as</span> client:</span><br><span class="line">        <span class="keyword">await</span> test_get(client, url=<span class="string">&quot;model&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>httpx支持钩子函数，可以在请求前后执行一些操作，比如请求前打印日志，请求后打印日志等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> httpx <span class="keyword">import</span> AsyncClient, Limits, Request, Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">log_request</span>(<span class="params">request: Request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    请求钩子，用于打印请求信息</span></span><br><span class="line"><span class="string">    :param request: 请求对象</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;&gt;&gt;&gt; 发送请求: <span class="subst">&#123;request.method&#125;</span> <span class="subst">&#123;request.url&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; 请求头:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> request.headers.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; 请求体:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(request.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">log_response</span>(<span class="params">response: Response</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    响应钩子，用于打印响应信息</span></span><br><span class="line"><span class="string">    :param response: 响应对象</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;&lt;&lt;&lt; 接收响应: <span class="subst">&#123;response.status_code&#125;</span> <span class="subst">&#123;response.url&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;&lt;&lt; 响应头:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> response.headers.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取响应体，由于响应体是异步的，所以需要使用aread()方法。aread()方法只能调用一次，多次调用会抛出异常</span></span><br><span class="line">    <span class="comment"># 需要再单独执行一次读取操作的原因是响应体一般比较大，如果在响应钩子中读取，会导致响应钩子执行时间过长，影响性能，因此需要显示的调用aread()方法</span></span><br><span class="line">    <span class="comment"># 注意：只有在响应钩子中读取响应体时，才需要使用aread()方法，其他情况下，可以直接使用response.text、response.json()等方法读取</span></span><br><span class="line">    content = <span class="keyword">await</span> response.aread()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;&lt;&lt; 响应体:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_get</span>(<span class="params">httpx_client: AsyncClient, url: <span class="built_in">str</span> = <span class="string">&quot;/&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试get请求</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    response = <span class="keyword">await</span> httpx_client.get(url)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.json())</span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建一个最大连接数为100，最大保持活动连接数为20的连接池</span></span><br><span class="line">    limits = Limits(max_connections=<span class="number">100</span>, max_keepalive_connections=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 应用连接池</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncClient(</span><br><span class="line">            base_url=<span class="string">&quot;http://10.209.0.23:5100/api/&quot;</span>,</span><br><span class="line">            limits=limits,</span><br><span class="line">            event_hooks=&#123;</span><br><span class="line">                <span class="comment"># 注册请求钩子</span></span><br><span class="line">                <span class="string">&quot;request&quot;</span>: [log_request],</span><br><span class="line">                <span class="comment"># 注册响应钩子</span></span><br><span class="line">                <span class="string">&quot;response&quot;</span>: [log_response]</span><br><span class="line">            &#125;</span><br><span class="line">    ) <span class="keyword">as</span> client:</span><br><span class="line">        <span class="keyword">await</span> test_get(client, url=<span class="string">&quot;model&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> httpx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins 初体验</title>
      <link href="/k8s-devops-jenkins/"/>
      <url>/k8s-devops-jenkins/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>CI&#x2F;CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI&#x2F;CD 的核心概念是持续集成、持续交付和持续部署。作为一种面向开发和运维团队的解决方案，CI&#x2F;CD 主要针对在集成新代码时所引发的问题。这里主要介绍jenkins的使用。</p><span id="more"></span><p>ci&#x2F;cd常用的持续集成工具：</p><ul><li>travis-ci</li><li>circleci</li><li>bamboo</li><li>teamcity</li><li>gitlabci</li><li>jenkins</li><li>tekton</li><li>argo</li><li>spinnaker</li><li>drone</li><li>concourse</li><li>等等……</li></ul><p>本次要实现的效果是基于k8s集群部署gitlab、sonarQube、Jenkins等工具，并把上述一些工具集成到Jenkins中，以Django项目和SpringBoot项目为例，通过多分支流水线及Jenkinsfile实现项目代码提交到不同的仓库分支，实现自动代码扫描、单元测试、docker容器构建、k8s服务的自动部署。</p><p>其中包含的内容有：</p><ul><li>DevOps、CI、CD介绍</li><li>Jenkins、sonarQube、gitlab的快速部署</li><li>Jenkins初体验</li><li>流水线入门及Jenkinsfile使用</li><li>Jenkins与Kubernetes的集成</li><li>sonarQube代码扫描与Jenkins的集成</li><li>实践Django项目的基于Jenkinsfile实现开发、测试环境的CI&#x2F;CD</li></ul><h1 id="DevOps、CI、CD介绍"><a href="#DevOps、CI、CD介绍" class="headerlink" title="DevOps、CI、CD介绍"></a>DevOps、CI、CD介绍</h1><p>CI&#x2F;CD就是持续集成 Continuous Integration (<em>CI</em>) &#x2F; 持续交付Continuous Delivery (<em>CD</em>)</p><p>一般的软件交付流程如下：</p><p><img src="/post/docker/devops-roles.jpg" alt="devops-roles"></p><h2 id="软件交付发展历程"><a href="#软件交付发展历程" class="headerlink" title="软件交付发展历程"></a>软件交付发展历程</h2><p>一个软件从零开始到最终交付，大概包括以下几个阶段：规划、编码、构建、测试、发布、部署和维护，基于这些阶段，我们的软件交付模型大致经历了几个阶段：</p><h3 id="瀑布式流程"><a href="#瀑布式流程" class="headerlink" title="瀑布式流程"></a>瀑布式流程</h3><p>软件交付的早期阶段，大家都是采用瀑布式流程，如下图所示：</p><p><img src="/post/docker/devops-waterfall.jpg" alt="devops-waterfall"></p><p>前期需求确立之后，软件开发人员花费数周和数月编写代码，把所有需求一次性开发完，然后将代码交给QA（质量保障）团队进行测试，然后将最终的发布版交给运维团队去部署。</p><p>瀑布模型，简单来说，就是等一个阶段所有工作完成之后，再进入下一个阶段。这种模式的问题也很明显，产品迭代周期长，灵活性差。一个周期动辄几周几个月，适应不了当下产品需要快速迭代的场景。</p><h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><p>为了解决瀑布模型的问题，以及更好地适应当下快速迭代的场景，敏捷开发模式越来越多地被采用。敏捷开发模式的核心是任务由大拆小，开发、测试协同工作，注重开发敏捷，不重视交付敏捷。</p><p><img src="/post/docker/devops-agile.jpg" alt="devops-agile"></p><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>敏捷开发模式注重开发敏捷，不重视交付敏捷。那么如何解决交付敏捷呢？DevOps就是为了解决这个问题而诞生的。</p><p><img src="/post/docker/devops-compire.jpg" alt="devops-compire"></p><p>开发、测试、运维协同工作, 持续开发+持续交付。</p><h2 id="DevOps的工具链"><a href="#DevOps的工具链" class="headerlink" title="DevOps的工具链"></a>DevOps的工具链</h2><p>我们是否可以认为DevOps &#x3D; 提倡开发、测试、运维协同工作来实现持续开发、持续交付的一种软件交付模式？为什么最初的开发模式没有直接进入DevOps的时代？</p><p>原因是：沟通成本。</p><p>各角色人员去沟通协作的时候都是手动去做，交流靠嘴，靠人去指挥，很显然会出大问题。所以说不能认为DevOps就是一种交付模式，因为解决不了沟通协作成本，这种模式就不具备可落地性。</p><p>那DevOps时代如何解决角色之间的成本问题？DevOps的核心就是自动化。自动化的能力靠什么来支撑，工具和技术。</p><p>DevOps工具链</p><p><img src="/post/docker/devops-tools.jpg" alt="devops-tools"></p><p>靠这些工具和技术，才实现了自动化流程，进而解决了协作成本，使得devops具备了可落地性。因此我们可以大致给devops一个定义：</p><p>devops &#x3D; 提倡开发、测试、运维协同工作来实现持续开发、持续交付的一种软件交付模式 + 基于工具和技术支撑的自动化流程的落地实践。</p><p>因此devops不是某一个具体的技术，而是一种思想+自动化能力，来使得构建、测试、发布软件能够更加地便捷、频繁和可靠的落地实践。本次核心内容就是要教会大家如何利用工具和技术来实现完整的DevOps平台的建设。我们主要使用的工具有：</p><ol><li>gitlab，代码仓库，企业内部使用最多的代码版本管理工具。</li><li>Jenkins， 一个可扩展的持续集成引擎，用于自动化各种任务，包括构建、测试和部署软件。</li><li>robotFramework， 基于Python的自动化测试框架</li><li>sonarqube，代码质量管理平台</li><li>maven，java包构建管理工具</li><li>Kubernetes</li><li>Docker</li></ol><h1 id="Kubernetes环境中部署jenkins"><a href="#Kubernetes环境中部署jenkins" class="headerlink" title="Kubernetes环境中部署jenkins"></a>Kubernetes环境中部署jenkins</h1><p>本次部署使用helm部署的方式，也可以使用yaml文件部署，参考<a href="https://jenkins.io/zh/doc/book/installing/">其他部署方式</a></p><p>注意点：</p><ul><li>第一次启动很慢</li><li>因为后面Jenkins会与kubernetes集群进行集成，会需要调用kubernetes集群的api，因此安装的时候创建了ServiceAccount并赋予了cluster-admin的权限</li><li>初始化容器来设置权限</li><li>ingress来外部访问</li><li>数据存储通过pvc挂载到宿主机中</li></ul><h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建chart仓库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm repo add jenkins https://charts.jenkins.io</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm repo update</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索jenkins</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm search repo jenkins</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载chart包</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm pull jenkins/jenkins</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -zxvf jenkins-4.9.1.tgz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim jenkins/values.yaml</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">  ingress:</span><br><span class="line">    # 启用ingress</span><br><span class="line">    enabled: true</span><br><span class="line">    ......</span><br><span class="line">    # 配置ingressClassName</span><br><span class="line">    ingressClassName: nginx</span><br><span class="line">    # 配置ingress的hosts</span><br><span class="line">    hostName: jenkins.test.com</span><br><span class="line">    ......</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">不进行测试</span></span><br><span class="line">  testEnabled: false</span><br><span class="line">  ......</span><br><span class="line">persistence:</span><br><span class="line">  enabled: true</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">配置storageClass</span></span><br><span class="line">  storageClass: &quot;nfs-client&quot;</span><br><span class="line">  annotations: &#123;&#125;</span><br><span class="line">  labels: &#123;&#125;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">设置pvc的模式</span></span><br><span class="line">  accessMode: &quot;ReadWriteMany&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">设置pvc的大小</span></span><br><span class="line">  size: &quot;200Gi&quot;</span><br><span class="line">  ......</span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm -n jenkins upgrade --create-namespace -i jenkins ./jenkins</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待安装完成</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -n jenkins get all</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取登录密码</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> --namespace jenkins -it svc/jenkins -c jenkins -- /bin/cat /run/secrets/additional/chart-admin-password &amp;&amp; <span class="built_in">echo</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用浏览器访问jenkins，输入账号密码就可以登录了</span></span><br></pre></td></tr></table></figure><p><img src="/post/docker/k8s-devops-jenkins-index.jpg" alt="k8s devops jenkins index"></p><p>由于默认的插件地址安装非常慢，我们可以替换成国内清华的源，进入 jenkins 工作目录，目录下面有一个 updates 的目录，下面有一个 default.json 文件，我们执行下面的命令替换插件地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n jenkins <span class="built_in">exec</span> -it jenkins-0 -c jenkins -- bash</span><br><span class="line">jenkins@jenkins-0:/$ <span class="built_in">cd</span> /var/jenkins_home/updates</span><br><span class="line">jenkins@jenkins-0:~/updates$ sed -i <span class="string">&#x27;s/https:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27;</span> default.json</span><br><span class="line">jenkins@jenkins-0:~/updates$ sed -i <span class="string">&#x27;s/https:\/\/updates.jenkins.io\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json</span><br></pre></td></tr></table></figure><blockquote><p>暂时先不用重新启动pod，汉化后一起重启。</p></blockquote><p>配置升级站点的URL：</p><ol><li>进入 web ui 的界面，点击 Manage Jenkins -&gt; Plugins 按钮，进入插件管理页面：<a href="http://jenkins.test.com/manage/pluginManager/advanced">http://jenkins.test.com/manage/pluginManager/advanced</a></li><li>选择最后一项 Advanced settings</li><li>在 Update Site 中将原有url替换为：<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></li><li>点击 Submit 按钮，保存设置</li></ol><p>接下来我们就可以重启服务了。重启jenkins服务有两种方式：</p><ol><li>删除pod，kubernetes会自动重启</li><li>访问下面这个url重启：<a href="http://jenkins.test.com/restart/">http://jenkins.test.com/restart/</a> 这样重启的话，pod不会重建</li></ol><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>分别点击以下菜单 Jenkins -&gt; Manage Jenkins -&gt; Plugins -&gt; Avaliable plugins</p><p>主要安装以下插件：</p><ul><li>GitLab</li><li>Pipeline: Multibranch</li><li>Blue Ocean</li><li>Localization: Chinese (Simplified)</li><li>Gogs （太老了，没有维护，但是gitlab比较重，这里先安装gogs，仅实验使用，之后webhook和gitlab用法相同）</li></ul><p>如果安装超时，需要查看之前更改的数据源是否生效，如果没有生效，需要重新配置。</p><p>选中后，选择[Install]，等待下载完成，然后点击[ Restart Jenkins when installation is complete and no jobs are running ]，让Jenkins自动重启</p><p>启动后，界面默认变成中文。</p><h1 id="Kubernetes环境中部署gogs"><a href="#Kubernetes环境中部署gogs" class="headerlink" title="Kubernetes环境中部署gogs"></a>Kubernetes环境中部署gogs</h1><p>这里我们需要一个git仓库，因为实验使用的环境比较轻量，因此选用gogs来部署。</p><h2 id="安装gogs"><a href="#安装gogs" class="headerlink" title="安装gogs"></a>安装gogs</h2><p>gogs的helm仓库已经很老了，因此整理了以下的资源清单，使用k8s部署gogs。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># postgres secret</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">cG9zdGdyZXM=</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">cG9zdGdyZXM=</span></span><br><span class="line">    <span class="attr">dbname:</span> <span class="string">Z29ncw==</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># postgres service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">5432</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5432</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">postgres</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># postgres persistent volume claim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">accessModes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">    <span class="attr">storageClassName:</span> <span class="string">nfs-client</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># postgres deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">postgres</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">postgres</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">postgres:15</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5432</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POSTGRES_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">password</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POSTGRES_USER</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">user</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POSTGRES_DB</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">dbname</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/postgresql/data</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">postgres</span></span><br><span class="line">        <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">          <span class="attr">claimName:</span> <span class="string">postgres</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># memcache service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">memcache</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">memcache</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">11211</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">11211</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">memcache</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># memcache deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">memcache</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">memcache</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">memcached</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">metadata:</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">memcached</span></span><br><span class="line">      <span class="attr">spec:</span></span><br><span class="line">        <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">memcached</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">memcached:1.6.22</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;memcached&quot;</span>, <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;64&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="string">&quot;11211&quot;</span>, <span class="string">&quot;-u&quot;</span>, <span class="string">&quot;memcache&quot;</span>, <span class="string">&quot;-v&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;1024&quot;</span>, <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;modern&quot;</span>]</span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">11211</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">memcached</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">tcpSocket:</span></span><br><span class="line">              <span class="attr">port:</span> <span class="string">memcached</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">tcpSocket:</span></span><br><span class="line">              <span class="attr">port:</span> <span class="string">memcached</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># gogs persistent volume claim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gogs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">accessModes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">    <span class="attr">storageClassName:</span> <span class="string">nfs-client</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># gogs configmap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gogs-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">app.ini:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">    BRAND_NAME = TestGogs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    [<span class="string">server</span>]</span><br><span class="line">    <span class="string">EXTERNAL_URL</span> <span class="string">=</span> <span class="string">http://gogs.test.com/</span></span><br><span class="line">    <span class="string">DOMAIN</span> <span class="string">=</span> <span class="string">gogs.test.com</span></span><br><span class="line">    <span class="string">HTTP_PORT</span> <span class="string">=</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">database</span>]</span><br><span class="line">    <span class="string">TYPE</span> <span class="string">=</span> <span class="string">postgres</span></span><br><span class="line">    <span class="string">HOST</span> <span class="string">=</span> <span class="string">postgres:5432</span></span><br><span class="line">    <span class="string">NAME</span> <span class="string">=</span> <span class="string">gogs</span></span><br><span class="line">    <span class="string">USER</span> <span class="string">=</span> <span class="string">postgres</span></span><br><span class="line">    <span class="string">PASSWORD</span> <span class="string">=</span> <span class="string">postgres</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">cache</span>]</span><br><span class="line">    <span class="string">ADAPTER</span> <span class="string">=</span> <span class="string">memcache</span></span><br><span class="line">    <span class="string">INTERVAL</span> <span class="string">=</span> <span class="number">60</span></span><br><span class="line">    <span class="string">HOST</span> <span class="string">=</span> <span class="string">memcached:11211</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">ui</span>]</span><br><span class="line">    <span class="string">EXPLORE_PAGING_NUM</span> <span class="string">=</span> <span class="number">50</span></span><br><span class="line">    <span class="string">ISSUE_PAGING_NUM</span> <span class="string">=</span> <span class="number">50</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">ui.user</span>]</span><br><span class="line">    <span class="string">REPO_PAGING_NUM</span> <span class="string">=</span> <span class="number">50</span></span><br><span class="line">    <span class="string">COMMITS_PAGING_NUM</span> <span class="string">=</span> <span class="number">50</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">prometheus</span>]</span><br><span class="line">    <span class="string">ENABLED</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">other</span>]</span><br><span class="line">    <span class="string">SHOW_FOOTER_BRANDING</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">security</span>]</span><br><span class="line">    <span class="string">INSTALL_LOCK</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="string">SECRET_KEY</span>   <span class="string">=</span> <span class="string">sHyaED0SMrLCR7x</span></span><br><span class="line">    <span class="string">LOCAL_NETWORK_ALLOWLIST</span> <span class="string">=</span> <span class="string">*</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># gogs service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gogs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssh</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">22</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">22</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">gogs</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># gogs deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gogs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">gogs</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">gogs</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">metadata:</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">gogs</span></span><br><span class="line">      <span class="attr">spec:</span></span><br><span class="line">        <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gogs</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">gogs/gogs:0.13.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">3000</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssh</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gogs</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gogs-config</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/data/gogs/conf/app.ini</span></span><br><span class="line">              <span class="attr">subPath:</span> <span class="string">app.ini</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gogs</span></span><br><span class="line">            <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">              <span class="attr">claimName:</span> <span class="string">gogs</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gogs-config</span></span><br><span class="line">            <span class="attr">configMap:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">gogs-config</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ingress</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gogs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">gogs</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">gogs.test.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">gogs</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p>有了资源配置清单，我们就可以部署gogs了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建命名空间</span></span><br><span class="line">$ kubectl create namespace gogs</span><br><span class="line"><span class="comment"># 部署gogs</span></span><br><span class="line">$ kubectl apply -f gogs.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">$ kubectl get pod -n gogs</span><br></pre></td></tr></table></figure><p>全部容器启动成功后，我们就可以配置host然后通过浏览器访问gogs了。</p><p><img src="/post/docker/k8s-devops-gogs-index.jpg" alt="k8s devops gogs index"></p><p>这时可以点击右上角的注册按钮，注册一个账户，在gogs中id&#x3D;0，也就是第一个注册的账户，是管理员账户，可以创建组织、创建仓库等操作。</p><p><img src="/post/docker/k8s-devops-gogs-register.jpg" alt="k8s devops gogs register"></p><p>注册完成后，我们就可以使用这个账户登录gogs了。</p><p><img src="/post/docker/k8s-devops-gogs-login.jpg" alt="k8s devops gogs login"></p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>安装完成gogs我们就可以创建一个仓库了。这里创建一个django项目的仓库，仓库名称为moonlight。创建方法与github类似，这里就不再赘述。</p><p>创建完成后的仓库如下图所示：</p><p><img src="/post/docker/k8s-devops-gogs-repo.jpg" alt="k8s devops gogs repo"></p><p>然后就可以创建django项目了，然后将远程仓库地址添加到django项目中，合并后提交到远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin startproject moonlight</span><br><span class="line">$ <span class="built_in">cd</span> moonlight</span><br><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">$ git remote add origin http://gogs.test.com/administrator/moonlight.git</span><br><span class="line">$ git pull --rebase origin master</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>通过gogs的网页，可以看到代码已经提交到了仓库中。</p><p><img src="/post/docker/k8s-devops-gogs-repo-commit.jpg" alt="k8s devops gogs repo commit"></p><h2 id="配置jenkins"><a href="#配置jenkins" class="headerlink" title="配置jenkins"></a>配置jenkins</h2><p>在gogs中，我们可以配置webhook，当代码提交到仓库后，会触发webhook，然后调用jenkins的接口，从而触发jenkins的流水线。</p><p>webhook触发的是jenkins的流水线，因此我们需要先创建一个流水线，然后再配置webhook。</p><p>因此我们先创建一个流水线</p><p><img src="/post/docker/k8s-devops-jenkins-create-a-job.jpg" alt="k8s devops jenkins create a job"></p><p>然后选择自由风格的软件项目，名字叫free-style-demo，然后点击确定。</p><p><img src="/post/docker/k8s-devops-jenkins-create-free-style-job.jpg" alt="k8s devops jenkins create free style job"></p><p>然后我们就可以配置流水线了。首先我们先配置源码管理。选择git，然后填写仓库地址，这里填写的是gogs的仓库地址。然后当焦点离开仓库地址的时候，会发现git报错了，提示指定一个git仓库。</p><p><img src="/post/docker/k8s-devops-jenkins-git-repo-error.jpg" alt="k8s devops jenkins git repo error"></p><p>这是因为我们使用的是url地址，而k8s内部无法解析这个地址，要想解决这个问题，有两种方式：</p><ol><li>在容器内配置hosts</li><li>配置coredns的静态解析</li></ol><p>这里我们使用第二种方式，配置coredns的静态解析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-system edit configmap coredns</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  Corefile: |</span><br><span class="line">    .:53 &#123;</span><br><span class="line">        errors</span><br><span class="line">        health &#123;</span><br><span class="line">           lameduck 5s</span><br><span class="line">        &#125;</span><br><span class="line">        ready</span><br><span class="line">        kubernetes cluster.local in-addr.arpa ip6.arpa &#123;</span><br><span class="line">           pods insecure</span><br><span class="line">           fallthrough in-addr.arpa ip6.arpa</span><br><span class="line">           ttl 30</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># hosts字段为新加内容，将解析地址填入。我们将git仓库和jenkins的地址都做了解析，是因为之后使用git的webhook的时候还得用jenkins的url，因此也需要解析。</span></span><br><span class="line">        hosts &#123;</span><br><span class="line">          192.168.100.1 gogs.test.com jenkins.test.com</span><br><span class="line">          fallthrough</span><br><span class="line">        &#125;</span><br><span class="line">        prometheus :9153</span><br><span class="line">        forward . /etc/resolv.conf &#123;</span><br><span class="line">           max_concurrent 1000</span><br><span class="line">        &#125;</span><br><span class="line">        cache 30</span><br><span class="line">        loop</span><br><span class="line">        reload</span><br><span class="line">        loadbalance</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>然后保存即可。保存后我们再回到jenkins的配置页面，重新刷新配置，发现git的报错已经消失了。</p><p><img src="/post/docker/k8s-devops-jenkins-git-repo-success.jpg" alt="k8s devops jenkins git repo success"></p><p>因为这里我们的仓库是公有的，因此不需要配置认证信息，如果是私有仓库，需要配置认证信息。</p><p>这里我们直接配置认证信息，做一个演示。点击添加，选择用户名密码，然后填写用户名密码，id保证内部唯一即可，然后点击添加。</p><p><img src="/post/docker/k8s-devops-jenkins-git-auth-username.jpg" alt="k8s devops jenkins git auth username"></p><p><img src="/post/docker/k8s-devops-jenkins-git-auth-password.jpg" alt="k8s devops jenkins git auth password"></p><p>然后认证选择刚刚添加的认证信息。</p><p><img src="/post/docker/k8s-devops-jenkins-git-auth.jpg" alt="k8s devops jenkins git auth"></p><p>往下走，构建触发器。这里我们选择”Build when a change is pushed to GoGS”，也就是当代码提交到gogs的时候，触发构建。</p><p><img src="/post/docker/k8s-devops-jenkins-build-trigger.jpg" alt="k8s devops jenkins build trigger"></p><p>再往下，Build Steps，我们选择执行shell命令。这个就是说，当代码提交到gogs的时候，jenkins会下载代码，然后执行Buile Steps中的命令。</p><p><img src="/post/docker/k8s-devops-jenkins-build-steps.jpg" alt="k8s devops jenkins build steps"></p><p>这里我们主要是测试，先写一个简单点的<code>echo success</code>，点击”可用的环境变量”，可以看到jenkins提供了很多环境变量，这些环境变量可以在shell中使用，这里也打印一个环境变量。</p><p><img src="/post/docker/k8s-devops-jenkins-build-steps-env.jpg" alt="k8s devops jenkins build steps env"></p><p>然后点击保存即可。</p><p><img src="/post/docker/k8s-devops-jenkins-build-steps-save.jpg" alt="k8s devops jenkins build steps save"></p><h2 id="配置webhook"><a href="#配置webhook" class="headerlink" title="配置webhook"></a>配置webhook</h2><p>jenkins的流水线配置完成后，我们就可以配置webhook了。点击仓库的设置按钮，然后选择管理Web钩子，点击添加Web钩子，选择Gogs</p><p><img src="/post/docker/k8s-devops-gogs-repo-webhook.jpg" alt="k8s devops gogs repo webhook"></p><p>然后填写推送地址，推送地址为 <code>http://jenkins.test.com/gogs-webhook/?job=free-style-demo</code> ，这里的<code>free-style-demo</code>为jenkins的流水线名称。</p><blockquote><p>gogs 配置的推送地址格式为 <code>http(s)://&lt;Jenkins地址&gt;/gogs-webhook/?job=&lt;Jenkins任务名&gt;</code></p></blockquote><p><img src="/post/docker/k8s-devops-gogs-repo-webhook-url.jpg" alt="k8s devops gogs repo webhook url"></p><p>然后点击添加Web钩子即可。</p><p><img src="/post/docker/k8s-devops-gogs-repo-webhook-add.jpg" alt="k8s devops gogs repo webhook add"></p><p>添加成功后能看到Web钩子列表中多了一个Web钩子。</p><p><img src="/post/docker/k8s-devops-gogs-repo-webhook-list.jpg" alt="k8s devops gogs repo webhook list"></p><p>然后我们点进去，点击测试按钮，测试一下是否能够触发jenkins的流水线。然后就能看到测试已经推送了。</p><p><img src="/post/docker/k8s-devops-gogs-repo-webhook-test.jpg" alt="k8s devops gogs repo webhook test"></p><p>测试按钮底下也有一个成功的推送记录。</p><p><img src="/post/docker/k8s-devops-gogs-repo-webhook-test-success.jpg" alt="k8s devops gogs repo webhook test success"></p><p>此时，去jenkins的流水线页面，可以看到流水线已经触发了。</p><p><img src="/post/docker/k8s-devops-jenkins-build-success.jpg" alt="k8s devops jenkins build success"></p><h2 id="触发构建"><a href="#触发构建" class="headerlink" title="触发构建"></a>触发构建</h2><p>在<code>moonlight</code>项目中，创建一个<code>test.md</code>文件，然后提交到远程仓库，触发jenkins的流水线。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> &gt; test.md</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;test&quot;</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>然后我们可以看到jenkins的流水线已经触发了。</p><p><img src="/post/docker/k8s-devops-jenkins-gogs-push-build-success.jpg" alt="k8s devops jenkins gogs push build success"></p><p>等待build完成后，点击序号，可以看到build的日志。</p><p><img src="/post/docker/k8s-devops-jenkins-gogs-push-build-info.jpg" alt="k8s devops jenkins gogs push build info"></p><p>点击控制台输出，可以看到整个流水线的执行过程以及日志。</p><p><img src="/post/docker/k8s-devops-jenkins-gogs-push-build-console.jpg" alt="k8s devops jenkins gogs push build console"></p><p>拉倒最后可以看到整体是先把git仓库拉取到本地，然后执行了我们配置的shell命令。</p><p><img src="/post/docker/k8s-devops-jenkins-gogs-push-build-console-success.jpg" alt="k8s devops jenkins gogs push build console success"></p><h1 id="Jenkins-的-Master-Slave-模式"><a href="#Jenkins-的-Master-Slave-模式" class="headerlink" title="Jenkins 的 Master-Slave 模式"></a>Jenkins 的 Master-Slave 模式</h1><h2 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h2><p>在 Jenkins 页面中，点击<code>系统管理</code>, 然后点击<code>节点和云管理</code>，可以看到 Jenkins 的工作节点列表。</p><p><img src="/post/docker/k8s-devops-jenkins-node-list-button.jpg" alt="k8s devops jenkins node list button"></p><p>可以看到在 Jenkins 中，只有一个节点，这个节点就是 Jenkins 的 Master 节点，也就是 Jenkins 的主节点。</p><p><img src="/post/docker/k8s-devops-jenkins-node-list.jpg" alt="k8s devops jenkins node list"></p><p>如果有多个任务都在master节点执行，对master节点的性能就会造成一定影响。因此我们可以添加多个工作节点，让工作节点来执行任务，这样就可以减轻master节点的压力。</p><p>Jenkins 的 Master-Slave 模式是指 Jenkins 的 Master 节点负责分发任务，Slave 节点负责执行任务。这样做的好处是可以将任务分发到不同的节点上执行，从而提高任务的执行效率。</p><h2 id="添加工作节点"><a href="#添加工作节点" class="headerlink" title="添加工作节点"></a>添加工作节点</h2><blockquote><p>因为目前这个环境已经接入了k8s集群，因此我们使用k8s集群中的节点作为jenkins的工作节点。以下内容仅作为演示，最后还是会切换回k8s集群中的节点。<br>多个k8s管理和多个slave节点的添加方式大致相同，这里不再赘述，可以尝试添加基本就会了。</p></blockquote><p>点击<code>新建节点</code>，进入新建节点页面。</p><p><img src="/post/docker/k8s-devops-jenkins-node-create.jpg" alt="k8s devops jenkins node create"></p><p>定义一个节点名称，这里我们定义为<code>slave</code>，然后选择<code>固定节点</code>，然后点击确定。</p><p><img src="/post/docker/k8s-devops-jenkins-node-create-name.jpg" alt="k8s devops jenkins node create name"></p><p>之后是填写更详细的信息</p><ul><li>Number of executors：这个是指这个节点可以同时执行多少个任务，这里我们填写5，也就是这个节点可以同时执行5个任务。</li><li>远程工作目录：这个是指这个节点的工作目录，这里我们填写<code>/home/jenkins</code>，也就是这个节点的工作目录为<code>/home/jenkins</code>。</li><li>标签：这个是指这个节点的标签，这里我们填写<code>slave</code>，也就是这个节点的标签为<code>slave</code>。之后我们可以在任务中指定任务执行在哪个节点上，就是通过标签来进行控制。</li><li>启动方法：这个是指这个节点的启动方式，也就是通过什么方式实现Master-Slave的通信。这里我们选择<code>通过Java Web启动代理</code>，也就是通过Java Web启动代理的方式来实现Master-Slave的通信。<ul><li>自定义工作目录：这个是指这个节点的工作目录，这里我们填写<code>/home/jenkins</code>，也就是和上面的远程工作目录一样。</li><li>Tunnel连接位置：点开”高级”按钮就可以看到了。<ul><li>这个是指这个节点连接到Master节点的时候，通过什么方式来连接。这里我们填入<code>10.99.223.156:50000</code>。</li><li>Jenkins 默认就会开放50000端口供Slave节点连接、通信。</li><li>因为我们使用的node节点，因此ClusterIP就可以在集群内部访问，因此填写Jenkins的ClusterIP即可。</li></ul></li></ul></li></ul><p><img src="/post/docker/k8s-devops-jenkins-node-create-info.jpg" alt="k8s devops jenkins node create info"></p><p><img src="/post/docker/k8s-devops-jenkins-node-create-jave-web.jpg" alt="k8s devops jenkins node create jave web"></p><p>填写完成后，点击保存即可。</p><p>保存后，我们可以看到节点列表中多了一个节点。但是节点的状态是离线的，因为我们还没有启动这个节点。</p><p><img src="/post/docker/k8s-devops-jenkins-node-create-success.jpg" alt="k8s devops jenkins node create success"></p><h2 id="启动工作节点"><a href="#启动工作节点" class="headerlink" title="启动工作节点"></a>启动工作节点</h2><p>点击节点列表中的节点名称，进入节点详情页面。可以看到连接节点的命令，这个命令就是启动节点的命令。</p><p><img src="/post/docker/k8s-devops-jenkins-slave-node-command.jpg" alt="k8s devops jenkins slave node command"></p><p>我们在node节点上执行这个命令，启动节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先配置hosts确保能够解析jenkins的地址</span></span><br><span class="line">$ sudo vim /etc/hosts</span><br><span class="line"></span><br><span class="line">192.168.100.1 jenkins.test.com gogs.test.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为命令是java的，因此需要先安装java，注意java的版本，要和jenkins的版本一致，jenkins的pod启动的镜像名称会包含java的版本。比如本次启动的镜像是jenkins/jenkins:2.426.1-jdk17，因此我们安装的java版本也要是jdk17。</span></span><br><span class="line">$ sudo yum install java-17-openjdk.x86_64 -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保证工作目录存在</span></span><br><span class="line">$ sudo <span class="built_in">mkdir</span> -p /home/jenkins</span><br><span class="line"><span class="comment"># 修改工作目录的权限，这里修改的用户就是下面执行java命令的用户</span></span><br><span class="line">$ sudo <span class="built_in">chown</span> -R jenkins:jenkins /home/jenkins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令启动节点</span></span><br><span class="line">$ curl -sO http://jenkins.test.com/jnlpJars/agent.jar</span><br><span class="line">$ java -jar agent.jar -jnlpUrl http://jenkins.test.com/computer/slave/jenkins-agent.jnlp -secret e74b242a6a58da754a7bdecb0e0511a0fa70f305321974b052a79d6aa8d9c56d -workDir <span class="string">&quot;/home/jenkins&quot;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">12月 29, 2023 11:56:51 下午 hudson.remoting.jnlp.Main<span class="variable">$CuiListener</span> status</span><br><span class="line">信息: Agent discovery successful</span><br><span class="line">  Agent address: 10.99.223.156</span><br><span class="line">  Agent port:    50000</span><br><span class="line">  Identity:      de:25:39:3d:94:4e:ca:0b:9b:c7:e8:fb:19:e2:92:70</span><br><span class="line">12月 29, 2023 11:56:51 下午 hudson.remoting.jnlp.Main<span class="variable">$CuiListener</span> status</span><br><span class="line">信息: Handshaking</span><br><span class="line">12月 29, 2023 11:56:51 下午 hudson.remoting.jnlp.Main<span class="variable">$CuiListener</span> status</span><br><span class="line">信息: Connecting to 10.99.223.156:50000</span><br><span class="line">12月 29, 2023 11:56:51 下午 hudson.remoting.jnlp.Main<span class="variable">$CuiListener</span> status</span><br><span class="line">信息: Trying protocol: JNLP4-connect</span><br><span class="line">12月 29, 2023 11:56:51 下午 org.jenkinsci.remoting.protocol.impl.BIONetworkLayer<span class="variable">$Reader</span> run</span><br><span class="line">信息: Waiting <span class="keyword">for</span> ProtocolStack to start.</span><br><span class="line">12月 29, 2023 11:56:52 下午 hudson.remoting.jnlp.Main<span class="variable">$CuiListener</span> status</span><br><span class="line">信息: Remote identity confirmed: de:25:39:3d:94:4e:ca:0b:9b:c7:e8:fb:19:e2:92:70</span><br><span class="line">12月 29, 2023 11:56:52 下午 hudson.remoting.jnlp.Main<span class="variable">$CuiListener</span> status</span><br><span class="line">信息: Connected</span><br></pre></td></tr></table></figure><p>此时我们再回到jenkins的节点列表中，可以看到节点的状态已经变成在线了。</p><p><img src="/post/docker/k8s-devops-jenkins-slave-node-online.jpg" alt="k8s devops jenkins slave node online"></p><h2 id="测试工作节点"><a href="#测试工作节点" class="headerlink" title="测试工作节点"></a>测试工作节点</h2><p>此时我们进入到<code>free-style-demo</code>任务中，然后点击<code>配置</code>，在<code>Gogs Webhook</code>中，选择<code>限制项目的运行节点</code>，然后填入<code>slave</code>，也就是这个任务只能在<code>slave</code>节点上执行。</p><p><img src="/post/docker/k8s-devops-jenkins-slave-node-test.jpg" alt="k8s devops jenkins slave node test"></p><p>然后点击保存，保存成功后，我们再次提交代码，触发jenkins的流水线。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;test again&quot;</span> &gt; test.md</span><br><span class="line">$ git commit -am <span class="string">&quot;test again&quot;</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>然后我们可以看到jenkins的流水线已经触发了。</p><p><img src="/post/docker/k8s-devops-jenkins-slave-node-test-build.jpg" alt="k8s devops jenkins slave node test build"></p><p>等待build完成后，点击序号，查看build的日志。可以看到build的时候，是在slave节点上执行的。</p><p><img src="/post/docker/k8s-devops-jenkins-slave-node-test-build-info.jpg" alt="k8s devops jenkins slave node test build info"></p><p>登录到slave节点上，可以看到slave节点上已经有了我们的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /home/jenkins/workspace/free-style-demo</span></span><br><span class="line">LICENSE  manage.py  moonlight  README.md  test.md</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/jenkins/workspace/free-style-demo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> test.md</span></span><br><span class="line">test again</span><br></pre></td></tr></table></figure><h1 id="Jenkins定制化容器"><a href="#Jenkins定制化容器" class="headerlink" title="Jenkins定制化容器"></a>Jenkins定制化容器</h1><p>由于每次新部署Jenkins环境，都需要安装很多必要的插件，因此考虑把插件提前做到镜像中，这样再部署的时候就不需要再在线安装插件了。</p><p>首先得知道插件都有哪些，我们可以访问Jenkins的url，然后生成插件列表文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># admin:admin@jenkins.test.com 需要替换成Jenkins的用户名、密码及访问地址</span></span><br><span class="line"></span><br><span class="line">curl -sSL <span class="string">&quot;http://admin:admin@jenkins.test.com/pluginManager/api/xml?depth=1&amp;xpath=/*/*/shortName|/*/*/version&amp;wrapper=plugins&quot;</span> | perl -pe <span class="string">&#x27;s/.*?&lt;shortName&gt;([\w-]+).*?&lt;version&gt;([^&lt;]+)()(&lt;\/\w+&gt;)+/\1:\2\n/g&#x27;</span>|sed <span class="string">&#x27;s/ /:/&#x27;</span> &gt; plugins.txt</span><br></pre></td></tr></table></figure><p>插件列表文件大致格式如下，这个文件中包含了我们需要安装的插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ace-editor:1.1</span><br><span class="line">allure-jenkins-plugin:2.28.1</span><br><span class="line">ant:1.10</span><br><span class="line">antisamy-markup-formatter:1.6</span><br><span class="line">apache-httpcomponents-client-4-api:4.5.10-1.0</span><br><span class="line">authentication-tokens:1.3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一个定制化的Jenkins镜像的Dockerfile文件，主要为了构建一个包含插件的镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> jenkinsci/blueocean:<span class="number">1.25</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;me@example.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> JENKINS_UC https://updates.jenkins-zh.cn</span><br><span class="line"><span class="keyword">ENV</span> JENKINS_UC_DOWNLOAD https://mirrors.tuna.tsinghua.edu.cn/jenkins</span><br><span class="line"><span class="keyword">ENV</span> JENKINS_OPTS=<span class="string">&quot;-Dhudson.model.UpdateCenter.updateCenterUrl=https://updates.jenkins-zh.cn/update-center.json&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> JENKINS_OPTS=<span class="string">&quot;-Djenkins.install.runSetupWizard=false&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 用最新的插件列表文件替换默认插件文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> plugins.txt /usr/share/jenkins/ref/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行插件安装</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /usr/local/bin/install-plugins.sh &lt; /usr/share/jenkins/ref/plugins.txt</span></span><br></pre></td></tr></table></figure><p>执行构建，定制jenkins容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t harbor.test.com/jenkins:v1 -f Dockerfile</span><br><span class="line">$ docker push harbor.test.com/jenkins:v1</span><br></pre></td></tr></table></figure><p>至此，我们已经有了定制化的Jenkins镜像，接下来我们就可以使用这个镜像来部署Jenkins了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑现有jenkins的statefulset，将镜像替换成我们定制化的镜像，保存即可</span></span><br><span class="line">$ kubectl -n jenkins edit statefulset jenkins</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> devops </tag>
            
            <tag> jenkins </tag>
            
            <tag> ci/cd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s prometheus 展示与告警</title>
      <link href="/k8s-prometheus-grafana/"/>
      <url>/k8s-prometheus-grafana/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>我们已经有了一些监控数据了，但是我们还需要一个监控面板，来展示我们的监控数据，这里我们使用Grafana来展示我们的监控数据。</p><span id="more"></span><h1 id="Grafana介绍"><a href="#Grafana介绍" class="headerlink" title="Grafana介绍"></a>Grafana介绍</h1><p>Grafana 是一个开源的度量分析和可视化工具，可以通过将采集的数据查询展示成漂亮的图表，并且提供了丰富的插件支持。支持 Graphite、zabbix、InfluxDB、Prometheus、OpenTSDB、Elasticsearch 等作为数据源，比 Prometheus 自带的图表展示功能强大太多，更加灵活，有丰富的插件，功能更加强大。</p><h1 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h1><p>最新的安装方式可以参考官方文档：<a href="https://grafana.com/docs/grafana/latest/setup-grafana/installation/kubernetes/">在Kubernetes上安装Grafana</a>，里面有资源配置清单可以参考进行安装。这里我们使用helm进行安装，如果想要单独安装请参考官方文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加helm仓库</span></span><br><span class="line">$ helm repo add grafana https://grafana.github.io/helm-charts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看chart版本</span></span><br><span class="line">$ helm search repo grafana</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载chart</span></span><br><span class="line">$ helm pull grafana/grafana</span><br><span class="line"><span class="comment"># 解压chart</span></span><br><span class="line">$ tar -zxvf grafana-7.0.11.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改values.yaml</span></span><br><span class="line">$ vim grafana/values.yaml</span><br><span class="line">......</span><br><span class="line">testFramework:</span><br><span class="line">  <span class="comment"># 不需要测试，将其设置为false</span></span><br><span class="line">  enabled: <span class="literal">false</span></span><br><span class="line">  image:</span><br><span class="line">    <span class="comment"># -- The Docker registry</span></span><br><span class="line">    registry: docker.io</span><br><span class="line">    repository: bats/bats</span><br><span class="line">    tag: <span class="string">&quot;v1.4.1&quot;</span></span><br><span class="line">......</span><br><span class="line">ingress:</span><br><span class="line">  <span class="comment"># 开启ingress</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  ......</span><br><span class="line">  hosts:</span><br><span class="line">    <span class="comment"># 设置ingress访问域名</span></span><br><span class="line">    - grafana.test.com</span><br><span class="line">......</span><br><span class="line">persistence:</span><br><span class="line">  <span class="built_in">type</span>: pvc</span><br><span class="line">  <span class="comment"># 启用持久化存储</span></span><br><span class="line">  enabled: <span class="built_in">enable</span></span><br><span class="line">  <span class="comment"># 设置sc的名称是nfs-client，这个sc是我们之前创建的。</span></span><br><span class="line">  <span class="comment"># 如果本身已经有pvc，可以将这个值设置为false，然后将pvc的名称设置到existingClaim中</span></span><br><span class="line">  storageClassName: nfs-client</span><br><span class="line">......</span><br><span class="line"><span class="comment"># web ui 登录的用户名和密码</span></span><br><span class="line"><span class="comment"># Administrator credentials when not using an existing secret (see below)</span></span><br><span class="line">adminUser: admin</span><br><span class="line">adminPassword: strongpassword</span><br><span class="line">......</span><br><span class="line">datasources:</span><br><span class="line">  <span class="comment"># 启用datasources并且设置数据源文件，文件中记录了prometheus的地址，这样grafana安装后默认就有了prometheus的数据源</span></span><br><span class="line">  datasources.yaml:</span><br><span class="line">    apiVersion: 1</span><br><span class="line">    datasources:</span><br><span class="line">    - name: Prometheus</span><br><span class="line">      <span class="built_in">type</span>: prometheus</span><br><span class="line">      <span class="comment"># 这里的url是prometheus的地址，这里我们使用prometheus的service地址</span></span><br><span class="line">      url: http://prometheus:9090</span><br><span class="line">      access: proxy</span><br><span class="line">      isDefault: <span class="literal">true</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装grafana</span></span><br><span class="line">$ helm install grafana ./grafana -n monitor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看grafana的pod状态</span></span><br><span class="line">$ kubectl get pod -n monitor</span><br></pre></td></tr></table></figure><p>安装完成后，我们就可以访问grafana了。</p><p><img src="/post/docker/k8s-prometheus-grafana-login.jpg" alt="k8s-prometheus-grafana-login"></p><p>使用上面配置的用户名和密码登录后，我们就可以看到grafana的首页了。但是目前的grafana还没有任何的监控面板，我们需要导入一些监控面板。</p><h1 id="导入监控面板"><a href="#导入监控面板" class="headerlink" title="导入监控面板"></a>导入监控面板</h1><p>导入监控面板主要有三种方式：</p><ul><li>导入dashboard</li><li>安装相应的插件</li><li>自定义监控面板</li></ul><h2 id="导入Dashboard的配置"><a href="#导入Dashboard的配置" class="headerlink" title="导入Dashboard的配置"></a>导入Dashboard的配置</h2><p>官方已经提供了一些Dashboard的配置，我们可以直接导入使用，可以在<a href="https://grafana.com/grafana/dashboards">官方Dashboard列表</a>中找到需要的Dashboard。</p><p>这里我们导入两个Dashboard：</p><ul><li><a href="https://grafana.com/grafana/dashboards/15172-node-exporter-for-prometheus-dashboard-based-on-11074/">Node Exporter</a></li><li><a href="https://grafana.com/grafana/dashboards/13105">Kubernetes</a></li></ul><h3 id="官方提供的Dashboard"><a href="#官方提供的Dashboard" class="headerlink" title="官方提供的Dashboard"></a>官方提供的Dashboard</h3><p>进入官方提供的Dashboard页面，可以看到有很多的Dashboard样式，我们可以根据自己的需求进行选择，进行不同的筛选，选到自己的Dashboard后，点击进入详情页面，可以看到Dashboard的ID，我们可以通过这个ID来导入Dashboard。</p><p><img src="/post/docker/k8s-prometheus-grafana-dashboard.jpg" alt="k8s-prometheus-grafana-dashboard"></p><h3 id="Node-Exporter"><a href="#Node-Exporter" class="headerlink" title="Node Exporter"></a>Node Exporter</h3><p>这个Dashboard是用来监控节点的，我们可以看到节点的CPU、内存、磁盘、网络等信息。</p><p>我们从官方提供的Dashboard页面中找到这个Dashboard，进入详情页面，可以看到Dashboard的ID为15172，我们可以通过这个ID来导入Dashboard。</p><p><img src="/post/docker/k8s-prometheus-grafana-node-exporter-dashboard.jpg" alt="k8s-prometheus-grafana-node-exporter-dashboard"></p><p>进入grafana的首页，点击[+]按钮，选择Import</p><p><img src="/post/docker/k8s-prometheus-grafana-import.jpg" alt="k8s-prometheus-grafana-import"></p><p>在输入框中输入Dashboard的ID，点击Load按钮</p><p><img src="/post/docker/k8s-prometheus-grafana-import-enter-id.jpg" alt="k8s-prometheus-grafana-import-enter-id"></p><p>然后可以看到Dashboard的信息，点击Import按钮导入Dashboard</p><p><img src="/post/docker/k8s-prometheus-grafana-import-load.jpg" alt="k8s-prometheus-grafana-import-load"></p><p>导入成功后，可以看到Dashboard的信息</p><p><img src="/post/docker/k8s-prometheus-grafana-import-info.jpg" alt="k8s-prometheus-grafana-import-info"></p><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>按照上面的步骤搜索到Kubernetes的Dashboard，进入详情页面，可以看到Dashboard的ID为13105，我们可以通过这个ID来导入Dashboard。</p><p><img src="/post/docker/k8s-prometheus-grafana-k8s-dashboard.jpg" alt="k8s-prometheus-grafana-k8s-dashboard"></p><p>安装完成后，我们可以看到Dashboard的信息</p><p><img src="/post/docker/k8s-prometheus-grafana-k8s-info.jpg" alt="k8s-prometheus-grafana-k8s-info"></p><h3 id="DevOpsProdigy-KubeGraf插件的使用"><a href="#DevOpsProdigy-KubeGraf插件的使用" class="headerlink" title="DevOpsProdigy KubeGraf插件的使用"></a>DevOpsProdigy KubeGraf插件的使用</h3><p>除了直接导入Dashboard，我们还可以通过安装插件的方式获得，在侧边栏中点击Administartion -&gt; Plugins，可以看到已经安装的插件，点击右上角的[Install]按钮，可以看到插件列表，我们可以在这里搜索到我们需要的插件。</p><p><img src="/post/docker/k8s-prometheus-grafana-plugins.jpg" alt="k8s-prometheus-grafana-plugins"></p><p>官方也提供了一些插件，我们可以在<a href="https://grafana.com/grafana/plugins?utm_source=grafana_plugin_list">官方插件列表</a>中找到需要的插件。</p><p><img src="/post/docker/k8s-prometheus-grafana-plugins-list.jpg" alt="k8s-prometheus-grafana-plugins-list"></p><p>Kubernetes相关的插件：</p><ul><li><a href="https://grafana.com/grafana/plugins/grafana-kubernetes-app">grafana-kubernetes-app</a></li><li><a href="https://grafana.com/grafana/plugins/devopsprodigy-kubegraf-app">devopsprodigy-kubegraf-app</a></li></ul><p><a href="https://grafana.com/grafana/plugins/devopsprodigy-kubegraf-app">DevOpsProdigy KubeGraf</a> 是一个非常优秀的 Grafana Kubernetes 插件，是 Grafana 官方的 Kubernetes 插件的升级版本，该插件可以用来可视化和分析 Kubernetes 集群的性能，通过各种图形直观的展示了 Kubernetes 集群的主要服务的指标和特征，还可以用于检查应用程序的生命周期和错误日志。</p><p>我们可以通过安装插件的方式来安装这个插件，也可以通过导入Dashboard的方式来安装这个插件。</p><p><img src="/post/docker/k8s-prometheus-grafana-plugins-kubegraf.jpg" alt="k8s-prometheus-grafana-plugins-kubegraf"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入grafana容器内部执行安装</span></span><br><span class="line">$ kubectl -n monitor <span class="built_in">exec</span> -ti grafana-84f769d885-9qjrc -- bash</span><br><span class="line">grafana-84f769d885-9qjrc:/usr/share/grafana$ grafana cli plugins install devopsprodigy-kubegraf-app 1.5.2</span><br><span class="line">✔ Plugin devopsprodigy-kubegraf-app v1.5.2 already installed.</span><br><span class="line"></span><br><span class="line">Please restart Grafana after installing or removing plugins. Refer to Grafana documentation <span class="keyword">for</span> instructions <span class="keyword">if</span> necessary.</span><br><span class="line"></span><br><span class="line">grafana-84f769d885-9qjrc:/usr/share/grafana$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重建pod生效</span></span><br><span class="line">$ kubectl -n monitor delete po grafana-594f447d6c-jmjsw</span><br></pre></td></tr></table></figure><blockquote><p>这个插件已经被废弃了，以下为之前的安装方式，现在已经不适用了。</p></blockquote><p>登录grafana界面，在 Plugins 中找到安装的插件，点击插件进入插件详情页面，点击 [Enable]按钮启用插件，点击 <code>Set up your first k8s-cluster</code> 创建一个新的 Kubernetes 集群:</p><ul><li>Name：test-k8s</li><li>URL：<a href="https://kubernetes.default/">https://kubernetes.default:443</a></li><li>Access：使用默认的Server(default)</li><li>Skip TLS Verify：勾选，跳过证书合法性校验</li><li>Auth：勾选TLS Client Auth以及With CA Cert，勾选后会下面有三块证书内容需要填写，内容均来自<code>~/.kube/config</code>文件，需要对文件中的内容做一次base64 解码<ul><li>CA Cert：使用config文件中的<code>certificate-authority-data</code>对应的内容</li><li>Client Cert：使用config文件中的<code>client-certificate-data</code>对应的内容</li><li>Client Key：使用config文件中的<code>client-key-data</code>对应的内容</li></ul></li></ul><blockquote><p>面板没有数据怎么办？</p><ul><li>DaemonSet<br>label_values(kube_pod_info{namespace&#x3D;”$namespace”,pod&#x3D;~”$daemonset-.*”},pod)</li><li>Deployment<br>label_values(kube_pod_info{namespace&#x3D;”$namespace”,pod&#x3D;~”$deployment-.*”},pod)</li><li>Pod<br>label_values(kube_pod_info{namespace&#x3D;”$namespace”},pod)</li></ul></blockquote><h3 id="自定义监控面板"><a href="#自定义监控面板" class="headerlink" title="自定义监控面板"></a>自定义监控面板</h3><p>通用的监控需求基本上都可以使用第三方的Dashboard来解决，对于业务应用自己实现的指标的监控面板，则需要我们手动进行创建。</p><p>点击[+]按钮，选择New Dashboard，进入新建Dashboard页面</p><p><img src="/post/docker/k8s-prometheus-grafana-new-dashboard.jpg" alt="k8s-prometheus-grafana-new-dashboard"></p><p>点击[Add visualizations]按钮，创建一个新的监控面板</p><p><img src="/post/docker/k8s-prometheus-grafana-new-panel.jpg" alt="k8s-prometheus-grafana-new-panel"></p><p>选择数据源，这里我们选择Prometheus</p><p><img src="/post/docker/k8s-prometheus-grafana-new-panel-data-source.jpg" alt="k8s-prometheus-grafana-new-panel-data-source"></p><p>然后就可以开始创建监控面板了，这里我们创建一个监控节点CPU使用率的监控面板。</p><p>如何根据字段过滤，实现联动效果？比如想实现根据集群节点名称进行过滤，可以通过如下方式：</p><ol><li><p>首先我们先apply监控面板<br> <img src="/post/docker/k8s-prometheus-grafana-new-panel-apply.jpg" alt="k8s-prometheus-grafana-new-panel-apply"></p></li><li><p>点击右上角的Edit按钮，进入编辑页面，选择Variables<br> <img src="/post/docker/k8s-prometheus-grafana-new-panel-variables.jpg" alt="k8s-prometheus-grafana-new-panel-variables"></p></li><li><p>点击Add Variable，添加一个变量node<br> <img src="/post/docker/k8s-prometheus-grafana-new-panel-variables-add.jpg" alt="k8s-prometheus-grafana-new-panel-variables-add"></p></li><li><p>填写变量的信息</p><ul><li>Name：node</li><li>Label：选择节点</li><li>Data Source：Prometheus</li><li>Query：<ul><li>Query type：Label values</li><li>Label: node</li><li>Metrics：kube_node_info</li></ul></li></ul><p> <img src="/post/docker/k8s-prometheus-grafana-new-panel-variables-info.jpg" alt="k8s-prometheus-grafana-new-panel-variables-info"></p></li><li><p>可以在页面下方的<code>Preview of values</code>查看到当前变量的可选值，点击Apply按钮保存变量<br> <img src="/post/docker/k8s-prometheus-grafana-new-panel-variables-preview.jpg" alt="k8s-prometheus-grafana-new-panel-variables-preview"></p></li><li><p>可以看到变量已经添加成功了<br> <img src="/post/docker/k8s-prometheus-grafana-new-panel-variables-success.jpg" alt="k8s-prometheus-grafana-new-panel-variables-success"></p></li><li><p>面板上方的变量选择框中，可以看到我们刚刚添加的变量<br> <img src="/post/docker/k8s-prometheus-grafana-new-panel-variables-select.jpg" alt="k8s-prometheus-grafana-new-panel-variables-select"></p></li><li><p>我们修改panel的Metrics，$node和变量名字保持一致，意思为自动读取当前设置的节点的名字</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_load1&#123;instance=~<span class="string">&quot;<span class="variable">$node</span>&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p> <img src="/post/docker/k8s-prometheus-grafana-new-panel-metrics.jpg" alt="k8s-prometheus-grafana-new-panel-metrics"></p></li><li><p>点击Apply按钮保存面板，可以看到面板已经有数据了<br> <img src="/post/docker/k8s-prometheus-grafana-new-panel-metrics-success.jpg" alt="k8s-prometheus-grafana-new-panel-metrics-success"></p></li><li><p>再添加一个面板，使用如下的表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100-avg(irate(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>,instance=~<span class="string">&quot;<span class="variable">$node</span>&quot;</span>&#125;[5m])) by (instance)*100</span><br></pre></td></tr></table></figure><p><img src="/post/docker/k8s-prometheus-grafana-new-panel-metrics-cpu.jpg" alt="k8s-prometheus-grafana-new-panel-metrics-cpu"></p></li></ol><h1 id="Metrics指标类型与PromQL"><a href="#Metrics指标类型与PromQL" class="headerlink" title="Metrics指标类型与PromQL"></a>Metrics指标类型与PromQL</h1><p>TSDB的样本分布示意图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">│   . . . . . . . . . . . . . . . . .   . .   node_cpu&#123;cpu=<span class="string">&quot;cpu0&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;</span><br><span class="line">│     . . . . . . . . . . . . . . . . . . .   node_cpu&#123;cpu=<span class="string">&quot;cpu0&quot;</span>,mode=<span class="string">&quot;system&quot;</span>&#125;</span><br><span class="line">│     . . . . . . . . . .   . . . . . . . .   node_load1&#123;&#125;</span><br><span class="line">│     . . . . . . . . . . . . . . . .   . .   node_cpu_seconds_total&#123;...&#125;</span><br><span class="line">v</span><br><span class="line">  &lt;------------------ 时间 ----------------&gt;</span><br></pre></td></tr></table></figure><p>Prometheus的监控指标分为四种类型：</p><ul><li>Counter（计数器）<ul><li>性质：表示单调递增的计数，通常用于表示事件发生的次数。</li><li>示例：HTTP请求数、任务启动次数等。node_cpu_seconds_total、http_requests_total、node_network_receive_bytes_total</li><li>用途：统计系统运行以来的总次数，如http请求总数、系统启动次数等</li><li>特性：只增不减，除非系统发生重置，Prometheus重启后会重置所有的Counter类型的指标</li></ul></li><li>Gauge（仪表盘）<ul><li>性质：表示单个数值的度量值，通常用于表示系统的当前状态。也可以说表示可任意上升或下降的数值，用于测量瞬时值。</li><li>示例：node_memory_MemAvailable_bytes、node_load1、node_cpu_seconds_total</li><li>用途：反应系统的当前状态，如内存使用率、CPU利用率等。memory_usage_bytes、node_load1</li><li>特性：可增可减，表示一个瞬时值，常见的监控指标，如node_memory_MemAvailable_bytes、node_load1都是Gauge类型的监控指标</li></ul></li><li>Histogram（直方图）<ul><li>性质：表示一组数据的分布情况，通常用于统计和分析数据的分布情况。</li><li>示例：请求持续时间、文件大小等。prometheus_http_request_duration_seconds_bucket</li><li>用途：统计和分析数据的分布情况，如http请求的响应时间分布情况</li><li>特性：通过分桶(bucket)和累积计数(cumulative count)表示一组数据的分布情况，常见的监控指标，如prometheus_http_request_duration_seconds_bucket都是Histogram类型的监控指标</li></ul></li><li>Summary（摘要）<ul><li>性质：与直方图类似，用于观察和分析样本值的分布情况，但更适用于长时间运行的服务。通常用于统计和分析数据的分布情况。</li><li>示例：请求持续时间、文件大小等。http_request_duration_seconds</li><li>用途：统计和分析数据的分布情况，如http请求的响应时间分布情况</li><li>特性：通过样本值的分位数表示一组数据的分布情况，常见的监控指标，如http_request_duration_seconds都是Summary类型的监控指标</li></ul></li></ul><h2 id="Guage类型"><a href="#Guage类型" class="headerlink" title="Guage类型"></a>Guage类型</h2><p>最常用类型的监控指标，如node_memory_MemAvailable_bytes、node_load1都是Gauge类型的监控指标。</p><p>Gauge类型的指标侧重于反应系统的当前状态。</p><ul><li>这类指标的样本数据可增可减。</li><li>常见指标如：node_memory_MemAvailable_bytes（可用内存大小）、node_load1（系统平均负载）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n monitor get po -o wide | grep k8s-master</span><br><span class="line">node-exporter-bmv4m                   1/1     Running   0          6d22h   192.168.100.1   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ curl -s 192.168.100.1:9100/metrics | grep node_load1</span><br><span class="line"><span class="comment"># HELP node_load1 1m load average.</span></span><br><span class="line"><span class="comment"># TYPE node_load1 gauge</span></span><br><span class="line">node_load1 0.15</span><br><span class="line"><span class="comment"># HELP node_load15 15m load average.</span></span><br><span class="line"><span class="comment"># TYPE node_load15 gauge</span></span><br><span class="line">node_load15 0.31</span><br></pre></td></tr></table></figure><p>Guage类型的数据，通常直接查询就会有比较直观的业务含义，比如：</p><ul><li>node_load5</li><li>node_memory_MemAvailable_bytes</li></ul><p>我们也会对这类数据做简单的处理，比如：</p><ul><li>过滤其中某些节点</li><li>对指标进行数学运算</li></ul><p>这就是PromQL提供的能力，可以对收集到的数据做聚合、计算等处理。</p><p>PromQL（ Prometheus Query Language ）是Prometheus自定义的一套强大的数据查询语言，除了使用监控指标作为查询关键字以为，还内置了大量的函数，帮助用户进一步对时序数据进行处理。</p><p>比如以下几种：</p><ul><li><p>只显示k8s-master节点的平均负载</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_load1&#123;instance=<span class="string">&quot;k8s-master&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>显示除了k8s-master节点外的其他节点的平均负载</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_load1&#123;instance!=<span class="string">&quot;k8s-master&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>显示过去一段时间内的样本数据</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_load1[5m]</span><br></pre></td></tr></table></figure></li><li><p>使用系统方法对数据进行处理</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg(node_cpu_seconds_total&#123;mode=<span class="string">&quot;system&quot;</span>, instance=<span class="string">&quot;k8s-master&quot;</span>&#125;) by (instance)</span><br></pre></td></tr></table></figure></li><li><p>正则匹配</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_load1&#123;instance=~<span class="string">&quot;k8s-master|k8s-slave1&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>集群各节点系统内存使用率</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((node_memory_MemTotal_bytes - (node_memory_MemFree_bytes + node_memory_Buffers_bytes + node_memory_Cached_bytes))/node_memory_MemTotal_bytes)*100</span><br></pre></td></tr></table></figure></li></ul><h2 id="Counter类型："><a href="#Counter类型：" class="headerlink" title="Counter类型："></a>Counter类型：</h2><p>Counter类型的指标其工作方式和计数器一样，只增不减（除非系统发生重置）。常见的监控指标，如http_requests_total，node_cpu_seconds_total都是Counter类型的监控指标。</p><p>通常计数器类型的指标，名称后面都以<code>_total</code>结尾。我们通过理解CPU利用率的PromQL表达式来讲解Counter指标类型的使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s 192.168.100.1:9100/metrics | grep node_cpu_seconds_total</span><br><span class="line"><span class="comment"># HELP node_cpu_seconds_total Seconds the CPUs spent in each mode.</span></span><br><span class="line"><span class="comment"># TYPE node_cpu_seconds_total counter</span></span><br><span class="line">node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125; 596447.77</span><br><span class="line">node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;iowait&quot;</span>&#125; 70.54</span><br><span class="line">node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;irq&quot;</span>&#125; 5690.25</span><br><span class="line">node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;nice&quot;</span>&#125; 24.83</span><br><span class="line">node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;softirq&quot;</span>&#125; 3159.72</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>我们通过一个示例来说明Counter类型的指标如何使用以及PromQL的使用。 这个例子是计算各节点CPU的平均使用率表达式，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1- <span class="built_in">sum</span>(increase(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[2m])) by (instance) / <span class="built_in">sum</span>(increase(node_cpu_seconds_total&#123;&#125;[2m])) by (instance)) * 100</span><br></pre></td></tr></table></figure><p>接下来我们来分析一下这个表达式：</p><p><code>node_cpu_seconds_total</code>的指标含义是统计系统运行以来，CPU资源分配的时间总数，单位为秒，是累加的值。</p><p>我们在Prometheus中查询这个指标，可以看到很多结果，显示的是所有节点、所有CPU核心、在各种工作模式下分配的时间总和。</p><p>其中mode的值和我们平常在系统中执行<code>top</code>命令看到的CPU显示的信息一致，每个mode对应的含义如下：</p><ul><li><code>user</code>(us)  表示用户态空间或者说是用户进程(running user space processes)使用CPU所耗费的时间。这是日常我们部署的应用所在的层面，最常见常用。</li><li><code>system</code>(sy)  表示内核态层级使用CPU所耗费的时间。分配内存、IO操作、创建子进程……都是内核操作。这也表明，当IO操作频繁时，System参数会很高。</li><li><code>steal</code>(st)  当运行在虚拟化环境中，花费在其它 OS 中的时间（基于虚拟机监视器 hypervisor 的调度）；可以理解成由于虚拟机调度器将 cpu 时间用于其它 OS 了，故当前 OS 无法使用 CPU 的时间。</li><li><code>softirq</code>(si)  从系统启动开始，累计到当前时刻，软中断时间</li><li><code>irq</code>(hi)  从系统启动开始，累计到当前时刻，硬中断时间</li><li><code>nice</code>(ni)  从系统启动开始，累计到当前时刻， 低优先级(低优先级意味着进程 nice 值小于 0)用户态的进程所占用的CPU时间</li><li><code>iowait</code>(wa)  从系统启动开始，累计到当前时刻，IO等待时间</li><li><code>idle</code>(id)  从系统启动开始，累计到当前时刻，除IO等待时间以外的其它等待时间，亦即空闲时间</li></ul><p>我们通过指标拿到的各核心cpu分配的总时长数据，都是瞬时的数据，如何转换成 CPU的利用率？</p><p>先来考虑如何我们如何计算CPU利用率，假如我的k8s-master节点是4核CPU，我们来考虑如下场景：</p><ol><li>过去60秒内每个CPU核心处于idle空闲状态的时长，假如分别为 :<ul><li>cpu0：20s</li><li>cpu1：30s</li><li>cpu2：50s</li><li>cpu3：40s</li></ul></li><li>则四个核心总共可分配的时长是 4*60&#x3D;240s</li><li>实际空闲状态的总时长为20+30+50+40&#x3D;140s</li><li>那么我们可以计算出过去1分钟k8s-master节点的CPU利用率为 (1- 140&#x2F;240) * 100 &#x3D; 41.7%</li></ol><p>因此，我们只需要使用PromQL取出上述过程中的值即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤出当前时间点idle的时长</span></span><br><span class="line">node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用[1m]取出1分钟区间内的样本值,注意，1m区间要大于prometheus设置的抓取周期，此处会将周期内所以的样本值取出</span></span><br><span class="line">node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[1m]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用increase方法，获取该区间内idle状态的增量值,即1分钟内，mode=&quot;idle&quot;状态增加的时长</span></span><br><span class="line">increase(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[1m])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于是多个cpu核心，因此需要做累加，使用sum函数</span></span><br><span class="line"><span class="built_in">sum</span>(increase(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[1m]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于是多台机器，因此，需要按照instance的值进行分组累加，使用by关键字做分组,这样就获得了1分钟内，每个节点上 所有CPU核心idle状态的增量时长，即前面示例中的”20+30+50+40=140s“</span></span><br><span class="line"><span class="built_in">sum</span>(increase(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[1m])) by (instance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉mode=idle的过滤条件，即可获取1分钟内，所有状态的cpu获得的增量总时长，即4*60=240s</span></span><br><span class="line"><span class="built_in">sum</span>(increase(node_cpu_seconds_total&#123;&#125;[1m])) by (instance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终的语句</span></span><br><span class="line">(1- <span class="built_in">sum</span>(increase(node_cpu_seconds_total&#123;mode=<span class="string">&quot;idle&quot;</span>&#125;[1m])) by (instance) / <span class="built_in">sum</span>(increase(node_cpu_seconds_total&#123;&#125;[1m])) by (instance)) * 100</span><br></pre></td></tr></table></figure><p>除此之外，还会经常看到avg,irate和rate方法的使用：</p><p><code>irate()</code> 是基于最后两个数据点计算一个时序指标在一个范围内的每秒递增率 ，举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1min内，k8s-master节点的idle状态的cpu分配时长增量值</span></span><br><span class="line">increase(node_cpu_seconds_total&#123;instance=<span class="string">&quot;k8s-master&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;[1m])</span><br><span class="line"></span><br><span class="line">&#123;cpu=<span class="string">&quot;0&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;56.5</span><br><span class="line">&#123;cpu=<span class="string">&quot;1&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;56.04</span><br><span class="line">&#123;cpu=<span class="string">&quot;2&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;56.6</span><br><span class="line">&#123;cpu=<span class="string">&quot;3&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;56.5</span><br><span class="line"></span><br><span class="line"><span class="comment">#以第一条数据为例，说明过去的1分钟，k8s-master节点的第一个CPU核心，有56.5秒的时长是出于idle状态的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1min内，k8s-master节点的idle状态的cpu分配每秒的速率</span></span><br><span class="line"><span class="comment"># 该值如何计算的？</span></span><br><span class="line"><span class="comment"># irate会取出样本中的最后两个点来作为增长依据，然后做差值计算，并且除以两个样本间的数据时长，也就是说，我们设置2m,5m取出来的值是一样的，因为只会计算最后两个样本差。</span></span><br><span class="line"><span class="comment"># 以第一条数据为例，表示用irate计算出来的结果是，过去的两分钟内，cpu平均每秒钟有0.934秒的时间是处于idle状态的</span></span><br><span class="line">irate(node_cpu_seconds_total&#123;instance=<span class="string">&quot;k8s-master&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;[1m])</span><br><span class="line">&#123;cpu=<span class="string">&quot;0&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;0.934</span><br><span class="line">&#123;cpu=<span class="string">&quot;1&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;0.932</span><br><span class="line">&#123;cpu=<span class="string">&quot;2&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;0.933</span><br><span class="line">&#123;cpu=<span class="string">&quot;3&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;0.936</span><br><span class="line"></span><br><span class="line"><span class="comment"># rate会1min内第一个和最后一个样本值为依据，计算方式和irate保持一致</span></span><br><span class="line">rate(node_cpu_seconds_total&#123;instance=<span class="string">&quot;k8s-master&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;[1m])</span><br><span class="line">&#123;cpu=<span class="string">&quot;0&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;0.933</span><br><span class="line">&#123;cpu=<span class="string">&quot;1&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;0.940</span><br><span class="line">&#123;cpu=<span class="string">&quot;2&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;0.935</span><br><span class="line">&#123;cpu=<span class="string">&quot;3&quot;</span>,instance=<span class="string">&quot;k8s-master&quot;</span>,job=<span class="string">&quot;kubernetes-sd-node-exporter&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;0.937</span><br></pre></td></tr></table></figure><p>因此rate的值，相对来讲更平滑，因为计算的是时间段内的平均，更适合于用作告警。</p><p>取CPU平均使用率也可以用如下表达式表示：<code>(1 - avg(rate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[1m])) by (instance)) * 100</code></p><h1 id="Alertmanager"><a href="#Alertmanager" class="headerlink" title="Alertmanager"></a>Alertmanager</h1><p>Alertmanager是一个独立的告警模块，主要作用有以下几点：</p><ul><li>接收Prometheus等客户端发来的警报</li><li>通过分组、删除重复等处理，并将它们通过路由发送给正确的接收器；</li><li>告警方式可以按照不同的规则发送给不同的模块负责人。Alertmanager支持Email, Slack，等告警方式, 也可以通过webhook接入钉钉等国内IM工具。</li></ul><p><img src="/post/docker/alertmanager.png" alt="alertmanager"></p><p>如果集群主机的内存使用率超过80%，且该现象持续了2分钟？想实现这样的监控告警，如何做？</p><p>从上图可得知设置警报和通知的主要步骤是：</p><ul><li>安装和配置 Alertmanager</li><li>配置Prometheus与Alertmanager对话</li><li>在Prometheus中创建警报规则</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>alertmanager的安装方式可以参考<a href="https://github.com/prometheus/alertmanager#install">官方仓库</a>，但是这里我们使用helm来安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ helm pull prometheus-community/alertmanager</span><br><span class="line">$ tar xf alertmanager-1.7.0.tgz</span><br><span class="line"><span class="comment"># 具体修改内容下面列出</span></span><br><span class="line">$ vim alertmanager/values.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就是安装环节了</span></span><br><span class="line">$ helm install alertmanager ./alertmanager -n monitor</span><br><span class="line"><span class="comment"># 查看安装的pod</span></span><br><span class="line">$ kubectl -n monitor get po -o wide</span><br></pre></td></tr></table></figure><p>修改的values.yaml文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">ingress:</span><br><span class="line">  # 开启ingress</span><br><span class="line">  enabled: true</span><br><span class="line">  className: &quot;&quot;</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/ingress.class: nginx</span><br><span class="line">    # kubernetes.io/tls-acme: &quot;true&quot;</span><br><span class="line">  hosts:</span><br><span class="line">    - host: alertmanager.test.com</span><br><span class="line">      paths:</span><br><span class="line">        - path: /</span><br><span class="line">          pathType: ImplementationSpecific</span><br><span class="line">  tls: []</span><br><span class="line">  ......</span><br><span class="line"># 数据可以保存，这里只需要指定sc的名称即可</span><br><span class="line">persistence:</span><br><span class="line">  enabled: true</span><br><span class="line">  ## Persistent Volume Storage Class</span><br><span class="line">  ## If defined, storageClassName: &lt;storageClass&gt;</span><br><span class="line">  ## If set to &quot;-&quot;, storageClassName: &quot;&quot;, which disables dynamic provisioning</span><br><span class="line">  ## If undefined (the default) or set to null, no storageClassName spec is</span><br><span class="line">  ## set, choosing the default provisioner.</span><br><span class="line">  ##</span><br><span class="line">  storageClass: &quot;nfs-client&quot;</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  size: 50Mi</span><br><span class="line">  ......</span><br><span class="line"># alertmanager的配置文件</span><br><span class="line">config:</span><br><span class="line">  enabled: true</span><br><span class="line">  global:</span><br><span class="line">    # slack_api_url: &#x27;&#x27;</span><br><span class="line">    # 当alertmanager持续多长时间未接收到告警后标记告警状态为 resolved</span><br><span class="line">    resolve_timeout: 5m</span><br><span class="line">    # 配置邮件发送信息</span><br><span class="line">    smtp_smarthost: &#x27;smtp.163.com:25&#x27;</span><br><span class="line">    smtp_from: &#x27;ganchangde@163.com&#x27;</span><br><span class="line">    smtp_auth_username: &#x27;ganchangde@163.com&#x27;</span><br><span class="line">    smtp_auth_password: &#x27;xxxxxxxxxx&#x27;</span><br><span class="line">    smtp_require_tls: false</span><br><span class="line"></span><br><span class="line">  templates:</span><br><span class="line">    - &#x27;/etc/alertmanager/*.tmpl&#x27;</span><br><span class="line"></span><br><span class="line">  # 配置告警接收者的信息</span><br><span class="line">  receivers:</span><br><span class="line">    - name: default-receiver</span><br><span class="line">      # slack_configs:</span><br><span class="line">      #  - channel: &#x27;@you&#x27;</span><br><span class="line">      #    send_resolved: true</span><br><span class="line">      email_configs:</span><br><span class="line">        - to: &#x27;changde.gan@iluvatar.com&#x27;</span><br><span class="line">          send_resolved: true</span><br><span class="line"></span><br><span class="line">  # 所有报警信息进入后的根路由，用来设置报警的分发策略</span><br><span class="line">  route:</span><br><span class="line">    # 接收到的报警信息里面有许多alertname=NodeLoadHigh 这样的标签的报警信息将会批量被聚合到一个分组里面</span><br><span class="line">    group_by: [&#x27;alertname&#x27;]</span><br><span class="line">    # 当一个新的报警分组被创建后，需要等待至少 group_wait 时间来初始化通知，如果在等待时间内当前group接收到了新的告警，这些告警将会合并为一个通知向receiver发送</span><br><span class="line">    group_wait: 30s</span><br><span class="line">    # 相同的group发送告警通知的时间间隔</span><br><span class="line">    group_interval: 5m</span><br><span class="line">    # 默认的receiver：如果一个报警没有被一个route匹配，则发送给默认的接收器</span><br><span class="line">    receiver: default-receiver</span><br><span class="line">    # 如果一个报警信息已经发送成功了，等待 repeat_interval 时间来重新发送</span><br><span class="line">    repeat_interval: 3h</span><br><span class="line">    # 上面所有的属性都由所有子路由继承，并且可以在每个子路由上进行覆盖。</span><br><span class="line">    routes:</span><br><span class="line">      - &#123;&#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>其中config字段中的内容是alertmanager的主要配置，它的作用如下：</p><ul><li><a href="https://prometheus.io/docs/alerting/configuration/#configuration-file">global</a>: 全局配置，包括报警解决后的超时时间、SMTP 相关配置、各种渠道通知的 API 地址等等。</li><li><a href="https://prometheus.io/docs/alerting/configuration/#route">route</a>: 用来设置报警的分发策略，它是一个树状结构，按照深度优先从左向右的顺序进行匹配。</li><li><a href="https://prometheus.io/docs/alerting/configuration/#receiver">receivers</a>: 配置告警消息接受者信息，例如常用的 email、wechat、slack、webhook 等消息通知方式。</li></ul><p>当alertmanager接收到一条新的alert时，会先根据group_by为其确定一个聚合组group，然后等待group_wait时间，如果在此期间接收到同一group的其他alert，则这些alert会被合并，然后再发送（alertmanager发送消息单位是group）。此参数的作用是防止短时间内出现大量告警的情况下，接收者被告警淹没。</p><p>在该组的alert第一次被发送后，该组会进入睡眠&#x2F;唤醒周期，睡眠周期将持续group_interval时间，在睡眠状态下该group不会进行任何发送告警的操作（但会插入&#x2F;更新(根据fingerprint)group中的内容），睡眠结束后进入唤醒状态，然后检查是否需要发送新的alert或者重复已发送的alert(resolved类型的alert在发送完后会从group中剔除)。这就是group_interval的作用。</p><p>聚合组在每次唤醒才会检查上一次发送alert是否已经超过repeat_interval时间，如果超过则再次发送该告警。</p><h2 id="配置Prometheus与Alertmanager对话"><a href="#配置Prometheus与Alertmanager对话" class="headerlink" title="配置Prometheus与Alertmanager对话"></a>配置Prometheus与Alertmanager对话</h2><p><img src="/post/docker/alertmanager.png" alt="alertmanager"></p><p>是否告警是由Prometheus进行判断的，若有告警产生，Prometheus会将告警push到Alertmanager，因此，需要在Prometheus端配置alertmanager的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n monitor edit configmap prometheus-config</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">    <span class="comment"># my global config</span></span><br><span class="line">    global:</span><br><span class="line">      scrape_interval: 30s</span><br><span class="line">      evaluation_interval: 30s</span><br><span class="line">      <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Alertmanager configuration</span></span><br><span class="line">    alerting:</span><br><span class="line">      alertmanagers:</span><br><span class="line">      - static_configs:</span><br><span class="line">        - targets:</span><br><span class="line">          - alertmanager:9093</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">$ kubectl -n monitor <span class="built_in">exec</span> prometheus-5bc5966ff8-f84vx -- <span class="built_in">cat</span> /etc/prometheus/prometheus.yml</span><br><span class="line">$ curl -XPOST 10.244.0.26:9090/-/reload</span><br></pre></td></tr></table></figure><p>到这里已经安装了alertmanager，也配置了Prometheus与Alertmanager对话，接下来就是配置告警规则了。</p><h2 id="配置告警规则"><a href="#配置告警规则" class="headerlink" title="配置告警规则"></a>配置告警规则</h2><p>目前Prometheus与Alertmanager已经连通，接下来我们可以针对收集到的各类指标配置报警规则，一旦满足报警规则的设置，则Prometheus将报警信息推送给Alertmanager，进而转发到我们配置的邮件中。</p><p>在哪里配置？同样是在prometheus-configmap中配置。我们配置报警文件的路径，然后使用configmap的方式，将报警规则文件挂载到prometheus容器内部。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ kuectl -n monitor edit configmap prometheus-config</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">    <span class="comment"># Load rules once and periodically evaluate them according to the global  &#x27;evaluation_interval&#x27;.</span></span><br><span class="line">    rule_files:</span><br><span class="line">      <span class="comment"># 配置告警规则文件</span></span><br><span class="line">      - /etc/prometheus/alert_rules.yml</span><br><span class="line">......</span><br><span class="line">  alert_rules.yml: |</span><br><span class="line">    <span class="built_in">groups</span>:</span><br><span class="line">    - name: node_metrics</span><br><span class="line">      rules:</span><br><span class="line">      - alert: NodeLoad</span><br><span class="line">        <span class="built_in">expr</span>: node_load15 &lt; 1</span><br><span class="line">        <span class="keyword">for</span>: 2m</span><br><span class="line">        annotations:</span><br><span class="line">          summary: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: Low node load detected&quot;</span></span><br><span class="line">          description: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: node load is below 1 (current value is: &#123;&#123; <span class="variable">$value</span> &#125;&#125;&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">$ kubectl -n monitor <span class="built_in">exec</span> prometheus-5bc5966ff8-f84vx -- <span class="built_in">cat</span> /etc/prometheus/alert_rules.yml</span><br><span class="line"><span class="comment"># 重载配置之后就可以进入Prometheus的web界面查看告警规则了</span></span><br><span class="line">$ curl -XPOST 10.244.0.26:9090/-/reload</span><br></pre></td></tr></table></figure><p>告警规则的几个要素：</p><ul><li><code>group.name</code>：告警分组的名称，一个组下可以配置一类告警规则，比如都是物理节点相关的告警</li><li><code>alert</code>：告警规则的名称</li><li><code>expr</code>：是用于进行报警规则 PromQL 查询语句，expr通常是布尔表达式，可以让Prometheus根据计算的指标值做 true or false 的判断</li><li><code>for</code>：评估等待时间（Pending Duration），用于表示只有当触发条件持续一段时间后才发送告警，在等待期间新产生的告警状态为<code>pending</code>，屏蔽掉瞬时的问题，把焦点放在真正有持续影响的问题上</li><li><code>labels</code>：自定义标签，允许用户指定额外的标签列表，把它们附加在告警上，可以用于后面做路由判断，通知到不同的终端，通常被用于添加告警级别的标签</li><li><code>annotations</code>：指定了另一组标签，它们不被当做告警实例的身份标识，它们经常用于存储一些额外的信息，用于报警信息的展示之类的</li></ul><p>规则配置中，支持模板的方式，其中：</p><ul><li><code>&#123;&#123;$labels&#125;&#125;</code>可以获取当前指标的所有标签，支持<code>&#123;&#123;$labels.instance&#125;&#125;</code>或者<code>&#123;&#123;$labels.job&#125;&#125;</code>这种形式</li><li><code>&#123;&#123; $value &#125;&#125;</code>可以获取当前计算出的指标值</li></ul><p>一个报警信息在生命周期内有下面3种状态：</p><ul><li><code>inactive</code>: 表示当前报警信息处于非活动状态，即不满足报警条件</li><li><code>pending</code>: 表示在设置的阈值时间范围内被激活了，即满足报警条件，但是还在观察期内</li><li><code>firing</code>: 表示超过设置的阈值时间被激活了，即满足报警条件，且报警触发时间超过了观察期，会发送到Alertmanager端</li></ul><p>对于已经 <code>pending</code> 或者 <code>firing</code> 的告警，Prometheus 也会将它们存储到时间序列<code>ALERTS&#123;&#125;</code>中。当然我们也可以通过表达式去查询告警实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALERTS&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义webhook实现告警消息的推送"><a href="#自定义webhook实现告警消息的推送" class="headerlink" title="自定义webhook实现告警消息的推送"></a>自定义webhook实现告警消息的推送</h2><p>目前官方内置的第三方通知集成包括：邮件、 即时通讯软件（如Slack、Hipchat）、移动应用消息推送(如Pushover)和自动化运维工具（例如：Pagerduty、Opsgenie、Victorops）。可以在alertmanager的管理界面中查看到。</p><p>每一个receiver具有一个全局唯一的名称，并且对应一个或者多个通知方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name: &lt;string&gt;</span><br><span class="line">email_configs:</span><br><span class="line">  [ - &lt;email_config&gt;, ... ]</span><br><span class="line">hipchat_configs:</span><br><span class="line">  [ - &lt;hipchat_config&gt;, ... ]</span><br><span class="line">slack_configs:</span><br><span class="line">  [ - &lt;slack_config&gt;, ... ]</span><br><span class="line">opsgenie_configs:</span><br><span class="line">  [ - &lt;opsgenie_config&gt;, ... ]</span><br><span class="line">webhook_configs:</span><br><span class="line">  [ - &lt;webhook_config&gt;, ... ]</span><br></pre></td></tr></table></figure><p>如果想实现告警消息推送给企业常用的即时聊天工具，如钉钉或者企业微信，如何配置？</p><p>Alertmanager的通知方式中还可以支持Webhook，通过这种方式开发者可以实现更多个性化的扩展支持，配置的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 警报接收者</span></span><br><span class="line">receivers:</span><br><span class="line">- name: <span class="string">&#x27;demo-webhook&#x27;</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - send_resolved: <span class="literal">true</span></span><br><span class="line">    url: http://demo-webhook/alert/send</span><br></pre></td></tr></table></figure><p>当我们配置了上述webhook地址，则当告警路由到<code>alertmanager</code>时，alertmanager端会向webhook地址推送POST请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST -d<span class="string">&quot;<span class="variable">$demoAlerts</span>&quot;</span>  http://demo-webhook/alert/send</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$demoAlerts</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">  <span class="string">&quot;groupKey&quot;</span>: &lt;string&gt;, alerts (e.g. to deduplicate) ,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;&lt;resolved|firing&gt;&quot;</span>, </span><br><span class="line">  <span class="string">&quot;receiver&quot;</span>: &lt;string&gt;, </span><br><span class="line">  <span class="string">&quot;groupLabels&quot;</span>: &lt;object&gt;, </span><br><span class="line">  <span class="string">&quot;commonLabels&quot;</span>: &lt;object&gt;, </span><br><span class="line">  <span class="string">&quot;commonAnnotations&quot;</span>: &lt;object&gt;, </span><br><span class="line">  <span class="string">&quot;externalURL&quot;</span>: &lt;string&gt;, // backlink to the Alertmanager. </span><br><span class="line">  <span class="string">&quot;alerts&quot;</span>: </span><br><span class="line">   [&#123; </span><br><span class="line">     <span class="string">&quot;labels&quot;</span>: &lt;object&gt;, </span><br><span class="line">      <span class="string">&quot;annotations&quot;</span>: &lt;object&gt;, </span><br><span class="line">      <span class="string">&quot;startsAt&quot;</span>: <span class="string">&quot;&lt;rfc3339&gt;&quot;</span>, </span><br><span class="line">      <span class="string">&quot;endsAt&quot;</span>: <span class="string">&quot;&lt;rfc3339&gt;&quot;</span> </span><br><span class="line">   &#125;] </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>因此，假如我们想把报警消息自动推送到钉钉群聊，只需要完成3个步骤：</p><ul><li>创建一个能给钉钉群聊发送消息的钉钉机器人</li><li>实现一个数据解析的容器，将Alertmanager传过来的数据做解析，成为钉钉机器人能够识别的格式，然后调用钉钉机器人的API，实现消息推送</li><li>配置alertmanager的receiver为webhook地址</li></ul><p>首先，我们要想给钉钉群聊发送消息，需要创建一个钉钉机器人，按照以下步骤创建。</p><ol><li>登录钉钉群</li><li>点击群设置</li><li>选择机器人管理</li><li>然后选择自定义机器人</li><li>创建一个机器人</li><li>选择自定义关键词</li><li>然后输入关键词</li><li>点击完成，即可创建一个机器人</li><li>创建完成后，会生成一个webhook地址，这个地址就是钉钉机器人的访问地址，后面我们会使用到</li></ol><p>接下来，我们试一下钉钉机器人的API，看看如何给钉钉群聊发送消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;https://oapi.dingtalk.com/robot/send?access_token=f628f749a7ad70e86ca7bcb68658d0ce5af7c201ce8ce32acaece4c592364ca9&#x27;</span> \</span><br><span class="line">   -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">   -d <span class="string">&#x27;&#123;&quot;msgtype&quot;: &quot;text&quot;,&quot;text&quot;: &#123;&quot;content&quot;: &quot;我就是我, 是不一样的烟火&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>再然后我们就需要一个容器，来实现Alertmanager传过来的数据解析，然后调用钉钉机器人的API，实现消息推送。这里我们选择使用项目：<a href="https://gitee.com/agagin/prometheus-webhook-dingtalk">prometheus-webhook-dingtalk</a></p><p>项目也有docker镜像，镜像地址：<code>timonwong/prometheus-webhook-dingtalk:master</code></p><p>这个项目的二进制运行方式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./prometheus-webhook-dingtalk --config.file=config.yml</span><br></pre></td></tr></table></figure><p>假如使用如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">targets:</span><br><span class="line">  webhook_dev:</span><br><span class="line">    url: https://oapi.dingtalk.com/robot/send?access_token=f33c539fa1012e0b3500f04ea98fb89468829ed324699d67ecd2f177a1dcc0c2</span><br><span class="line">  webhook_ops:</span><br><span class="line">    url: https://oapi.dingtalk.com/robot/send?access_token=4778abd23dbdbaf66fc6f413e6ab9c0103a039b0054201344a22a5692cdcc54e</span><br></pre></td></tr></table></figure><p>则prometheus-webhook-dingtalk启动后会自动支持如下API的POST访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://locahost:8060/dingtalk/webhook_dev/send</span><br><span class="line">http://localhost:8060/dingtalk/webhook_ops/send</span><br></pre></td></tr></table></figure><p>这样可以使用一个prometheus-webhook-dingtalk来实现多个钉钉群的webhook地址</p><p>那么我们来部署一下prometheus-webhook-dingtalk，从项目的Dockerfile可以得知需要注意以下几点：</p><ul><li>默认使用配置文件<code>/etc/prometheus-webhook-dingtalk/config.yml</code>，可以通过configmap挂载</li><li>该目录下还有模板文件，因此需要使用subpath的方式挂载</li><li>部署Service，作为Alertmanager的默认访问，服务端口默认8060</li></ul><p>首先准备配置文件的资源清单，通过configmap挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> webhook-dingtalk-configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  config.yml: |</span><br><span class="line">    targets:</span><br><span class="line">      webhook_dev:</span><br><span class="line">        url: https://oapi.dingtalk.com/robot/send?access_token=f33c539fa1012e0b3500f04ea98fb89468829ed324699d67ecd2f177a1dcc0c2</span><br><span class="line">      webhook_ops:</span><br><span class="line">        url: https://oapi.dingtalk.com/robot/send?access_token=4778abd23dbdbaf66fc6f413e6ab9c0103a039b0054201344a22a5692cdcc54e</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: webhook-dingtalk-config</span><br><span class="line">  namespace: monitor</span><br></pre></td></tr></table></figure><p>准备Deployment和Service的资源清单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> webhook-dingtalk-deploy.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: webhook-dingtalk</span><br><span class="line">  namespace: monitor</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: webhook-dingtalk</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: webhook-dingtalk</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: webhook-dingtalk</span><br><span class="line">        image: timonwong/prometheus-webhook-dingtalk:master</span><br><span class="line">        args:</span><br><span class="line">        - <span class="string">&quot;--config.file=/etc/prometheus-webhook-dingtalk/config.yml&quot;</span></span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: <span class="string">&quot;/etc/prometheus-webhook-dingtalk/config.yml&quot;</span></span><br><span class="line">          name: config</span><br><span class="line">          subPath: config.yml</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8060</span><br><span class="line">          name: http</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 50m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 50m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">      volumes:</span><br><span class="line">      - name: config</span><br><span class="line">        configMap:</span><br><span class="line">          name: webhook-dingtalk-config</span><br><span class="line">          items:</span><br><span class="line">          - key: config.yml</span><br><span class="line">            path: config.yml</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: webhook-dingtalk</span><br><span class="line">  namespace: monitor</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: webhook-dingtalk</span><br><span class="line">  ports:</span><br><span class="line">  - name: hook</span><br><span class="line">    port: 8060</span><br><span class="line">    targetPort: http</span><br></pre></td></tr></table></figure><p>创建资源清单并部署prometheus-webhook-dingtalk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f webhook-dingtalk-configmap.yaml</span><br><span class="line">$ kubectl apply -f webhook-dingtalk-deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志，可以得知当前的可用webhook日志</span></span><br><span class="line">$ kubectl -n monitor logs -f webhook-dingtalk-54f7d5475f-lwrs8</span><br><span class="line">...</span><br><span class="line">level=info ts=2023-12-11T15:59:27.792Z <span class="built_in">caller</span>=coordinator.go:91 component=configuration file=/etc/prometheus-webhook-dingtalk/config.yml msg=<span class="string">&quot;Completed loading of configuration file&quot;</span></span><br><span class="line">level=info ts=2023-12-11T15:59:27.792Z <span class="built_in">caller</span>=main.go:98 component=configuration msg=<span class="string">&quot;Loading templates&quot;</span> templates=</span><br><span class="line">ts=2023-12-11T15:59:27.890Z <span class="built_in">caller</span>=main.go:114 component=configuration msg=<span class="string">&quot;Webhook urls for prometheus alertmanager&quot;</span> urls=<span class="string">&quot;http://localhost:8060/dingtalk/webhook_dev/send http://localhost:8060/dingtalk/webhook_ops/send&quot;</span></span><br><span class="line">level=info ts=2023-12-11T15:59:27.891Z <span class="built_in">caller</span>=web.go:210 component=web msg=<span class="string">&quot;Start listening for connections&quot;</span> address=:8060</span><br></pre></td></tr></table></figure><p>一切准备就绪了，接下来就可以修改Alertmanager路由及webhook配置了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n monitor edit configmap alertmanager</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: alertmanager</span><br><span class="line">  namespace: monitor</span><br><span class="line">data:</span><br><span class="line">  config.yml: |-</span><br><span class="line">    global:</span><br><span class="line">      <span class="comment"># 当alertmanager持续多长时间未接收到告警后标记告警状态为 resolved</span></span><br><span class="line">      resolve_timeout: 5m</span><br><span class="line">      <span class="comment"># 配置邮件发送信息</span></span><br><span class="line">      smtp_smarthost: <span class="string">&#x27;smtp.163.com:25&#x27;</span></span><br><span class="line">      smtp_from: <span class="string">&#x27;ganchangde@163.com&#x27;</span></span><br><span class="line">      smtp_auth_username: <span class="string">&#x27;ganchangde@163.com&#x27;</span></span><br><span class="line">      <span class="comment"># 注意这里不是邮箱密码，是邮箱开启第三方客户端登录后的授权码</span></span><br><span class="line">      smtp_auth_password: <span class="string">&#x27;GXIWNXKMMEVMNHAJ&#x27;</span></span><br><span class="line">      smtp_require_tls: <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 所有报警信息进入后的根路由，用来设置报警的分发策略</span></span><br><span class="line">    route:</span><br><span class="line">      <span class="comment"># 按照告警名称分组</span></span><br><span class="line">      group_by: [<span class="string">&#x27;alertname&#x27;</span>]</span><br><span class="line">      <span class="comment"># 当一个新的报警分组被创建后，需要等待至少 group_wait 时间来初始化通知，这种方式可以确保您能有足够的时间为同一分组来获取多个警报，然后一起触发这个报警信息。</span></span><br><span class="line">      group_wait: 30s</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 相同的group之间发送告警通知的时间间隔</span></span><br><span class="line">      group_interval: 30s</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 如果一个报警信息已经发送成功了，等待 repeat_interval 时间来重新发送他们，不同类型告警发送频率需要具体配置</span></span><br><span class="line">      repeat_interval: 1m</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 默认的receiver：如果一个报警没有被一个route匹配，则发送给默认的接收器</span></span><br><span class="line">      receiver: default</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 路由树，默认继承global中的配置，并且可以在每个子路由上进行覆盖。</span></span><br><span class="line">      routes:</span><br><span class="line">      - &#123;&#125;</span><br><span class="line">    receivers:</span><br><span class="line">    - name: <span class="string">&#x27;default&#x27;</span></span><br><span class="line">      email_configs:</span><br><span class="line">      - to: <span class="string">&#x27;changde.gan@iluvatar.com&#x27;</span></span><br><span class="line">        <span class="comment"># 接受告警恢复的通知</span></span><br><span class="line">        send_resolved: <span class="literal">true</span></span><br><span class="line">      webhook_configs:</span><br><span class="line">      - send_resolved: <span class="literal">true</span></span><br><span class="line">        url: http://webhook-dingtalk:8060/dingtalk/webhook_dev/send</span><br></pre></td></tr></table></figure><p>验证钉钉消息是否正常收到。</p><h2 id="基于Label的动态告警处理"><a href="#基于Label的动态告警处理" class="headerlink" title="基于Label的动态告警处理"></a>基于Label的动态告警处理</h2><p>真实的场景中，我们往往期望可以给告警设置级别，而且可以实现不同的报警级别可以由不同的receiver接收告警消息。</p><p>Alertmanager中路由负责对告警信息进行分组匹配，并向告警接收器发送通知。告警接收器可以通过以下形式进行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">routes:</span><br><span class="line">- receiver: ops</span><br><span class="line">  group_wait: 10s</span><br><span class="line">  match:</span><br><span class="line">    severity: critical</span><br><span class="line">- receiver: dev</span><br><span class="line">  group_wait: 10s</span><br><span class="line">  match_re:</span><br><span class="line">    severity: normal|middle</span><br><span class="line">receivers:</span><br><span class="line">  - ops</span><br><span class="line">    ...</span><br><span class="line">  - dev</span><br><span class="line">    ...</span><br><span class="line">  - &lt;receiver&gt; ...</span><br></pre></td></tr></table></figure><p>因此可以为了更全面的感受报警的逻辑，我们再添加两个报警规则，并且它们通过labels字段打标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">alert_rules.yml: |</span><br><span class="line">  <span class="built_in">groups</span>:</span><br><span class="line">  - name: node_metrics</span><br><span class="line">    rules:</span><br><span class="line">    - alert: NodeLoad</span><br><span class="line">      <span class="built_in">expr</span>: node_load15 &lt; 1</span><br><span class="line">      <span class="keyword">for</span>: 2m</span><br><span class="line">      labels:</span><br><span class="line">        severity: normal</span><br><span class="line">      annotations:</span><br><span class="line">        summary: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: Low node load detected&quot;</span></span><br><span class="line">        description: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: node load is below 1 (current value is: &#123;&#123; <span class="variable">$value</span> &#125;&#125;&quot;</span></span><br><span class="line">    - alert: NodeMemoryUsage</span><br><span class="line">      <span class="built_in">expr</span>: (node_memory_MemTotal_bytes - (node_memory_MemFree_bytes + node_memory_Buffers_bytes + node_memory_Cached_bytes)) / node_memory_MemTotal_bytes * 100 &gt; 30</span><br><span class="line">      <span class="keyword">for</span>: 2m</span><br><span class="line">      labels:</span><br><span class="line">        severity: critical</span><br><span class="line">      annotations:</span><br><span class="line">        summary: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: High Memory usage detected&quot;</span></span><br><span class="line">        description: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: Memory usage is above 40% (current value is: &#123;&#123; <span class="variable">$value</span> &#125;&#125;&quot;</span></span><br><span class="line">  - name: targets_status</span><br><span class="line">    rules:</span><br><span class="line">    - alert: TargetStatus</span><br><span class="line">      <span class="built_in">expr</span>: up == 0</span><br><span class="line">      <span class="keyword">for</span>: 1m</span><br><span class="line">      labels:</span><br><span class="line">        severity: critical</span><br><span class="line">      annotations:</span><br><span class="line">        summary: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: prometheus target down&quot;</span></span><br><span class="line">        description: <span class="string">&quot;&#123;&#123;<span class="variable">$labels</span>.instance&#125;&#125;: prometheus target down，job is &#123;&#123;<span class="variable">$labels</span>.job&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>我们为不同的报警规则设置了不同的标签，如<code>severity: critical</code>，针对规则中的label，来配置alertmanager路由规则，实现转发给不同的接收者。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> alertmanager-configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: alertmanager</span><br><span class="line">  namespace: monitor</span><br><span class="line">data:</span><br><span class="line">  config.yml: |-</span><br><span class="line">    global:</span><br><span class="line">      <span class="comment"># 当alertmanager持续多长时间未接收到告警后标记告警状态为 resolved</span></span><br><span class="line">      resolve_timeout: 5m</span><br><span class="line">      <span class="comment"># 配置邮件发送信息</span></span><br><span class="line">      smtp_smarthost: <span class="string">&#x27;smtp.163.com:25&#x27;</span></span><br><span class="line">      smtp_from: <span class="string">&#x27;ganchangde@163.com&#x27;</span></span><br><span class="line">      smtp_auth_username: <span class="string">&#x27;ganchangde@163.com&#x27;</span></span><br><span class="line">      <span class="comment"># 注意这里不是邮箱密码，是邮箱开启第三方客户端登录后的授权码</span></span><br><span class="line">      smtp_auth_password: <span class="string">&#x27;RMAOPQVHKLPYFVHZ&#x27;</span></span><br><span class="line">      smtp_require_tls: <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 所有报警信息进入后的根路由，用来设置报警的分发策略</span></span><br><span class="line">    route:</span><br><span class="line">      <span class="comment"># 按照告警名称分组</span></span><br><span class="line">      group_by: [<span class="string">&#x27;alertname&#x27;</span>]</span><br><span class="line">      <span class="comment"># 当一个新的报警分组被创建后，需要等待至少 group_wait 时间来初始化通知，这种方式可以确保您能有足够的时间为同一分组来获取多个警报，然后一起触发这个报警信息。</span></span><br><span class="line">      group_wait: 30s</span><br><span class="line">      <span class="comment"># 相同的group之间发送告警通知的时间间隔</span></span><br><span class="line">      group_interval: 30s</span><br><span class="line">      <span class="comment"># 如果一个报警信息已经发送成功了，等待 repeat_interval 时间来重新发送他们，不同类型告警发送频率需要具体配置</span></span><br><span class="line">      repeat_interval: 1m</span><br><span class="line">      <span class="comment"># 默认的receiver：如果一个报警没有被一个route匹配，则发送给默认的接收器</span></span><br><span class="line">      receiver: default</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 路由树，默认继承global中的配置，并且可以在每个子路由上进行覆盖。</span></span><br><span class="line">      routes:</span><br><span class="line">      - receiver: critical_alerts</span><br><span class="line">        group_wait: 10s</span><br><span class="line">        match:</span><br><span class="line">          severity: critical</span><br><span class="line">      - receiver: normal_alerts</span><br><span class="line">        group_wait: 10s</span><br><span class="line">        match_re:</span><br><span class="line">          severity: normal|middle</span><br><span class="line">    receivers:</span><br><span class="line">    - name: <span class="string">&#x27;default&#x27;</span></span><br><span class="line">      email_configs:</span><br><span class="line">      - to: <span class="string">&#x27;changde.gan@iluvatar.com&#x27;</span></span><br><span class="line">        <span class="comment"># 接受告警恢复的通知</span></span><br><span class="line">        send_resolved: <span class="literal">true</span></span><br><span class="line">    - name: <span class="string">&#x27;critical_alerts&#x27;</span></span><br><span class="line">      webhook_configs:</span><br><span class="line">      - send_resolved: <span class="literal">true</span></span><br><span class="line">        url: http://webhook-dingtalk:8060/dingtalk/webhook_ops/send</span><br><span class="line">    - name: <span class="string">&#x27;normal_alerts&#x27;</span></span><br><span class="line">      webhook_configs:</span><br><span class="line">      - send_resolved: <span class="literal">true</span></span><br><span class="line">        url: http://webhook-dingtalk:8060/dingtalk/webhook_dev/send</span><br></pre></td></tr></table></figure><p>再配置一个钉钉机器人，修改webhook-dingtalk的配置，添加webhook_ops的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> webhook-dingtalk-configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  config.yml: |</span><br><span class="line">    targets:</span><br><span class="line">      webhook_dev:</span><br><span class="line">        url: https://oapi.dingtalk.com/robot/send?access_token=f628f749a7ad70e86ca7bcb68658d0ce5af7c201ce8ce32acaece4c592364ca9</span><br><span class="line">      webhook_ops:</span><br><span class="line">        url: https://oapi.dingtalk.com/robot/send?access_token=5a68888fbecde75b1832ff024d7374e51f2babd33f1078e5311cdbb8e2c00c3a</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: webhook-dingtalk-config</span><br><span class="line">  namespace: monitor</span><br></pre></td></tr></table></figure><p>分别更新Prometheus和Alertmanager配置，查看报警的发送。</p><h2 id="抑制和静默"><a href="#抑制和静默" class="headerlink" title="抑制和静默"></a>抑制和静默</h2><p>前面我们知道，告警的<code>group(分组)</code>功能通过把多条告警数据聚合，有效的减少告警的频繁发送。除此之外，Alertmanager还支持<code>Inhibition(抑制)</code>和<code>Silences(静默)</code>，帮助我们抑制或者屏蔽报警。</p><h3 id="Inhibition-抑制"><a href="#Inhibition-抑制" class="headerlink" title="Inhibition 抑制"></a>Inhibition 抑制</h3><p>抑制是当出现其它告警的时候压制当前告警的通知，可以有效的防止告警风暴。</p><p>比如当机房出现网络故障时，所有服务都将不可用而产生大量服务不可用告警，但这些警告并不能反映真实问题在哪，真正需要发出的应该是网络故障告警。当出现网络故障告警的时候，应当抑制服务不可用告警的通知。</p><p>在Alertmanager配置文件中，使用inhibit_rules定义一组告警的抑制规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inhibit_rules:</span><br><span class="line">[ - &lt;inhibit_rule&gt; ... ]</span><br></pre></td></tr></table></figure><p>每一条抑制规则的具体配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">target_match:</span><br><span class="line">[ &lt;labelname&gt;: &lt;labelvalue&gt;, ... ]</span><br><span class="line">target_match_re:</span><br><span class="line">[ &lt;labelname&gt;: &lt;regex&gt;, ... ]</span><br><span class="line"></span><br><span class="line">source_match:</span><br><span class="line">[ &lt;labelname&gt;: &lt;labelvalue&gt;, ... ]</span><br><span class="line">source_match_re:</span><br><span class="line">[ &lt;labelname&gt;: &lt;regex&gt;, ... ]</span><br><span class="line"></span><br><span class="line">[ equal: <span class="string">&#x27;[&#x27;</span> &lt;labelname&gt;, ... <span class="string">&#x27;]&#x27;</span> ]</span><br></pre></td></tr></table></figure><p>当已经发送的告警通知匹配到target_match或者target_match_re规则，当有新的告警规则如果满足source_match或者定义的匹配规则，并且已发送的告警与新产生的告警中equal定义的标签完全相同，则启动抑制机制，新的告警不会发送。</p><p>例如，定义如下抑制规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- source_match:</span><br><span class="line">  alertname: NodeDown</span><br><span class="line">  severity: critical</span><br><span class="line">target_match:</span><br><span class="line">  severity: critical</span><br><span class="line">equal:</span><br><span class="line">  - node</span><br></pre></td></tr></table></figure><p>如当集群中的某一个主机节点异常宕机导致告警NodeDown被触发，同时在告警规则中定义了告警级别severity&#x3D;critical。由于主机异常宕机，该主机上部署的所有服务，中间件会不可用并触发报警。根据抑制规则的定义，如果有新的告警级别为severity&#x3D;critical，并且告警中标签node的值与NodeDown告警的相同，则说明新的告警是由NodeDown导致的，则启动抑制机制停止向接收器发送通知。</p><p>演示：实现如果 NodeMemoryUsage 报警触发，则抑制NodeLoad指标规则引起的报警。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inhibit_rules:</span><br><span class="line">- source_match:</span><br><span class="line">    alertname: NodeMemoryUsage</span><br><span class="line">    severity: critical</span><br><span class="line">  target_match:</span><br><span class="line">    severity: normal;</span><br><span class="line">  equal:</span><br><span class="line">    - instance</span><br></pre></td></tr></table></figure><h3 id="Silences：-静默"><a href="#Silences：-静默" class="headerlink" title="Silences： 静默"></a>Silences： 静默</h3><p>简单直接的在指定时段关闭告警。静默通过匹配器（Matcher）来配置，类似于路由树。警告进入系统的时候会检查它是否匹配某条静默规则，如果是则该警告的通知将忽略。静默规则在Alertmanager的Web界面里配置。</p><h2 id="告警的生命周期"><a href="#告警的生命周期" class="headerlink" title="告警的生命周期"></a>告警的生命周期</h2><p>一条告警产生后，还要经过 Alertmanager 的分组、抑制处理、静默处理、去重处理和降噪处理最后再发送给接收者。这个过程中可能会因为各种原因会导致告警产生了却最终没有进行通知，可以通过下图了解整个告警的生命周期：</p><p><img src="/post/docker/alertmanager-process.png" alt="alertmanager-process"></p><h1 id="自定义指标实现业务伸缩"><a href="#自定义指标实现业务伸缩" class="headerlink" title="自定义指标实现业务伸缩"></a>自定义指标实现业务伸缩</h1><h2 id="Kubernetes-Metrics-API体系回顾"><a href="#Kubernetes-Metrics-API体系回顾" class="headerlink" title="Kubernetes Metrics API体系回顾"></a>Kubernetes Metrics API体系回顾</h2><p>前面章节，我们讲过基于CPU和内存的HPA，即利用metrics-server及HPA，可以实现业务服务可以根据pod的cpu和内存进行弹性伸缩。</p><p><img src="/post/docker/hpa-prometheus-custom.png" alt="hpa-prometheus-custom"></p><p>k8s对监控接口进行了标准化：</p><ul><li>Resource Metrics 对应的接口是 metrics.k8s.io，主要的实现就是 metrics-server</li><li>Custom Metrics 对应的接口是 custom.metrics.k8s.io，主要的实现是 Prometheus， 它提供的是资源监控和自定义监控</li></ul><p><img src="/post/docker/k8s-metrics.png" alt="k8s-metrics"></p><p>安装完metrics-server后，利用kube-aggregator的功能，实现了metrics api的注册。可以通过如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl api-versions</span><br><span class="line">...</span><br><span class="line">metrics.k8s.io/v1beta1</span><br></pre></td></tr></table></figure><p>HPA通过使用该API获取监控的CPU和内存资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询nodes节点的cpu和内存数据</span></span><br><span class="line">$ kubectl get --raw=<span class="string">&quot;/apis/metrics.k8s.io/v1beta1/nodes&quot;</span>|jq</span><br><span class="line">$ kubectl get --raw=<span class="string">&quot;/apis/metrics.k8s.io/v1beta1/pods&quot;</span>|jq</span><br></pre></td></tr></table></figure><p>同样，为了实现通用指标的采集，需要部署<code>Prometheus Adapter</code>，来提供<code>custom.metrics.k8s.io</code>，作为HPA获取通用指标的入口。</p><h2 id="Adapter安装对接-仅记录没有实验"><a href="#Adapter安装对接-仅记录没有实验" class="headerlink" title="Adapter安装对接(仅记录没有实验)"></a>Adapter安装对接(仅记录没有实验)</h2><p>k8s-prometheus-adapter是一个Prometheus的适配器，它可以将Prometheus的指标数据转换成k8s的Metrics API，从而可以被HPA使用。项目地址在这里 <a href="https://github.com/DirectXMan12/k8s-prometheus-adapter">k8s-prometheus-adapter</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b v0.8.4 https://github.com/DirectXMan12/k8s-prometheus-adapter.git</span><br></pre></td></tr></table></figure><p>查看部署说明 <a href="https://github.com/DirectXMan12/k8s-prometheus-adapter/tree/v0.8.4/deploy">deploy</a></p><ol><li><p>镜像使用官方提供的<a href="https://hub.docker.com/r/directxman12/k8s-prometheus-adapter/tags">v0.8.4最新版</a></p></li><li><p>准备证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PURPOSE=serving</span><br><span class="line">$ openssl req -x509 -sha256 -new -nodes -days 3650 -newkey rsa:2048 -keyout <span class="variable">$&#123;PURPOSE&#125;</span>.key -out <span class="variable">$&#123;PURPOSE&#125;</span>.crt -subj <span class="string">&quot;/CN=ca&quot;</span></span><br><span class="line"></span><br><span class="line">$ kubectl -n monitor create secret generic cm-adapter-serving-certs --from-file=./serving.crt --from-file=./serving.key </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看证书</span></span><br><span class="line">$ kubectl -n monitor describe secret cm-adapter-serving-certs</span><br></pre></td></tr></table></figure></li><li><p>替换命名空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源清单文件默认用的命名空间是custom-metrics，替换为本例中使用的monitor</span></span><br><span class="line">$ sed -i <span class="string">&#x27;s/namespace: custom-metrics/namespace: monitor/g&#x27;</span> manifests/*</span><br></pre></td></tr></table></figure></li><li><p>配置adapter对接的Prometheus地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于adapter会和Prometheus交互，因此需要配置对接的Prometheus地址</span></span><br><span class="line"><span class="comment"># 替换掉28行：yamls/custom-metrics-apiserver-deployment.yaml 中的--prometheus-url</span></span><br><span class="line">$ vim manifests/custom-metrics-apiserver-deployment.yaml</span><br><span class="line">...</span><br><span class="line">     18     spec:</span><br><span class="line">     19       serviceAccountName: custom-metrics-apiserver</span><br><span class="line">     20       containers:</span><br><span class="line">     21       - name: custom-metrics-apiserver</span><br><span class="line">     22         image: directxman12/k8s-prometheus-adapter-amd64:v0.7.0</span><br><span class="line">     23         args:</span><br><span class="line">     24         - --secure-port=6443</span><br><span class="line">     25         - --tls-cert-file=/var/run/serving-cert/serving.crt</span><br><span class="line">     26         - --tls-private-key-file=/var/run/serving-cert/serving.key</span><br><span class="line">     27         - --logtostderr=<span class="literal">true</span></span><br><span class="line">     28         - --prometheus-url=http://prometheus:9090/</span><br><span class="line">     29         - --metrics-relist-interval=1m</span><br><span class="line">     30         - --v=10</span><br><span class="line">     31         - --config=/etc/adapter/config.yaml</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>部署服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> manifests/custom-metrics-config-map.yaml .</span><br><span class="line">$ vi manifests/custom-metrics-configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: adapter-config</span><br><span class="line">  namespace: monitor</span><br><span class="line">data:</span><br><span class="line">  config.yaml: |</span><br><span class="line">    rules:</span><br><span class="line">    - &#123;&#125;</span><br><span class="line">$ kubectl apply -f manifests/</span><br></pre></td></tr></table></figure></li></ol><p>完成后验证一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl api-versions|grep metrics</span><br><span class="line">custom.metrics.k8s.io/v1beta1</span><br><span class="line">custom.metrics.k8s.io/v1beta2</span><br><span class="line">external.metrics.k8s.io/v1beta1</span><br><span class="line">metrics.k8s.io/v1beta1</span><br><span class="line"></span><br><span class="line">$ kubectl get --raw /apis/custom.metrics.k8s.io/v1beta2 |jq</span><br><span class="line">&#123;                                                    </span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;APIResourceList&quot;</span>,                         </span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;groupVersion&quot;</span>: <span class="string">&quot;custom.metrics.k8s.io/v1beta2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;resources&quot;</span>: []                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置自定义指标"><a href="#配置自定义指标" class="headerlink" title="配置自定义指标"></a>配置自定义指标</h1><h2 id="通用指标示例程序部署"><a href="#通用指标示例程序部署" class="headerlink" title="通用指标示例程序部署"></a>通用指标示例程序部署</h2><p><img src="/post/docker/hpa-prometheus-custom.png" alt="hpa-prometheus-custom"></p><p>为了演示效果，我们新建一个deployment来模拟业务应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> custom-metrics-demo.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: custom-metrics-demo</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: custom-metrics-demo</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: custom-metrics-demo</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: custom-metrics-demo</span><br><span class="line">        image: luxas/autoscale-demo:v0.1.2</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 50m</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 50m</span><br></pre></td></tr></table></figure><p>部署应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f custom-metrics-demo.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl get po -o wide</span><br><span class="line">custom-metrics-demo-95b5bc949-xpppl   1/1     Running   0          65s   10.244.1.194</span><br><span class="line"></span><br><span class="line">$ curl 10.244.1.194:8080/metrics</span><br><span class="line"><span class="comment"># HELP http_requests_total The amount of requests served by the server in total</span></span><br><span class="line"><span class="comment"># TYPE http_requests_total counter</span></span><br><span class="line">http_requests_total 2</span><br></pre></td></tr></table></figure><p>注册为Prometheus的target：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> custom-metrics-demo-svc.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: custom-metrics-demo</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/scrape: <span class="string">&quot;true&quot;</span></span><br><span class="line">    prometheus.io/port: <span class="string">&quot;8080&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">    name: http</span><br><span class="line">  selector:</span><br><span class="line">    app: custom-metrics-demo</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br></pre></td></tr></table></figure><p>自动注册为Prometheus的采集Targets。</p><p>通常web类的应用，会把每秒钟的请求数作为业务伸缩的指标依据。</p><p>部署完成，接下我们需要进行测试了。但是测试前还有一些问题得解决。</p><p>使用案例应用<code>custom-metrics-demo</code>，如果<code>custom-metrics-demo</code>最近1分钟内每秒钟的请求数超过10次，则自动扩充业务应用的副本数。</p><ul><li><p>配置自定义指标</p><p>告诉Adapter去采集转换哪些指标，Adapter支持转换的指标，才可以作为HPA的依据</p></li><li><p>配置HPA规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: autoscaling/v2beta1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: front-app-hpa</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: custom-metrics-demo</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  maxReplicas: 3</span><br><span class="line">  metrics:</span><br><span class="line">  - <span class="built_in">type</span>: Pods</span><br><span class="line">    pods:</span><br><span class="line">      metricName: http_requests_per_second</span><br><span class="line">      targetAverageValue: 10</span><br></pre></td></tr></table></figure></li></ul><h2 id="Adapter配置自定义指标"><a href="#Adapter配置自定义指标" class="headerlink" title="Adapter配置自定义指标"></a>Adapter配置自定义指标</h2><p><img src="/post/docker/customer-metrics.png" alt="customer-metrics"></p><p>前面讲CPU的平均使用率的采集，其实是通过<code>node_cpu_seconds_total</code>指标计算得到的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">│   . . . . . . . . . . . . . . . . .   . .   node_cpu&#123;cpu=<span class="string">&quot;cpu0&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;</span><br><span class="line">│     . . . . . . . . . . . . . . . . . . .   node_cpu&#123;cpu=<span class="string">&quot;cpu0&quot;</span>,mode=<span class="string">&quot;system&quot;</span>&#125;</span><br><span class="line">│     . . . . . . . . . .   . . . . . . . .   node_load1&#123;&#125;</span><br><span class="line">│     . . . . . . . . . . . . . . . .   . .   node_cpu_seconds_total&#123;...&#125;</span><br><span class="line">v</span><br><span class="line">  &lt;------------------ 时间 ----------------&gt;</span><br></pre></td></tr></table></figure><p>同样，如果想获得每个业务应用最近1分钟内每秒的访问次数，也是根据总数来做计算，因此，需要使用业务自定义指标<code>http_requests_total</code>，配合<code>rate</code>方法即可获取每秒钟的请求数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[2m])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如查询有多条数据，需做汇聚，需要使用sum</span></span><br><span class="line"><span class="built_in">sum</span>(rate(http_requests_total[2m])) by(kubernetes_pod_name)</span><br></pre></td></tr></table></figure><ol><li><p>自定义指标可以配置多个，因此，需要将规则使用数组来配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rules:</span><br><span class="line">- &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>告诉Adapter，哪些自定义指标可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rules:</span><br><span class="line">- seriesQuery: <span class="string">&#x27;http_requests_total&#123;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>seriesQuery是PromQL语句，和直接用<code>http_requests_total</code>查询到的结果一样，凡是seriesQuery可以查询到的指标，都可以用作自定义指标</p></li><li><p>告诉Adapter，指标中的标签和k8s中的资源对象的关联关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules:</span><br><span class="line">- seriesQuery: <span class="string">&#x27;http_requests_total&#123;&#125;&#x27;</span></span><br><span class="line">  resources:</span><br><span class="line">    overrides:</span><br><span class="line">      kubernetes_namespace: &#123;resource: <span class="string">&quot;namespace&quot;</span>&#125;</span><br><span class="line">      kubernetes_pod_name: &#123;resource: <span class="string">&quot;pod&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>hpa 拿着k8s里的namepace和pod名称，来查询adaptor，adaptor去查询Prometheus的时候根据resources的适配来转换，namepace&#x3D;default, pod&#x3D;front-app-xxxx,  kubernetes_namespace&#x3D;”default”</p><p>我们查询到的可用指标格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;instance=<span class="string">&quot;10.244.2.140:8080&quot;</span>, job=<span class="string">&quot;kubernetes-sd-endpoints&quot;</span>, kubernetes_name=<span class="string">&quot;custom-metrics-demo&quot;</span>, kubernetes_namespace=<span class="string">&quot;default&quot;</span>, kubernetes_pod_name=<span class="string">&quot;front-app-df5fc79dd-rmzr6&quot;</span>, namespace=<span class="string">&quot;default&quot;</span>, pod=<span class="string">&quot;front-app-df5fc79dd-rmzr6&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>由于HPA在调用Adapter接口的时候，告诉Adapter的是查询哪个命名空间下的哪个Pod的指标，因此，Adapter在去查询的时候，需要做一层适配转换（因为并不是每个prometheus查询到的结果中都是叫做<code>kubernetes_namespace</code>和<code>kubernetes_pod_name</code>）</p><p><code>/apis/custom.metrics.k8s.io/v1beta2/namespaces/default/pods/xxx/http_requests_total</code></p></li><li><p>指定自定义的指标名称，供HPA配置使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rules:</span><br><span class="line">- seriesQuery: <span class="string">&#x27;http_requests_total&#123;&#125;&#x27;</span></span><br><span class="line">  resources:</span><br><span class="line">    overrides:</span><br><span class="line">      kubernetes_namespace: &#123;resource: <span class="string">&quot;namespace&quot;</span>&#125;</span><br><span class="line">      kubernetes_pod_name: &#123;resource: <span class="string">&quot;pod&quot;</span>&#125;</span><br><span class="line">  name:</span><br><span class="line">    as: <span class="string">&quot;http_requests_per_second&quot;</span></span><br></pre></td></tr></table></figure><p>因为Adapter转换完之后的指标含义为：每秒钟的请求数。因此提供指标名称，该配置根据正则表达式做了匹配替换，转换完后的指标名称为：<code>http_requests_per_second</code>，HPA规则中可以直接配置该名称。</p></li><li><p>告诉Adapter如何获取最终的自定义指标值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rules:</span><br><span class="line">- seriesQuery: <span class="string">&#x27;http_requests_total&#123;&#125;&#x27;</span></span><br><span class="line">  resources:</span><br><span class="line">    overrides:</span><br><span class="line">      kubernetes_namespace: &#123;resource: <span class="string">&quot;namespace&quot;</span>&#125;</span><br><span class="line">      kubernetes_pod_name: &#123;resource: <span class="string">&quot;pod&quot;</span>&#125;</span><br><span class="line">  name:</span><br><span class="line">    as: <span class="string">&quot;http_requests_per_second&quot;</span></span><br><span class="line">  metricsQuery: <span class="string">&#x27;sum(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;[2m])) by (&lt;&lt;.GroupBy&gt;&gt;)&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><p>我们最终期望的写法可能是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(rate(http_requests_total&#123;kubernetes_namespace=<span class="string">&quot;default&quot;</span>,kubernetes_pod_name=<span class="string">&quot;xxxx&quot;</span>&#125;[2m])) by (kubernetes_pod_name)</span><br></pre></td></tr></table></figure><p>但是Adapter提供了更简单的写法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;[2m])) by (&lt;&lt;.GroupBy&gt;&gt;)</span><br></pre></td></tr></table></figure><ul><li><code>Series</code>: 指标名称<ul><li><code>LabelMatchers</code>: 指标查询的label</li><li><code>GroupBy</code>: 结果分组，针对HPA过来的查询，都会匹配成<code>kubernetes_pod_name</code></li></ul></li></ul><p>更新Adapter的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ vi custom-metrics-configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: adapter-config</span><br><span class="line">  namespace: monitor</span><br><span class="line">data:</span><br><span class="line">  config.yaml: |</span><br><span class="line">    rules:</span><br><span class="line">    - seriesQuery: <span class="string">&#x27;http_requests_total&#x27;</span></span><br><span class="line">      seriesFilters: []</span><br><span class="line">      resources:</span><br><span class="line">        overrides:</span><br><span class="line">          kubernetes_namespace: &#123;resource: <span class="string">&quot;namespace&quot;</span>&#125;</span><br><span class="line">          kubernetes_pod_name: &#123;resource: <span class="string">&quot;pod&quot;</span>&#125;</span><br><span class="line">      name:</span><br><span class="line">        as: <span class="string">&quot;http_requests_per_second&quot;</span></span><br><span class="line">      metricsQuery: (<span class="built_in">sum</span>(rate(&lt;&lt;.Series&gt;&gt;&#123;&lt;&lt;.LabelMatchers&gt;&gt;&#125;[1m])) by (&lt;&lt;.GroupBy&gt;&gt;))</span><br></pre></td></tr></table></figure><p>需要更新configmap并重启adapter服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f custom-metrics-configmap.yaml</span><br><span class="line">$ kubectl -n monitor delete po custom-metrics-apiserver-c689ff947-zp8gq</span><br></pre></td></tr></table></figure><p>再次查看可用的指标数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1 |jq</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;APIResourceList&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;groupVersion&quot;</span>: <span class="string">&quot;custom.metrics.k8s.io/v1beta2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;resources&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;namespaces/http_requests_per_second&quot;</span>,</span><br><span class="line">      <span class="string">&quot;singularName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;namespaced&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;MetricValueList&quot;</span>,</span><br><span class="line">      <span class="string">&quot;verbs&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;get&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;pods/http_requests_per_second&quot;</span>,</span><br><span class="line">      <span class="string">&quot;singularName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;namespaced&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;MetricValueList&quot;</span>,</span><br><span class="line">      <span class="string">&quot;verbs&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;get&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际中，hpa会去对如下地址发起请求，获取数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get --raw /apis/custom.metrics.k8s.io/v1beta2/namespaces/default/pods/*/http_requests_per_second |jq</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;MetricValueList&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;custom.metrics.k8s.io/v1beta2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;selfLink&quot;</span>: <span class="string">&quot;/apis/custom.metrics.k8s.io/v1beta2/namespaces/default/pods/%2A/http_requests_per_second&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;items&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;describedObject&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Pod&quot;</span>,</span><br><span class="line">        <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;front-app-df5fc79dd-rmzr6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;/v1&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;metric&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;http_requests_per_second&quot;</span>,</span><br><span class="line">        <span class="string">&quot;selector&quot;</span>: null</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2021-07-02T09:24:12Z&quot;</span>,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="string">&quot;33m&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中33m等于0.033，即当前指标查询每秒钟请求数为0.033次.</p><p>我们发现有两个可用的resources，引用官方的一段解释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Notice that we get an entry <span class="keyword">for</span> both <span class="string">&quot;pods&quot;</span> and <span class="string">&quot;namespaces&quot;</span> -- the adapter exposes the metric on each resource that we<span class="string">&#x27;ve associated the metric with (and all namespaced resources must be associated with a namespace), and will fill in the &lt;&lt;.GroupBy&gt;&gt; section with the appropriate label depending on which we ask for.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">We can now connect to $KUBERNETES/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/nginx_vts_server_requests_per_second, and we should see</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config-walkthrough.md">https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config-walkthrough.md</a></p><p><a href="https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config.md">https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/config.md</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> prometheus </tag>
            
            <tag> grafana </tag>
            
            <tag> alertmanager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s prometheus 添加监控目标</title>
      <link href="/k8s-prometheus-add-targets/"/>
      <url>/k8s-prometheus-add-targets/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>上面我们已经部署了Prometheus，现在我们来看看如何添加监控目标。</p><span id="more"></span><h1 id="添加coreDNS监控"><a href="#添加coreDNS监控" class="headerlink" title="添加coreDNS监控"></a>添加coreDNS监控</h1><h2 id="coreDNS监控指标"><a href="#coreDNS监控指标" class="headerlink" title="coreDNS监控指标"></a>coreDNS监控指标</h2><p>无论是业务应用还是k8s系统组件，只要提供了metrics api，并且该api返回的数据格式满足标准的Prometheus数据格式要求即可。</p><p>其实，很多组件已经为了适配Prometheus采集指标，添加了对应的&#x2F;metrics api，比如CoreDNS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-system get po -owide | grep coredns</span><br><span class="line">coredns-66f779496c-cx2zv             1/1     Running   0            98d   10.244.1.2      k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-66f779496c-t5zs2             1/1     Running   0            98d   10.244.1.3      k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ curl 10.244.1.2:9153/metrics</span><br></pre></td></tr></table></figure><h2 id="修改target配置"><a href="#修改target配置" class="headerlink" title="修改target配置"></a>修改target配置</h2><p>加入coreDns的监控目标，只需要修改Prometheus的配置文件即可。因为Prometheus的配置文件是以configmap的形式保存的，所以我们需要修改configmap的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询coreDNS的ClusterIP，因为Pod的IP可能会变化</span></span><br><span class="line">$ kubectl -n kube-system get svc</span><br><span class="line">NAME             TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns         ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP,9153/TCP   98d</span><br><span class="line">metrics-server   ClusterIP   10.105.155.213   &lt;none&gt;        443/TCP                  15d</span><br><span class="line"></span><br><span class="line">$ kubectl -n monitor edit configmap prometheus-config</span><br><span class="line">...</span><br><span class="line">    scrape_configs:</span><br><span class="line">      - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">        static_configs:</span><br><span class="line">        - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">      - job_name: <span class="string">&#x27;coredns&#x27;</span></span><br><span class="line">        static_configs:</span><br><span class="line">        - targets: [<span class="string">&#x27;10.96.0.10:9153&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待30s左右，确认配置文件已经更新，这个是k8s的机制，只需要等待即可</span></span><br><span class="line">$ kubectl -n monitor <span class="built_in">exec</span> prometheus-5bc5966ff8-f84vx -- <span class="built_in">cat</span> /etc/prometheus/prometheus.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启Prometheus进程，因为我们添加了参数，所以使用热更新即可</span></span><br><span class="line">$ kubectl -n monitor get po -owide</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE     IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">prometheus-5bc5966ff8-f84vx   1/1     Running   0          3h39m   10.244.0.26   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ curl -XPOST 10.244.0.26:9090/-/reload</span><br></pre></td></tr></table></figure><p>此时我们登录Prometheus的Web界面，可以看到coreDNS已经添加到监控目标中了。</p><p><img src="/post/docker/k8s-prometheus-coredns-target.jpg" alt="k8s-prometheus-coredns-target"></p><p>我们使用Prometheus的查询语句，可以看到coreDNS的监控指标：</p><p><img src="/post/docker/k8s-prometheus-coredns-graph.jpg" alt="k8s-prometheus-coredns-graph"></p><h1 id="监控api-server等系统组件"><a href="#监控api-server等系统组件" class="headerlink" title="监控api-server等系统组件"></a>监控api-server等系统组件</h1><h2 id="常用监控对象的指标采集"><a href="#常用监控对象的指标采集" class="headerlink" title="常用监控对象的指标采集"></a>常用监控对象的指标采集</h2><p>对于集群的监控一般我们需要考虑以下几个方面：</p><ul><li>内部系统组件的状态：比如 kube-apiserver、kube-scheduler、kube-controller-manager、kubedns&#x2F;coredns 等组件的详细运行状态</li><li>Kubernetes 节点的监控：比如节点的 cpu、load、disk、memory 等指标</li><li>业务容器基础指标的监控（容器CPU、内存、磁盘等）, hpa ,kubelet, advistor</li><li>业务容器业务指标的监控，业务代码实现了&#x2F;metrics的api，暴露业务的指标</li><li>编排级的 metrics：比如 Deployment 的状态、资源请求、调度和 API 延迟等数据指标</li></ul><h2 id="监控-kube-apiserver"><a href="#监控-kube-apiserver" class="headerlink" title="监控 kube-apiserver"></a>监控 kube-apiserver</h2><p>api-server自身也提供了 &#x2F;metrics 的api来提供监控数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   98d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建token</span></span><br><span class="line">$ kubectl -n monitor create token prometheus</span><br><span class="line">$ token=<span class="string">&quot;eyJhbGciOiJSUzI1NiIsImtpZCI6IkFJa1A2OHMwZnVKdHl2VnBaWG5QWl9TRlFCbFhKcmtvcGdEZjFDR1RuMjQifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNzAxNDQ5MzcyLCJpYXQiOjE3MDE0NDU3NzIsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJtb25pdG9yIiwic2VydmljZWFjY291bnQiOnsibmFtZSI6InByb21ldGhldXMiLCJ1aWQiOiJhNGJjMWI5Yi0wMzBjLTRhMGItYjI3MS1kOTMwNGJiZjEwYjAifX0sIm5iZiI6MTcwMTQ0NTc3Miwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Om1vbml0b3I6cHJvbWV0aGV1cyJ9.Frbx-O0rFmf0DXdFGCU2Nh1avWK6EUOlGahyebwoDHHJC0eFEITrJWw7oE8crOlC_fdBsRcqoLZkgRPna2lxJmzZ_Imxo6nepKqhzDjaoeXngcx1w-rAmuzkjSSJJxsCIIpwAjW3ZMBNdpaj1Q5cKhjOMgFwFEcfCAAzxabRrDkH_qPrMsY3eHmxYqFD168HktpVhUkDmzfUvJKypECp4YGccjNAtN7T5hpe8q94hn-_fdvf_xmRUeOqEUSHcdr9lwf8Tq8fF8rMcSM_0OCnUQjvHM6jixyxEOw53axoXmL2VN3RPajfUB5ECV27fi_XG1oTJck7OzE0vA0kOfUN3w&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求apiserver的监控数据</span></span><br><span class="line">$ curl -k -H <span class="string">&quot;Authorization: Bearer <span class="variable">$&#123;token&#125;</span>&quot;</span> https://10.96.0.1/metrics</span><br></pre></td></tr></table></figure><p>确认api-server的监控数据已经正常返回后，就可以通过手动配置如下job来添加对apiserver服务的监控，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n monitor edit configmap prometheus-config</span><br><span class="line">...</span><br><span class="line">      - job_name: <span class="string">&#x27;kubernetes-apiserver&#x27;</span></span><br><span class="line">        static_configs:</span><br><span class="line">        - targets: [<span class="string">&#x27;10.96.0.1&#x27;</span>]</span><br><span class="line">        scheme: https</span><br><span class="line">        tls_config:</span><br><span class="line">          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">          insecure_skip_verify: <span class="literal">true</span></span><br><span class="line">        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br></pre></td></tr></table></figure><p>只有我们创建了一个service account资源，就会在容器挂载目录&#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;下生成一个token文件，这个文件就是apiserver的token，我们可以通过这个token来访问apiserver的&#x2F;metrics api。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认配置文件更新</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -n monitor <span class="built_in">exec</span> prometheus-5bc5966ff8-f84vx -- <span class="built_in">cat</span> /etc/prometheus/prometheus.yml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启Prometheus进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -XPOST 10.244.0.26:9090/-/reload</span></span><br></pre></td></tr></table></figure><p>确认api-server已经添加到监控目标中了。</p><p><img src="/post/docker/k8s-prometheus-api-server-target.jpg" alt="k8s-prometheus-api-server-target"></p><p>我们使用Prometheus的查询语句，可以看到apiserver的监控指标：</p><p><img src="/post/docker/k8s-prometheus-api-server-graph.jpg" alt="k8s-prometheus-api-server-graph"></p><h1 id="监控宿主机指标"><a href="#监控宿主机指标" class="headerlink" title="监控宿主机指标"></a>监控宿主机指标</h1><h2 id="监控集群节点基础指标"><a href="#监控集群节点基础指标" class="headerlink" title="监控集群节点基础指标"></a>监控集群节点基础指标</h2><p>如果想要监控集群节点的基础指标，比如节点的cpu、load、disk、memory等指标，可以使用node_exporter来采集。</p><p><a href="https://github.com/prometheus/node_exporter">node_exporter</a>是一个开源的第三方组件，工作原理是通过在节点上启动一个进程，该进程会定期采集节点的基础指标，然后通过http的方式暴露给Prometheus采集。</p><p>我们要部署node_exporter，需要满足以下几个条件：</p><ul><li>每个节点都需要监控，因此可以使用DaemonSet类型来管理node_exporter</li><li>添加节点的容忍配置，</li><li>挂载宿主机中的系统文件信息</li></ul><h3 id="部署node-exporter"><a href="#部署node-exporter" class="headerlink" title="部署node_exporter"></a>部署node_exporter</h3><p>创建 node-exporter 的资源清单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> node-exporter.ds.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: node-exporter</span><br><span class="line">  namespace: monitor</span><br><span class="line">  labels:</span><br><span class="line">    app: node-exporter</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: node-exporter</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: node-exporter</span><br><span class="line">    spec:</span><br><span class="line">      hostPID: <span class="literal">true</span></span><br><span class="line">      hostIPC: <span class="literal">true</span></span><br><span class="line">      hostNetwork: <span class="literal">true</span></span><br><span class="line">      nodeSelector:</span><br><span class="line">        kubernetes.io/os: linux</span><br><span class="line">      containers:</span><br><span class="line">      - name: node-exporter</span><br><span class="line">        image: prom/node-exporter:v1.7.0</span><br><span class="line">        args:</span><br><span class="line">        - --web.listen-address=$(HOSTIP):9100</span><br><span class="line">        - --path.procfs=/host/proc</span><br><span class="line">        - --path.sysfs=/host/sys</span><br><span class="line">        - --path.rootfs=/host/root</span><br><span class="line">        - --collector.filesystem.ignored-mount-points=^/(dev|proc|sys|var/lib/docker/.+)($|/)</span><br><span class="line">        - --collector.filesystem.ignored-fs-types=^(autofs|binfmt_misc|cgroup|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|mqueue|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|sysfs|tracefs)$</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9100</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">        - name: HOSTIP</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: status.hostIP</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 150m</span><br><span class="line">            memory: 180Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 150m</span><br><span class="line">            memory: 180Mi</span><br><span class="line">        securityContext:</span><br><span class="line">          runAsNonRoot: <span class="literal">true</span></span><br><span class="line">          runAsUser: 65534</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: proc</span><br><span class="line">          mountPath: /host/proc</span><br><span class="line">        - name: sys</span><br><span class="line">          mountPath: /host/sys</span><br><span class="line">        - name: root</span><br><span class="line">          mountPath: /host/root</span><br><span class="line">          mountPropagation: HostToContainer</span><br><span class="line">          readOnly: <span class="literal">true</span></span><br><span class="line">      tolerations:</span><br><span class="line">      - operator: <span class="string">&quot;Exists&quot;</span></span><br><span class="line">      volumes:</span><br><span class="line">      - name: proc</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /proc</span><br><span class="line">      - name: dev</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /dev</span><br><span class="line">      - name: sys</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /sys</span><br><span class="line">      - name: root</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /</span><br></pre></td></tr></table></figure><p>创建node-exporter服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f node-exporter.ds.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl -n monitor get po -owide</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE     IP              NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">node-exporter-7vdxl           1/1     Running   0          36s     192.168.100.3   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">node-exporter-bkqj6           1/1     Running   0          36s     192.168.100.2   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">node-exporter-bmv4m           1/1     Running   0          36s     192.168.100.1   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">prometheus-5bc5966ff8-f84vx   1/1     Running   0          4h34m   10.244.0.26     k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取k8s-master节点的监控指标</span></span><br><span class="line">$ curl 192.168.100.1:9100/metrics</span><br></pre></td></tr></table></figure><p>这样我们就可以通过node-exporter的服务来采集节点的基础指标了。</p><blockquote><p>我们也可以通过helm来部署node-exporter，指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span><br><span class="line">$ helm repo update</span><br><span class="line">$ helm install node-exporter prometheus-community/prometheus-node-exporter -n monitor</span><br></pre></td></tr></table></figure></blockquote><h2 id="Prometheus的服务发现与Relabeling"><a href="#Prometheus的服务发现与Relabeling" class="headerlink" title="Prometheus的服务发现与Relabeling"></a>Prometheus的服务发现与Relabeling</h2><p>接下来就要将node-exporter添加到监控目标，那么如何添加到Prometheus的target中呢？</p><ul><li>配置一个Service，后端挂载node-exporter的服务，把Service的地址配置到target中<ul><li>带来新的问题，target中无法直观的看到各节点node-exporter的状态</li></ul></li><li>把每个node-exporter的服务都添加到target列表中<ul><li>带来新的问题，集群节点的增删，都需要手动维护列表</li><li>target列表维护量随着集群规模增加</li></ul></li></ul><p>于是我们需要一种更加智能的方式来添加监控目标，这就是Prometheus的服务发现机制。</p><p>我们之前已经给Prometheus配置了RBAC，有读取node的权限，因此Prometheus可以去调用Kubernetes API获取node信息，所以Prometheus通过与 Kubernetes API 集成，提供了内置的服务发现分别是：<code>Node</code>、<code>Service</code>、<code>Pod</code>、<code>Endpoints</code>、<code>Ingress</code></p><p>我们再次修改prometheus的配置文件，添加node的服务发现配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">    scrape_configs:</span><br><span class="line">      - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">        static_configs:</span><br><span class="line">        - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">      - job_name: <span class="string">&#x27;coredns&#x27;</span></span><br><span class="line">        static_configs:</span><br><span class="line">        - targets: [<span class="string">&#x27;10.96.0.10:9153&#x27;</span>]</span><br><span class="line">      <span class="comment"># 下面是添加的内容</span></span><br><span class="line">      - job_name: <span class="string">&#x27;kubernetes-sd-node-exporter&#x27;</span></span><br><span class="line">        <span class="comment"># 注意：类型换了，之前使用的是static_configs，都是静态配置，现在使用的是kubernetes_sd_configs，是kubernetes的服务发现</span></span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">          - role: node</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>重新reload后查看效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -n monitor <span class="built_in">exec</span> prometheus-5bc5966ff8-f84vx -- <span class="built_in">cat</span> /etc/prometheus/prometheus.yml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -XPOST 10.244.0.26:9090/-/reload</span></span><br></pre></td></tr></table></figure><p>重新reload后，查看Prometheus的targets列表，可以看到node-exporter已经添加到监控目标中了，但是似乎有点问题，我们看到node-exporter的状态是DOWN的。</p><p><img src="/post/docker/k8s-prometheus-node-exporter-target-error.jpg" alt="k8s-prometheus-node-exporter-target-error"></p><p>可以看到默认访问的地址是<a href="http://node-ip:10250/metrics%EF%BC%8C10250%E6%98%AFkubelet">http://node-ip:10250/metrics，10250是kubelet</a> API的服务端口，说明Prometheus的node类型的服务发现模式，默认是和kubelet的10250绑定的，而我们是期望使用node-exporter作为采集的指标来源，因此需要把访问的endpoint替换成<a href="http://node-ip:9100/metrics%E3%80%82">http://node-ip:9100/metrics。</a></p><p><img src="/post/docker/when-relabel-work.png" alt="when-relabel-work"></p><p>在真正抓取数据前，Prometheus提供了relabeling的能力。Relabeling 重新标记用于配置 Prometheus 元信息的方式，它是转换和过滤 Prometheus 中 label 标签对象的核心。</p><p>那怎么理解这个功能呢？</p><p>查看Target的Label列，可以发现，每个target对应会有很多<code>Before Relabeling/Discovered labels</code>的标签，这些__开头的label是系统内部使用，不会存储到样本的数据里，但是，我们在查看数据的时候，可以发现，每个数据都有两个默认的label，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus_notifications_dropped_total&#123;instance=<span class="string">&quot;localhost:9090&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>instance的值其实则取自于<code>__address__</code></p><p>这种发生在采集样本数据之前，对Target实例的标签进行重写的机制在Prometheus被称为Relabeling，这些配置还是在Prometheus配置文件里面配置。。</p><p>因此，利用relabeling的能力，只需要将<code>__address__</code>替换成node_exporter的服务地址即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">      - job_name: <span class="string">&#x27;kubernetes-sd-node-exporter&#x27;</span></span><br><span class="line">        kubernetes_sd_configs:</span><br><span class="line">          - role: node</span><br><span class="line">        relabel_configs:</span><br><span class="line">        - source_labels: [__address__]</span><br><span class="line">          regex: <span class="string">&#x27;(.*):10250&#x27;</span></span><br><span class="line">          replacement: <span class="string">&#x27;$&#123;1&#125;:9100&#x27;</span></span><br><span class="line">          target_label: __address__</span><br><span class="line">          action: replace</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>再次更新Prometheus服务后，查看targets列表及node-exporter提供的指标</p><p><img src="/post/docker/k8s-prometheus-node-exporter-target.jpg" alt="k8s-prometheus-node-exporter-target"></p><p>查看node-exporter的监控指标 node_load1 （1分钟的load）</p><p><img src="/post/docker/k8s-prometheus-node-exporter-graph.jpg" alt="k8s-prometheus-node-exporter-graph"></p><h2 id="容器指标采集"><a href="#容器指标采集" class="headerlink" title="容器指标采集"></a>容器指标采集</h2><h3 id="使用cadvisor实现容器指标的采集"><a href="#使用cadvisor实现容器指标的采集" class="headerlink" title="使用cadvisor实现容器指标的采集"></a>使用cadvisor实现容器指标的采集</h3><p>目前cAdvisor集成到了kubelet组件内 ，因此如果我们希望通过cadvisor采集容器指标，可以通过kubelet的接口实现容器指标的采集，具体的API为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://&lt;node-ip&gt;:10250/metrics/cadvisor    <span class="comment"># node上的cadvisor采集到的容器指标</span></span><br><span class="line">https://&lt;node-ip&gt;:10250/metrics             <span class="comment"># node上的kubelet的指标数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $ token=`kubectl -n kube-system create token metrics-server`</span></span><br><span class="line"><span class="comment"># $ curl -k -H &quot;Authorization: Bearer $&#123;token&#125;&quot; https://192.168.100.1:10250/metrics</span></span><br></pre></td></tr></table></figure><p>因此，针对容器指标来讲，我们期望的采集target是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://192.168.100.1:10250/metrics/cadvisor</span><br><span class="line">https://192.168.100.2:10250/metrics/cadvisor</span><br><span class="line">https://192.168.100.3:10250/metrics/cadvisor</span><br></pre></td></tr></table></figure><p>即每个node节点都需要去采集数据，联想到prometheus的服务发现中的node类型，因此，配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-sd-cadvisor&#x27;</span></span><br><span class="line">      <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>重新加载配置（reload，具体过程与上面类似，这里不再赘述），查看targets列表，可以看到cadvisor已经添加到监控目标中了。</p><p>但是默认添加的target列表为：<code>__schema__://__address__ __metrics_path__</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.100.1:10250/metrics</span><br><span class="line">http://192.168.100.2:10250/metrics</span><br><span class="line">http://192.168.100.3:10250/metrics</span><br></pre></td></tr></table></figure><p><img src="/post/docker/k8s-prometheus-cadvisor-target-error.jpg" alt="k8s-prometheus-cadvisor-target-error"></p><p>和期望值不同的是<code>__schema__</code>和<code>__metrics_path__</code>，针对<code>__schema__</code>，我们可以直接针对<code>__metrics_path__</code>可以使用relabel修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-sd-cadvisor&#x27;</span></span><br><span class="line">        <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">        <span class="attr">tls_config:</span></span><br><span class="line">          <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">          <span class="attr">insecure_skip_verify:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line">        <span class="attr">relabel_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">          <span class="attr">replacement:</span> <span class="string">/metrics/cadvisor</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>重新应用配置，然后重建Prometheus的pod。</p><p>查看targets列表，可以看到targets已经更新为我们期望的值。</p><p><img src="/post/docker/k8s-prometheus-cadvisor-target.jpg" alt="k8s-prometheus-cadvisor-target"></p><p>查看cadvisor指标，比如container_cpu_system_seconds_total，container_memory_usage_bytes</p><p><img src="/post/docker/k8s-prometheus-cadvisor-graph.jpg" alt="k8s-prometheus-cadvisor-graph"> </p><p>综上，利用node类型的服务发现，可以实现对daemonset类型服务的目标自动发现以及监控数据抓取。</p><h2 id="采集kubelet的指标"><a href="#采集kubelet的指标" class="headerlink" title="采集kubelet的指标"></a>采集kubelet的指标</h2><p>若想采集kubelet的指标，只需要使用以下配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-sd-kubelet&#x27;</span></span><br><span class="line">        <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">node</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">        <span class="attr">tls_config:</span></span><br><span class="line">          <span class="attr">ca_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span></span><br><span class="line">          <span class="attr">insecure_skip_verify:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">bearer_token_file:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount/token</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>还是同样的操作，修改配置文件，reload，重建pod，查看targets列表，查看kubelet的监控指标。</p><p><img src="/post/docker/k8s-prometheus-kubelet-target.jpg" alt="k8s-prometheus-kubelet-target"></p><p><img src="/post/docker/k8s-prometheus-container-graph.jpg" alt="k8s-prometheus-container-graph"></p><p><img src="/post/docker/k8s-prometheus-kubelet-graph.jpg" alt="k8s-prometheus-kubelet-graph"></p><h1 id="集群Service服务的监控指标采集"><a href="#集群Service服务的监控指标采集" class="headerlink" title="集群Service服务的监控指标采集"></a>集群Service服务的监控指标采集</h1><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>比如集群中存在100个业务应用，每个业务应用都需要被Prometheus监控。</p><p>每个服务都需要手动添加配置的话，工作量太大，而且随着集群规模的增加，维护成本也会增加。那么有没有更好的方式呢？</p><p>答案是肯定的，Prometheus提供了服务发现的功能，可以自动发现集群中的服务，然后自动添加到监控目标中。</p><p>我们只需要在Prometheus的配置文件中，添加如下配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-sd-endpoints&#x27;</span></span><br><span class="line">        <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>同样的，还是那几个步骤，修改配置文件，reload，重建pod，查看targets列表。</p><p><img src="/post/docker/k8s-prometheus-endpoints-target-error.jpg" alt="k8s-prometheus-endpoints-target-error"></p><p>可以看到，targets列表中，<code>kubernetes-sd-endpoints</code>下出现了N多条数。</p><p>这些数据其实就是集群中所有的Service的Endpoint列表中的内容每一个都添加<code>/metrics</code>后缀，然后作为监控目标。</p><p>我们可以通过查看集群中的所有ep列表来对比网页中的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get endpoints --all-namespaces</span></span><br></pre></td></tr></table></figure><p>但是实际上并不是每个服务都已经实现了&#x2F;metrics监控的，也不是每个实现了&#x2F;metrics接口的服务都需要注册到Prometheus中，因此，我们需要一种方式对需要采集的服务实现自主可控。这就需要利用relabeling中的keep功能。</p><h2 id="relabeling的keep功能"><a href="#relabeling的keep功能" class="headerlink" title="relabeling的keep功能"></a>relabeling的keep功能</h2><p>我们知道，relabel的作用对象是target的<code>Before Relabling</code>标签，那么我们可以定义如下的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-sd-endpoints&#x27;</span></span><br><span class="line">        <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">        <span class="attr">relabel_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_scrape</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">            <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>上面的配置的意思是，如果target的<code>Before Relabling</code>中存在<code>__meta_kubernetes_service_annotation_prometheus_io_scrape</code>，且值为<code>true</code>的话，则会加入到kubernetes-sd-endpoints这个target中，否则就会被删除。</p><p>因此可以为我们期望被采集的服务，加上对应的Prometheus的label即可，那么就可以只采集我们期望的服务了。</p><h2 id="添加label"><a href="#添加label" class="headerlink" title="添加label"></a>添加label</h2><p>那么问题来了，怎么添加这个label呢？</p><p>解决这个问题之前，我们先来查看coredns的metrics类型<code>Before Relabling</code>中的值，可以发现，存在如下类型的Prometheus的标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__meta_kubernetes_service_annotation_prometheus_io_scrape=<span class="string">&quot;true&quot;</span></span><br><span class="line">__meta_kubernetes_service_annotation_prometheus_io_port=<span class="string">&quot;9153&quot;</span></span><br></pre></td></tr></table></figure><p>接下来我们查看一下coredns对应的service的属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-system get service kube-dns -oyaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/port: <span class="string">&quot;9153&quot;</span></span><br><span class="line">    prometheus.io/scrape: <span class="string">&quot;true&quot;</span></span><br><span class="line">  creationTimestamp: <span class="string">&quot;2023-08-25T07:17:31Z&quot;</span></span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    kubernetes.io/cluster-service: <span class="string">&quot;true&quot;</span></span><br><span class="line">    kubernetes.io/name: CoreDNS</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>发现存在annotations声明，并且和之前查看的<code>Before Relabling</code>中的值是一致的，因此可以联想到二者存在对应关系，Service的定义中的annotations里的特殊字符会被转换成Prometheus中的label中的下划线。</p><p>这样的话，我们只需要为我们需要采集的服务定义上如下的annotations声明，即可实现Prometheus自动采集数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="attr">prometheus.io/scrape:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><h2 id="修改path"><a href="#修改path" class="headerlink" title="修改path"></a>修改path</h2><p>有些时候，我们业务应用提供监控数据的path地址并不一定是&#x2F;metrics，如何实现兼容呢？</p><p>同样的思路，我们知道，Prometheus会默认使用<code>Before Relabling</code>中的<code>__metrics_path</code>作为采集路径，因此，我们再自定义一个annotation，<code>prometheus.io/path</code>，然后想办法让prometheus使用该值替换<code>__metrics_path</code>即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">prometheus.io/path:</span> <span class="string">&quot;/path/to/metrics&quot;</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>这样，Prometheus端会自动生成如下标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__meta_kubernetes_service_annotation_prometheus_io_path=<span class="string">&quot;/path/to/metrics&quot;</span></span><br></pre></td></tr></table></figure><p>我们只需要在relabel_configs中用该标签的值，去重写<code>__metrics_path__</code>的值即可。因此：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-sd-endpoints&#x27;</span></span><br><span class="line">        <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">        <span class="attr">relabel_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_scrape</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">            <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 新加部分</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_path</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">            <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">            <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><h2 id="修改port"><a href="#修改port" class="headerlink" title="修改port"></a>修改port</h2><p>有些时候，业务服务的metrics是独立的端口，比如coredns，业务端口是53，监控指标采集端口是9153，这种情况，又该如何处理呢？</p><p>很自然的，还是通过自定义annotation来处理，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">prometheus.io/path:</span> <span class="string">&quot;/path/to/metrics&quot;</span></span><br><span class="line">    <span class="attr">prometheus.io/port:</span> <span class="string">&quot;9153&quot;</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>annotations已经编写好了，那么如何替换又是一个问题了。</p><p>我们知道Prometheus默认使用<code>Before Relabeling</code>中的<code>__address__</code>进行作为服务指标采集的地址，但是该地址的格式通常是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__address__=<span class="string">&quot;10.244.1.2:53&quot;</span></span><br><span class="line">__address__=<span class="string">&quot;10.244.1.3&quot;</span></span><br></pre></td></tr></table></figure><p>我们的目标是将如下两部分拼接在一起：</p><ul><li>10.244.1.2</li><li>prometheus.io&#x2F;port定义的值，即<code>__meta_kubernetes_service_annotation_prometheus_io_port</code>的值</li></ul><p>因此，需要使用正则规则取出上述两部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-sd-endpoints&#x27;</span></span><br><span class="line">        <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">        <span class="attr">relabel_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_scrape</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">            <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_path</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">            <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">            <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">          <span class="comment"># 新加部分</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>, <span class="string">__meta_kubernetes_service_annotation_prometheus_io_port</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">            <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">            <span class="attr">regex:</span> <span class="string">([^:]+)(?::\d+)?;(\d+)</span></span><br><span class="line">            <span class="attr">replacement:</span> <span class="string">$1:$2</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>需要注意的几点：</p><ul><li><code>__address__</code>中的<code>:&lt;port&gt;</code>有可能不存在，因此，使用<code>()?</code>的匹配方式进行</li><li>表达式中，三段<code>()</code>我们只需要第一和第三段，不需要中间括号部分的内容，因此使用<code>?:</code>的方式来做非获取匹配，即可以匹配内容，但是不会被记录到$1,$2这种变量中</li><li>多个source_labels中间默认使用<code>;</code>号分割，因此匹配的时候需要注意添加<code>;</code>号</li></ul><h2 id="添加更多的label"><a href="#添加更多的label" class="headerlink" title="添加更多的label"></a>添加更多的label</h2><p>此外，还可以将<code>Before relabeling</code>中的更多常用的字段取出来添加到目标的label中，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">  action: replace</span><br><span class="line">  target_label: kubernetes_namespace</span><br><span class="line">- source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">  action: replace</span><br><span class="line">  target_label: kubernetes_service_name</span><br><span class="line">- source_labels: [__meta_kubernetes_pod_name]</span><br><span class="line">  action: replace</span><br><span class="line">  target_label: kubernetes_pod_name</span><br></pre></td></tr></table></figure><h2 id="全部配置"><a href="#全部配置" class="headerlink" title="全部配置"></a>全部配置</h2><p>因此，目前的relabel的配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;kubernetes-sd-endpoints&#x27;</span></span><br><span class="line">        <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">endpoints</span></span><br><span class="line">        <span class="attr">relabel_configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_scrape</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">keep</span></span><br><span class="line">            <span class="attr">regex:</span> <span class="literal">true</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_annotation_prometheus_io_path</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">            <span class="attr">target_label:</span> <span class="string">__metrics_path__</span></span><br><span class="line">            <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>, <span class="string">__meta_kubernetes_service_annotation_prometheus_io_port</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">            <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">            <span class="attr">regex:</span> <span class="string">([^:]+)(?::\d+)?;(\d+)</span></span><br><span class="line">            <span class="attr">replacement:</span> <span class="string">$1:$2</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_namespace</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">            <span class="attr">target_label:</span> <span class="string">kubernetes_namespace</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_service_name</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">            <span class="attr">target_label:</span> <span class="string">kubernetes_service_name</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_name</span>]</span><br><span class="line">            <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">            <span class="attr">target_label:</span> <span class="string">kubernetes_pod_name</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><h2 id="重新加载配置，查看效果"><a href="#重新加载配置，查看效果" class="headerlink" title="重新加载配置，查看效果"></a>重新加载配置，查看效果</h2><p>更新configmap并reload Prometheus服务，查看target列表。</p><p><img src="/post/docker/k8s-prometheus-endpoints-target.jpg" alt="k8s-prometheus-endpoints-target"></p><h1 id="kube-state-metrics监控"><a href="#kube-state-metrics监控" class="headerlink" title="kube-state-metrics监控"></a>kube-state-metrics监控</h1><h2 id="kube-state-metrics监控是什么？"><a href="#kube-state-metrics监控是什么？" class="headerlink" title="kube-state-metrics监控是什么？"></a>kube-state-metrics监控是什么？</h2><p>已经有了cadvisor，容器运行的指标已经可以获取到，但是下面这种情况却无能为力：</p><ul><li>我调度了多少个replicas？现在可用的有几个？</li><li>多少个Pod是running&#x2F;stopped&#x2F;terminated状态？</li><li>Pod重启了多少次？</li></ul><p>而这些则是kube-state-metrics提供的内容，它基于client-go开发，轮询Kubernetes API，并将Kubernetes的结构化信息转换为metrics。因此，需要借助于<code>kube-state-metrics</code>来实现。</p><h2 id="kube-state-metrics提供的指标"><a href="#kube-state-metrics提供的指标" class="headerlink" title="kube-state-metrics提供的指标"></a>kube-state-metrics提供的指标</h2><p>指标类别包括：</p><ul><li>CronJob Metrics</li><li>DaemonSet Metrics</li><li>Deployment Metrics</li><li>Job Metrics</li><li>LimitRange Metrics</li><li>Node Metrics</li><li>PersistentVolume Metrics</li><li>PersistentVolumeClaim Metrics</li><li>Pod Metrics<ul><li>kube_pod_info</li><li>kube_pod_owner</li><li>kube_pod_status_phase</li><li>kube_pod_status_ready</li><li>kube_pod_status_scheduled</li><li>kube_pod_container_status_waiting</li><li>kube_pod_container_status_terminated_reason</li><li>…</li></ul></li><li>Pod Disruption Budget Metrics</li><li>ReplicaSet Metrics</li><li>ReplicationController Metrics</li><li>ResourceQuota Metrics</li><li>Service Metrics</li><li>StatefulSet Metrics</li><li>Namespace Metrics</li><li>Horizontal Pod Autoscaler Metrics</li><li>Endpoint Metrics</li><li>Secret Metrics</li><li>ConfigMap Metrics</li></ul><h2 id="部署kube-state-metrics"><a href="#部署kube-state-metrics" class="headerlink" title="部署kube-state-metrics"></a>部署kube-state-metrics</h2><p>kube-state-metrics的部署，可以参考<a href="https://github.com/kubernetes/kube-state-metrics#kubernetes-deployment">官方文档</a></p><p>这里我使用helm部署，helm的官方chart<a href="https://artifacthub.io/packages/helm/prometheus-community/kube-state-metrics/">在这里</a>，部署清单的github地址是<a href="https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-state-metrics">prometheus-community&#x2F;helm-charts</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span><br><span class="line">$ helm repo update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载chart</span></span><br><span class="line">$ helm pull prometheus-community/kube-state-metrics</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">$ tar zxf kube-state-metrics-5.15.2.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改values.yaml，如果镜像无法下载，可以修改镜像地址为bitnami/kube-state-metrics:2.10.1</span></span><br><span class="line"><span class="comment"># 这里我没做任何修改，直接使用默认的配置</span></span><br><span class="line"><span class="comment"># $ vim kube-state-metrics/values.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">$ helm install kube-state-metrics prometheus-community/kube-state-metrics -n monitor</span><br></pre></td></tr></table></figure><h2 id="如何添加到Prometheus监控target中"><a href="#如何添加到Prometheus监控target中" class="headerlink" title="如何添加到Prometheus监控target中"></a>如何添加到Prometheus监控target中</h2><p>因为我们已经添加了<code>kubernetes-sd-endpoints</code>的服务发现，因此，只需要在Service的annotations中添加<code>prometheus.io/scrape: &quot;true&quot;</code>即可。这里我们使用的helm进行的部署，因此使用默认的配置即可，不需要做任何修改。</p><p>如果使用yaml文件进行部署，可以参考如下的配置修改service的配置让其支持prometheus的监控：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> service.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/scrape: <span class="string">&quot;true&quot;</span></span><br><span class="line">    prometheus.io/port: <span class="string">&quot;8080&quot;</span></span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: 2.1.0</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">  namespace: monitor</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">  - name: http-metrics</span><br><span class="line">    port: 8080</span><br><span class="line">    targetPort: http-metrics</span><br><span class="line">  - name: telemetry</span><br><span class="line">    port: 8081</span><br><span class="line">    targetPort: telemetry</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    </span><br><span class="line">$ kubectl apply -f service.yaml</span><br></pre></td></tr></table></figure><h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><p>不需要修改Prometheus的配置文件了，因为有了<code>kubernetes-sd-endpoints</code>的服务发现，直接查看targets列表，可以看到<code>kubenetes-sd-endpoints</code>下已经添加了<code>kube-state-metrics</code>的监控目标。</p><p><img src="/post/docker/k8s-prometheus-kube-state-metrics-target.jpg" alt="k8s-prometheus-kube-state-metrics-target"></p><p>查看kube-state-metrics的监控指标，比如kube_pod_container_status_running，kube_deployment_status_replicas，kube_deployment_status_replicas_unavailable等。</p><p><img src="/post/docker/k8s-prometheus-kube-state-metrics-graph.jpg" alt="k8s-prometheus-kube-state-metrics-graph"></p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> prometheus </tag>
            
            <tag> monitoring </tag>
            
            <tag> targets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux iptables 防火墙</title>
      <link href="/linux-iptables/"/>
      <url>/linux-iptables/</url>
      
        <content type="html"><![CDATA[<p>iptables是linux下的防火墙，可以用来过滤网络数据包，防止恶意攻击，也可以用来做端口转发，端口映射等。docker以及k8s中的网络也广泛的使用了iptables的功能。</p><p>以下内容主要是整理的学习笔记，参考了以下文章：<a href="https://www.zsythink.net/?s=iptables%E8%AF%A6%E8%A7%A3">iptables详解-朱双印博客</a></p><span id="more"></span><h1 id="iptables基本概念"><a href="#iptables基本概念" class="headerlink" title="iptables基本概念"></a>iptables基本概念</h1><p>从物理上来说，防火墙可以分为硬件防火墙和软件防火墙。</p><ul><li>硬件防火墙：在硬件级别实现部分防火墙功能，另一部分功能基于软件实现，性能高，成本高。比如：Cisco PIX、Cisco ASA、Juniper NetScreen、Fortinet FortiGate、Check Point Firewall-1等。</li><li>软件防火墙：应用软件处理逻辑运行于通用硬件平台之上的防火墙，性能低，成本低。比如：iptables、ipfw、pf、ipf、ipchains等。</li></ul><p>这里我们主要讲解软件防火墙 iptables</p><p>iptables其实是一个命令行工具，位于用户空间，我们用这个工具操作真正的框架，真正的框架位于内核空间，这个框架的名字叫netfilter，netfilter才是防火墙真正的安全框架（framework），所有的数据包都要经过netfilter，netfilter根据设定的规则对数据包进行过滤，然后决定是否放行，netfilter的规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，netfilter就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p><p>netfilter&#x2F;iptables（下文中简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。</p><p>Netfilter是Linux操作系统核心层内部的一个数据包处理模块，它具有如下功能：</p><ul><li>网络地址转换(Network Address Translate)</li><li>数据包内容修改</li><li>数据包过滤的防火墙功能</li></ul><h2 id="iptables的链"><a href="#iptables的链" class="headerlink" title="iptables的链"></a>iptables的链</h2><p>首先要了解一下iptables的规则，iptables的规则由匹配条件和处理动作组成，含义为当数据包满足匹配条件时，执行处理动作。</p><p>下面我们来通过几个具体的例子来理解iptables中的几个概念。</p><h3 id="例子1：web服务通信"><a href="#例子1：web服务通信" class="headerlink" title="例子1：web服务通信"></a>例子1：web服务通信</h3><p>比如我们有一个网站<code>www.demo.com</code>，这个网站我们部署在服务器node1上。那么用户访问这个网站的过程中防火墙是怎样起作用的呢？</p><ol><li>客户端需要访问web服务的时候，客户端会将请求报文发送到服务器的网卡上。</li><li>网卡会将报文交给内核的TCP&#x2F;IP协议栈，TCP&#x2F;IP协议栈会将报文交给内核的netfilter模块。</li><li>netfilter会根据iptables的规则对报文进行过滤，如果报文满足某个规则，那么就会执行这个规则对应的动作，比如放行，拒绝等。</li><li>如果报文满足放行的条件，那么就会交给用户空间中的web服务进程，web服务进程会对报文进行处理，然后返回响应报文。</li><li>响应报文会经过内核的netfilter模块，netfilter会根据iptables的规则对报文进行过滤，如果报文满足某个规则，那么就会执行这个规则对应的动作，比如放行，拒绝等。</li><li>如果报文满足放行的条件，那么就会交给内核的TCP&#x2F;IP协议栈，TCP&#x2F;IP协议栈会将报文交给网卡，网卡会将报文发送给客户端。</li><li>客户端收到响应报文，然后显示网页。</li></ol><p><img src="/post/linux/iptables/input-output.svg" alt="input-output"></p><p>可以看到，数据报文经过了两个逻辑区域input和output，这两个区域中分别有对应的规则，和一条链一样，因此我们可以把input和output称为链，这就是iptales中的input链和output链。</p><h3 id="例子2：web服务转发"><a href="#例子2：web服务转发" class="headerlink" title="例子2：web服务转发"></a>例子2：web服务转发</h3><p>我们在上面的例子中，我们的web服务是部署在node1上的，那么如果我们想要将web服务部署在node2上，而只有node1对外提供访问，那么我们就需要将node1上的请求转发到node2上（node1内核需要支持IP_FORWARD），这个过程中防火墙是怎样起作用的呢？</p><ol><li>客户端需要访问web服务的时候，客户端会将请求报文发送到node1服务器的网卡上。</li><li>网卡会将报文交给内核的TCP&#x2F;IP协议栈，TCP&#x2F;IP协议栈会将报文交给内核的netfilter模块。</li><li>netfilter会根据iptables的规则对报文进行过滤，如果报文满足某个规则，那么就会执行这个规则对应的动作，比如放行，拒绝等。</li><li>报文满足条件后，netfilter会发现目标不是本机，而是node2服务器，那么就会走转发链，转发链会将报文转发给node2服务器。</li><li>node2服务器收到报文后，就会走node2机器的input链、output链，然后返回node1响应报文。</li><li>响应报文会再通过node1的转发链转发给客户端。</li><li>客户端收到响应报文，然后显示网页。</li></ol><p><img src="/post/linux/iptables/forward.svg" alt="forward"></p><h3 id="iptables的链-1"><a href="#iptables的链-1" class="headerlink" title="iptables的链"></a>iptables的链</h3><p>我们通过上面的两个例子，可以大致了解iptables的链的概念，那么iptables中的链有哪些呢？</p><p>iptables中的链有5个，分别是input、output、forward、prerouting、postrouting，他们的作用范围如下图：</p><p><img src="/post/linux/iptables/iptables-chain.svg" alt="iptables-chain"></p><p>根据上图，我们能够想象出某些常用场景中，报文的流向：</p><ul><li>到本机某进程的报文：PREROUTING –&gt; INPUT</li><li>由本机转发的报文：PREROUTING –&gt; FORWARD –&gt; POSTROUTING</li><li>由本机的某进程发出报文（通常为响应报文）：OUTPUT –&gt; POSTROUTING</li></ul><h2 id="iptables的表"><a href="#iptables的表" class="headerlink" title="iptables的表"></a>iptables的表</h2><h3 id="表的概念"><a href="#表的概念" class="headerlink" title="表的概念"></a>表的概念</h3><p>现在我们我们有了5个链，那么我们就需要在链中添加规则，那么规则是怎样存储的呢？不可能每个链都有一个规则列表吧，那样太麻烦了。</p><p>在iptables中，规则是存储在表中的，iptables中的表有4个，分别是filter、nat、mangle、raw，他们的作用范围如下图：</p><ul><li>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</li><li>nat表：network address translation，网络地址转换功能；内核模块：iptable_nat</li><li>mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle</li><li>raw表：关闭nat表上启用的连接追踪机制；iptable_raw</li></ul><p>也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张“表”中。</p><h3 id="表和链的关系"><a href="#表和链的关系" class="headerlink" title="表和链的关系"></a>表和链的关系</h3><p>需要了解的是，某些链天生就不能使用某些表中的规则，比如input链就不能使用nat表中的规则，因为input链只能用于处理本机的数据包，而nat表中的规则是用于处理转发的数据包的。</p><p>那让我们来看看，每个“链”都有哪些能力，或者说，让我们看看每个“链”上的规则都存在于哪些“表”中。</p><p>我们还是以图为例，先看看prerouting”链”上的规则都存在于哪些表中。</p><p>注意：下图只用于说明prerouting链上的规则存在于哪些表中，并没有描述表的顺序。</p><p><img src="/post/linux/iptables/iptables-table.png" alt="iptables-table"></p><p>这幅图是什么意思呢？它的意思是说，prerouting”链”只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。</p><p>根据上图，我们大致可以总结出，每个”链”都拥有什么功能，或者说，每个”链”中的规则都存在于哪些”表”中。</p><ul><li>PREROUTING 的规则可以存在于：raw表，mangle表，nat表。</li><li>INPUT 的规则可以存在于：mangle表，filter表，nat表。</li><li>FORWARD 的规则可以存在于：mangle表，filter表。</li><li>OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。</li><li>POSTROUTING 的规则可以存在于：mangle表，nat表。</li></ul><h3 id="表的使用以及优先级"><a href="#表的使用以及优先级" class="headerlink" title="表的使用以及优先级"></a>表的使用以及优先级</h3><p>实际使用的过程中，我们往往是通过”表”作为操作入口，对规则进行定义的，为了在实际使用的时候，更加顺畅的理解它们，此处我们还要将各”表”与”链”的关系罗列出来。</p><table><thead><tr><th>表</th><th>PREROUTING</th><th>INPUT</th><th>FORWARD</th><th>OUTPUT</th><th>POSTROUTING</th></tr></thead><tbody><tr><td>raw</td><td>√</td><td>×</td><td>×</td><td>√</td><td>×</td></tr><tr><td>mangle</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>nat</td><td>√</td><td>√</td><td>×</td><td>√</td><td>√</td></tr><tr><td>filter</td><td>×</td><td>√</td><td>√</td><td>√</td><td>×</td></tr></tbody></table><p>上表中的√表示可以使用，×表示不能使用。</p><p>数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，它会一条一条的去匹配，既然规则都放在”表”中，那么哪些”表”中的规则会放在”链”的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿之前“prerouting链”的图做示例。</p><p>prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：</p><p>raw –&gt; mangle –&gt; nat</p><p>但是我们知道，iptables为我们定义了4张”表”，所以当他们处于同一条”链”时，执行的优先级如下。</p><p>优先级次序（由高而低）：<code>raw –&gt; mangle –&gt; nat –&gt; filter</code></p><p>为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用。具体的内容我们会在后面的文章中进行总结。</p><h3 id="数据经过防火墙的流程"><a href="#数据经过防火墙的流程" class="headerlink" title="数据经过防火墙的流程"></a>数据经过防火墙的流程</h3><p>结合上述所有的描述，我们可以将数据包通过防火墙的流程总结为下图：</p><p><img src="/post/linux/iptables/iptables-flow.png" alt="iptables-flow"></p><p>我们在写iptables规则的时候，要时刻牢记这张路由次序图，灵活配置规则。</p><p><strong>我们将经常用到的对应关系重新写在此处，方便对应图例查看。</strong></p><p>链的规则存放于哪些表中（从链到表的对应关系）：</p><ul><li>PREROUTING 的规则可以存在于：raw表，mangle表，nat表。</li><li>INPUT 的规则可以存在于：mangle表，filter表，nat表。</li><li>FORWARD 的规则可以存在于：mangle表，filter表。</li><li>OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。</li><li>POSTROUTING 的规则可以存在于：mangle表，nat表。</li></ul><p>表中的规则可以被哪些链使用（从表到链的对应关系）：</p><ul><li>raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT</li><li>mangle 表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</li><li>nat 表中的规则可以被哪些链使用：PREROUTING，OUTPUT，POSTROUTING，INPUT</li><li>filter 表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT</li></ul><h2 id="iptables的规则"><a href="#iptables的规则" class="headerlink" title="iptables的规则"></a>iptables的规则</h2><h3 id="规则的概念"><a href="#规则的概念" class="headerlink" title="规则的概念"></a>规则的概念</h3><p>在上面的内容中，我们已经了解了iptables的链和表，那么我们来聊聊规则的概。</p><p>规则就是一种匹配条件，它会根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理；</p><p>规则由匹配条件和处理动作组成。</p><h3 id="规则的匹配条件"><a href="#规则的匹配条件" class="headerlink" title="规则的匹配条件"></a>规则的匹配条件</h3><p>规则的匹配条件分为基本匹配条件与扩展匹配条件</p><p>基本匹配条件：</p><ul><li>源地址Source IP</li><li>目标地址 Destination IP</li></ul><p>上述内容都可以作为基本匹配条件。除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。</p><p>扩展匹配条件：</p><ul><li>源端口Source Port</li><li>目标端口Destination Port</li></ul><h3 id="规则的处理动作"><a href="#规则的处理动作" class="headerlink" title="规则的处理动作"></a>规则的处理动作</h3><p>规则的处理动作在iptables中被称为target（这样说并不准确，我们暂且这样称呼），动作也可以分为基本动作和扩展动作。</p><p>以下是一些常用的动作，之后的文章会对它们进行详细的示例与总结：</p><ul><li>ACCEPT：允许数据包通过。</li><li>DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。</li><li>REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</li><li>SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。</li><li>MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。</li><li>DNAT：目标地址转换。</li><li>REDIRECT：在本机做端口映射。</li><li>LOG：在&#x2F;var&#x2F;log&#x2F;messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s prometheus监控</title>
      <link href="/k8s-prometheus-introduction-install/"/>
      <url>/k8s-prometheus-introduction-install/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>Prometheus 是一个开源监控系统，它本身已经成为了云原生中指标监控的事实标准，本文主要介绍k8s集群监控的安装和配置。</p><span id="more"></span><h1 id="k8s集群监控体系演变史"><a href="#k8s集群监控体系演变史" class="headerlink" title="k8s集群监控体系演变史"></a>k8s集群监控体系演变史</h1><p>k8s集群监控体系主要经历了三个版本的演变：</p><h2 id="第一版本：Cadvisor-InfluxDB-Grafana"><a href="#第一版本：Cadvisor-InfluxDB-Grafana" class="headerlink" title="第一版本：Cadvisor+InfluxDB+Grafana"></a>第一版本：<strong>Cadvisor+InfluxDB+Grafana</strong></h2><p>只能从主机维度进行采集，没有Namespace、Pod等维度的汇聚功能</p><h2 id="第二版本：-Heapster-InfluxDB-Grafana"><a href="#第二版本：-Heapster-InfluxDB-Grafana" class="headerlink" title="第二版本： Heapster+InfluxDB+Grafana"></a>第二版本： <strong>Heapster+InfluxDB+Grafana</strong></h2><p>heapster负责调用各node中的cadvisor接口，对数据进行汇总，然后导到InfluxDB，可以从cluster，node，pod的各个层面提供详细的资源使用情况。</p><p><img src="/post/docker/monitor-earlier.png" alt="monitor-earlier"></p><h2 id="第三版本：Metrics-Server-Prometheus"><a href="#第三版本：Metrics-Server-Prometheus" class="headerlink" title="第三版本：Metrics-Server + Prometheus"></a>第三版本：Metrics-Server + Prometheus</h2><p><img src="/post/docker/custom-hpa.png" alt="custom-hpa"></p><h2 id="监控接口标准化"><a href="#监控接口标准化" class="headerlink" title="监控接口标准化"></a>监控接口标准化</h2><p>k8s对监控接口进行了标准化，主要分了三类：</p><ol><li><p>Resource Metrics</p><p> metric-api对应的接口是 metrics.k8s.io，主要的实现就是 metrics-server，它提供的是资源的监控，比较常见的是节点级别、pod 级别、namespace 级别、class 级别。这类的监控指标都可以通过 metrics.k8s.io 这个接口获取到 </p></li><li><p>Custom Metrics<br> 对应的接口是 custom.metrics.k8s.io，主要的实现是 Prometheus， 它提供的是资源监控和自定义监控，资源监控和上面的资源监控其实是有覆盖关系的。</p><p> 自定义监控指的是：比如应用上面想暴露一个类似像在线人数，或者说调用后面的这个数据库的 MySQL 的慢查询。这些其实都是可以在应用层做自己的定义的，然后并通过标准的 Prometheus 的 client，暴露出相应的 metrics，然后再被 Prometheus 进行采集</p></li><li><p>External Metrics</p><p> 对应的接口是 external.metrics.k8s.io。主要的实现厂商就是各个云厂商的 provider，通过这个 provider 可以通过云资源的监控指标</p></li></ol><h1 id="Prometheus架构"><a href="#Prometheus架构" class="headerlink" title="Prometheus架构"></a>Prometheus架构</h1><p><img src="/post/docker/prometheus.svg" alt="prometheus"></p><ol><li>Prometheus Server ，监控、告警平台核心，抓取目标端监控数据，生成聚合数据，存储时间序列数据</li><li>exporter，由被监控的对象提供，提供API暴漏监控对象的指标，供prometheus 抓取<ul><li>node-exporter</li><li>blackbox-exporter</li><li>redis-exporter</li><li>mysql-exporter</li><li>custom-exporter</li><li>…</li></ul></li><li>pushgateway，提供一个网关地址，外部数据可以推送到该网关，prometheus也会从该网关拉取数据 </li><li>Alertmanager，接收Prometheus发送的告警并对于告警进行一系列的处理后发送给指定的目标 </li><li>Grafana：配置数据源，图标方式展示数据</li></ol><h1 id="Prometheus安装"><a href="#Prometheus安装" class="headerlink" title="Prometheus安装"></a>Prometheus安装</h1><p>Prometheus基于go开发，项目地址<a href="https://github.com/prometheus/prometheus">在这里</a></p><h2 id="docker-启动"><a href="#docker-启动" class="headerlink" title="docker 启动"></a>docker 启动</h2><p>真正部署到k8s之前，我们可以先使用docker启动一个prometheus实例，这样可以方便我们进行测试，我们先看一下它启动需要什么参数可以供我们修改。</p><p>使用docker部署直接启动镜像即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name prometheus -d -p 127.0.0.1:9090:9090 prom/prometheus:v2.48.0</span><br></pre></td></tr></table></figure><p>接下来我们去容器内容查看一下默认的启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name prometheus -p 9090:9090 prom/prometheus:v2.48.0</span><br><span class="line">$ docker <span class="built_in">exec</span> -it prometheus sh</span><br><span class="line">/prometheus $ ps aux</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 nobody    0:00 /bin/prometheus --config.file=/etc/prometheus/prometheus.yml --storage.tsdb.path=/prometheus --web.console.libraries=/usr/share/prometheus/console_libraries --web.console.templates=/usr/share/prometheu</span><br><span class="line">   26 nobody    0:00 sh</span><br><span class="line">   32 nobody    0:00 ps aux</span><br><span class="line"></span><br><span class="line"><span class="comment">#/ cat /etc/prometheus/prometheus.yml</span></span><br><span class="line"><span class="comment"># my global config</span></span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line">  evaluation_interval: 15s <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span></span><br><span class="line">rule_files:</span><br><span class="line">  <span class="comment"># - &quot;first_rules.yml&quot;</span></span><br><span class="line">  <span class="comment"># - &quot;second_rules.yml&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it&#x27;s Prometheus itself.</span></span><br><span class="line">scrape_configs:</span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br></pre></td></tr></table></figure><p>从上面的结果可以看到prometheus的启动命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/prometheus --config.file=/etc/prometheus/prometheus.yml --storage.tsdb.path=/prometheus --web.console.libraries=/usr/share/prometheus/console_libraries --web.console.templates=/usr/share/prometheus/consoles</span><br></pre></td></tr></table></figure><p>其中，我们可以看到几个关键的参数：</p><ul><li>–config.file：配置文件路径，配置了哪些指标需要采集，采集的频率是多少等</li><li>–storage.tsdb.path：tsdb数据存储路径</li><li>–web.console.libraries：prometheus的web控制台的静态文件路径</li><li>–web.console.templates：prometheus的web控制台的模板文件路径</li></ul><p>其他常用参数：</p><ul><li>–web.enable-lifecycle：支持热更新，直接执行localhost:9090&#x2F;-&#x2F;reload立即生效</li><li>–web.enable-admin-api：支持admin api，可以通过api来获取prometheus的一些信息</li><li>–web.route-prefix：prometheus的ui&#x2F;api的前缀</li><li>–web.external-url：prometheus的ui&#x2F;api的外部访问地址</li><li>–web.page-title：prometheus的web控制台的标题</li><li>–web.max-connections：prometheus的web控制台的最大连接数</li></ul><h2 id="k8s部署"><a href="#k8s部署" class="headerlink" title="k8s部署"></a>k8s部署</h2><p>我们通过docker启动已经知道了prometheus的启动参数，接下来我们就可以通过k8s来部署prometheus了。</p><p>首先准备所需的资源清单，比如配置文件，数据库的pvc资源，rbac资源，deployment资源，service资源，ingress资源等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件，使用configmap的形式保存，覆盖默认的配置文件</span></span><br><span class="line">$ <span class="built_in">cat</span> prometheus-cm.yml</span><br><span class="line"><span class="comment"># my global config</span></span><br><span class="line">global:</span><br><span class="line">  scrape_interval: 30s</span><br><span class="line">  evaluation_interval: 30s</span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span></span><br><span class="line">rule_files:</span><br><span class="line">  <span class="comment"># - &quot;first_rules.yml&quot;</span></span><br><span class="line">  <span class="comment"># - &quot;second_rules.yml&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it&#x27;s Prometheus itself.</span></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库的pvc资源</span></span><br><span class="line">$ <span class="built_in">cat</span> prometheus-pvc.yaml</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: monitor</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  storageClassName: nfs-client</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 200Gi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># prometheus的资源文件</span></span><br><span class="line"><span class="comment"># 需要防止出现Prometheus数据存储权限问题，因为Prometheus内部使用nobody启动进程，挂载数据目录后权限为root，因此使用initContainer进行目录权限修复：</span></span><br><span class="line">$ <span class="built_in">cat</span> prometheus-deployment.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: monitor</span><br><span class="line">  labels:</span><br><span class="line">    app: prometheus</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: prometheus</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: prometheus</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccountName: prometheus</span><br><span class="line">      initContainers:</span><br><span class="line">      - name: <span class="string">&quot;change-permission-of-directory&quot;</span></span><br><span class="line">        image: busybox</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">        args: [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;chown -R 65534:65534 /prometheus&quot;</span>]</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: <span class="literal">true</span></span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: <span class="string">&quot;/etc/prometheus&quot;</span></span><br><span class="line">          name: config-volume</span><br><span class="line">        - mountPath: <span class="string">&quot;/prometheus&quot;</span></span><br><span class="line">          name: data</span><br><span class="line">      containers:</span><br><span class="line">      - image: prom/prometheus:v2.48.0</span><br><span class="line">        name: prometheus</span><br><span class="line">        args:</span><br><span class="line">        - <span class="string">&quot;--config.file=/etc/prometheus/prometheus.yml&quot;</span></span><br><span class="line">        - <span class="string">&quot;--storage.tsdb.path=/prometheus&quot;</span>  <span class="comment"># 指定tsdb数据路径</span></span><br><span class="line">        - <span class="string">&quot;--web.enable-lifecycle&quot;</span>  <span class="comment"># 支持热更新，直接执行localhost:9090/-/reload立即生效</span></span><br><span class="line">        - <span class="string">&quot;--web.console.libraries=/usr/share/prometheus/console_libraries&quot;</span></span><br><span class="line">        - <span class="string">&quot;--web.console.templates=/usr/share/prometheus/consoles&quot;</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9090</span><br><span class="line">          name: http</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: <span class="string">&quot;/etc/prometheus&quot;</span></span><br><span class="line">          name: config-volume</span><br><span class="line">        - mountPath: <span class="string">&quot;/prometheus&quot;</span></span><br><span class="line">          name: data</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 512Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 512Mi</span><br><span class="line">      volumes:</span><br><span class="line">      - name: data</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: prometheus</span><br><span class="line">      - configMap:</span><br><span class="line">          name: prometheus-config</span><br><span class="line">        name: config-volume</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rbac,prometheus会调用k8s api做服务发现进行抓取指标</span></span><br><span class="line">$ <span class="built_in">cat</span> prometheus-rbac.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: monitor</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">rules:</span><br><span class="line">- apiGroups:</span><br><span class="line">  - <span class="string">&quot;&quot;</span></span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  - services</span><br><span class="line">  - endpoints</span><br><span class="line">  - pods</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - <span class="string">&quot;extensions&quot;</span></span><br><span class="line">  resources:</span><br><span class="line">    - ingresses</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - <span class="string">&quot;&quot;</span></span><br><span class="line">  resources:</span><br><span class="line">  - configmaps</span><br><span class="line">  - nodes/metrics</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">- nonResourceURLs:</span><br><span class="line">  - /metrics</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: prometheus</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: monitor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供Service，为Ingress使用</span></span><br><span class="line">$ <span class="built_in">cat</span> prometheus-svc.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: monitor</span><br><span class="line">  labels:</span><br><span class="line">    app: prometheus</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">    - name: web</span><br><span class="line">      port: 9090</span><br><span class="line">      targetPort: http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建访问的ingress资源</span></span><br><span class="line">$ <span class="built_in">cat</span> prometheus-ingress.yaml</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: monitor</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: prometheus.test.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service: </span><br><span class="line">            name: prometheus</span><br><span class="line">            port:</span><br><span class="line">              number: 9090</span><br></pre></td></tr></table></figure><p>部署上述资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命名空间</span></span><br><span class="line">$ kubectl create namespace monitor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建cm</span></span><br><span class="line">$ kubectl -n monitor create cm prometheus-config --from-file=prometheus.yml=prometheus-cm.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建pvc</span></span><br><span class="line">$ kubectl apply -f prometheus-pvc.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建rbac</span></span><br><span class="line">$ kubectl apply -f prometheus-rbac.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建deployment</span></span><br><span class="line">$ kubectl apply -f prometheus-deployment.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建svc</span></span><br><span class="line">$ kubectl apply -f prometheus-svc.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ingress</span></span><br><span class="line">$ kubectl apply -f prometheus-ingress.yaml</span><br></pre></td></tr></table></figure><p>等待pod启动完成后，我们就可以通过ingress访问prometheus了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n monitor get po -o wide</span><br><span class="line"></span><br><span class="line">$ kubectl -n monitor logs prometheus-5bc5966ff8-f84vx</span><br><span class="line">......</span><br><span class="line">ts=2023-12-01T11:43:56.696Z <span class="built_in">caller</span>=main.go:1048 level=info msg=<span class="string">&quot;TSDB started&quot;</span></span><br><span class="line">ts=2023-12-01T11:43:56.696Z <span class="built_in">caller</span>=main.go:1229 level=info msg=<span class="string">&quot;Loading configuration file&quot;</span> filename=/etc/prometheus/prometheus.yml</span><br><span class="line">ts=2023-12-01T11:43:56.697Z <span class="built_in">caller</span>=main.go:1266 level=info msg=<span class="string">&quot;Completed loading of configuration file&quot;</span> filename=/etc/prometheus/prometheus.yml totalDuration=1.610796ms db_storage=2.624µs remote_storage=3.863µs web_handler=1.187µs query_engine=1.973µs scrape=786.861µs scrape_sd=80.748µs notify=79.645µs notify_sd=28.501µs rules=3.403µs tracing=12.743µs</span><br><span class="line">ts=2023-12-01T11:43:56.698Z <span class="built_in">caller</span>=main.go:1009 level=info msg=<span class="string">&quot;Server is ready to receive web requests.&quot;</span></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">$ curl http://prometheus.test.com</span><br></pre></td></tr></table></figure><h2 id="prometheus的数据"><a href="#prometheus的数据" class="headerlink" title="prometheus的数据"></a>prometheus的数据</h2><p>部署完成后，我们可以访问prometheus的web控制台，查看prometheus的数据。</p><p><img src="/post/docker/k8s-prometheus-ui-page.jpg" alt="k8s-prometheus-ui-page"></p><p>然后我们选择进入targets页面，查看prometheus的默认targets：</p><p><img src="/post/docker/k8s-prometheus-ui-choose-targets.jpg" alt="k8s-prometheus-ui-choose-targets"></p><p><img src="/post/docker/k8s-prometheus-ui-targets-page.jpg" alt="k8s-prometheus-ui-targets-page"></p><p>可以看到prometheus默认采集了一些k8s的指标，这里只有一个endpoint是 <code>http://localhost:9090/metrics</code> ，这个是prometheus自身的指标。</p><p>我们可以通过访问这个endpoint来查看prometheus自身的指标：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://prometheus.test.com/metrics</span><br><span class="line">......</span><br><span class="line"><span class="comment"># HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.</span></span><br><span class="line"><span class="comment"># TYPE promhttp_metric_handler_requests_total counter</span></span><br><span class="line">promhttp_metric_handler_requests_total&#123;code=<span class="string">&quot;200&quot;</span>&#125; 152</span><br><span class="line">promhttp_metric_handler_requests_total&#123;code=<span class="string">&quot;500&quot;</span>&#125; 0</span><br><span class="line">promhttp_metric_handler_requests_total&#123;code=<span class="string">&quot;503&quot;</span>&#125; 0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到返回的监控数据格式都比较固定，那它们怎么存储呢？接下来我们就来看一下prometheus的数据存储。</p><h1 id="时间序列数据库（TSDB）"><a href="#时间序列数据库（TSDB）" class="headerlink" title="时间序列数据库（TSDB）"></a>时间序列数据库（TSDB）</h1><h2 id="初识TSDB"><a href="#初识TSDB" class="headerlink" title="初识TSDB"></a>初识TSDB</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http://prometheus.test.com/metrics 是通过ingress访问，接下来我们直接使用pod的ip访问9090端口获取信息</span></span><br><span class="line">$ kubectl -n monitor get po -o wide</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE    IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">prometheus-5bc5966ff8-f84vx   1/1     Running   0          129m   10.244.0.26   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ $ curl http://10.244.0.26:9090/metrics</span><br><span class="line">......</span><br><span class="line"><span class="comment"># HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.</span></span><br><span class="line"><span class="comment"># TYPE promhttp_metric_handler_requests_total counter</span></span><br><span class="line">promhttp_metric_handler_requests_total&#123;code=<span class="string">&quot;200&quot;</span>&#125; 258</span><br><span class="line">promhttp_metric_handler_requests_total&#123;code=<span class="string">&quot;500&quot;</span>&#125; 0</span><br><span class="line">promhttp_metric_handler_requests_total&#123;code=<span class="string">&quot;503&quot;</span>&#125; 0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>分析一下上面的监控数据信息：</p><ul><li>首先是注释的HELP开头的信息，说明该行为指标的帮助信息，通常解释指标的含义</li><li>然后是注释的TYPE开头的信息，指明了指标的类型<ul><li>counter 计数器</li><li>guage 测量器</li><li>histogram 柱状图</li><li>summary 采样点分位图统计</li></ul></li><li>最后是非注释的每一行，表示当前采集到的一个监控样本：<ul><li>promhttp_metric_handler_requests_total表明了当前指标的名称</li><li>大括号中的标签则反映了当前样本的一些特征和维度</li><li>浮点数则是该监控样本的具体值。</li></ul></li></ul><h2 id="TSDB存储工作方式"><a href="#TSDB存储工作方式" class="headerlink" title="TSDB存储工作方式"></a>TSDB存储工作方式</h2><p>每次采集到的数据都会被Prometheus以time-series（时间序列）的方式保存到内存中，定期刷新到硬盘。如下所示，可以将time-series理解为一个以时间为X轴的数字矩阵：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">│   . . . . . . . . . . . . . . . . .   . .   node_cpu&#123;cpu=<span class="string">&quot;cpu0&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125;</span><br><span class="line">│     . . . . . . . . . . . . . . . . . . .   node_cpu&#123;cpu=<span class="string">&quot;cpu0&quot;</span>,mode=<span class="string">&quot;system&quot;</span>&#125;</span><br><span class="line">│     . . . . . . . . . .   . . . . . . . .   node_load1&#123;&#125;</span><br><span class="line">│     . . . . . . . . . . . . . . . .   . .  </span><br><span class="line">v</span><br><span class="line">  &lt;------------------ 时间 ----------------&gt;</span><br></pre></td></tr></table></figure><p>在time-series中的每一个点称为一个样本（sample），样本由以下三部分组成：</p><ul><li>指标(metric)：metric name和描述当前样本特征的labelsets;</li><li>时间戳(timestamp)：一个精确到毫秒的时间戳;</li><li>样本值(value)： 一个float64的浮点型数据表示当前样本的值。</li></ul><h2 id="TSDB数据格式"><a href="#TSDB数据格式" class="headerlink" title="TSDB数据格式"></a>TSDB数据格式</h2><p>在形式上，所有的指标(Metric)都通过如下格式标示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</span><br></pre></td></tr></table></figure><ul><li>指标的名称(metric name)可以反映被监控样本的含义（比如，<code>http_request_total</code> - 表示当前系统接收到的HTTP请求总量）。</li><li>标签(label)反映了当前样本的特征维度，通过这些维度Prometheus可以对样本数据进行过滤，聚合等。</li></ul><h2 id="TSDB数据更新"><a href="#TSDB数据更新" class="headerlink" title="TSDB数据更新"></a>TSDB数据更新</h2><p>Prometheus会定期去targets列表拉取监控数据，存储到TSDB中，并且提供指标查询、分析的语句和接口。这样我们就能获取到比较全面的监控数据，进行分析、报警等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s helm</title>
      <link href="/k8s-helm/"/>
      <url>/k8s-helm/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>helm 是 k8s 的包管理工具，类似于 yum&#x2F;apt&#x2F;homebrew。</p><span id="more"></span><h1 id="Helm的安装和使用"><a href="#Helm的安装和使用" class="headerlink" title="Helm的安装和使用"></a>Helm的安装和使用</h1><h2 id="认识Helm"><a href="#认识Helm" class="headerlink" title="认识Helm"></a>认识Helm</h2><p>Helm的重要概念有以下几个：</p><ul><li>chart，应用的信息集合，包括各种对象的配置模板、参数定义、依赖关系、文档说明等</li><li>Repository，chart仓库，存储chart的地方，并且提供了一个该 Repository 的 Chart 包的清单文件以供查询。Helm 可以同时管理多个不同的 Repository。</li><li>release， 当 chart 被安装到 kubernetes 集群，就生成了一个 release ， 是 chart 的运行实例，代表了一个正在运行的应用</li></ul><p>helm 是包管理工具，包就是指 chart，helm 能够：</p><ul><li>从零创建chart</li><li>与仓库交互，拉取、保存、更新 chart</li><li>在kubernetes集群中安装、卸载 release</li><li>更新、回滚、测试 release</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载最新的稳定版本：<code>https://get.helm.sh/helm-v3.2.4-linux-amd64.tar.gz</code></p><blockquote><p>helm的版本兼容性可以<a href="https://helm.sh/docs/topics/version_skew/">查看这里</a>，中文版<a href="https://helm.sh/zh/docs/topics/version_skew/">查看这里</a></p><p>最新安装方式<a href="https://helm.sh/docs/intro/install/">查看这里</a>，中文版<a href="https://helm.sh/zh/docs/intro/install/">查看这里</a>，release版本可以通过github进行查找<a href="https://github.com/helm/helm/releases">查看这里</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># k8s-master节点</span></span><br><span class="line">$ wget https://get.helm.sh/helm-v3.13.3-linux-amd64.tar.gz</span><br><span class="line">$ tar -zxf helm-v3.13.3-linux-amd64.tar.gz</span><br><span class="line">$ sudo <span class="built_in">cp</span> linux-amd64/helm /usr/sbin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">$ helm version</span><br><span class="line">version.BuildInfo&#123;Version:<span class="string">&quot;v3.13.3&quot;</span>, GitCommit:<span class="string">&quot;c8b948945e52abba22ff885446a1486cb5fd3474&quot;</span>, GitTreeState:<span class="string">&quot;clean&quot;</span>, GoVersion:<span class="string">&quot;go1.20.11&quot;</span>&#125;</span><br><span class="line">$ helm <span class="built_in">env</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看仓库</span></span><br><span class="line">$ helm repo <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 添加仓库</span></span><br><span class="line">$ helm repo add stable https://charts.bitnami.com/bitnami</span><br><span class="line"><span class="comment"># 同步最新charts信息到本地</span></span><br><span class="line">$ helm repo update</span><br></pre></td></tr></table></figure><h2 id="入门实践1：使用helm安装wordpress应用"><a href="#入门实践1：使用helm安装wordpress应用" class="headerlink" title="入门实践1：使用helm安装wordpress应用"></a>入门实践1：使用helm安装wordpress应用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># helm 搜索chart包</span></span><br><span class="line">$ helm search repo wordpress</span><br><span class="line">NAME                    CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line">stable/wordpress        18.1.15         6.4.1           WordPress is the world<span class="string">&#x27;s most popular blogging ...</span></span><br><span class="line"><span class="string">stable/wordpress-intel  2.1.31          6.1.1           DEPRECATED WordPress for Intel is the most popu...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ kubectl create namespace wordpress</span></span><br><span class="line"><span class="string"># 从仓库安装</span></span><br><span class="line"><span class="string">$ helm -n wordpress install wordpress stable/wordpress --set mariadb.primary.persistence.enabled=false --set service.type=ClusterIP --set ingress.enabled=true --set persistence.enabled=false --set ingress.hostname=wordpress.test.com</span></span><br><span class="line"><span class="string">NAME: wordpress</span></span><br><span class="line"><span class="string">LAST DEPLOYED: Sat Nov 25 00:39:08 2023</span></span><br><span class="line"><span class="string">NAMESPACE: wordpress</span></span><br><span class="line"><span class="string">STATUS: deployed</span></span><br><span class="line"><span class="string">REVISION: 1</span></span><br><span class="line"><span class="string">TEST SUITE: None</span></span><br><span class="line"><span class="string">NOTES:</span></span><br><span class="line"><span class="string">CHART NAME: wordpress</span></span><br><span class="line"><span class="string">CHART VERSION: 18.1.15</span></span><br><span class="line"><span class="string">APP VERSION: 6.4.1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">** Please be patient while the chart is being deployed **</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Your WordPress site can be accessed through the following DNS name from within your cluster:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    wordpress.wordpress.svc.cluster.local (port 80)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To access your WordPress site from outside the cluster follow the steps below:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. Get the WordPress URL and associate WordPress hostname to your cluster external IP:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   export CLUSTER_IP=$(minikube ip) # On Minikube. Use: `kubectl cluster-info` on others K8s clusters</span></span><br><span class="line"><span class="string">   echo &quot;WordPress URL: http://wordpress.test.com/&quot;</span></span><br><span class="line"><span class="string">   echo &quot;$CLUSTER_IP  wordpress.test.com&quot; | sudo tee -a /etc/hosts</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. Open a browser and access WordPress using the obtained URL.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. Login with the following credentials below to see your blog:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  echo Username: user</span></span><br><span class="line"><span class="string">  echo Password: $(kubectl get secret --namespace wordpress wordpress -o jsonpath=&quot;&#123;.data.wordpress-password&#125;&quot; | base64 -d)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看release</span></span><br><span class="line"><span class="string">$ helm -n wordpress ls</span></span><br><span class="line"><span class="string">NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION</span></span><br><span class="line"><span class="string">wordpress       wordpress       1               2023-11-25 00:39:08.988234268 +0800 CST deployed        wordpress-18.1.15       6.4.1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看k8s中的资源</span></span><br><span class="line"><span class="string">$ kubectl -n wordpress get all</span></span><br><span class="line"><span class="string">NAME                             READY   STATUS    RESTARTS   AGE</span></span><br><span class="line"><span class="string">pod/wordpress-6c64d789df-hvpfl   1/1     Running   0          8m2s</span></span><br><span class="line"><span class="string">pod/wordpress-mariadb-0          1/1     Running   0          8m2s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span></span><br><span class="line"><span class="string">service/wordpress           ClusterIP   10.98.202.134   &lt;none&gt;        80/TCP,443/TCP   8m3s</span></span><br><span class="line"><span class="string">service/wordpress-mariadb   ClusterIP   10.96.212.179   &lt;none&gt;        3306/TCP         8m3s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME                        READY   UP-TO-DATE   AVAILABLE   AGE</span></span><br><span class="line"><span class="string">deployment.apps/wordpress   1/1     1            1           8m2s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME                                   DESIRED   CURRENT   READY   AGE</span></span><br><span class="line"><span class="string">replicaset.apps/wordpress-6c64d789df   1         1         1       8m2s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME                                 READY   AGE</span></span><br><span class="line"><span class="string">statefulset.apps/wordpress-mariadb   1/1     8m2s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># chart不适配k8s的ingress，需要添加上ingressClassName: nginx</span></span><br><span class="line"><span class="string">$ kubectl -n wordpress edit ing wordpress</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  ingressClassName: nginx</span></span><br><span class="line"><span class="string">  rules:</span></span><br><span class="line"><span class="string">  - host: wordpress.test.com</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 从chart仓库中把chart包下载到本地</span></span><br><span class="line"><span class="string">$ helm pull stable/wordpress</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 卸载</span></span><br><span class="line"><span class="string">$ helm -n wordpress uninstall wordpress</span></span><br></pre></td></tr></table></figure><h2 id="入门实践2：新建nginx的chart并安装"><a href="#入门实践2：新建nginx的chart并安装" class="headerlink" title="入门实践2：新建nginx的chart并安装"></a>入门实践2：新建nginx的chart并安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ helm create nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地安装到别的命名空间demo</span></span><br><span class="line">$ kubectl create namespace demo</span><br><span class="line">$ helm -n demo install nginx ./nginx --<span class="built_in">set</span> replicaCount=2 --<span class="built_in">set</span> image.tag=alpine</span><br><span class="line">NAME: nginx</span><br><span class="line">LAST DEPLOYED: Sat Nov 25 00:53:52 2023</span><br><span class="line">NAMESPACE: demo</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">NOTES:</span><br><span class="line">1. Get the application URL by running these commands:</span><br><span class="line">  <span class="built_in">export</span> POD_NAME=$(kubectl get pods --namespace demo -l <span class="string">&quot;app.kubernetes.io/name=nginx,app.kubernetes.io/instance=nginx&quot;</span> -o jsonpath=<span class="string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Visit http://127.0.0.1:8080 to use your application&quot;</span></span><br><span class="line">  kubectl --namespace demo port-forward <span class="variable">$POD_NAME</span> 8080:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">$ helm -n demo <span class="built_in">ls</span></span><br><span class="line">$ kubectl -n demo get all</span><br></pre></td></tr></table></figure><h1 id="Chart的模板语法及开发"><a href="#Chart的模板语法及开发" class="headerlink" title="Chart的模板语法及开发"></a>Chart的模板语法及开发</h1><p>接下来我们分析一下nginx的chart实现分析，然后总结出chart的开发规范。</p><h2 id="Chart的目录结构"><a href="#Chart的目录结构" class="headerlink" title="Chart的目录结构"></a>Chart的目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ tree nginx/</span><br><span class="line">nginx/</span><br><span class="line">├── charts<span class="comment"># 存放子chart</span></span><br><span class="line">├── Chart.yaml<span class="comment"># 该chart的全局定义信息</span></span><br><span class="line">├── templates<span class="comment"># chart运行所需的资源清单模板，用于和values做渲染</span></span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── _helpers.tpl<span class="comment"># 定义全局的命名模板，方便在其他模板中引入使用</span></span><br><span class="line">│   ├── hpa.yaml</span><br><span class="line">│   ├── ingress.yaml</span><br><span class="line">│   ├── NOTES.txt<span class="comment"># helm安装完成后终端的提示信息</span></span><br><span class="line">│   ├── serviceaccount.yaml</span><br><span class="line">│   ├── service.yaml</span><br><span class="line">│   └── tests</span><br><span class="line">│       └── test-connection.yaml</span><br><span class="line">└── values.yaml<span class="comment"># 模板使用的默认值信息</span></span><br></pre></td></tr></table></figure><p>很明显，资源清单都在templates中，数据来源于values.yaml，安装的过程就是将模板与数据融合成k8s可识别的资源清单，然后部署到k8s环境中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看模板渲染后的资源清单</span></span><br><span class="line"><span class="comment"># --dry-run：不真正安装，只是渲染模板</span></span><br><span class="line"><span class="comment"># --debug：打印渲染后的资源清单</span></span><br><span class="line">$ helm install debug-nginx ./nginx --dry-run --<span class="built_in">set</span> replicaCount=2 --debug</span><br></pre></td></tr></table></figure><h2 id="分析模板文件的实现"><a href="#分析模板文件的实现" class="headerlink" title="分析模板文件的实现"></a>分析模板文件的实现</h2><h3 id="引用命名模板并传递作用域"><a href="#引用命名模板并传递作用域" class="headerlink" title="引用命名模板并传递作用域"></a>引用命名模板并传递作用域</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; include <span class="string">&quot;nginx.fullname&quot;</span> . &#125;&#125;</span><br></pre></td></tr></table></figure><p>include从_helpers.tpl中引用命名模板，并传递顶级作用域.</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.Values</span><br><span class="line">.Release.Name</span><br><span class="line">.Chart</span><br></pre></td></tr></table></figure><ul><li><code>Release</code>：该对象描述了 release 本身的相关信息，它内部有几个对象：<ul><li><code>Release.Name</code>：release 名称</li><li><code>Release.Namespace</code>：release 安装到的命名空间</li><li><code>Release.IsUpgrade</code>：如果当前操作是升级或回滚，则该值为 true</li><li><code>Release.IsInstall</code>：如果当前操作是安装，则将其设置为 true</li><li><code>Release.Revision</code>：release 的 revision 版本号，在安装的时候，值为1，每次升级或回滚都会增加</li><li><code>Release.Service</code>：渲染当前模板的服务，在 Helm 上，实际上该值始终为 Helm</li></ul></li><li><code>Values</code>：从 <code>values.yaml</code> 文件和用户提供的 values 文件传递到模板的 Values 值</li><li><code>Chart</code>：获取 <code>Chart.yaml</code> 文件的内容，该文件中的任何数据都可以访问，例如 <code>&#123;&#123; .Chart.Name &#125;&#125;-&#123;&#123; .Chart.Version&#125;&#125;</code> 可以渲染成 <code>mychart-0.1.0</code></li></ul><h3 id="模板定义"><a href="#模板定义" class="headerlink" title="模板定义"></a>模板定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define <span class="string">&quot;nginx.fullname&quot;</span> -&#125;&#125;</span><br><span class="line">&#123;&#123;- <span class="keyword">if</span> .Values.fullnameOverride &#125;&#125;</span><br><span class="line">&#123;&#123;- .Values.fullnameOverride | trunc <span class="number">63</span> | trimSuffix <span class="string">&quot;-&quot;</span> &#125;&#125;</span><br><span class="line">&#123;&#123;- <span class="keyword">else</span> &#125;&#125;</span><br><span class="line">&#123;&#123;- $name := <span class="keyword">default</span> .Chart.Name .Values.nameOverride &#125;&#125;</span><br><span class="line">&#123;&#123;- <span class="keyword">if</span> contains $name .Release.Name &#125;&#125;</span><br><span class="line">&#123;&#123;- .Release.Name | trunc <span class="number">63</span> | trimSuffix <span class="string">&quot;-&quot;</span> &#125;&#125;</span><br><span class="line">&#123;&#123;- <span class="keyword">else</span> &#125;&#125;</span><br><span class="line">&#123;&#123;- printf <span class="string">&quot;%s-%s&quot;</span> .Release.Name $name | trunc <span class="number">63</span> | trimSuffix <span class="string">&quot;-&quot;</span> &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">data:</span><br><span class="line">myvalue: &quot;Hello World&quot;</span><br><span class="line">drink: &#123;&#123; .Values.favorite.drink | default &quot;tea&quot; | quote &#125;&#125;</span><br><span class="line">food: &#123;&#123; .Values.favorite.food | upper | quote &#125;&#125;</span><br><span class="line">&#123;&#123; if eq .Values.favorite.drink &quot;coffee&quot; &#125;&#125;</span><br><span class="line">mug: true</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>渲染完后是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">mychart-1575971172-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">myvalue:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="attr">drink:</span> <span class="string">&quot;coffee&quot;</span></span><br><span class="line"><span class="attr">food:</span> <span class="string">&quot;PIZZA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mug:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="去掉空格"><a href="#去掉空格" class="headerlink" title="去掉空格"></a>去掉空格</h3><ul><li><code>&#123;&#123;- &#125;&#125;</code>  去掉左边的空格及换行</li><li><code>&#123;&#123; -&#125;&#125; </code>  去掉右侧的空格及换行</li></ul><h3 id="管道及方法"><a href="#管道及方法" class="headerlink" title="管道及方法"></a>管道及方法</h3><ol><li><p>trunc表示字符串截取，63作为参数传递给trunc方法，trimSuffix表示去掉<code>-</code>后缀</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- .Values.fullnameOverride | trunc <span class="number">63</span> | trimSuffix <span class="string">&quot;-&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>nindent表示前面的空格数</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selector:</span><br><span class="line">  matchLabels:</span><br><span class="line">    &#123;&#123;- include <span class="string">&quot;nginx.selectorLabels&quot;</span> . | nindent <span class="number">6</span> &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>lower表示将内容小写，quote表示用双引号引起来</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value: &#123;&#123; include <span class="string">&quot;mytpl&quot;</span> . | lower | quote &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件判断语句每个if对应一个end</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- <span class="keyword">if</span> .Values.fullnameOverride &#125;&#125;</span><br><span class="line">...</span><br><span class="line">&#123;&#123;- <span class="keyword">else</span> &#125;&#125;</span><br><span class="line">...</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p> 通常用来根据values.yaml中定义的开关来控制模板中的显示：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- <span class="keyword">if</span> not .Values.autoscaling.enabled &#125;&#125;</span><br><span class="line">replicas: &#123;&#123; .Values.replicaCount &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义变量，模板中可以通过变量名字去引用</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- $name := <span class="keyword">default</span> .Chart.Name .Values.nameOverride &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历values的数据</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- with .Values.nodeSelector &#125;&#125;</span><br><span class="line">nodeSelector:</span><br><span class="line">  &#123;&#123;- toYaml . | nindent <span class="number">8</span> &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p> toYaml处理值中的转义及特殊字符， “kubernetes.io&#x2F;role”&#x3D;master ， name&#x3D;”value1,value2” 类似的情况</p></li><li><p>default设置默认值</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: <span class="string">&quot;&#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag | default .Chart.AppVersion &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>更多语法参考：</p><p><a href="https://helm.sh/docs/topics/charts/">https://helm.sh/docs/topics/charts/</a></p><h1 id="Helm-使用"><a href="#Helm-使用" class="headerlink" title="Helm 使用"></a>Helm 使用</h1><h2 id="Helm-template"><a href="#Helm-template" class="headerlink" title="Helm template"></a>Helm template</h2><p>hpa.yaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- if .Values.autoscaling.enabled &#125;&#125;</span><br><span class="line">apiVersion: autoscaling/v2beta1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;nginx.fullname&quot; . &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- include &quot;nginx.labels&quot; . | nindent 4 &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: &#123;&#123; include &quot;nginx.fullname&quot; . &#125;&#125;</span><br><span class="line">  minReplicas: &#123;&#123; .Values.autoscaling.minReplicas &#125;&#125;</span><br><span class="line">  maxReplicas: &#123;&#123; .Values.autoscaling.maxReplicas &#125;&#125;</span><br><span class="line">  metrics:</span><br><span class="line">  &#123;&#123;- if .Values.autoscaling.targetCPUUtilizationPercentage &#125;&#125;</span><br><span class="line">    - type: Resource</span><br><span class="line">      resource:</span><br><span class="line">        name: cpu</span><br><span class="line">        targetAverageUtilization: &#123;&#123; .Values.autoscaling.targetCPUUtilizationPercentage &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br><span class="line">  &#123;&#123;- if .Values.autoscaling.targetMemoryUtilizationPercentage &#125;&#125;</span><br><span class="line">    - type: Resource</span><br><span class="line">      resource:</span><br><span class="line">        name: memory</span><br><span class="line">        targetAverageUtilization: &#123;&#123; .Values.autoscaling.targetMemoryUtilizationPercentage &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h2><p>创建Release的时候赋值</p><ul><li><p>set的方式</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改变副本数和resource值</span></span><br><span class="line">$ helm install nginx-2 ./nginx --<span class="built_in">set</span> replicaCount=2 --<span class="built_in">set</span> resources.limits.cpu=200m --<span class="built_in">set</span> resources.limits.memory=256Mi</span><br></pre></td></tr></table></figure></li><li><p>value文件的方式</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> nginx-values.yaml</span><br><span class="line">resources:</span><br><span class="line">limits:</span><br><span class="line">  cpu: 100m</span><br><span class="line">  memory: 128Mi</span><br><span class="line">requests:</span><br><span class="line">  cpu: 100m</span><br><span class="line">  memory: 128Mi</span><br><span class="line">autoscaling:</span><br><span class="line">enabled: <span class="literal">true</span></span><br><span class="line">minReplicas: 1</span><br><span class="line">maxReplicas: 3</span><br><span class="line">targetCPUUtilizationPercentage: 80</span><br><span class="line">ingress:</span><br><span class="line">enabled: <span class="literal">true</span></span><br><span class="line">hosts:</span><br><span class="line">  - host: chart-example.test.com</span><br><span class="line">    paths:</span><br><span class="line">    - /</span><br><span class="line"></span><br><span class="line">$ helm install -f nginx-values.yaml nginx-3 ./nginx</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看渲染后的资源清单"><a href="#查看渲染后的资源清单" class="headerlink" title="查看渲染后的资源清单"></a>查看渲染后的资源清单</h2><p>使用helm template查看渲染模板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm -n <span class="built_in">test</span> template nginx ./nginx --<span class="built_in">set</span> replicaCount=2 --<span class="built_in">set</span> image.tag=alpine --<span class="built_in">set</span> autoscaling.enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="实战：使用Helm部署Harbor镜像及chart仓库"><a href="#实战：使用Helm部署Harbor镜像及chart仓库" class="headerlink" title="实战：使用Helm部署Harbor镜像及chart仓库"></a>实战：使用Helm部署Harbor镜像及chart仓库</h1><h2 id="harbor架构"><a href="#harbor架构" class="headerlink" title="harbor架构"></a>harbor架构</h2><p>架构 <a href="https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor">https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor</a></p><p><img src="/post/docker/harbor-architecture.png" alt="harbor-architecture"></p><ul><li>Core，核心组件<ul><li>API Server，接收处理用户请求</li><li>Config Manager ：所有系统的配置，比如认证、邮件、证书配置等</li><li>Project Manager：项目管理</li><li>Quota Manager ：配额管理</li><li>Chart Controller：chart管理</li><li>Replication Controller ：镜像副本控制器，可以与不同类型的仓库实现镜像同步<ul><li>Distribution (docker registry)</li><li>Docker Hub</li><li>…</li></ul></li><li>Scan Manager ：扫描管理，引入第三方组件，进行镜像安全扫描</li><li>Registry Driver ：镜像仓库驱动，目前使用docker registry</li></ul></li><li>Job Service，执行异步任务，如同步镜像信息</li><li>Log Collector，统一日志收集器，收集各模块日志</li><li>GC Controller</li><li>Chart Museum，chart仓库服务，第三方</li><li>Docker Registry，镜像仓库服务</li><li>kv-storage，redis缓存服务，job service使用，存储job metadata</li><li>local&#x2F;remote storage，存储服务，比较镜像存储</li><li>SQL Database，postgresl，存储用户、项目等元数据</li></ul><p>通常用作企业级镜像仓库服务，实际功能强大很多。</p><p>组件众多，因此使用helm部署</p><h2 id="准备repo"><a href="#准备repo" class="headerlink" title="准备repo"></a>准备repo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加harbor chart仓库</span></span><br><span class="line">$ helm repo add harbor https://helm.goharbor.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索harbor的chart</span></span><br><span class="line">$ helm search repo harbor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不知道如何部署，因此拉到本地</span></span><br><span class="line">$ helm pull harbor/harbor</span><br></pre></td></tr></table></figure><h2 id="创建pvc"><a href="#创建pvc" class="headerlink" title="创建pvc"></a>创建pvc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create namespace harbor</span><br><span class="line">$ <span class="built_in">cat</span> harbor-pvc.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: harbor-data</span><br><span class="line">  namespace: harbor</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 20Gi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建pvc</span></span><br><span class="line">kubectl create -f harbor-pvc.yaml</span><br></pre></td></tr></table></figure><h2 id="修改helm配置"><a href="#修改helm配置" class="headerlink" title="修改helm配置"></a>修改helm配置</h2><p>修改harbor配置：</p><ul><li><p>ingress访问的配置（36行和46行）</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">core:</span> <span class="string">core.harbor.domain</span></span><br><span class="line">    <span class="attr">notary:</span> <span class="string">notary.harbor.domain</span></span><br><span class="line">  <span class="comment"># set to the type of ingress controller if it has specific requirements.</span></span><br><span class="line">  <span class="comment"># leave as `default` for most ingress controllers.</span></span><br><span class="line">  <span class="comment"># set to `gce` if using the GCE ingress controller</span></span><br><span class="line">  <span class="comment"># set to `ncp` if using the NCP (NSX-T Container Plugin) ingress controller</span></span><br><span class="line">  <span class="comment"># set to `alb` if using the ALB ingress controller</span></span><br><span class="line">  <span class="attr">controller:</span> <span class="string">default</span></span><br><span class="line">  <span class="comment">## Allow .Capabilities.KubeVersion.Version to be overridden while creating ingress</span></span><br><span class="line">  <span class="attr">kubeVersionOverride:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">&quot;nginx&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>externalURL，web访问入口，和ingress的域名相同（126行）</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">126 externalURL:</span> <span class="string">https://harbor.test.com</span></span><br></pre></td></tr></table></figure></li><li><p>持久化，使用PVC对接的nfs（215，220，225，227，249，251，258，260）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">204 persistence:</span><br><span class="line">205   enabled: true</span><br><span class="line">206   # Setting it to &quot;keep&quot; to avoid removing PVCs during a helm delete</span><br><span class="line">207   # operation. Leaving it empty will delete PVCs after the chart deleted</span><br><span class="line">208   # (this does not apply for PVCs that are created for internal database</span><br><span class="line">209   # and redis components, i.e. they are never deleted automatically)</span><br><span class="line">210   resourcePolicy: &quot;keep&quot;</span><br><span class="line">211   persistentVolumeClaim:</span><br><span class="line">212     registry:</span><br><span class="line">213       # Use the existing PVC which must be created manually before bound,</span><br><span class="line">214       # and specify the &quot;subPath&quot; if the PVC is shared with other components</span><br><span class="line">215       existingClaim: &quot;harbor-data&quot;</span><br><span class="line">216       # Specify the &quot;storageClass&quot; used to provision the volume. Or the default</span><br><span class="line">217       # StorageClass will be used (the default).</span><br><span class="line">218       # Set it to &quot;-&quot; to disable dynamic provisioning</span><br><span class="line">219       storageClass: &quot;&quot;</span><br><span class="line">220       subPath: &quot;registry&quot;</span><br><span class="line">221       accessMode: ReadWriteOnce</span><br><span class="line">222       size: 5Gi</span><br><span class="line">223       annotations: &#123;&#125;</span><br><span class="line">224     chartmuseum:</span><br><span class="line">225       existingClaim: &quot;harbor-data&quot;</span><br><span class="line">226       storageClass: &quot;&quot;</span><br><span class="line">227       subPath: &quot;chartmuseum&quot;</span><br><span class="line">228       accessMode: ReadWriteOnce</span><br><span class="line">229       size: 5Gi</span><br><span class="line">230       annotations: &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">246     # If external database is used, the following settings for database will</span><br><span class="line">247     # be ignored</span><br><span class="line">248     database:</span><br><span class="line">249       existingClaim: &quot;harbor-data&quot;</span><br><span class="line">250       storageClass: &quot;&quot;</span><br><span class="line">251       subPath: &quot;database&quot;</span><br><span class="line">252       accessMode: ReadWriteOnce</span><br><span class="line">253       size: 1Gi</span><br><span class="line">254       annotations: &#123;&#125;</span><br><span class="line">255     # If external Redis is used, the following settings for Redis will</span><br><span class="line">256     # be ignored</span><br><span class="line">257     redis:</span><br><span class="line">258       existingClaim: &quot;harbor-data&quot;</span><br><span class="line">259       storageClass: &quot;&quot;</span><br><span class="line">260       subPath: &quot;redis&quot;</span><br><span class="line">261       accessMode: ReadWriteOnce</span><br><span class="line">262       size: 1Gi</span><br><span class="line">263       annotations: &#123;&#125;</span><br><span class="line">264     trivy:</span><br><span class="line">265       existingClaim: &quot;harbor-data&quot;</span><br><span class="line">266       storageClass: &quot;&quot;</span><br><span class="line">267       subPath: &quot;trivy&quot;</span><br><span class="line">268       accessMode: ReadWriteOnce</span><br><span class="line">269       size: 5Gi</span><br><span class="line">270       annotations: &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>管理员账户密码（382行）</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">382 harborAdminPassword:</span> <span class="string">&quot;Harbor12345!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>trivy、notary漏洞扫描组件，暂不启用（639，711行）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">637 trivy:</span><br><span class="line">638   # enabled the flag to enable Trivy scanner</span><br><span class="line">639   enabled: false</span><br><span class="line">640   image:</span><br><span class="line">641     # repository the repository for Trivy adapter image</span><br><span class="line">642     repository: goharbor/trivy-adapter-photon</span><br><span class="line">643     # tag the tag for Trivy adapter image</span><br><span class="line">644     tag: v2.6.2</span><br><span class="line"></span><br><span class="line">710 notary:</span><br><span class="line">711   enabled: false</span><br><span class="line">712   server:</span><br><span class="line">713     # set the service account to be used, default if left empty</span><br><span class="line">714     serviceAccountName: &quot;&quot;</span><br><span class="line">715     # mount the service account token</span><br><span class="line">716     automountServiceAccountToken: false</span><br></pre></td></tr></table></figure></li></ul><h2 id="helm创建"><a href="#helm创建" class="headerlink" title="helm创建"></a>helm创建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用本地chart安装</span></span><br><span class="line">$ helm -n harbor install harbor ./harbor</span><br></pre></td></tr></table></figure><h2 id="推送镜像到Harbor仓库"><a href="#推送镜像到Harbor仓库" class="headerlink" title="推送镜像到Harbor仓库"></a>推送镜像到Harbor仓库</h2><p>配置hosts及docker非安全仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/hosts</span><br><span class="line">...</span><br><span class="line">172.21.65.226 k8s-master harbor.test.com</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;registry.access.redhat.com&quot;</span>,<span class="string">&quot;quay.io&quot;</span>,<span class="string">&quot;harbor.test.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line">                       </span><br><span class="line"><span class="comment"># 重启docker,使配置生效</span></span><br><span class="line">$ systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用账户密码登录admin/Harbor12345</span></span><br><span class="line">$ docker login harbor.test.com</span><br><span class="line"></span><br><span class="line">$ docker tag nginx:alpine harbor.test.com/library/nginx:alpine</span><br><span class="line">$ docker push harbor.test.com/library/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># containerd使用harbor.test.com</span></span><br><span class="line">$ <span class="built_in">mkdir</span> -p /etc/containerd/certs.d/harbor.test.com</span><br><span class="line">$ <span class="built_in">cat</span> /etc/containerd/certs.d/harbor.test.com/hosts.toml</span><br><span class="line">server = <span class="string">&quot;https://harbor.test.com&quot;</span></span><br><span class="line">[host.<span class="string">&quot;https://harbor.test.com&quot;</span>]</span><br><span class="line">  capabilities = [<span class="string">&quot;pull&quot;</span>, <span class="string">&quot;resolve&quot;</span>, <span class="string">&quot;push&quot;</span>]</span><br><span class="line">  skip_verify = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速启动服务验证</span></span><br><span class="line">$ kubectl create deployment <span class="built_in">test</span> --image=harbor.test.com/library/nginx:alpine</span><br></pre></td></tr></table></figure><h2 id="推送chart到Harbor仓库"><a href="#推送chart到Harbor仓库" class="headerlink" title="推送chart到Harbor仓库"></a>推送chart到Harbor仓库</h2><p>helm3默认没有安装helm push插件，需要手动安装。插件地址 <a href="https://github.com/chartmuseum/helm-push">https://github.com/chartmuseum/helm-push</a></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>在线安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm plugin install https://github.com/chartmuseum/helm-push</span><br></pre></td></tr></table></figure><p>离线安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> helm-push</span><br><span class="line">$ wget https://github.com/chartmuseum/helm-push/releases/download/v0.8.1/helm-push_0.8.1_linux_amd64.tar.gz</span><br><span class="line">$ tar zxf helm-push_0.8.1_linux_amd64.tar.gz -C helm-push</span><br><span class="line">$ helm plugin install ./helm-push</span><br></pre></td></tr></table></figure><h3 id="添加repo"><a href="#添加repo" class="headerlink" title="添加repo"></a>添加repo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add myharbor https://harbor.test.com/chartrepo/test</span><br><span class="line"><span class="comment"># x509错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加证书信任，根证书为配置给ingress使用的证书</span></span><br><span class="line">$ kubectl get secret harbor-ingress -n harbor -o jsonpath=<span class="string">&quot;&#123;.data.ca\.crt&#125;&quot;</span> | <span class="built_in">base64</span> -d &gt;harbor.ca.crt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cp</span> harbor.ca.crt /etc/pki/ca-trust/source/anchors</span><br><span class="line">$ update-ca-trust <span class="built_in">enable</span>; update-ca-trust extract</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次添加</span></span><br><span class="line">$ helm repo add <span class="built_in">test</span> https://harbor.test.com/chartrepo/test --ca-file=harbor.ca.crt  --username admin --password Harbor12345!</span><br><span class="line"></span><br><span class="line">$ helm repo <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="推送chart到仓库："><a href="#推送chart到仓库：" class="headerlink" title="推送chart到仓库："></a>推送chart到仓库：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm push harbor <span class="built_in">test</span> --ca-file=harbor.ca.crt -u admin -p Harbor12345!</span><br></pre></td></tr></table></figure><h1 id="实战：使用Helm部署NFS-StorageClass"><a href="#实战：使用Helm部署NFS-StorageClass" class="headerlink" title="实战：使用Helm部署NFS StorageClass"></a>实战：使用Helm部署NFS StorageClass</h1><h2 id="准备repo-1"><a href="#准备repo-1" class="headerlink" title="准备repo"></a>准备repo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加nfs-subdir-external-provisioner chart仓库</span></span><br><span class="line">$ helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索nfs-subdir-external-provisioner的chart</span></span><br><span class="line">$ helm search repo nfs-subdir-external-provisioner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉到本地，目前我看到最新版本是4.0.18，我们就使用指定版本的方式安装</span></span><br><span class="line">$ helm pull nfs-subdir-external-provisioner/nfs-subdir-external-provisioner --version 4.0.18</span><br></pre></td></tr></table></figure><h2 id="修改helm配置-1"><a href="#修改helm配置-1" class="headerlink" title="修改helm配置"></a>修改helm配置</h2><p>这里我们之前创建了nfs服务器，服务器地址是<code>192.168.100.1</code>，共享目录是<code>/</code>，因此我们修改对应的配置即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tar xf nfs-subdir-external-provisioner-4.0.18.tgz</span><br><span class="line">$ <span class="built_in">cd</span> nfs-subdir-external-provisioner</span><br><span class="line"></span><br><span class="line">$ vim values.yaml</span><br><span class="line">...</span><br><span class="line">image:</span><br><span class="line">  <span class="comment"># 如果不放心镜像的下载可以修改仓库地址</span></span><br><span class="line">  repository: willdockerhub/nfs-subdir-external-provisioner</span><br><span class="line">...</span><br><span class="line">nfs:</span><br><span class="line">  server: 192.168.100.1</span><br><span class="line">  path: /</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="helm创建-1"><a href="#helm创建-1" class="headerlink" title="helm创建"></a>helm创建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建命名空间</span></span><br><span class="line">$ kubectl create namespace nfs-subdir-external-provisioner</span><br><span class="line"><span class="comment"># 使用本地chart安装，因为我进入了nfs-subdir-external-provisioner目录，所以直接使用.表示当前目录</span></span><br><span class="line">$ helm -n nfs-subdir-external-provisioner install nfs-subdir-external-provisioner .</span><br></pre></td></tr></table></figure><h2 id="确认StorageClass"><a href="#确认StorageClass" class="headerlink" title="确认StorageClass"></a>确认StorageClass</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看pod运行情况</span></span><br><span class="line">$ kubectl -n nfs-subdir-external-provisioner get pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看StorageClass</span></span><br><span class="line">$ kubectl get sc</span><br></pre></td></tr></table></figure><h1 id="实战：使用Helm部署Ingress-Controller"><a href="#实战：使用Helm部署Ingress-Controller" class="headerlink" title="实战：使用Helm部署Ingress Controller"></a>实战：使用Helm部署Ingress Controller</h1><h2 id="准备repo-2"><a href="#准备repo-2" class="headerlink" title="准备repo"></a>准备repo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加ingress-nginx chart仓库</span></span><br><span class="line">$ helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索ingress-nginx的chart</span></span><br><span class="line">$ helm search repo ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉到本地，目前我看到最新版本是4.8.3</span></span><br><span class="line">$ helm pull ingress-nginx/ingress-nginx</span><br></pre></td></tr></table></figure><h2 id="修改helm配置-2"><a href="#修改helm配置-2" class="headerlink" title="修改helm配置"></a>修改helm配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ tar xf ingress-nginx-4.8.3.tgz</span><br><span class="line">$ vim ingress-nginx/values.yaml</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">controller:</span><br><span class="line">  <span class="comment"># 之前使用的是hostNetwork方式，这里我们使用hostPort方式</span></span><br><span class="line">  hostPort:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment"># 做集群负载均衡需要将所有的节点都部署上ingress-controller，可以使用daemonset方式部署</span></span><br><span class="line">  kind: DaemonSet</span><br><span class="line">...</span><br><span class="line">  nodeSelector:</span><br><span class="line">    kubernetes.io/os: linux</span><br><span class="line">    <span class="comment"># 这里我们多加一个标签，控制在哪些节点上部署ingress-controller</span></span><br><span class="line">    ingress: <span class="string">&quot;true&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="helm创建-2"><a href="#helm创建-2" class="headerlink" title="helm创建"></a>helm创建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给节点打标签，所有想要部署ingress-controller的节点都需要打上该标签</span></span><br><span class="line">$ kubectl label node k8s-master ingress=<span class="literal">true</span></span><br><span class="line">$ kubectl label node k8s-node1 ingress=<span class="literal">true</span></span><br><span class="line">$ kubectl label node k8s-node2 ingress=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建命名空间并使用本地chart安装</span></span><br><span class="line">$ helm upgrade -n ingress-nginx --create-namespace --install ingress-nginx ./ingress-nginx</span><br></pre></td></tr></table></figure><h2 id="确认Ingress-Controller"><a href="#确认Ingress-Controller" class="headerlink" title="确认Ingress Controller"></a>确认Ingress Controller</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看pod运行情况</span></span><br><span class="line">$ kubectl -n ingress-nginx get pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ingress-controller的service</span></span><br><span class="line">$ kubectl -n ingress-nginx get svc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署测试应用，使用ingress暴露服务，然后访问测试确认是否生效。这里具体的应用部署方式不再赘述。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> helm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 容器网络接口</title>
      <link href="/k8s-cni/"/>
      <url>/k8s-cni/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>k8s中的网络也是一个比较复杂的部分，这里我们看一下k8s中的网络，以及网络插件。</p><span id="more"></span><h1 id="Kubernetes集群的网络实现"><a href="#Kubernetes集群的网络实现" class="headerlink" title="Kubernetes集群的网络实现"></a>Kubernetes集群的网络实现</h1><h2 id="容器网络回顾"><a href="#容器网络回顾" class="headerlink" title="容器网络回顾"></a>容器网络回顾</h2><p><img src="/post/docker/docker-bridge.jpeg" alt="docker-bridge"></p><p>Docker 创建一个容器的时候，会执行如下操作：</p><ul><li>创建一对虚拟接口&#x2F;网卡，也就是veth pair；</li><li>veth pair的一端桥接 到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxxx；</li><li>veth pair的另一端放到新启动的容器内部，并修改名字作为 eth0，这个网卡&#x2F;接口只在容器的命名空间可见；</li><li>从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0</li><li>配置容器的默认路由</li></ul><h2 id="Pod-IP唯一性保障"><a href="#Pod-IP唯一性保障" class="headerlink" title="Pod IP唯一性保障"></a>Pod IP唯一性保障</h2><p>Kubernetes网络模型的核心要求之一是每个Pod应该获得自己的IP地址，如何实现？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/kubernetes/manifests/kube-controller-manager.yaml</span><br><span class="line">...</span><br><span class="line">- --cluster-cidr=10.244.0.0/16</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为每个节点从cidr中分配一个网段，供该节点分配pod ip</span></span><br><span class="line">$ kubectl describe nodes k8s-node1</span><br><span class="line">...</span><br><span class="line">PodCIDR:                      10.244.1.0/24</span><br><span class="line">PodCIDRs:                     10.244.1.0/24</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Pod配置网络流程"><a href="#Pod配置网络流程" class="headerlink" title="Pod配置网络流程"></a>Pod配置网络流程</h2><p>CNI：容器网络接口（Container Network Interface）， 主要能力是对接 Kubelet 完成容器网卡的创建，申请和设置 ip 地址，路由设置，网关设置，实现kubernetes集群的Pod网络通信及管理。</p><p>CNI的具体实现有很多种：</p><ul><li>通用类型：flannel、calico、Cilium 等，部署使用简单</li><li>其他：根据具体的网络环境及网络需求选择，比如<ul><li>公有云机器，可以选择厂商与网络插件的定制Backend，如AWS、阿里、腾讯针对flannel均有自己的插件，也有AWS ECS CNI</li><li>私有云厂商，比如Vmware NSX-T等</li><li>网络性能等，MacVlan</li></ul></li></ul><blockquote><p>k8s本身不提供cni的实现，因此安装完k8s集群后，需要单独安装网络组件</p></blockquote><p><img src="/post/docker/kubelet-cni-process.jpg" alt="kubelet-cni-process"></p><ol><li>pod调度到k8s的节点k8s-node1中</li><li>k8s-node1的kubelet调用containerd创建pod</li><li>containerd创建pod沙箱和pod所用的网络空间</li><li>containerd查找配置 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/containerd/config.toml</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]</span><br><span class="line">  bin_dir = &quot;/opt/cni/bin&quot;</span><br><span class="line">  conf_dir = &quot;/etc/cni/net.d&quot;</span><br><span class="line">  conf_template = &quot;&quot;</span><br><span class="line">  ip_pref = &quot;&quot;</span><br><span class="line">  max_conf_num = 1</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li>查看目录<code>/etc/cni/net.d/</code>，发现<code>10-flannel.conflist</code>，使用flannel作为网络插件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">ls</span> /etc/cni/net.d/</span></span><br><span class="line">10-flannel.conflist</span><br></pre></td></tr></table></figure></li><li>CNI开始为pod配置网络<ul><li>flannel启动时候，写入了本机配置文件<code>/run/flannel/subnet.env</code>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /run/flannel/subnet.env</span></span><br><span class="line">FLANNEL_NETWORK=10.244.0.0/16</span><br><span class="line">FLANNEL_SUBNET=10.244.0.1/24</span><br><span class="line">FLANNEL_MTU=1450</span><br><span class="line">FLANNEL_IPMASQ=true</span><br></pre></td></tr></table></figure></li><li>flannel将本机网段等信息传递给bridge插件<ul><li>bridge插件创建cni0网桥</li><li>创建veth pair，分别接入到pod网络空间和cni0网桥</li><li>调用 本地IPAM CNI 插件，设置pod ip地址并记录已分配地址  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip a s cni0</span></span><br><span class="line">15: cni0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 6a:93:41:87:41:22 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.244.0.1/24 brd 10.244.0.255 scope global cni0</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::6893:41ff:fe87:4122/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install bridge-utils -y</span></span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">cni0            8000.6a9341874122       no              veth8a587a83</span><br><span class="line">docker0         8000.024289168674       no</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li>IPAM CNI 插件从子网返回容器的IP地址，并将分配的IP本地存储在主机上 <code>/var/lib/cni/networks/cbr0/</code></li></ul></li><li>containerd创建pause容器，并配置到新建的网络空间</li><li>kubelet调用containerd开始拉取业务镜像</li><li>启动业务容器并设置namespace和cgroup</li></ol><p>上图可以清晰的看到如下重点：</p><ul><li>kubelet、containerd、cni的工作边界和职责</li><li>cni是被containerd进行调用，cni的实现是可以根据不同的网络环境配置的</li><li>配置Pod网络的过程，实际上是一个网络工具的链式调用</li></ul><p>更细致的CNI调用过程如下图：</p><p><img src="/post/docker/cni-network.webp" alt="cni-network"></p><ul><li>Flannel CNI<ul><li>使用Flannel作为网络提供程序时，Containered CRI插件使用CNI配置文件<code>/etc/cni/net.d/10-flannel.conflist</code>调用Flannel CNI插件</li><li>Flannel CNI插件与Flanneld结合使用。当Flanneld启动时，它会从apiserver中获取podCIDR和其他与网络相关的详细信息，并将它们存储在文件<code>/run/flannel/subnet.env</code>中</li><li>Flannel CNI插件使用<code>/run/flannel/subnet.env</code>中的信息来配置和调用网桥CNI插件。</li></ul></li><li>Bridge CNI<ul><li>首次调用Bridge CNI插件时，它将使用配置文件中指定的<code>&quot;name&quot;: &quot;cni0&quot;</code>创建一个Linux网桥。然后，它为每个Pod创建veth对，该对的一端在容器的网络名称空间中，另一端连接到主机网络上的linux桥。使用Bridge CNI插件，主机上的所有容器都连接到主机网络上的linux网桥。</li><li>配置完veth对后，Bridge插件将调用主机本地IPAM CNI插件</li></ul></li><li>host-local IPAM CNI<ul><li>Host-local IPAM（IP地址管理）插件从子网返回容器的IP地址，并将分配的IP本地存储在主机上</li></ul></li></ul><p>经过Pod网络配置后，本机的Pod应该是这样的：</p><p><img src="/post/docker/pod-local.png" alt="pod-local"></p><h2 id="kube-flannel的作用"><a href="#kube-flannel的作用" class="headerlink" title="kube-flannel的作用"></a>kube-flannel的作用</h2><p>从Pod的启动进程，看flannel的Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-flannel get po -owide</span><br><span class="line">NAME                    READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-flannel-ds-6tx4f   1/1     Running   0          87d   192.168.100.1   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-7p2rb   1/1     Running   0          87d   192.168.100.2   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-flannel-ds-rx54g   1/1     Running   0          87d   192.168.100.3   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ kubectl -n kube-flannel get pod kube-flannel-ds-gdvpx -oyaml</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">  containers:</span><br><span class="line">  - args:</span><br><span class="line">    - --ip-masq</span><br><span class="line">    - --kube-subnet-mgr</span><br><span class="line">    - --iface=ens192</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - /opt/bin/flanneld</span><br><span class="line">......</span><br><span class="line">  initContainers:</span><br><span class="line">  - args:</span><br><span class="line">    - -f</span><br><span class="line">    - /flannel</span><br><span class="line">    - /opt/cni/bin/flannel</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - <span class="built_in">cp</span></span><br><span class="line">    image: docker.io/flannel/flannel-cni-plugin:v1.2.0</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: install-cni-plugin</span><br><span class="line">    resources: &#123;&#125;</span><br><span class="line">    terminationMessagePath: /dev/termination-log</span><br><span class="line">    terminationMessagePolicy: File</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /opt/cni/bin</span><br><span class="line">      name: cni-plugin</span><br><span class="line">    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">      name: kube-api-access-db2cl</span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">  - args:</span><br><span class="line">    - -f</span><br><span class="line">    - /etc/kube-flannel/cni-conf.json</span><br><span class="line">    - /etc/cni/net.d/10-flannel.conflist</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - <span class="built_in">cp</span></span><br><span class="line">    image: docker.io/flannel/flannel:v0.22.2</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: install-cni</span><br><span class="line">    resources: &#123;&#125;</span><br><span class="line">    terminationMessagePath: /dev/termination-log</span><br><span class="line">    terminationMessagePolicy: File</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /etc/cni/net.d</span><br><span class="line">      name: cni</span><br><span class="line">    - mountPath: /etc/kube-flannel/</span><br><span class="line">      name: flannel-cfg</span><br><span class="line">    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">      name: kube-api-access-db2cl</span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">......</span><br><span class="line">  volumes:</span><br><span class="line">  - hostPath:</span><br><span class="line">      path: /run/flannel</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    name: run</span><br><span class="line">  - hostPath:</span><br><span class="line">      path: /opt/cni/bin</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    name: cni-plugin</span><br><span class="line">  - hostPath:</span><br><span class="line">      path: /etc/cni/net.d</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    name: cni</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从配置文中可以知道，flannel的Pod做了如下事情：</span></span><br><span class="line"><span class="comment"># 1. 执行命令 /opt/bin/flanneld --ip-masq --kube-subnet-mgr --iface=eth0</span></span><br><span class="line"><span class="comment"># 2. 第一个 initContainer 执行命令 cp -f /flannel /opt/cni/bin/flannel</span></span><br><span class="line"><span class="comment"># 3. 第二个 initContainer 执行命令 cp -f /etc/kube-flannel/cni-conf.json /etc/cni/net.d/10-flannel.conflist</span></span><br></pre></td></tr></table></figure><p>从进程可以得知：</p><ol><li>启动flanneld进程，功能未知</li><li>拷贝flannel的网络插件到宿主机中，为containerd调用</li><li>考虑flannel的配置文件，当成宿主机的CNI配置，告知containerd使用flannel</li></ol><h2 id="跨主机Pod通信"><a href="#跨主机Pod通信" class="headerlink" title="跨主机Pod通信"></a>跨主机Pod通信</h2><p>跨主机间的通信流程：</p><p><img src="/post/docker/pods-network.webp" alt="pods-network"></p><p>flannel的网络有多种后端实现：</p><p>1.<code>udp</code><br>2. <code>vxlan</code><br>3. <code>host-gw</code><br>4. …</p><p>不特殊指定的话，默认会使用vxlan技术作为Backend，可以通过如下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-flannel <span class="built_in">exec</span> -it kube-flannel-ds-6tx4f -- <span class="built_in">cat</span> /etc/kube-flannel/net-conf.json</span><br><span class="line">Defaulted container <span class="string">&quot;kube-flannel&quot;</span> out of: kube-flannel, install-cni-plugin (init), install-cni (init)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;10.244.0.0/16&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Backend&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;vxlan&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用vxlan作为后端实现时，flanneld进程的作用：</p><ul><li>启动flannel.1作为VTEP设备，用来封包、解包，实现跨主机通信</li><li>监听宿主机的Pod CIDR，维护本机路由表</li></ul><h3 id="vxlan介绍及点对点通信的实现"><a href="#vxlan介绍及点对点通信的实现" class="headerlink" title="vxlan介绍及点对点通信的实现"></a>vxlan介绍及点对点通信的实现</h3><p>VXLAN 全称是虚拟可扩展的局域网（ Virtual eXtensible Local Area Network），它是一种 overlay 技术，通过三层的网络来搭建虚拟的二层网络。</p><p><img src="/post/docker/vxlan.png" alt="vxlan"></p><p>它创建在原来的 IP 网络（三层）上，只要是三层可达（能够通过 IP 互相通信）的网络就能部署 vxlan。在每个端点上都有一个 vtep 负责 vxlan 协议报文的封包和解包，也就是在虚拟报文上封装 vtep 通信的报文头部。物理网络上可以创建多个 vxlan 网络，这些 vxlan 网络可以认为是一个隧道，不同节点的虚拟机能够通过隧道直连。每个 vxlan 网络由唯一的 VNI 标识，不同的 vxlan 可以不相互影响。</p><ul><li>VTEP（VXLAN Tunnel Endpoints）：vxlan 网络的边缘设备，用来进行 vxlan 报文的处理（封包和解包）。vtep 可以是网络设备（比如交换机），也可以是一台机器（比如虚拟化集群中的宿主机）</li><li>VNI（VXLAN Network Identifier）：VNI 是每个 vxlan 的标识，一共有 2^24 &#x3D; 16,777,216，一般每个 VNI 对应一个租户，也就是说使用 vxlan 搭建的公有云可以理论上可以支撑千万级别的租户</li></ul><h3 id="vxlan点对点通信的实现"><a href="#vxlan点对点通信的实现" class="headerlink" title="vxlan点对点通信的实现"></a>vxlan点对点通信的实现</h3><p>在k8s选择两台机器，利用vxlan的点对点能力，实现虚拟二层网络的通信</p><p><img src="/post/docker/vxlan-p2p.png" alt="vxlan-p2p"></p><h4 id="配置vxlan网络"><a href="#配置vxlan网络" class="headerlink" title="配置vxlan网络"></a>配置vxlan网络</h4><p><code>192.168.100.1</code>节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建vTEP设备，对端指向192.168.100.2节点，指定VNI及underlay网络使用的网卡</span></span><br><span class="line">$ sudo ip <span class="built_in">link</span> add vxlan20 <span class="built_in">type</span> vxlan <span class="built_in">id</span> 20 remote 192.168.100.2 dstport 4789 dev ens224</span><br><span class="line"><span class="comment"># 查看设备信息</span></span><br><span class="line">$ sudo ip -d <span class="built_in">link</span> show vxlan20</span><br><span class="line"><span class="comment"># 启动设备</span></span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> vxlan20 up</span><br><span class="line"><span class="comment"># 设置ip地址</span></span><br><span class="line">$ sudo ip addr add 172.16.1.1/24 dev vxlan20</span><br></pre></td></tr></table></figure><p><code>192.168.100.2</code>节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建VTEP设备，对端指向192.168.100.1节点，指定VNI及underlay网络使用的网卡</span></span><br><span class="line">$ sudo ip <span class="built_in">link</span> add vxlan20 <span class="built_in">type</span> vxlan <span class="built_in">id</span> 20 remote 192.168.100.1 dstport 4789 dev ens224</span><br><span class="line"><span class="comment"># 启动设备</span></span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> vxlan20 up</span><br><span class="line"><span class="comment"># 设置ip地址</span></span><br><span class="line">$ sudo ip addr add 172.16.2.2/24 dev vxlan20</span><br></pre></td></tr></table></figure><h4 id="测试点对点通信"><a href="#测试点对点通信" class="headerlink" title="测试点对点通信"></a>测试点对点通信</h4><p>在<code>192.168.100.1</code>节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ping -c 6 172.16.2.2</span><br><span class="line">PING 172.16.2.2 (172.16.2.2) 56(84) 比特的数据。</span><br><span class="line">^C</span><br><span class="line">--- 172.16.2.2 ping 统计 ---</span><br><span class="line">已发送 6 个包， 已接收 0 个包, 100% packet loss, time 5105ms</span><br></pre></td></tr></table></figure><h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><p>在<code>192.168.100.1</code>节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">走vtep封包解包</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route add 172.16.2.0/24 dev vxlan20</span></span><br></pre></td></tr></table></figure><p>在<code>192.168.100.2</code>机器上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip route add 172.16.1.0/24 dev vxlan20</span><br></pre></td></tr></table></figure><h4 id="再次测试点对点通信"><a href="#再次测试点对点通信" class="headerlink" title="再次测试点对点通信"></a>再次测试点对点通信</h4><p>在<code>192.168.100.1</code>节点，再次ping：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 172.16.2.2</span></span><br></pre></td></tr></table></figure><h4 id="等似模型"><a href="#等似模型" class="headerlink" title="等似模型"></a>等似模型</h4><p><img src="/post/docker/vxlan-p2p-overlay.png" alt="vxlan-p2p-overlay"></p><p>这里的隧道是一个逻辑上的概念，在 vxlan 模型中并没有具体的物理实体相对应。隧道可以看做是一种虚拟通道，vxlan 通信双方认为自己是在直接通信，并不知道底层网络的存在。从整体来说，每个 vxlan 网络像是为通信的虚拟机搭建了一个单独的通信通道，也就是隧道。</p><p>整个vxlan实现的过程就是机器的报文通过 vtep 添加上 vxlan 以及外部的报文层，然后发送出去，对方 vtep 收到之后拆除 vxlan 头部然后根据 VNI 把原始报文发送到目的虚拟机。</p><h4 id="清除配置"><a href="#清除配置" class="headerlink" title="清除配置"></a>清除配置</h4><p>两台机器上都进行清除配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip <span class="built_in">link</span> del vxlan20</span><br></pre></td></tr></table></figure><h3 id="跨主机Pod通信-1"><a href="#跨主机Pod通信-1" class="headerlink" title="跨主机Pod通信"></a>跨主机Pod通信</h3><p>接下来看看k8s中跨主机Pod通信的流量详细过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群中的Pod，查找两个不同节点的Pod，这里选取了myblog和testpod</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po -o wide</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   IP              NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">myblog-84985b5b66-smpwb    1/1     Running   0          76d   10.244.1.5      k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">mysql-7f97cb6cc9-vzxpd     1/1     Running   0          76d   192.168.100.2   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">testpod-865855cfc5-m2f99   1/1     Running   0          63d   10.244.2.13     k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> myblog-84985b5b66-smpwb -- ping 10.244.2.13 -c 6</span><br><span class="line">PING 10.244.2.13 (10.244.2.13) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.244.2.13: icmp_seq=1 ttl=62 time=1.05 ms</span><br><span class="line">64 bytes from 10.244.2.13: icmp_seq=2 ttl=62 time=1.04 ms</span><br><span class="line">64 bytes from 10.244.2.13: icmp_seq=3 ttl=62 time=0.856 ms</span><br><span class="line">64 bytes from 10.244.2.13: icmp_seq=4 ttl=62 time=1.14 ms</span><br><span class="line">64 bytes from 10.244.2.13: icmp_seq=5 ttl=62 time=1.03 ms</span><br><span class="line">64 bytes from 10.244.2.13: icmp_seq=6 ttl=62 time=0.974 ms</span><br><span class="line"></span><br><span class="line">--- 10.244.2.13 ping statistics ---</span><br><span class="line">6 packets transmitted, 6 received, 0% packet loss, time 5005ms</span><br><span class="line">rtt min/avg/max/mdev = 0.856/1.014/1.143/0.086 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看路由</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> myblog-84985b5b66-smpwb -- route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.244.1.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.244.0.0      10.244.1.1      255.255.0.0     UG    0      0        0 eth0</span><br><span class="line">10.244.1.0      0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看k8s-master 的veth pair 和网桥</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge <span class="built_in">id</span>               STP enabled     interfaces</span><br><span class="line">cni0            8000.6a9341874122       no              veth8a587a83</span><br><span class="line">                                                        vethe7a6a0e0</span><br><span class="line">docker0         8000.024289168674       no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 流量到了cni0后，查看master节点的route</span></span><br><span class="line">$ ip r s</span><br><span class="line">default via 10.209.0.200 dev ens192 proto dhcp src 10.209.0.13 metric 100</span><br><span class="line">default via 192.168.100.254 dev ens224 proto static metric 101</span><br><span class="line">10.209.0.0/21 dev ens192 proto kernel scope <span class="built_in">link</span> src 10.209.0.13 metric 100</span><br><span class="line">10.244.0.0/24 dev cni0 proto kernel scope <span class="built_in">link</span> src 10.244.0.1</span><br><span class="line">10.244.1.0/24 via 10.244.1.0 dev flannel.1 onlink</span><br><span class="line">10.244.2.0/24 via 10.244.2.0 dev flannel.1 onlink</span><br><span class="line">172.7.21.0/24 dev docker0 proto kernel scope <span class="built_in">link</span> src 172.7.21.1 linkdown</span><br><span class="line">192.168.100.0/24 dev ens224 proto kernel scope <span class="built_in">link</span> src 192.168.100.1 metric 101</span><br><span class="line"></span><br><span class="line"><span class="comment"># 流量转发到了flannel.1网卡，查看该网卡，其实是vtep设备</span></span><br><span class="line">$ ip -d <span class="built_in">link</span> show flannel.1</span><br><span class="line">$ ip -d <span class="built_in">link</span> show flannel.1</span><br><span class="line">6: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN mode DEFAULT group default</span><br><span class="line">    <span class="built_in">link</span>/ether 0e:af:83:0c:88:29 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65535</span><br><span class="line">    vxlan <span class="built_in">id</span> 1 <span class="built_in">local</span> 10.209.0.13 dev ens192 srcport 0 0 dstport 8472 nolearning ttl auto ageing 300 udpcsum noudp6zerocsumtx noudp6zerocsumrx addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 tso_max_size 65536 tso_max_segs 65535 gro_max_size 65536</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该转发到哪里，通过etcd查询数据，然后本地缓存，流量不用走多播发送</span></span><br><span class="line">$ bridge fdb show dev flannel.1</span><br><span class="line">f6:62:9f:90:cf:fe dst 10.209.0.15 self permanent</span><br><span class="line">66:1a:39:32:d5:13 dst 10.209.0.11 self permanent</span><br></pre></td></tr></table></figure><p>查看k8s-node1的路由</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对端的vtep设备接收到请求后做解包，取出源payload内容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">route -n</span></span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.21.64.190   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.244.0.0      10.244.0.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line">10.244.1.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0</span><br><span class="line">10.244.2.0      10.244.2.0      255.255.255.0   UG    0      0        0 flannel.1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据路由规则转发到cni0网桥,然后由网桥转到具体的Pod中</span></span><br></pre></td></tr></table></figure><p>实际的请求图：</p><p><img src="/post/docker/flannel-actual.png" alt="flannel-actual"></p><h3 id="kube-flannel中flanneld的作用"><a href="#kube-flannel中flanneld的作用" class="headerlink" title="kube-flannel中flanneld的作用"></a>kube-flannel中flanneld的作用</h3><p>现在我们可以说一下前面未知的flanneld进程的作用了。</p><p>从上面的分析可以看到，flannel的Pod中的flanneld进程的作用有如下几点，保证Pod网络的通信（vxlan模式）：</p><ul><li>启动flannel.1作为VTEP设备，用来封包、解包，实现跨主机通信</li><li>监听宿主机的Pod CIDR，维护本机路由表</li><li>通过etcd查询数据，然后本地缓存，流量不用走多播发送</li></ul><h3 id="利用host-gw模式提升集群网络性能"><a href="#利用host-gw模式提升集群网络性能" class="headerlink" title="利用host-gw模式提升集群网络性能"></a>利用host-gw模式提升集群网络性能</h3><p>vxlan模式适用于三层可达的网络环境，对集群的网络要求很宽松，但是同时由于会通过VTEP设备进行额外封包和解包，因此给性能带来了额外的开销。</p><p>网络插件的目的其实就是将本机的cni0网桥的流量送到目的主机的cni0网桥。实际上有很多集群是部署在同一二层网络环境下的，可以直接利用二层的主机当作流量转发的网关。这样的话，可以不用进行封包解包，直接通过路由表去转发流量。</p><p><img src="/post/docker/flannel-host-gw.png" alt="flannel-host-gw"></p><blockquote><p>为什么三层可达的网络不直接利用网关转发流量？</p><p>这是因为内核当中的路由规则，网关必须在跟主机当中至少一个 IP 处于同一网段。<br>由于k8s集群内部各节点均需要实现Pod互通，因此，也就意味着host-gw模式需要整个集群节点都在同一二层网络内。</p></blockquote><p>首先修改flannel的网络后端为host-gw</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit cm kube-flannel-cfg -n kube-flannel</span><br><span class="line">...</span><br><span class="line">net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;10.244.0.0/16&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Backend&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;host-gw&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">kind: ConfigMap</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>重建Flannel的Pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-flannel get pod</span><br><span class="line">NAME                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-flannel-ds-6tx4f   1/1     Running   0          88d</span><br><span class="line">kube-flannel-ds-7p2rb   1/1     Running   0          88d</span><br><span class="line">kube-flannel-ds-rx54g   1/1     Running   0          88d</span><br><span class="line"></span><br><span class="line">$ kubectl -n kube-flannel delete po kube-flannel-ds-6tx4f kube-flannel-ds-7p2rb kube-flannel-ds-rx54g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待Pod新启动后，查看日志，出现Backend type: host-gw字样</span></span><br><span class="line">$ kubectl -n kube-flannel logs -f kube-flannel-ds-xbbg2</span><br><span class="line">Defaulted container <span class="string">&quot;kube-flannel&quot;</span> out of: kube-flannel, install-cni-plugin (init), install-cni (init)</span><br><span class="line">I1121 17:30:43.302575       1 main.go:212] CLI flags config: &#123;etcdEndpoints:http://127.0.0.1:4001,http://127.0.0.1:2379 etcdPrefix:/coreos.com/network etcdKeyfile: etcdCertfile: etcdCAFile: etcdUsername: etcdPassword: version:<span class="literal">false</span> kubeSubnetMgr:<span class="literal">true</span> kubeApiUrl: kubeAnnotationPrefix:flannel.alpha.coreos.com kubeConfigFile: iface:[ens224] ifaceRegex:[] ipMasq:<span class="literal">true</span> ifaceCanReach: subnetFile:/run/flannel/subnet.env publicIP: publicIPv6: subnetLeaseRenewMargin:60 healthzIP:0.0.0.0 healthzPort:0 iptablesResyncSeconds:5 iptablesForwardRules:<span class="literal">true</span> netConfPath:/etc/kube-flannel/net-conf.json setNodeNetworkUnavailable:<span class="literal">true</span> useMultiClusterCidr:<span class="literal">false</span>&#125;</span><br><span class="line">W1121 17:30:43.302852       1 client_config.go:617] Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work.</span><br><span class="line">I1121 17:30:43.336114       1 kube.go:145] Waiting 10m0s <span class="keyword">for</span> node controller to <span class="built_in">sync</span></span><br><span class="line">I1121 17:30:43.336353       1 kube.go:489] Starting kube subnet manager</span><br><span class="line">I1121 17:30:43.345998       1 kube.go:510] Creating the node lease <span class="keyword">for</span> IPv4. This is the n.Spec.PodCIDRs: [10.244.0.0/24]</span><br><span class="line">I1121 17:30:43.346170       1 kube.go:510] Creating the node lease <span class="keyword">for</span> IPv4. This is the n.Spec.PodCIDRs: [10.244.1.0/24]</span><br><span class="line">I1121 17:30:43.346257       1 kube.go:510] Creating the node lease <span class="keyword">for</span> IPv4. This is the n.Spec.PodCIDRs: [10.244.2.0/24]</span><br><span class="line">I1121 17:30:44.337195       1 kube.go:152] Node controller <span class="built_in">sync</span> successful</span><br><span class="line">I1121 17:30:44.337292       1 main.go:232] Created subnet manager: Kubernetes Subnet Manager - k8s-master</span><br><span class="line">I1121 17:30:44.337312       1 main.go:235] Installing signal handlers</span><br><span class="line">I1121 17:30:44.337914       1 main.go:543] Found network config - Backend <span class="built_in">type</span>: host-gw</span><br><span class="line">I1121 17:30:44.339623       1 match.go:259] Using interface with name ens224 and address 192.168.100.1</span><br><span class="line">I1121 17:30:44.339696       1 match.go:281] Defaulting external address to interface address (192.168.100.1)</span><br><span class="line">I1121 17:30:44.360432       1 main.go:357] Setting up masking rules</span><br><span class="line">I1121 17:30:44.361152       1 kube.go:510] Creating the node lease <span class="keyword">for</span> IPv4. This is the n.Spec.PodCIDRs: [10.244.0.0/24]</span><br><span class="line">I1121 17:30:44.417318       1 main.go:408] Changing default FORWARD chain policy to ACCEPT</span><br><span class="line">I1121 17:30:44.422345       1 iptables.go:290] generated 7 rules</span><br><span class="line">I1121 17:30:44.428274       1 iptables.go:290] generated 3 rules</span><br><span class="line">I1121 17:30:44.428651       1 main.go:436] Wrote subnet file to /run/flannel/subnet.env</span><br><span class="line">I1121 17:30:44.428713       1 main.go:440] Running backend.</span><br><span class="line">I1121 17:30:44.429253       1 route_network.go:56] Watching <span class="keyword">for</span> new subnet leases</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>查看节点路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ip r s</span><br><span class="line">default via 10.209.0.200 dev ens192 proto dhcp src 10.209.0.13 metric 100</span><br><span class="line">default via 192.168.100.254 dev ens224 proto static metric 101</span><br><span class="line">10.209.0.0/21 dev ens192 proto kernel scope <span class="built_in">link</span> src 10.209.0.13 metric 100</span><br><span class="line">10.244.0.0/24 dev cni0 proto kernel scope <span class="built_in">link</span> src 10.244.0.1</span><br><span class="line">10.244.1.0/24 via 192.168.100.2 dev ens224</span><br><span class="line">10.244.2.0/24 via 192.168.100.3 dev ens224</span><br><span class="line">172.7.21.0/24 dev docker0 proto kernel scope <span class="built_in">link</span> src 172.7.21.1 linkdown</span><br><span class="line">192.168.100.0/24 dev ens224 proto kernel scope <span class="built_in">link</span> src 192.168.100.1 metric 101</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>flannel pod做的几个事情：</p><ul><li>为了配置本机的Pod网络<ul><li>flannel pod启动时，拷贝cni的配置文件<code>/etc/cni/net.d/10-flannel.conflist</code>，告知CRI(containerd) 使用flannel插件进行配置网络</li><li>拷贝一份可执行文件到宿主机 <code>/opt/cni/bin/flannel</code></li><li>调用apiserver，得到分配到本机的PodCIDR，写入到<code>/run/flannel/subnet.env</code></li><li>调用本机的bridge插件，创建本地cni0网桥，创建虚拟网卡对，链接cni0和Pod网络空间</li><li>bridge cni调用local ipam插件（host-local），记录并分配pod ip，写入到<code>/var/lib/cni/networks/cbr0/</code></li></ul></li><li>为了使得跨主机实现Pod的访问<ul><li>创建flannel.1 vtep设备，支持vxlan模式下封包解包</li><li>维护本机路由表，转发Pod的流量</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> cni </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 持久卷</title>
      <link href="/k8s-persistent-volume/"/>
      <url>/k8s-persistent-volume/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>Kubernetes 中的持久卷（Persistent Volume）是一种存储卷，它的生命周期独立于 Pod，这意味着 Pod 被删除后，持久卷中的数据不会被删除。持久卷可以在多个 Pod 之间共享，但是同一时间只能被一个 Pod 挂载。持久卷的类型可以是 NFS、iSCSI、GlusterFS、Ceph 等。</p><span id="more"></span><h2 id="持久化卷方式"><a href="#持久化卷方式" class="headerlink" title="持久化卷方式"></a>持久化卷方式</h2><p>k8s存储的目的就是保证Pod重建后，数据不丢失。简单的数据持久化有以下几种方式：</p><h3 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h3><ul><li>Pod内的容器共享卷的数据</li><li>存在于Pod的生命周期，Pod销毁，数据丢失</li><li>Pod内的容器自动重建后，数据不会丢失</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">webserver</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/cache</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/test-redis</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="comment"># 与webserver容器共享同一个卷，数据会被共享</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h3><p>指定节点上的目录作为卷，这种方式不适合生产环境，因为Pod可能会被调度到其他节点，数据会不一致或者丢失，因此通常配合nodeSelector使用，保证Pod一直调度到指定的节点上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="string">k8s-node1</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/test-pod</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="comment"># 节点上的本地目录</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data</span></span><br><span class="line">      <span class="comment"># 可选项</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><h3 id="nfs存储"><a href="#nfs存储" class="headerlink" title="nfs存储"></a>nfs存储</h3><p>通过nfs挂载远程存储</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redisdata</span>             <span class="comment">#卷名称</span></span><br><span class="line">    <span class="attr">nfs:</span>                        <span class="comment">#使用NFS网络存储卷</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>     <span class="comment">#NFS服务器地址</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data/redis</span>         <span class="comment">#NFS服务器共享的目录</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">false</span>           <span class="comment">#是否为只读</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="存储支持"><a href="#存储支持" class="headerlink" title="存储支持"></a>存储支持</h2><p>volume支持的种类众多（参考 <a href="https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes">https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes</a> ）每种对应不同的存储后端实现。</p><p>为了屏蔽后端存储的细节，同时使得Pod在使用存储的时候更加简洁和规范，k8s引入了两个新的资源类型，PV和PVC。</p><h2 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h2><p>PersistentVolume（持久化卷），是对底层的存储的一种抽象，它和具体的底层的共享存储技术的实现方式有关，比如 Ceph、GlusterFS、NFS 等，都是通过插件机制完成与共享存储的对接。如使用PV对接NFS存储：</p><p>pv的声明式清单如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/k8s</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><ul><li>capacity，存储能力， 目前只支持存储空间的设置， 就是我们这里的 storage&#x3D;1Gi，不过未来可能会加入 IOPS、吞吐量等指标的配置。</li><li>persistentVolumeReclaimPolicy，pv的回收策略, 目前只有 NFS 和 HostPath 两种类型支持回收策略<ul><li>Retain（保留）- 保留数据，需要管理员手工清理数据</li><li>Recycle（回收）- 清除 PV 中的数据，效果相当于执行 rm -rf &#x2F;thevolume&#x2F;*</li><li>Delete（删除）- 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务，比如 ASW EBS。</li></ul></li><li>accessModes，访问模式， 是用来对 PV 进行访问模式的设置，用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：<ul><li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li><li>ReadOnlyMany（ROX）：只读权限，可以被多个节点挂载</li><li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</li></ul></li></ul><p><img src="/post/docker/pv-access-mode.png" alt="pv-access-mode"></p><h2 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h2><p>因为PV是直接对接底层存储的，就像集群中的Node可以为Pod提供计算资源（CPU和内存）一样，PV可以为Pod提供存储资源。因此PV不是namespaced的资源，属于集群层面可用的资源。Pod如果想使用该PV，需要通过创建PVC挂载到Pod中。</p><p>PVC全写是PersistentVolumeClaim（持久化卷声明），PVC 是用户存储的一种声明，创建完成后，可以和PV实现一对一绑定。对于真正使用存储的用户不需要关心底层的存储实现细节，只需要直接使用 PVC 即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc-nfs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure><p>然后Pod中通过如下方式去使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">volumeMounts:</span> <span class="comment">#挂载容器中的目录到 pvc nfs 中的目录</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span> <span class="comment"># 指定挂载的卷名称</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span> <span class="comment"># 挂载到容器中的目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span> <span class="comment"># 指定卷名称</span></span><br><span class="line">        <span class="attr">persistentVolumeClaim:</span> <span class="comment">#指定pvc</span></span><br><span class="line">          <span class="attr">claimName:</span> <span class="string">pvc-nfs</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>PV是集群层面的资源，PVC是命名空间层面的资源，因此PVC定义的时候需要指定命名空间，而且PVC只能给同一个命名空间下的Pod使用。</p><h2 id="PV与PVC管理NFS存储卷实践"><a href="#PV与PVC管理NFS存储卷实践" class="headerlink" title="PV与PVC管理NFS存储卷实践"></a>PV与PVC管理NFS存储卷实践</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>服务端：192.168.100.1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install nfs-utils rpcbind</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享目录</span></span><br><span class="line">$ <span class="built_in">mkdir</span> -p /data/k8s &amp;&amp; <span class="built_in">chmod</span> 755 /data/k8s</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;/data/k8s  *(insecure,rw,sync,no_root_squash,fsid=0)&#x27;</span>&gt;&gt;/etc/exports</span><br><span class="line"></span><br><span class="line">$ systemctl <span class="built_in">enable</span> rpcbind &amp;&amp; systemctl start rpcbind</span><br><span class="line">$ systemctl <span class="built_in">enable</span> nfs-server &amp;&amp; systemctl start nfs-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看共享目录，确认nfs服务正常</span></span><br><span class="line">$ showmount -e 127.0.0.1</span><br></pre></td></tr></table></figure><p>客户端：k8s集群slave节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install nfs-utils</span><br><span class="line">$ <span class="built_in">mkdir</span> /nfsdata</span><br><span class="line">$ mount -t nfs 192.168.100.1:/ /nfsdata</span><br></pre></td></tr></table></figure><h3 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在nfs-server机器中创建</span></span><br><span class="line">$ <span class="built_in">mkdir</span> /data/k8s/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把/data/k8s/nginx 目录作为数据卷给k8s集群中的Pod使用</span></span><br><span class="line">$ <span class="built_in">cat</span> pv-nfs.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pv</span><br><span class="line">spec:</span><br><span class="line">  capacity: </span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteMany</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nginx</span><br><span class="line">    server: 192.168.100.1</span><br><span class="line"></span><br><span class="line">$ kubectl create -f pv-nfs.yaml</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS  </span><br><span class="line">nfs-pv   1Gi        RWO            Retain           Available</span><br></pre></td></tr></table></figure><p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p><ul><li>Available（可用）：表示可用状态，还未被任何 PVC 绑定</li><li>Bound（已绑定）：表示 PV 已经被 PVC 绑定</li><li>Released（已释放）：PVC 被删除，但是资源还未被集群重新声明</li><li>Failed（失败）： 表示该 PV 的自动回收失败</li></ul><h3 id="创建PVC"><a href="#创建PVC" class="headerlink" title="创建PVC"></a>创建PVC</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> pvc.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-nfs</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br><span class="line"></span><br><span class="line">$ kubectl create -f pvc.yaml</span><br><span class="line">$ kubectl get pvc</span><br><span class="line">NAME      STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">pvc-nfs   Bound    nfs-pv   1Gi        RWO                           3s</span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM             </span><br><span class="line">nfs-pv   1Gi        RWO            Retain           Bound    default/pvc-nfs             </span><br><span class="line"></span><br><span class="line"><span class="comment">#访问模式，storage大小（pvc大小需要小于pv大小），以及 PV 和 PVC 的 storageClassName 字段必须一样，这样才能够进行绑定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PersistentVolumeController会不断地循环去查看每一个 PVC，是不是已经处于 Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的 PV，并尝试将其与未绑定的 PVC 进行绑定，这样，Kubernetes 就可以保证用户提交的每一个 PVC，只要有合适的 PV 出现，它就能够很快进入绑定状态。而所谓将一个 PV 与 PVC 进行“绑定”，其实就是将这个 PV 对象的名字，填在了 PVC 对象的 spec.volumeName 字段上。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看nfs数据目录</span></span><br><span class="line">$ <span class="built_in">ls</span> /nfsdata</span><br></pre></td></tr></table></figure><h2 id="创建Pod挂载PVC"><a href="#创建Pod挂载PVC" class="headerlink" title="创建Pod挂载PVC"></a>创建Pod挂载PVC</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> deployment.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pvc</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector: <span class="comment">#指定Pod的选择器</span></span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:alpine</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">      volumes:</span><br><span class="line">      - name: www</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: pvc-nfs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ kubectl create -f deployment.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器/usr/share/nginx/html目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除pvc</span></span><br></pre></td></tr></table></figure><h2 id="StorageClass动态挂载"><a href="#StorageClass动态挂载" class="headerlink" title="StorageClass动态挂载"></a>StorageClass动态挂载</h2><p>上述的PV和PVC都是静态的，需要手动创建，且PV与PVC一一对应，手动创建很繁琐。因此，通过 storageClass  +  provisioner 的方式来实现通过PVC自动创建并绑定PV。</p><p><img src="/post/docker/storage-class.png" alt="storage-class"></p><p>一些关于nfs的StorageClass可以查看github仓库 (sig-storage-lib-external-provisioner)[<a href="https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner]">https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner]</a></p><h3 id="准备yaml文件"><a href="#准备yaml文件" class="headerlink" title="准备yaml文件"></a>准备yaml文件</h3><p>在github仓库中下载配置文件nfs-subdir-external-provisioner&#x2F;deploy&#x2F;deployment.yaml，然后进行修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">          <span class="comment"># 修改镜像地址，使用阿里云镜像</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-beijing.aliyuncs.com/mydlq/nfs-subdir-external-provisioner:v4.0.2</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/persistentvolumes</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROVISIONER_NAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line">              <span class="comment"># 修改为nfs-server的ip地址</span></span><br><span class="line">              <span class="attr">value:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span></span><br><span class="line">                <span class="comment"># 修改为nfs-server的共享目录</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="comment"># 修改为nfs-server的ip地址</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span></span><br><span class="line">            <span class="comment"># 修改为nfs-server的共享目录</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p>再下载nfs-subdir-external-provisioner&#x2F;deploy&#x2F;rbac.yaml，然后进行修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;nodes&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;persistentvolumes&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;persistentvolumeclaims&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;storage.k8s.io&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;storageclasses&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;events&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">run-nfs-client-provisioner</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;endpoints&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>最后，下载nfs-subdir-external-provisioner&#x2F;deploy&#x2F;class.yaml文件，然后进行修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client</span></span><br><span class="line">  <span class="comment"># 添加一个注解，设置为default StorageClass</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">storageclass.kubernetes.io/is-default-class:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span> <span class="comment"># or choose another name, must match deployment&#x27;s env PROVISIONER_NAME&#x27;</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">archiveOnDelete:</span> <span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure><h3 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a>创建资源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面文件使用的ns是default，没有指定其他ns，因此这一步不执行</span></span><br><span class="line"><span class="comment"># $ kubectl create namespace nfs-provisioner</span></span><br><span class="line">$ kubectl create -f rbac.yaml</span><br><span class="line">$ kubectl create -f deployment.yaml</span><br><span class="line">$ kubectl create -f class.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待pod启动成功</span></span><br><span class="line">$ kubectl -n nfs-provisioner get pod </span><br><span class="line">nfs-client-provisioner-6cfb58c597-rmc45   1/1     Running   0          27s  </span><br></pre></td></tr></table></figure><h3 id="验证效果"><a href="#验证效果" class="headerlink" title="验证效果"></a>验证效果</h3><p>验证使用<code>storageclass</code>自动创建并绑定pv</p><p>创建一个 <em>pvc.yaml</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">registry-claim</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs-client</span></span><br></pre></td></tr></table></figure><p>创建资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f pvc.yaml</span></span><br></pre></td></tr></table></figure><p>查看pvc和pv是否绑定成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span></span><br><span class="line">NAME             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">registry-claim   Bound    pvc-eb692323-553e-4350-8749-d972ff785567   1Gi        RWX            nfs-client     8s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pv</span></span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                    STORAGECLASS   REASON   AGE</span><br><span class="line">pvc-eb692323-553e-4350-8749-d972ff785567   1Gi        RWX            Delete           Bound    default/registry-claim   nfs-client              8s</span><br></pre></td></tr></table></figure><p>查看nfs-server上的数据目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /data/k8s/nginx</span></span><br><span class="line">total 0</span><br><span class="line">drwxrwxrwx 2 root root 6 Nov 23 10:28 default-test-claim-pvc-eb692323-553e-4350-8749-d972ff785567</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们所说的容器的持久化，实际上应该理解为宿主机中volume的持久化，因为Pod是支持销毁重建的，所以只能通过宿主机volume持久化，然后挂载到Pod内部来实现Pod的数据持久化。</p><p>宿主机上的volume持久化，因为要支持数据漂移，所以通常是数据存储在分布式存储中，宿主机本地挂载远程存储（NFS，Ceph，OSS），这样即使Pod漂移也不影响数据。</p><p>k8s的pod的挂载盘通常的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/kubelet/pods/&lt;Pod的ID&gt;/volumes/kubernetes.io~&lt;Volume类型&gt;/&lt;Volume名字&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成自签名SSL证书</title>
      <link href="/generate-a-self-signed-ssl-certificate/"/>
      <url>/generate-a-self-signed-ssl-certificate/</url>
      
        <content type="html"><![CDATA[<img src="/post/ssl/ssl-cover.png" height="700px" alt="cover"><p>平常我们在开发的时候，经常需要使用到SSL证书，比如说使用https协议，或者使用双向认证等，这时候我们就需要生成SSL证书，这里介绍一下如何生成自签名的SSL证书。</p><span id="more"></span><h1 id="证书的基本概念"><a href="#证书的基本概念" class="headerlink" title="证书的基本概念"></a>证书的基本概念</h1><h2 id="证书的基本格式"><a href="#证书的基本格式" class="headerlink" title="证书的基本格式"></a>证书的基本格式</h2><ul><li>x509: 证书的格式，它是一种标准，定义了证书的格式</li><li>pem和der: 两种编码格式，pem是base64编码，der是二进制编码</li><li>crt和cer: 两种后缀名，crt一般是pem编码，cer一般是der编码</li><li>csr: 证书签名请求，这个并不是证书，而是向证书颁发机构申请证书的文件，包含了申请者的信息和公钥</li><li>key: 常见的私钥的后缀名</li></ul><h2 id="数字证书和公钥的关系"><a href="#数字证书和公钥的关系" class="headerlink" title="数字证书和公钥的关系"></a>数字证书和公钥的关系</h2><p>数字证书是由证书颁发机构（CA）签发的，证书颁发机构（CA）是一个可信任的第三方机构，它会对证书申请者的身份进行验证，然后签发证书。</p><p>证书颁发机构（CA）会对证书申请者的身份进行验证，然后签发证书，证书中包含了申请者的公钥，证书颁发机构（CA）会对申请者的公钥进行签名，这样就形成了数字证书。</p><p>当客户端需要验证服务端的身份时，客户端会向服务端请求证书，服务端会将证书发送给客户端，客户端会验证证书的合法性，验证的过程是这样的：</p><ol><li>客户端会从证书中获取证书颁发机构（CA）的公钥</li><li>客户端会使用证书颁发机构（CA）的公钥对证书中的签名进行验证，如果验证通过，则证明证书是合法的</li><li>客户端会从证书中获取服务端的公钥</li><li>客户端会使用服务端的公钥对数据进行加密，然后发送给服务端</li><li>服务端会使用自己的私钥对数据进行解密，然后进行处理</li><li>服务端会使用客户端的公钥对数据进行加密，然后发送给客户端</li><li>客户端会使用自己的私钥对数据进行解密，然后进行处理</li><li>服务端和客户端就可以进行通信了</li><li>服务端和客户端会使用对称加密算法对数据进行加密，然后进行通信</li></ol><h3 id="x509证书"><a href="#x509证书" class="headerlink" title="x509证书"></a>x509证书</h3><p>x.509 是一种证书格式，它是一种标准，定义了证书的格式。它其实是作为x.500标准的一部分而出现的，x.500标准定义了唯一标识一个实体的信息，该实体可以是机构、组织、个人或一台服务器。而x.509则把该实体与公钥绑定在一起，从而提供了通信实体的鉴别机制，也就是目前最流行的x.509数字证书。</p><p>通常说的证书，就是指x.509数字证书，它是一种非常通用的证书格式，几乎所有的证书都是基于x.509的，如果不特别说明，都是指x.509 v3版本的证书。</p><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>HyperText Transfer Protocol，超文本传输协议，是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式。HTTP传输的是明文，未加密的数据，因此不安全。</p><p>TCP端口默认为80</p><h2 id="https-1"><a href="#https-1" class="headerlink" title="https"></a>https</h2><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS传输的数据是加密的，保证会话过程的安全性。</p><p>TCP端口默认为443</p><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>SSL（Secure Sockets Layer），安全套接层，位于可靠的面向连接的网络层协议和应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol）和SSL握手协议（SSL Handshake Protocol）。</p><p>SSL协议既用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p><ul><li>对称加密：速度高，可加密内容较大，用来加密会话过程中的消息</li><li>公钥加密：加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</li></ul><h1 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h1><p>对称加密就是加密和解密使用的是同一个密钥，非对称加密就是加密和解密使用的是不同的密钥。</p><h2 id="对称加密和非对称加密的优缺点"><a href="#对称加密和非对称加密的优缺点" class="headerlink" title="对称加密和非对称加密的优缺点"></a>对称加密和非对称加密的优缺点</h2><p>对称加密的优点是加密和解密速度快，缺点是密钥的传输比较麻烦，因为密钥的传输也需要加密，如果密钥也被泄露了，那么加密就没有意义了。</p><p>非对称加密的优点是密钥的传输比较方便，因为加密和解密使用的是不同的密钥，缺点是加密和解密速度比较慢。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密的密钥分为公钥和私钥，公钥可以公开，私钥不能公开，公钥加密的数据只能使用私钥解密，私钥加密的数据只能使用公钥解密。</p><p>因为公钥是公开的，因此私钥加密的数据就都会被知道了。所以一般情况下，私钥加密的数据被用来作身份验证使用，比如说数字签名。</p><p>非对称加密已然存在安全隐患，比如此时也有一个中间人，他也生成了自己的公钥和私钥，并且先一步与客户端和服务器端建立了连接，获取了服务器端的公钥又把自己的公钥发送给了客户端，那么此时中间人已经可以获取甚至篡改客户端和服务器端的所有通信数据了。</p><p>为了解决这个问题，就出现了另外一个办法，需要一个权威的第三方平台，这个平台叫做证书颁发机构（Certificate Authority，CA），这个方法有个前提，就是客户端需要知道CA的公钥。 CA会对申请者的身份进行验证，然后签发证书，证书中包含了申请者的公钥，证书颁发机构（CA）会对申请者的公钥进行签名，这样就形成了数字证书。</p><p>CA工作流程如下：</p><ol><li>CA用自己的私钥对证书中的信息进行签名，生成自签名证书</li><li>服务端给CA发送请求，CA用自己的私钥和证书，对服务端的私钥进行签名，生成证书，证书中包含了服务端的公钥信息</li><li>服务端把自己的证书发送给客户端，客户端使用CA的公钥对证书中的签名进行验证，如果验证通过，则证明证书是合法的</li><li>最后客户端就可以使用这个证书和服务端进行通信了</li></ol><h1 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h1><p>认证方式分为两种，一种是单向认证，一种是双向认证。具体使用哪种认证方式，是由服务端决定的。</p><h2 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h2><p>单向认证就是服务端向客户端证明自己的身份，客户端不需要证明自己的身份。</p><p><img src="/post/ssl/single-authentication.webp" alt="single-authentication"></p><p>认证过程如下：</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：<ul><li>证书是否过期</li><li>发行服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li><li>验证通过后，将继续进行通信，否则，终止通信</li></ul></li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</li><li>服务器将选择好的加密方案通过明文方式返回给客户端</li><li>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</li><li>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</li></ol><h2 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h2><p>双向认证就是服务端向客户端证明自己的身份，客户端也需要证明自己的身份。</p><p><img src="/post/ssl/double-authentication.webp" alt="double-authentication"></p><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：<ul><li>证书是否过期</li><li>发行服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li><li>验证通过后，将继续进行通信，否则，终止通信</li></ul></li><li>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</li><li>验证客户端的证书，通过验证后，会获得客户端的公钥</li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</li><li>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</li><li>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</li><li>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</li></ol><h1 id="生成自签名SSL证书"><a href="#生成自签名SSL证书" class="headerlink" title="生成自签名SSL证书"></a>生成自签名SSL证书</h1><p>我们平常使用的SSL证书，一般都是通过证书颁发机构（CA）签发的。这些证书都是内装在操作系统或者浏览器中，CA机构要么会向操作系统或者浏览器厂商支付一定的费用，要么足够强大到物理消灭项目，因此这些证书都是内装的。</p><p>既然机构能够将根证书内装了，那么他们就可以自己售卖签发的证书了，这些证书就会进行高昂的收费。如果我们安全性并没有那么高，我们可以自己生成自签名证书，这样就可以免费使用了。</p><h2 id="生成证书过程"><a href="#生成证书过程" class="headerlink" title="生成证书过程"></a>生成证书过程</h2><p>生成证书的过程如下：</p><ol><li>生成私钥(.key)</li><li>生成证书签名请求(.csr)</li><li>将证书请求文件(.csr)提交给证书颁发机构（CA），CA会对提交的证书请求中的所有信息生成一个摘要，然后使用CA根证书对应的私钥对摘要进行加密，生成签名，然后将签名和证书请求文件(.csr)一起打包，生成证书(.crt或.cer)</li><li>用户拿到签发后的证书，可能需要导入到自己的密钥库中，或根据需要再进行各种格式的转换（.pem、.pfx、.p12等）</li></ol><p>生成自签名SSL证书有两个工具可以使用，一个是<code>openssl</code>，另一个是<code>cfssl</code></p><h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><h3 id="根证书私钥"><a href="#根证书私钥" class="headerlink" title="根证书私钥"></a>根证书私钥</h3><p>根证书就是自己的CA证书，它是自签名的，因此需要自己生成私钥，然后用私钥生成自签名证书。</p><p>如果只是一个网站，那么直接生成一个证书就可以了，因为网站不验证用户的身份。但是，如果是一个需要双向认证的系统，比如物联网设备等，每个连接都单独生成证书的话就太多了，这时候通过CA生成证书就比较方便了。</p><p>这里我们模仿的是需要认证机构的场景，因此需要生成CA证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line"><span class="comment"># genrsa: 生成RSA私有密钥，不会生成公钥，因为公钥是由私钥生成的。生成时可以指定私钥的长度，一般为1024位或2048位。如果需要查看公钥或者生成公钥，可以使用 openssl ras</span></span><br><span class="line"><span class="comment"># -out: 指定生成的私钥文件的路径</span></span><br><span class="line"><span class="comment"># -des|-des3|-idea: 指定私钥的加密算法，如果不指定，则不会对私钥进行加密。如果指定，则每次使用私钥时都需要输入密码，太麻烦所以一般不指定</span></span><br><span class="line"><span class="comment"># -passout: 指定私钥的密码，如果不指定，则提示输入密码。</span></span><br><span class="line"><span class="comment"># numbits: 指定私钥的长度，默认为1024，这里指定的是8192，一般4096就已经无法被太阳系总算力在几千年内破解了。这个参数必须为命令行参数的最后一个参数</span></span><br><span class="line">$ openssl genrsa -out ca-key.pem 8192</span><br><span class="line">Generating RSA private key, 8192 bit long modulus (2 primes)</span><br><span class="line">......................................+++</span><br><span class="line">..................................................+++</span><br><span class="line">e is 65537 (0x010001)</span><br></pre></td></tr></table></figure><p>此时直接查看私钥内容，会发现一段ASCII码，具体的私钥内容需要使用以下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsa -<span class="keyword">in</span> ca-key.pem -noout -text</span><br></pre></td></tr></table></figure><h3 id="生成根证书签发申请文件CSR"><a href="#生成根证书签发申请文件CSR" class="headerlink" title="生成根证书签发申请文件CSR"></a>生成根证书签发申请文件CSR</h3><p>在正式的证书申请时，需要向证书颁发机构（CA）提交证书签发申请文件CSR，这个文件中包含了申请者的信息和公钥。</p><p>这里这个申请文件是用来生成自签名证书的，用来最后生成的证书作为整体认证使用。根证书信息可以不填，但是如果是为了演示的正常，可以填写一些信息。</p><p>生成证书签发申请文件CSR的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># req: 生成证书签发申请文件CSR</span></span><br><span class="line"><span class="comment"># -new: 生成新的证书签发申请文件CSR</span></span><br><span class="line"><span class="comment"># -key: 指定私钥文件</span></span><br><span class="line"><span class="comment"># -out: 指定生成的证书签发申请文件CSR的路径</span></span><br><span class="line"><span class="comment"># -subj: 指定证书签发申请文件CSR中的信息，这里指定了国家、省份、城市、公司、部门、邮箱、域名等信息，如果不指定，则需要手动输入</span></span><br><span class="line"><span class="comment"># $ openssl req -new -key ca-key.pem -out ca.csr -subj &quot;/C=CN/ST=beijing/L=beijing/O=test-on/OU=test-ou/CN=test-fqdn/emailAddress=test@example.com&quot;</span></span><br><span class="line">$ openssl req -new -key ca-key.pem -out ca.csr</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">&#x27;.&#x27;</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [AU]:CN</span><br><span class="line">State or Province Name (full name) [Some-State]:beijing</span><br><span class="line">Locality Name (eg, city) []:beijing</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:test-on</span><br><span class="line">Organizational Unit Name (eg, section) []:test-ou</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:test-fqdn</span><br><span class="line">Email Address []:<span class="built_in">test</span>@example.com</span><br><span class="line"></span><br><span class="line">Please enter the following <span class="string">&#x27;extra&#x27;</span> attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br></pre></td></tr></table></figure><p>如果报错 <code>Can&#39;t load /home/aaron/.rnd into RNG</code>，则需要执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/aaron</span><br><span class="line">openssl rand -writerand .rnd</span><br></pre></td></tr></table></figure><p>如果想查看证书签发申请文件CSR的内容，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -<span class="keyword">in</span> ca.csr -noout -text</span><br><span class="line">Certificate Request:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 1 (0x0)</span><br><span class="line">        Subject: C = CN, ST = beijing, L = beijing, O = test-on, OU = test-ou, CN = test-fqdn, emailAddress = <span class="built_in">test</span>@example.com</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                RSA Public-Key: (8192 bit)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h3 id="生成自签名证书-CER"><a href="#生成自签名证书-CER" class="headerlink" title="生成自签名证书 CER"></a>生成自签名证书 CER</h3><p>根证书的私钥、签发请求文件都有了，现在可以自己给自己办法一个证书了。这个生成的证书就是公钥，包含了证书持有组织的信息以及公钥、公钥的哈希校验。后面使用该根证书签发的证书都可以递归到该根证书，证明可信，从而实现信任链。</p><p>根证书需要存储到所有设备中，而且必须是通过”可信的“方式。因为其他证书能靠它来验证，但是它自己没办法验证自己。</p><p>生成自签名证书的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x509: 生成x509证书</span></span><br><span class="line"><span class="comment"># -req: 指定证书签发申请文件CER</span></span><br><span class="line"><span class="comment"># -in: 指定证书签发申请文件CSR</span></span><br><span class="line"><span class="comment"># -signkey: 指定私钥文件</span></span><br><span class="line"><span class="comment"># -out: 指定生成的证书文件CER的路径</span></span><br><span class="line"><span class="comment"># -days: 指定证书的有效期，单位为天，默认为30天</span></span><br><span class="line"><span class="comment"># -sha256: 指定签名算法为sha256，默认为sha1，sha1已经找到暴力撞值的方法，因此不安全了</span></span><br><span class="line">$ openssl x509 -req -days 3650 -sha256 -signkey ca-key.pem -<span class="keyword">in</span> ca.csr -out ca.cer</span><br><span class="line">Signature ok</span><br><span class="line">subject=C = CN, ST = beijing, L = beijing, O = test-on, OU = test-ou, CN = test-fqdn, emailAddress = <span class="built_in">test</span>@example.com</span><br><span class="line">Getting Private key</span><br></pre></td></tr></table></figure><p>此时直接查看证书内容，也会发现是一段ASCII码，具体的证书内容使用以下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -<span class="keyword">in</span> ca.cer -noout -text</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 1 (0x0)</span><br><span class="line">        Serial Number:</span><br><span class="line">            67:6b:09:ad:8e:e9:05:60:9d:d3:f5:c5:2a:27:20:14:b0:59:14:a3</span><br><span class="line">        Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C = CN, ST = beijing, L = beijing, O = test-on, OU = test-ou, CN = test-fqdn, emailAddress = <span class="built_in">test</span>@example.com</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Oct 24 15:24:37 2023 GMT</span><br><span class="line">            Not After : Oct 21 15:24:37 2033 GMT</span><br><span class="line">        Subject: C = CN, ST = beijing, L = beijing, O = test-on, OU = test-ou, CN = test-fqdn, emailAddress = <span class="built_in">test</span>@example.com</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h3 id="一步生成自签名证书"><a href="#一步生成自签名证书" class="headerlink" title="一步生成自签名证书"></a>一步生成自签名证书</h3><p>上面的方法使用了三步，生成私钥、生成证书签发申请文件、生成自签名证书。其实可以一步生成私钥以及自签名证书，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># req: 生成证书文件</span></span><br><span class="line"><span class="comment"># -newkey: 生成新的私钥的命令，指定算法以及密钥长度，这里指定了rsa算法，长度为2048位</span></span><br><span class="line"><span class="comment"># -nodes: 表示私钥不加密，如果不带参数，则表示私钥加密，会提示输入密码</span></span><br><span class="line"><span class="comment"># -keyout: 指定生成的私钥文件的路径</span></span><br><span class="line"><span class="comment"># -x509: 指定生成的是x509证书，而不是证书签发申请文件</span></span><br><span class="line"><span class="comment"># -days: 指定证书的有效期，单位为天，默认为30天</span></span><br><span class="line"><span class="comment"># -out: 指定生成的证书文件的路径</span></span><br><span class="line"><span class="comment"># -subj: 指定证书中的信息，这里指定了国家、省份、城市、公司、部门、邮箱、域名等信息，如果不指定，则需要手动输入</span></span><br><span class="line">$ openssl req -newkey rsa:2048 -nodes -keyout ca-key.pem -x509 -days 3650 -out ca.cer -subj <span class="string">&quot;/C=CN/ST=beijing/L=beijing/O=test-on/OU=test-ou/CN=test-fqdn/emailAddress=test@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>这一段只是一个扩展知识，因为命令太长了，我个人见用的人还是比较少的。</p><h3 id="生成网站用私钥PEM"><a href="#生成网站用私钥PEM" class="headerlink" title="生成网站用私钥PEM"></a>生成网站用私钥PEM</h3><p>我们现在已经有了根证书，作为CA的存在。现在我们拿CA来给网站签发证书。这样网站就可以用CA来验证证书的合法性，进行https通信了。</p><p>每个网站都有自己的子证书，证书可以层层嵌套，即使是子证书也可以再签发孙子证书，这样就形成了证书链。这里我们只需要二级就行了。</p><p>实际中，越靠近权威根证书，则证书越可信，如果花钱买的话，也就越贵。</p><p>生成业务用私钥PEM的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -out server.key 2048</span><br><span class="line">Generating RSA private key, 2048 bit long modulus (2 primes)</span><br><span class="line">...........................................................+++++</span><br><span class="line">..................................................................+++++</span><br><span class="line">e is 65537 (0x010001)</span><br></pre></td></tr></table></figure><p>一般来说，子证书的存续时间与加密强度都不如根证书。</p><p>子证书事需要颁发出去的。根证书的私钥只有签发机构有，但是子证书的私钥需要给各个业务使用，因此需要将子证书的私钥导出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rsa: 生成RSA私钥。如果上一步使用的其他算法生成的私钥，这里需要执行。否则执行前后没有变化</span></span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> server.key -out server.key</span><br></pre></td></tr></table></figure><h3 id="生成网站用证书签发申请文件CSR"><a href="#生成网站用证书签发申请文件CSR" class="headerlink" title="生成网站用证书签发申请文件CSR"></a>生成网站用证书签发申请文件CSR</h3><p>注意，由于这里测试的是给网站使用的，证书的请求文件中的CN必须是域名，否则浏览器会报错。这里我们假定测试的域名为<code>cert.galaxy.com</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -new -key server.key -out server.csr</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">&#x27;.&#x27;</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [AU]:CN</span><br><span class="line">State or Province Name (full name) [Some-State]:BEIJING</span><br><span class="line">Locality Name (eg, city) []:BEIJING</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:server-on</span><br><span class="line">Organizational Unit Name (eg, section) []:server-ou</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:cert.galaxy.com</span><br><span class="line">Email Address []:cert@galaxy.com</span><br><span class="line"></span><br><span class="line">Please enter the following <span class="string">&#x27;extra&#x27;</span> attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br></pre></td></tr></table></figure><h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>有时候，网站即使 <code>Common Name</code> 和域名是一样的，但是浏览器还是会报错 <code>NET::ERR_CERT_COMMON_NAME_INVALID</code>，这是因为证书中没有正确的嵌入域名信息，这时候就需要在配置文件中指定域名了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成配置文件，指定域名。</span></span><br><span class="line">$ <span class="built_in">cat</span> server.dns.ext</span><br><span class="line">keyUsage = nonRepudiation, digitalSignature, keyEncipherment</span><br><span class="line">extendedKeyUsage = serverAuth, clientAuth</span><br><span class="line">subjectAltName=@SubjectAlternativeName</span><br><span class="line"></span><br><span class="line">[ SubjectAlternativeName ]</span><br><span class="line">DNS.1=galaxy.com</span><br><span class="line">DNS.2=cert.galaxy.com</span><br></pre></td></tr></table></figure><p>配置文件格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">keyUsage = nonRepudiation, digitalSignature, keyEncipherment</span><br><span class="line">extendedKeyUsage = serverAuth, clientAuth</span><br><span class="line">subjectAltName=@SubjectAlternativeName</span><br><span class="line"> </span><br><span class="line">[SubjectAlternativeName]</span><br><span class="line">DNS.1=your.domain.name</span><br><span class="line">DNS.2=此处填写你的网站的域名.cn</span><br><span class="line">DNS.3=如果有多个域名就这么增加.com</span><br><span class="line">DNS.4=*.当然支持泛解析域名.net</span><br></pre></td></tr></table></figure><p>如果没有域名，而是有固定IP，可以使用以下格式文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">keyUsage = nonRepudiation, digitalSignature, keyEncipherment</span><br><span class="line">extendedKeyUsage = serverAuth, clientAuth</span><br><span class="line">subjectAltName=@SubjectAlternativeName</span><br><span class="line"> </span><br><span class="line">[SubjectAlternativeName]</span><br><span class="line">IP.1=192.168.100.1</span><br><span class="line">IP.2=222.90.100.1</span><br></pre></td></tr></table></figure><h3 id="生成网站用证书-CER"><a href="#生成网站用证书-CER" class="headerlink" title="生成网站用证书 CER"></a>生成网站用证书 CER</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x509: 生成x509证书</span></span><br><span class="line"><span class="comment"># -req: 指定证书签发申请文件CER</span></span><br><span class="line"><span class="comment"># -days: 指定证书的有效期，单位为天，默认为30天</span></span><br><span class="line"><span class="comment"># -CA: 指定CA证书</span></span><br><span class="line"><span class="comment"># -CAkey: 指定CA证书的私钥</span></span><br><span class="line"><span class="comment"># -CAcreateserial: 指定生成序列号文件。当签署证书时，CA需要为每个证书生成一个唯一的序列号，因此颁发者需要跟踪它以前使用过哪些序列号。这个选项会将一个随机数分配给签名证书，然后创建此序列号文件。</span></span><br><span class="line"><span class="comment"># -CAserial: 指定CA证书的序列号文件。将每个证书的唯一序列号都存储在文件中，以便在下次签署证书时使用。这样即使创建多个证书，也不会出现重复的序列号。</span></span><br><span class="line"><span class="comment"># -in: 指定证书签发申请文件CSR</span></span><br><span class="line"><span class="comment"># -out: 指定生成的证书文件CRT的路径</span></span><br><span class="line"><span class="comment"># -extfile: 指定配置文件</span></span><br><span class="line"><span class="comment"># -extensions: 指定配置文件中的扩展字段</span></span><br><span class="line">$ openssl x509 -req -days 730 -sha256 -CA ca.cer -CAkey ca-key.pem -CAserial ca.srl -CAcreateserial -<span class="keyword">in</span> server.csr -out server.cer -extfile server.dns.ext</span><br><span class="line">Signature ok</span><br><span class="line">subject=C = CN, ST = BEIJING, L = BEIJING, O = server-on, OU = server-ou, CN = cert.galaxy.com, emailAddress = cert@galaxy.com</span><br><span class="line">Getting CA Private Key</span><br></pre></td></tr></table></figure><p>以上是生成的证书全过程，如果只有IP，则将最后的配置文件改为记录IP的文件即可。</p><p>通过证书获取公钥的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -pubkey -<span class="keyword">in</span> server.cer -noout</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="comment">### 证书格式转换</span></span><br><span class="line"></span><br><span class="line">可能有时候需要将证书转换为其他格式，比如说pfx格式，这时候就需要进行转换了。这里实验并不需要进行格式转换，因此转换操作仅是记录。</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 将证书转换为pfx格式</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> server.cer -inkey server.key -out server.pfx</span><br><span class="line"><span class="comment"># 转换为pem格式，如果后缀名不标准的话还需要指定-inform der</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> server.cer -out server.pem -outform pem</span><br><span class="line"><span class="comment"># 转换为der格式，如果后缀名不标准的话还需要指定-outform pem</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> server.cer -out server.der -outform der</span><br></pre></td></tr></table></figure><h3 id="客户端证书"><a href="#客户端证书" class="headerlink" title="客户端证书"></a>客户端证书</h3><p>如果需要客户端证书，那么就需要生成客户端证书了。客户端证书的生成方式和网站证书的生成方式是一样的，只是在生成证书签发申请文件CSR时，需要将<code>Common Name</code>改为客户端的名称，比如说<code>client.galaxy.com</code>。</p><p>简单来说，就是客户端证书和服务端证书是同级的两套不同的证书。</p><h2 id="使用证书"><a href="#使用证书" class="headerlink" title="使用证书"></a>使用证书</h2><p>经过上面的步骤，我们已经生成了根证书和网站证书，现在我们就可以使用这个证书了。</p><p>这里我使用的docker方式启动了一个nginx，然后将证书挂载到容器中，这样就可以使用https协议了。其他的服务也是类似的。</p><p>首先将所有的证书文件放到一个目录中，这里我放到了<code>/data/docker/nginx/conf/ssl</code>目录中。然后新建nginx配置文件，书写配置即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建证书目录，将证书文件放到该目录中</span></span><br><span class="line">$ <span class="built_in">mkdir</span> -p /data/docker/nginx/conf/ssl</span><br><span class="line"><span class="comment"># 将证书文件放到该目录中，根据自己情况进行复制即可。我之前的证书都下载到了家目录下的cert目录中，因此从这里进行复制</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/cert</span><br><span class="line">$ <span class="built_in">cp</span> server.cer server.key /data/docker/nginx/conf/ssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建nginx配置文件</span></span><br><span class="line">$ vim /data/docker/nginx/conf/ssl-test.conf</span><br><span class="line">$ <span class="built_in">cat</span> /data/docker/nginx/conf/ssl-test.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    listen  [::]:443 ssl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 网站域名</span></span><br><span class="line">    server_name cert.galaxy.com;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 证书文件</span></span><br><span class="line">    ssl_certificate conf.d/ssl/server.cer;</span><br><span class="line">    <span class="comment"># 证书私钥文件</span></span><br><span class="line">    ssl_certificate_key conf.d/ssl/server.key;</span><br><span class="line">    </span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    </span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nginx-ssl -p 443:443 -v /data/docker/nginx/conf/:/etc/nginx/conf.d -d nginx:1.23-alpine</span><br></pre></td></tr></table></figure><p>然后就可以使用https协议访问了。</p><h3 id="访问截图"><a href="#访问截图" class="headerlink" title="访问截图"></a>访问截图</h3><p>直接访问会提示警告，因为证书是自签名的，不被浏览器信任。</p><p><img src="/post/ssl/err_cert_authority_invalid.png" alt="err cert authority invalid"></p><p>点开高级，点击继续访问。</p><p><img src="/post/ssl/err_cert_authority_invalid_go_on.png" alt="err cert authority invalid go on"></p><p>此时访问成功，但是浏览器地址栏前面会提示不安全。</p><p><img src="/post/ssl/err_cert_authority_invalid_page.png" alt="err cert authority invalid page"></p><p>点击地址栏前面的提示信息，可以看到证书的警告信息，证书也提示是无效的。</p><p><img src="/post/ssl/err_cert_authority_invalid_warning.png" alt="err cert authority invalid warning"></p><p>点击证书那个按钮，可以看到证书的详细信息。</p><p><img src="/post/ssl/err_cert_authority_invalid_cert.png" alt="err cert authority invalid cert"></p><p>点击消息信息，可以看到证书的详细信息。可以看到证书层次结构中只有一个证书，就是自己这个证书。</p><p><img src="/post/ssl/err_cert_authority_invalid_cert_struct.png" alt="err cert authority invalid cert struct"></p><h3 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h3><p>如果是自签名的证书，那么证书链就只有一个证书，就是自己的证书。如果是CA签发的证书，那么证书链就有多个证书，这些证书都是CA签发的，最后一个证书就是自己的证书。</p><p>对应我们之前的证书，现在地址栏会提示不安全，那怎么提示安全访问呢？这时候就需要将根证书导入到浏览器中，这样浏览器就会完成整个证书链的验证信任这个证书了。</p><p>首先，我们要导入根证书，这里我们使用chrome浏览器进行导入。打开浏览器的设置，然后隐私和安全侧边栏，然后点击管理证书，选择授权机构，然后点击导入。</p><p><img src="/post/ssl/cert_with_ca_chrome_manage.png" alt="cert with ca chrome manage"></p><p>我们选择对应的ca证书文件，这里我们创建的是<code>ca.cer</code>，然后点击打开。</p><p><img src="/post/ssl/cert_with_ca_chrome_select.png" alt="cert with ca chrome select"></p><p>导入的时候会选择证书的身份，这里我们选择网站，然后点击确定。注意，这里会显示证书的FQDN信息，也就是创建的时候<code>Common Name</code>的信息。</p><p><img src="/post/ssl/cert_with_ca_chrome_load.png" alt="cert with ca chrome load"></p><p>导入证书之后。在列表中一直往下拉，名字组成是<code>org-&#123;Organizational Unit Name&#125;</code>，点开就可以看到<code>Organizational Unit Name</code>和<code>Common Name</code>信息。</p><p><img src="/post/ssl/cert_with_ca_chrome_list.png" alt="cert with ca chrome list"></p><p>点击证书后面的操作按钮。如果之后想要删除证书，可以点击删除按钮。这里我们要看根证书的详细信息，因此点击视图按钮。</p><p><img src="/post/ssl/cert_with_ca_chrome_operation.png" alt="cert with ca chrome operation"></p><p>可以看到这是一个自签名的证书，证书的层次结构中只有一个证书，就是自己的证书。</p><p><img src="/post/ssl/cert_with_ca_chrome_ca_info.png" alt="cert with ca chrome ca info"></p><p>此时再访问 <code>https://127.0.0.1</code> 就会提示错误信息 <code>NET::ERR_CERT_COMMON_NAME_INVALID</code>，因为证书中的域名和访问的域名不一致。</p><p><img src="/post/ssl/cert_with_ca_common_name_invalid.png" alt="cert with ca common name invalid"></p><p>现在我们在本地的host中加入域名映射，然后再访问 <code>https://cert.galaxy.com</code></p><p>此时访问直接就会成功了，而且浏览器地址栏前面也不会提示不安全了，地址栏前面取而代之的是一个锁型图标。</p><p><img src="/post/ssl/cert_with_ca_success.png" alt="cert with ca success"></p><p>点击地址栏前面的锁型图标，可以看到证书的信息。此时信息提示是安全的，同时提示证书是有效的。</p><p><img src="/post/ssl/cert_with_ca_valid.png" alt="cert with ca valid"></p><p>点击证书按钮，查看证书信息。</p><p><img src="/post/ssl/cert_with_ca_cert_info.png" alt="cert with ca cert info"></p><p>点击详细信息，可以看到证书的详细信息。可以看到证书层次结构中有两个证书，第一个证书就是自己的证书，第二个证书就是根证书。这里的根证书就是我们之前导入的证书。</p><p>因为证书链中的证书都是CA签发的，因此浏览器就会信任这个证书了。</p><p><img src="/post/ssl/cert_with_ca_cert_struct.png" alt="cert with ca cert struct"></p><h2 id="cfssl"><a href="#cfssl" class="headerlink" title="cfssl"></a>cfssl</h2><p>cfssl是一个云原生的证书管理工具，可以用来生成证书、签发证书、管理证书等。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>cfssl需要我们先下载二进制程序，然后才能进行使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载cfssl</span></span><br><span class="line">$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O /usr/bin/cfssl</span><br><span class="line"><span class="comment"># 下载cfssljson</span></span><br><span class="line">$ wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O /usr/bin/cfssl-json</span><br><span class="line"><span class="comment"># 下载cfssl-certinfo</span></span><br><span class="line">$ wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -O /usr/bin/cfssl-certinfo</span><br><span class="line"><span class="comment"># 设置文件权限</span></span><br><span class="line">$ <span class="built_in">chmod</span> +x /usr/bin/cfssl*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建证书目录</span></span><br><span class="line">$ <span class="built_in">mkdir</span> -p /opt/certs</span><br><span class="line">$ <span class="built_in">cd</span> /opt/certs</span><br></pre></td></tr></table></figure><h3 id="生成根证书"><a href="#生成根证书" class="headerlink" title="生成根证书"></a>生成根证书</h3><p>生成证书配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ vim /opt/certs/ca-csr.json</span><br><span class="line">$ <span class="built_in">cat</span> /opt/certs/ca-csr.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;CN&quot;</span>: <span class="string">&quot;ca.galaxy.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;names&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ST&quot;</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">            <span class="string">&quot;L&quot;</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">            <span class="string">&quot;O&quot;</span>: <span class="string">&quot;test-on&quot;</span>,</span><br><span class="line">            <span class="string">&quot;OU&quot;</span>: <span class="string">&quot;test-ou&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;ca&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;expiry&quot;</span>: <span class="string">&quot;87600h&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成根证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gencert: 生成证书</span></span><br><span class="line"><span class="comment"># -initca: 指定生成根证书</span></span><br><span class="line"><span class="comment"># 只使用cfssl命令会将证书输出到标准输出，因此需要重定向到文件中</span></span><br><span class="line">$ cfssl gencert -initca ca-csr.json</span><br><span class="line">2023/10/30 21:20:06 [INFO] generating a new CA key and certificate from CSR</span><br><span class="line">2023/10/30 21:20:06 [INFO] generate received request</span><br><span class="line">2023/10/30 21:20:06 [INFO] received CSR</span><br><span class="line">2023/10/30 21:20:06 [INFO] generating key: rsa-2048</span><br><span class="line">2023/10/30 21:20:07 [INFO] encoded CSR</span><br><span class="line">2023/10/30 21:20:07 [INFO] signed certificate with serial number 664542684350169622832034206885696124480833745240</span><br><span class="line">&#123;<span class="string">&quot;cert&quot;</span>:<span class="string">&quot;-----BEGIN CERTIFICATE-----\nMIIDzjCCAragAwIBAgIUdGcf5FWyqUAx3gID1+gF9KMAcVgwDQYJKoZIhvcNAQEL\nBQAwbTELMAkGA1UEBhMCQ04xEDAOBgNVBAgTB2JlaWppbmcxEDAOBgNVBAcTB2Jl\naWppbmcxEDAOBgNVBAoTB3Rlc3Qtb24xEDAOBgNVBAsTB3Rlc3Qtb3UxFjAUBgNV\nBAMTDWNhLmdhbGF4eS5jb20wHhcNMjMxMDMwMTMxNTAwWhcNMzMxMDI3MTMxNTAw\nWjBtMQswCQYDVQQGEwJDTjEQMA4GA1UECBMHYmVpamluZzEQMA4GA1UEBxMHYmVp\namluZzEQMA4GA1UEChMHdGVzdC1vbjEQMA4GA1UECxMHdGVzdC1vdTEWMBQGA1UE\nAxMNY2EuZ2FsYXh5LmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAKvYTErhsIaKNuA7nzen4ttbDKNih1trigiFottMLkxot9Iv3cks04RTAYxb4bmT\nmPF1GuA2WyfCkvvq8oJY4E8DzR54GLmkpNaGsMUIOjkaltnSiEYn4UjFkQDKveg+\nOdYmNvYTbMwl8Bs7F+REKbjxBKR/khRYcWE2NdW2OThSlvtNhcmWntD3Bw2tQekb\nUMCesD3uc7h3D+V8wrYGi0aTxZDMaV8R0e8bQPBDaSOxa/ViMbom82mnGq9ma51O\nSjr1wJmh2GUMZwsTXaTM8lB9AyUdFsBKmyuM0CltEJ/mRpb/uDPWjiQe+gL57m/y\nlMBkcbsBbnuEccK80cYzsesCAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgEGMBIGA1Ud\nEwEB/wQIMAYBAf8CAQIwHQYDVR0OBBYEFLz7Dt3Drg9gb1VCbeboC6gh6Nt6MB8G\nA1UdIwQYMBaAFLz7Dt3Drg9gb1VCbeboC6gh6Nt6MA0GCSqGSIb3DQEBCwUAA4IB\nAQATDZKrQyrf77Lkj3TZsnDoXY5S3X4APRZVeat+hV39cO2ez+e1IG4gDUi2uxNR\nkfUh108HVA/nRqODrLfunBDCBAWOdeGuyFa2pOtG0T3CSngWfHN4LxzLOotYiFz4\nlcTYPAAew3MM4KmaKqofwG1mBkRCiRWNy/4cFFznCDMrW+srdt3DSAdJbqVneeGV\nusNpvgRXQZgME5+Ib0//FVaX3mxoiySw4RTuazqRuAHvLN9KJGHHuKzKI7+8GqpW\nttAJn4OD/XwYljJ15u48SKbJyP66d/spPDWLEiA60CXKrxWtpdmL0+XDXV2rLLoK\nrCk7sinyyBDYrMhSA3cJyHkC\n-----END CERTIFICATE-----\n&quot;</span>,<span class="string">&quot;csr&quot;</span>:<span class="string">&quot;-----BEGIN CERTIFICATE REQUEST-----\nMIICsjCCAZoCAQAwbTELMAkGA1UEBhMCQ04xEDAOBgNVBAgTB2JlaWppbmcxEDAO\nBgNVBAcTB2JlaWppbmcxEDAOBgNVBAoTB3Rlc3Qtb24xEDAOBgNVBAsTB3Rlc3Qt\nb3UxFjAUBgNVBAMTDWNhLmdhbGF4eS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQCr2ExK4bCGijbgO583p+LbWwyjYodba4oIhaLbTC5MaLfSL93J\nLNOEUwGMW+G5k5jxdRrgNlsnwpL76vKCWOBPA80eeBi5pKTWhrDFCDo5GpbZ0ohG\nJ+FIxZEAyr3oPjnWJjb2E2zMJfAbOxfkRCm48QSkf5IUWHFhNjXVtjk4Upb7TYXJ\nlp7Q9wcNrUHpG1DAnrA97nO4dw/lfMK2BotGk8WQzGlfEdHvG0DwQ2kjsWv1YjG6\nJvNppxqvZmudTko69cCZodhlDGcLE12kzPJQfQMlHRbASpsrjNApbRCf5kaW/7gz\n1o4kHvoC+e5v8pTAZHG7AW57hHHCvNHGM7HrAgMBAAGgADANBgkqhkiG9w0BAQsF\nAAOCAQEAH8uavX8ZPlOfphmHTcXtz5u/uaDSdXSF/Ktamkgc9XHXZHu08QiuU0Ae\nhL4iW6M1jyBImD2Eu/FHFRusBTH/GVZCT3pVnf1ngmCeHRPStEHLnEqzLuA1JySD\nM+ahhldlmbM22eMYrj6U3y9KkD4okiXEfiLCrhZQyA5Om6Ux9k/GCUFhDJLcup3m\nGmZXv+0e9oFChJd7TJNj0WMuJUjikAwFqUHWqhrO6Tn0YUIOn382hi4mSvN50E6R\nGSM8JRgeSn46ERpKG1N6/z9a9vEyMAHYvGidYfz2aykUyB8Xs002ZCmk0BFx/93w\nmVC9NroN3CUDDcj2LWvpkwwnMEeApQ==\n-----END CERTIFICATE REQUEST-----\n&quot;</span>,<span class="string">&quot;key&quot;</span>:<span class="string">&quot;-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEAq9hMSuGwhoo24DufN6fi21sMo2KHW2uKCIWi20wuTGi30i/d\nySzThFMBjFvhuZOY8XUa4DZbJ8KS++rygljgTwPNHngYuaSk1oawxQg6ORqW2dKI\nRifhSMWRAMq96D451iY29hNszCXwGzsX5EQpuPEEpH+SFFhxYTY11bY5OFKW+02F\nyZae0PcHDa1B6RtQwJ6wPe5zuHcP5XzCtgaLRpPFkMxpXxHR7xtA8ENpI7Fr9WIx\nuibzaacar2ZrnU5KOvXAmaHYZQxnCxNdpMzyUH0DJR0WwEqbK4zQKW0Qn+ZGlv+4\nM9aOJB76Avnub/KUwGRxuwFue4RxwrzRxjOx6wIDAQABAoIBAGGnBqO+4Mtzm3+N\nIgtEkjvI38Ow5+5hjA0Ps94eymiNUXhVzxjVKlWVvdl/FSSZ5V3BCEbFXMOZZGFX\nv/umecEtDdD0ukg0cZ+e5rDw3fU5UOPzKZGEdBcgfigPDh/9zGwPR0hK/ZZ9MJao\n3AjRW0xHWjYIcICzSarOXYVWiemgxtCwj4RXu4Ub83BAUupImtOzKfnQdStZ8wpk\nII13+J4RsB+l7ME6cC9moBJ4jt7G9i6OlZY8/JX2nmTHCyltLzg9QdxViRjyFETk\nvdfhj4YiYlcklTqlZ/WC9rOmQOrDwbx2SBqR5ahLaNFwTcgeFJ3i766GDd+3WkTv\nLAGvWFECgYEA1iwpuyPapPRd0lXJVXCKeLyplDxvLVd+JdqxSd79Gs6vqXX60g3Z\nzojjGQrwkRk0G0fI3hHohvrNaOaZr7MtNY8vfns7bFYXQ0dKD1MWJ9qF9zVjfhiy\nv4Y2HJRNt1HIazRlpSZh5IXWZDTQMM0cwIGDj8I/v+7lQwn9w0hKcPcCgYEAzWfp\nNdVuVCb6dHdN4njYE/DHd/H5CJHIkufP5HKeVCW3t2fjo6sw08AHaMrMrrgkAIfz\nrVfNAuW/cn48IkO8W+qq+1Hc2b/wsNbZB0sM5e5lvdn7sZlDdJJHGJybxwGsbuYZ\nv1lwwbCIj3KtOzFjbXdmMwFycyjtXfUhiky5va0CgYAk+hz+XXNbdYFZVkxbfwG5\nVMFmgYSkbG2wNXDUkzZZ0YOMm30BlTicqw+ifDwKoTJY32zzwl3GKDkcumugZSwS\nCjWl/brFuptrlzxXJv41RUpJ4yLZW4RJAvAGwSgl1W3n7HT8LYNLRDw+ssubEV68\ncd/4Cw6coa9dgrUYaTvJAwKBgQC1c4PaoI50HHLHi9TrqWEITH2JAeLCpTYQQGOw\nJWikYSVoCYhYvxPFGy/wbKZf+h8jsPWcPaHHW3nCBK3OfxPYBvfAR9LXMO3I6iKS\nhMQCIpUSH4xumTuzsLzJix85r8rJtM8t8C7hi7c3MVDCp6BzxTQs/qxB+velNrTI\nXXr/iQKBgQCNXdas7MwBxg5TUAbRbiMbQsJqeatLDc34ojckNxhT9896GLhXILHb\nTBRlOwd5mePRk9RxuCPzXWs3080QWDsMtEqCm2aTRcAtZpM0lAFGDInPVfjbvQ3n\nrr4Psi4TR0dcq2n6xwKDxHQHBw4mMwa+50lkE6l0foJ4LAgO0044ig==\n-----END RSA PRIVATE KEY-----\n&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看没有任何文件生成</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ca-csr.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过cfssl-json命令将证书输出到文件中</span></span><br><span class="line"><span class="comment"># -bare: 指定输出文件的前缀</span></span><br><span class="line">$ cfssl gencert -initca ca-csr.json | cfssl-json -bare ca</span><br><span class="line">2023/10/30 21:20:31 [INFO] generating a new CA key and certificate from CSR</span><br><span class="line">2023/10/30 21:20:31 [INFO] generate received request</span><br><span class="line">2023/10/30 21:20:31 [INFO] received CSR</span><br><span class="line">2023/10/30 21:20:31 [INFO] generating key: rsa-2048</span><br><span class="line">2023/10/30 21:20:32 [INFO] encoded CSR</span><br><span class="line">2023/10/30 21:20:32 [INFO] signed certificate with serial number 623569630703280871026003415413519558412232890993</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时查看就有证书文件了</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure><p>接下来还要创建ca配置文件，这个配置文件用来指定证书的有效期、签名算法等信息。为了之后创建各种类型的证书做一个通用的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ vim /opt/certs/ca-config.json</span><br><span class="line">$ <span class="built_in">cat</span> /opt/certs/ca-config.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;signing&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;default&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;expiry&quot;</span>: <span class="string">&quot;87600h&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;profiles&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;server&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;expiry&quot;</span>: <span class="string">&quot;87600h&quot;</span>,</span><br><span class="line">                <span class="string">&quot;usages&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;signing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;key encipherment&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;server auth&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;client auth&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;client&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;expiry&quot;</span>: <span class="string">&quot;87600h&quot;</span>,</span><br><span class="line">                <span class="string">&quot;usages&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;signing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;key encipherment&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;client auth&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各部分的含义如下：</p><ul><li>signing: 证书签名配置</li><li>default: 默认配置</li><li>expiry: 证书有效期</li><li>profiles: 证书配置</li><li>server&#x2F;client: 各配置的名称</li><li>usages: 证书用途<ul><li>signing: 证书签名</li><li>key encipherment: 密钥加密</li><li>server auth: 服务器端认证</li><li>client auth: 客户端认证</li></ul></li></ul><h3 id="服务器端证书"><a href="#服务器端证书" class="headerlink" title="服务器端证书"></a>服务器端证书</h3><p>这里我们以生成k8s-apiserver的证书为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成证书配置文件</span></span><br><span class="line">$ vim /opt/certs/apiserver-csr.json</span><br><span class="line">$ <span class="built_in">cat</span> /opt/certs/apiserver-csr.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;CN&quot;</span>: <span class="string">&quot;k8s-apiserver&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hosts&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;192.168.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kubernetes.default&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kubernetes.default.svc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kubernetes.default.svc.cluster&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kubernetes.default.svc.cluster.local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;10.4.7.10&quot;</span>,</span><br><span class="line">        <span class="string">&quot;10.4.7.21&quot;</span>,</span><br><span class="line">        <span class="string">&quot;10.4.7.22&quot;</span>,</span><br><span class="line">        <span class="string">&quot;10.4.7.23&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;names&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ST&quot;</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">            <span class="string">&quot;L&quot;</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">            <span class="string">&quot;O&quot;</span>: <span class="string">&quot;test-on&quot;</span>,</span><br><span class="line">            <span class="string">&quot;OU&quot;</span>: <span class="string">&quot;test-ou&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各部分的含义如下：</p><ul><li>CN: 证书的名称</li><li>hosts: 证书的域名或者IP地址。必须包含所有能访问的域名或者IP地址，否则会提示证书不安全。如果之后需要添加域名或者IP地址，那么就需要重新生成证书了。</li><li>key: 密钥配置<ul><li>algo: 密钥算法</li><li>size: 密钥长度</li></ul></li><li>names: 证书的其他信息<ul><li>C: 国家</li><li>ST: 省份</li><li>L: 城市</li><li>O: 组织</li><li>OU: 组织单位</li></ul></li></ul><p>有了请求文件就可以生成证书了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line"><span class="comment"># genceert: 生成证书</span></span><br><span class="line"><span class="comment"># -ca: 指定CA证书</span></span><br><span class="line"><span class="comment"># -ca-key: 指定CA证书的私钥</span></span><br><span class="line"><span class="comment"># -config: 指定配置文件</span></span><br><span class="line"><span class="comment"># -profile: 指定配置文件中的配置段</span></span><br><span class="line">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server apiserver-csr.json | cfssl-json -bare apiserver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看生成的证书</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">apiserver.csr  apiserver-csr.json  apiserver-key.pem  apiserver.pem  ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure><p>在K8S中，提取出签发证书时指定的CN(Common Name)，作为请求的用户名 (User Name), 从证书中提取O(Organization)字段作为请求用户所属的组 (Group)，然后传递给后面的授权模块。</p><h3 id="客户端证书-1"><a href="#客户端证书-1" class="headerlink" title="客户端证书"></a>客户端证书</h3><p>以下是生成客户端证书的步骤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成客户端证书配置文件</span></span><br><span class="line">$ vim /opt/certs/client-csr.json</span><br><span class="line">$ <span class="built_in">cat</span> /opt/certs/client-csr.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;CN&quot;</span>: <span class="string">&quot;k8s-node&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;names&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ST&quot;</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">            <span class="string">&quot;L&quot;</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">            <span class="string">&quot;O&quot;</span>: <span class="string">&quot;test-on&quot;</span>,</span><br><span class="line">            <span class="string">&quot;OU&quot;</span>: <span class="string">&quot;test-ou&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，生成客户端证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成客户端证书</span></span><br><span class="line">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client client-csr.json | cfssl-json -bare client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看生成的证书</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">apiserver.csr  apiserver-csr.json  apiserver-key.pem  apiserver.pem  ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem  client.csr  client-csr.json  client-key.pem  client.pem</span><br></pre></td></tr></table></figure><h3 id="使用证书-1"><a href="#使用证书-1" class="headerlink" title="使用证书"></a>使用证书</h3><p>如果我们的apiserver是二进制方式进行部署的，那么我们可以通过以下命令启动apiserver（假定kube-apiserver命令在&#x2F;opt中）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">./kube-apiserver \</span><br><span class="line">  --apiserver-count 2 \</span><br><span class="line">  --audit-log-path /data/logs/kubernetes/kube-apiserver/audit-log \</span><br><span class="line">  --audit-policy-file ./conf/audit.yaml \</span><br><span class="line">  --authorization-mode RBAC \</span><br><span class="line">  --client-ca-file ./certs/ca.pem \</span><br><span class="line">  --requestheader-client-ca-file ./certs/ca.pem \</span><br><span class="line">  --enable-admission-plugins NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota \</span><br><span class="line">  --etcd-cafile ./certs/ca.pem \</span><br><span class="line">  --etcd-certfile ./certs/client.pem \</span><br><span class="line">  --etcd-keyfile ./certs/client-key.pem \</span><br><span class="line">  --etcd-servers https://10.4.7.12:2379,https://10.4.7.21:2379,https://10.4.7.22:2379 \</span><br><span class="line">  --service-account-key-file ./certs/ca-key.pem \</span><br><span class="line">  --service-cluster-ip-range 192.168.0.0/16 \</span><br><span class="line">  --service-node-port-range 3000-29999 \</span><br><span class="line">  --target-ram-mb=1024 \</span><br><span class="line">  --kubelet-client-certificate ./certs/client.pem \</span><br><span class="line">  --kubelet-client-key ./certs/client-key.pem \</span><br><span class="line">  --log-dir  /data/logs/kubernetes/kube-apiserver \</span><br><span class="line">  --tls-cert-file ./certs/apiserver.pem \</span><br><span class="line">  --tls-private-key-file ./certs/apiserver-key.pem \</span><br><span class="line">  --v 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ssl </tag>
            
            <tag> certificate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 动态扩缩容</title>
      <link href="/k8s-hpa/"/>
      <url>/k8s-hpa/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>Kubernetes HPA (Horizontal Pod Autoscaler) 是 Kubernetes 提供的一个自动扩容的功能，它可以根据 CPU 利用率或者自定义的指标，自动的扩容或者缩容 Pod 的数量，从而保证应用程序的稳定性和高可用性。</p><span id="more"></span><h1 id="通过HPA实现业务应用的动态扩缩容"><a href="#通过HPA实现业务应用的动态扩缩容" class="headerlink" title="通过HPA实现业务应用的动态扩缩容"></a>通过HPA实现业务应用的动态扩缩容</h1><h2 id="HPA控制器介绍"><a href="#HPA控制器介绍" class="headerlink" title="HPA控制器介绍"></a>HPA控制器介绍</h2><p>当系统资源过高的时候，我们可以使用如下命令来实现 Pod 的扩缩容功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> scale deployment myblog --replicas=2</span><br></pre></td></tr></table></figure><p>但是这个过程是手动操作的。在实际项目中，我们需要做到是的是一个自动化感知并自动扩容的操作。Kubernetes 也为提供了这样的一个资源对象：Horizontal Pod Autoscaling（Pod 水平自动伸缩），简称<a href="https://v1-14.docs.kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">HPA</a></p><p><img src="/post/docker/hpa.png" alt="hpa"></p><p>基本原理：HPA 通过监控分析控制器控制的所有 Pod 的负载变化情况来确定是否需要调整 Pod 的副本数量</p><h2 id="Metric-Server"><a href="#Metric-Server" class="headerlink" title="Metric Server"></a>Metric Server</h2><p><a href="https://v1-14.docs.kubernetes.io/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#metrics-server">官方介绍</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Metric server collects metrics from the Summary API, exposed by Kubelet on each node.</span><br><span class="line"></span><br><span class="line">Metrics Server registered in the main API server through Kubernetes aggregator, which was introduced in Kubernetes 1.7</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Metric Server 从每个节点的 Kubelet 暴露的 Summary API 中收集指标。</p><p>Metric Server 通过 Kubernetes 聚合器注册到主 API 服务器中，该聚合器在 Kubernetes 1.7 中引入。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官方代码仓库地址：<a href="https://github.com/kubernetes-sigs/metrics-server">https://github.com/kubernetes-sigs/metrics-server</a></p><blockquote><p>Depending on your cluster setup, you may also need to change flags passed to the Metrics Server container. Most useful flags:</p><ul><li><code>--kubelet-preferred-address-types</code> - The priority of node address types used when determining an address for connecting to a particular node (default [Hostname,InternalDNS,InternalIP,ExternalDNS,ExternalIP])</li><li><code>--kubelet-insecure-tls</code> - Do not verify the CA of serving certificates presented by Kubelets. For testing purposes only.</li><li><code>--requestheader-client-ca-file</code> - Specify a root certificate bundle for verifying client certificates on incoming requests.</li></ul></blockquote><p>上面的话翻译如下：</p><p>根据你的集群设置，你可能需要修改Metrics Server容器的参数。最有用的参数：</p><ul><li><code>--kubelet-preferred-address-types</code> - 确定连接到特定节点的地址时使用的节点地址类型的优先级（默认值[Hostname,InternalDNS,InternalIP,ExternalDNS,ExternalIP]）</li><li><code>--kubelet-insecure-tls</code> - 不要验证Kubelets提供的服务证书的CA。仅用于测试。</li><li><code>--requestheader-client-ca-file</code> - 指定用于验证传入请求上的客户端证书的根证书包。</li></ul><h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>首先，我们需要下载配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果想使用最新版本，可以使用这个url下载最新的配置 https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</span></span><br><span class="line">$ wget https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.6.4/components.yaml</span><br></pre></td></tr></table></figure><p>修改配置文中args参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加- --kubelet-insecure-tls</span></span><br><span class="line">...</span><br><span class="line">133       containers:</span><br><span class="line">134       - args:</span><br><span class="line">135         - --cert-dir=/tmp</span><br><span class="line">136         - --secure-port=4443</span><br><span class="line">            <span class="comment"># 添加这一句</span></span><br><span class="line">            - --kubelet-insecure-tls</span><br><span class="line">137         - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span><br><span class="line">138         - --kubelet-use-node-status-port</span><br><span class="line">139         - --metric-resolution=15s</span><br><span class="line">            <span class="comment"># 修改镜像地址，之前的地址是google的镜像源，国内有可能无法访问</span></span><br><span class="line">140         image: bitnami/metrics-server:0.6.4</span><br><span class="line">141         imagePullPolicy: IfNotPresent</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们添加了参数 –kubelet-insecure-tls，因为部署集群的时候，CA 证书并没有把各个节点的 IP 签上去，所以这里 metrics-server 通过 IP 去请求时，提示签的证书没有对应的 IP（错误：x509: cannot validate certificate for xxx.xxx.xxx.xxx because it doesn’t contain any IP SANs）。</p><p>当然官方文档也说了，这个参数只用于测试，生产环境不建议使用，正常环境还是要把证书部署完全。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>因为我们已经有了配置文件，所以直接使用 kubectl 部署即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署配置文件</span></span><br><span class="line">$ kubectl apply -f components.yaml</span><br><span class="line"><span class="comment"># 查看部署情况</span></span><br><span class="line">$ kubectl -n kube-system get pods</span><br><span class="line"><span class="comment"># 查看节点的监控数据</span></span><br><span class="line"><span class="comment"># 如果没有安装之前会报错，现在应该可以正常获取数据了。报错信息如下： Error from server (NotFound): the server could not find the requested resource (get services http:heapster:)</span></span><br><span class="line">$ kubectl top nodes</span><br><span class="line">NAME         CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%</span><br><span class="line">k8s-master   456m         5%     1829Mi          47%</span><br><span class="line">k8s-node1    170m         2%     1435Mi          37%</span><br><span class="line">k8s-node2    100m         1%     1649Mi          43%</span><br></pre></td></tr></table></figure><h2 id="HPA实践"><a href="#HPA实践" class="headerlink" title="HPA实践"></a>HPA实践</h2><p>HPA的实现有两个版本：</p><ul><li>autoscaling&#x2F;v1，只包含了根据CPU指标的检测，稳定版本</li><li>autoscaling&#x2F;v2，支持根据cpu、memory或者用户自定义指标进行伸缩</li></ul><h3 id="基于CPU和内存的动态伸缩"><a href="#基于CPU和内存的动态伸缩" class="headerlink" title="基于CPU和内存的动态伸缩"></a>基于CPU和内存的动态伸缩</h3><h4 id="创建hpa资源"><a href="#创建hpa资源" class="headerlink" title="创建hpa资源"></a>创建hpa资源</h4><p><img src="/post/docker/autoscaling.png" alt="autoscaling"></p><p>要想使用HPA，必须要创建HPA资源对象，有两种方法进行创建：</p><ul><li>方式一：声明式创建，通过yaml文件创建</li><li>方式二：命令式创建，通过kubectl命令创建</li></ul><p>以下是两种创建方式：</p><p>方法一，声明式创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> hpa-myblog.yaml</span><br><span class="line">apiVersion: autoscaling/v2</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: hpa-myblog</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">spec:</span><br><span class="line">  maxReplicas: 3</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: myblog</span><br><span class="line">  metrics:</span><br><span class="line">    - <span class="built_in">type</span>: Resource</span><br><span class="line">      resource:</span><br><span class="line">        name: memory</span><br><span class="line">        target:</span><br><span class="line">          <span class="built_in">type</span>: Utilization</span><br><span class="line">          averageUtilization: 80</span><br><span class="line">    - <span class="built_in">type</span>: Resource</span><br><span class="line">      resource:</span><br><span class="line">        name: cpu</span><br><span class="line">        target:</span><br><span class="line">          <span class="built_in">type</span>: Utilization</span><br><span class="line">          averageUtilization: 80</span><br><span class="line">          </span><br><span class="line">$ kubectl -n <span class="built_in">test</span> apply -f hpa-myblog.yaml</span><br></pre></td></tr></table></figure><p>方法二，命令式创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n test autoscale deployment myblog --cpu-percent=80 --min=1 --max=3</span><br></pre></td></tr></table></figure><blockquote><p>Deployment对象必须配置requests的参数，不然无法获取监控数据，也无法通过HPA进行动态伸缩</p></blockquote><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>查看k8s创建hpa的资源对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -n <span class="built_in">test</span> get hpa</span></span><br><span class="line">NAME         REFERENCE           TARGETS           MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">hpa-myblog   Deployment/myblog   27%/80%, 1%/80%   1         3         1          23s</span><br></pre></td></tr></table></figure><p>可以看到，名字叫做hpa-myblog的hpa资源已经存在了，它的目标对象是myblog的deployment，目标是80%的cpu利用率和80%的内存利用率，当前使用的是27%的cpu和1%的内存，当前副本数是1，最大副本数是3，最小副本数是1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了能将负载压力加大，我们安装一个压测工具来模拟大量的用户访问</span></span><br><span class="line">$ sudo yum install httpd-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了更快看到效果，先调整副本数为1。这里我们已经是1个副本了，所以不需要再调整了</span></span><br><span class="line"><span class="comment"># $ kubectl -n test scale deploy myblog --replicas=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：压力测试的时候一定要使用ClusterIP的地址，不要使用Pod的IP地址，否则就会只有这一个Pod在承担压力，扩容的其他Pod没有压力</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po -o wide</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   IP              NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">myblog-84985b5b66-smpwb    1/1     Running   0          70d   10.244.1.5      k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">mysql-7f97cb6cc9-vzxpd     1/1     Running   0          71d   192.168.100.2   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">testpod-865855cfc5-m2f99   1/1     Running   0          58d   10.244.2.13     k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get svc -o wide</span><br><span class="line">NAME        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class="line">myblog      ClusterIP   10.104.58.9     &lt;none&gt;        80/TCP         70d   app=myblog</span><br><span class="line">myblog-np   NodePort    10.98.222.213   &lt;none&gt;        80:31174/TCP   70d   app=myblog</span><br><span class="line">mysql       ClusterIP   10.110.89.44    &lt;none&gt;        3306/TCP       70d   app=mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面可以看到myblog的ClusterIP是10.104.58.9，端口是80，因此我们使用这个地址进行压力测试</span></span><br><span class="line"><span class="comment"># 使用压力测试程序模拟1000个用户并发访问页面10万次，注意，工具规定必须明确指定IP和PORT</span></span><br><span class="line">$ ab -n 100000 -c 1000 http://10.104.58.9:80/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看压力测试的结果，可以看到hpa的使用率有一段反应时间，然后快速上升，迅速将副本数扩展到了3个</span></span><br><span class="line">$ kubectl get hpa</span><br><span class="line"><span class="comment"># 查看pod的副本数，可以看到副本数已经扩展到了3个</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get pods</span><br></pre></td></tr></table></figure><p>压力降下来后，会有默认5分钟的<code>scaledown</code>的时间，也就是说k8s在等待5分钟后，没有压力的情况下，会缩容一个副本，之后再等待5分钟，如果还没有压力，再缩容一个副本，以此类推，直到副本数为1。</p><p>所以与扩容立刻就扩不同，缩容是一个逐步的过程，比如本例从3个副本降低到1个副本，中间大概会等待2*5分钟 &#x3D; 10分钟</p><p><code>scaledown</code>的时间可以通过<code>controller-manager</code>的如下参数设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--horizontal-pod-autoscaler-downscale-stabilization</span><br><span class="line"></span><br><span class="line">The value for this option is a duration that specifies how long the autoscaler has to wait before another downscale operation can be performed after the current one has completed. The default value is 5 minutes (5m0s).</span><br></pre></td></tr></table></figure><p>也可以通过设置每个hpa的<code>behavior</code>来控制<code>scaleDown</code>和<code>scaleUp</code>的行为。</p><h3 id="基于自定义指标的动态伸缩"><a href="#基于自定义指标的动态伸缩" class="headerlink" title="基于自定义指标的动态伸缩"></a>基于自定义指标的动态伸缩</h3><p>除了基于 CPU 和内存来进行自动扩缩容之外，我们还可以根据自定义的监控指标来进行。这个我们就需要使用 <code>Prometheus Adapter</code>，Prometheus 用于监控应用的负载和集群本身的各种指标，<code>Prometheus Adapter</code> 可以帮我们使用 Prometheus 收集的指标并使用它们来制定扩展策略，这些指标都是通过 APIServer 暴露的，而且 HPA 资源对象也可以很轻易的直接使用。</p><p><img src="/post/docker/custom-hpa.png" alt="custom-hpa"></p><p>架构图：</p><p><img src="/post/docker/hpa-prometheus-custom.png" alt="hpa-prometheus-custom"></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="如何获取Pod的监控数据"><a href="#如何获取Pod的监控数据" class="headerlink" title="如何获取Pod的监控数据"></a>如何获取Pod的监控数据</h3><ul><li>k8s 1.8以下：使用heapster，1.11版本完全废弃</li><li>k8s 1.8以上：使用metric-server</li></ul><p>官方从 1.8 版本开始提出了 Metric api 的概念，而 metrics-server 就是这种概念下官方的一种实现，用于从 kubelet获取指标，替换掉之前的 heapster。</p><p><code>Metrics Server</code> 可以通过标准的 Kubernetes API 把监控数据暴露出来，比如获取某一Pod的监控数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://192.168.100.1:6443/apis/metrics.k8s.io/v1beta1/namespaces/&lt;namespace-name&gt;/pods/&lt;pod-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://192.168.100.1:6443/api/v1/namespaces/test/pods?limit=500</span></span><br></pre></td></tr></table></figure><p>集群中安装了<code>metrics-server</code>就可以用上述接口获取Pod的基础监控数据了，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取myblog的pod的监控数据</span></span><br><span class="line">$ $ kubectl -n <span class="built_in">test</span> get po</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">myblog-84985b5b66-smpwb    1/1     Running   0          71d</span><br><span class="line">mysql-7f97cb6cc9-vzxpd     1/1     Running   0          71d</span><br><span class="line">testpod-865855cfc5-m2f99   1/1     Running   0          58d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 则请求的接口应该是 </span></span><br><span class="line">URL=<span class="string">&quot;https://192.168.100.1:6443/apis/metrics.k8s.io/v1beta1/namespaces/test/pods/myblog-84985b5b66-smpwb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们知道调用apiserver需要认证和鉴权流程，因此，前篇我们已经在test名称空间下创建了名为test-pods-admin的serviceaccount，并赋予了test名称空间的pods的操作权限，因此可以使用该serviceaccount的token来进行认证</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create token test-pods-admin</span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IktJeWtHUFlydXZ2ZncxQVNxUlZyWHhCTkkwb01IbjNKUnFwZ18wUUxkVGcifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjY4MjI4Mzg5LCJpYXQiOjE2NjgyMjQ3ODksImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJsdWZmeSIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJsdWZmeS1wb2RzLWFkbWluIiwidWlkIjoiNjAzYWEzMDYtNDljZi00Y2UxLWI1OGYtMGNmMjUzYTI4YmY2In19LCJuYmYiOjE2NjgyMjQ3ODksInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpsdWZmeTpsdWZmeS1wb2RzLWFkbWluIn0.HywSHWpsq9yHraUsPwehpaJKWWZFIQY2xE3mZBcVbbXA6ZerEjBzy1q_7VwonNMyUDo_kgK_vM0CVWKDFbESXqG-tbYd6LLD_PNvL8WyEZsKfiK2LYBiTNOAXnUqReUNt9XD_oHVoaEfeEpIO1WPONnmdcOLl_OBa7sdWFH8iT42hVufOHjYELJrOF8PG741BvtMuAIohYwFgO76G8dTWEaOYCX9Rg8n9jJQTqhMvm1fvW6c0V558q63e3oi7OFFR_V90dg4PYbBMAVMrKrrGAogEPnBhHFiY8YKF9lECzTyoVIxOphyvS5M9noU6G_W3-0w7gsMYGrXQVw7xlywNg</span><br><span class="line"></span><br><span class="line">$ TOKEN=<span class="string">&quot;eyJhbGciOiJSUzI1NiIsImtpZCI6IktJeWtHUFlydXZ2ZncxQVNxUlZyWHhCTkkwb01IbjNKUnFwZ18wUUxkVGcifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjY4MjI4Mzg5LCJpYXQiOjE2NjgyMjQ3ODksImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJsdWZmeSIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJsdWZmeS1wb2RzLWFkbWluIiwidWlkIjoiNjAzYWEzMDYtNDljZi00Y2UxLWI1OGYtMGNmMjUzYTI4YmY2In19LCJuYmYiOjE2NjgyMjQ3ODksInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpsdWZmeTpsdWZmeS1wb2RzLWFkbWluIn0.HywSHWpsq9yHraUsPwehpaJKWWZFIQY2xE3mZBcVbbXA6ZerEjBzy1q_7VwonNMyUDo_kgK_vM0CVWKDFbESXqG-tbYd6LLD_PNvL8WyEZsKfiK2LYBiTNOAXnUqReUNt9XD_oHVoaEfeEpIO1WPONnmdcOLl_OBa7sdWFH8iT42hVufOHjYELJrOF8PG741BvtMuAIohYwFgO76G8dTWEaOYCX9Rg8n9jJQTqhMvm1fvW6c0V558q63e3oi7OFFR_V90dg4PYbBMAVMrKrrGAogEPnBhHFiY8YKF9lECzTyoVIxOphyvS5M9noU6G_W3-0w7gsMYGrXQVw7xlywNg&quot;</span></span><br><span class="line"></span><br><span class="line">$ curl -k -H <span class="string">&quot;Authorization: Bearer <span class="variable">$TOKEN</span>&quot;</span> <span class="variable">$URL</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;PodMetrics&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;metrics.k8s.io/v1beta1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;myblog-84985b5b66-smpwb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;creationTimestamp&quot;</span>: <span class="string">&quot;2023-10-24T03:46:47Z&quot;</span></span><br><span class="line">    <span class="string">&quot;labels&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;app&quot;</span>: <span class="string">&quot;myblog&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pod-template-hash&quot;</span>: <span class="string">&quot;6b5d9664d8&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2023-10-24T03:46:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;window&quot;</span>: <span class="string">&quot;30s&quot;</span>,</span><br><span class="line">  <span class="string">&quot;containers&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;myblog&quot;</span>,</span><br><span class="line">      <span class="string">&quot;usage&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;cpu&quot;</span>: <span class="string">&quot;2082398n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;memory&quot;</span>: <span class="string">&quot;3795872Ki&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前的采集流程：</p><p><img src="/post/docker/k8s-hpa-ms.png" alt="k8s-hpa-ms"></p><h3 id="kubelet的指标采集"><a href="#kubelet的指标采集" class="headerlink" title="kubelet的指标采集"></a>kubelet的指标采集</h3><p>无论是 heapster 还是 metric-server，都只是数据的中转和聚合，两者都是调用的 kubelet 的 api 接口获取的数据，而 kubelet 代码中实际采集指标的是 cadvisor 模块，你可以在 node 节点访问 10250 端口获取监控数据：</p><ul><li>Kubelet Summary metrics:  <code>https://127.0.0.1:10250/metrics</code> ，暴露 node、pod 汇总数据</li><li>Cadvisor metrics: <code>https://127.0.0.1:10250/metrics/cadvisors</code> ，暴露 container 维度数据</li></ul><p>调用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-system create token metrics-server</span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IktJeWtHUFlydXZ2ZncxQVNxUlZyWHhCTkkwb01IbjNKUnFwZ18wUUxkVGcifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjY4MjI4ODY0LCJpYXQiOjE2NjgyMjUyNjQsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJtZXRyaWNzLXNlcnZlciIsInVpZCI6IjE4MDJmNGVkLWFjMDYtNDcwYS04YmExLWM0MDJjODgwMjI2OCJ9fSwibmJmIjoxNjY4MjI1MjY0LCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06bWV0cmljcy1zZXJ2ZXIifQ.Wz3kRbwoCJr2v_Gh5gG9oTMcZOPAgUPcSCmS-Nv7TB7a0aiYzSAqlH2PIqDt1wsv_bmNlpg2QifuDF1lnd5FmBmPCsY-zJX-uW-MStAQaCjfV8iBDmlThIP20srpmMf-z6JzkAlIF7JTTeuv03AkZg50FVKvu_2Zk-lm9gEwUhWgXns3oSnhTCWFHh2rOwnNq3IwcypTrRGWBEt5e9BQ6HWWMiCkkZ0WfgATXAAzYsmzRMIp2ZXntoqYEJGLEwgqJNLPVFpCdSn_C3Ft_2Mnfex84uSH0SL08fD5KP23SibWcPyOHIsSrsuPqA03JF-XW_JjRQyhOZsadSjvTBSSMQ</span><br><span class="line"></span><br><span class="line">$ TOKEN=<span class="string">&quot;eyJhbGciOiJSUzI1NiIsImtpZCI6IktJeWtHUFlydXZ2ZncxQVNxUlZyWHhCTkkwb01IbjNKUnFwZ18wUUxkVGcifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjY4MjI4ODY0LCJpYXQiOjE2NjgyMjUyNjQsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJtZXRyaWNzLXNlcnZlciIsInVpZCI6IjE4MDJmNGVkLWFjMDYtNDcwYS04YmExLWM0MDJjODgwMjI2OCJ9fSwibmJmIjoxNjY4MjI1MjY0LCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06bWV0cmljcy1zZXJ2ZXIifQ.Wz3kRbwoCJr2v_Gh5gG9oTMcZOPAgUPcSCmS-Nv7TB7a0aiYzSAqlH2PIqDt1wsv_bmNlpg2QifuDF1lnd5FmBmPCsY-zJX-uW-MStAQaCjfV8iBDmlThIP20srpmMf-z6JzkAlIF7JTTeuv03AkZg50FVKvu_2Zk-lm9gEwUhWgXns3oSnhTCWFHh2rOwnNq3IwcypTrRGWBEt5e9BQ6HWWMiCkkZ0WfgATXAAzYsmzRMIp2ZXntoqYEJGLEwgqJNLPVFpCdSn_C3Ft_2Mnfex84uSH0SL08fD5KP23SibWcPyOHIsSrsuPqA03JF-XW_JjRQyhOZsadSjvTBSSMQ&quot;</span></span><br><span class="line"></span><br><span class="line">$ curl -k  -H <span class="string">&quot;Authorization: Bearer <span class="variable">$TOKEN</span>&quot;</span> https://localhost:10250/metrics</span><br></pre></td></tr></table></figure><p>kubelet虽然提供了metric接口，但实际监控逻辑由内置的cAdvisor模块负责，早期的时候，cadvisor是单独的组件，从k8s 1.12开始，cadvisor监听的端口在k8s中被删除，所有监控数据统一由Kubelet的API提供。</p><p>cadvisor获取指标时实际调用的是runc&#x2F;libcontainer库，而libcontainer是对cgroup文件的封装，即cadvsior也只是个转发者，它的数据来自于cgroup文件。</p><p>所以cgroup文件中的值才是监控数据的最终来源</p><p><strong>下图是Metrics数据流</strong></p><p><img src="/post/docker/hpa-flow.webp" alt="hpa-flow"></p><p><em>Metrics Server是独立的一个服务，只能服务内部实现自己的api，那么它是如何做到通过标准的kubernetes 的API格式暴露出去的？</em></p><p>这是因为它使用到了k8s的聚合器 <a href="https://github.com/kubernetes/kube-aggregator">kube-aggregator</a></p><h3 id="kube-aggregator聚合器及Metric-Server的实现"><a href="#kube-aggregator聚合器及Metric-Server的实现" class="headerlink" title="kube-aggregator聚合器及Metric-Server的实现"></a>kube-aggregator聚合器及Metric-Server的实现</h3><p>kube-aggregator是对 apiserver 的api的一种拓展机制，它允许开发人员编写一个自己的服务，并把这个服务注册到k8s的api里面，即扩展 API 。</p><p><img src="/post/docker/kube-aggregation.webp" alt="kube-aggregation"></p><p>看下metric-server的实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get apiservice </span><br><span class="line">NAME                       SERVICE                      AVAILABLE                      </span><br><span class="line">v1beta1.metrics.k8s.io   kube-system/metrics-serverTrue</span><br><span class="line"></span><br><span class="line">$ kubectl get apiservice v1beta1.metrics.k8s.io -oyaml</span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  group: metrics.k8s.io</span><br><span class="line">  groupPriorityMinimum: 100</span><br><span class="line">  insecureSkipTLSVerify: <span class="literal">true</span></span><br><span class="line">  service:</span><br><span class="line">    name: metrics-server</span><br><span class="line">    namespace: kube-system</span><br><span class="line">    port: 443</span><br><span class="line">  version: v1beta1</span><br><span class="line">  versionPriority: 100</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会往apiserver里注册一个</span></span><br><span class="line"><span class="comment"># proxyPath := &quot;/apis/&quot; + apiService.Spec.Group + &quot;/&quot; + apiService.Spec.Version</span></span><br><span class="line"><span class="comment"># https://192.168.100.1:6443/apis/metrics.k8s.io/v1beta1 </span></span><br><span class="line"><span class="comment"># =&gt; https://metrics-server:443/apis/metrics.k8s.io/v1beta1 </span></span><br><span class="line"></span><br><span class="line">$ kubectl -n kube-system get svc metrics-server</span><br><span class="line">NAME             TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">metrics-server   ClusterIP   10.105.155.213   &lt;none&gt;        443/TCP   10h</span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create token test-pods-admin</span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IktJeWtHUFlydXZ2ZncxQVNxUlZyWHhCTkkwb01IbjNKUnFwZ18wUUxkVGcifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjY4MjI5OTMyLCJpYXQiOjE2NjgyMjYzMzIsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJsdWZmeSIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJsdWZmeS1wb2RzLWFkbWluIiwidWlkIjoiNjAzYWEzMDYtNDljZi00Y2UxLWI1OGYtMGNmMjUzYTI4YmY2In19LCJuYmYiOjE2NjgyMjYzMzIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpsdWZmeTpsdWZmeS1wb2RzLWFkbWluIn0.LeKFaXBeaAsyHd06JFc6exenNtfuBadjUj3YtqgHiBMmhNds4zmB9_ysvI4p04W6Kov37YTZg4WSj_AqpsplfCVVg8h-3kAQfPC6cHG5oBN-VUsMC80lu-MZsBTI4C5in7WgddFyFqFMxXL_-TdpguYohOJ6NC90z3IGLCKy8pS5mOCUA34o1_9x5P3JM5e--R-NIbwZmdESkfHejiaENCau_cwP2L2lxmU364kppSrcX_kGLybT7nMV-Bg6Q_-pt0JZVtP5C5NZUuLN0Mtmsd9me8LJFyPDX4fkWtXwZraqiRDx_OTgbckIwQAIDseFEu8ikVBYZ2p6qPCvtIgsMQ</span><br><span class="line"></span><br><span class="line">$ Token=<span class="string">&quot;eyJhbGciOiJSUzI1NiIsImtpZCI6IktJeWtHUFlydXZ2ZncxQVNxUlZyWHhCTkkwb01IbjNKUnFwZ18wUUxkVGcifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjY4MjI5OTMyLCJpYXQiOjE2NjgyMjYzMzIsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJsdWZmeSIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJsdWZmeS1wb2RzLWFkbWluIiwidWlkIjoiNjAzYWEzMDYtNDljZi00Y2UxLWI1OGYtMGNmMjUzYTI4YmY2In19LCJuYmYiOjE2NjgyMjYzMzIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpsdWZmeTpsdWZmeS1wb2RzLWFkbWluIn0.LeKFaXBeaAsyHd06JFc6exenNtfuBadjUj3YtqgHiBMmhNds4zmB9_ysvI4p04W6Kov37YTZg4WSj_AqpsplfCVVg8h-3kAQfPC6cHG5oBN-VUsMC80lu-MZsBTI4C5in7WgddFyFqFMxXL_-TdpguYohOJ6NC90z3IGLCKy8pS5mOCUA34o1_9x5P3JM5e--R-NIbwZmdESkfHejiaENCau_cwP2L2lxmU364kppSrcX_kGLybT7nMV-Bg6Q_-pt0JZVtP5C5NZUuLN0Mtmsd9me8LJFyPDX4fkWtXwZraqiRDx_OTgbckIwQAIDseFEu8ikVBYZ2p6qPCvtIgsMQ&quot;</span></span><br><span class="line">$ URL=<span class="string">&quot;https://10.105.155.213/apis/metrics.k8s.io/v1beta1/namespaces/test/pods/myblog-84985b5b66-smpwb&quot;</span></span><br><span class="line"></span><br><span class="line">$ curl -k -H <span class="string">&quot;Authorization: Bearer <span class="variable">$Token</span>&quot;</span> <span class="variable">$URL</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;PodMetrics&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;metrics.k8s.io/v1beta1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;myblog-84985b5b66-smpwb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;creationTimestamp&quot;</span>: <span class="string">&quot;2023-10-24T03:46:47Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;labels&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;app&quot;</span>: <span class="string">&quot;myblog&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pod-template-hash&quot;</span>: <span class="string">&quot;6b5d9664d8&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2023-10-24T03:46:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;window&quot;</span>: <span class="string">&quot;30s&quot;</span>,</span><br><span class="line">  <span class="string">&quot;containers&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;myblog&quot;</span>,</span><br><span class="line">      <span class="string">&quot;usage&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;cpu&quot;</span>: <span class="string">&quot;1569859n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;memory&quot;</span>: <span class="string">&quot;3800032Ki&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> hpa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 认证和授权</title>
      <link href="/k8s-auth/"/>
      <url>/k8s-auth/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>Kubernetes 有一个内建的 Role-based access control (RBAC) 机制，它可以控制用户对 Kubernetes API 的访问权限。RBAC 机制可以让集群管理员控制用户、服务账户和组对 Kubernetes API 的访问权限。</p><span id="more"></span><h2 id="APIServer安全控制"><a href="#APIServer安全控制" class="headerlink" title="APIServer安全控制"></a>APIServer安全控制</h2><p><img src="/post/docker/k8s-apiserver-access-control-overview.svg" alt="k8s apiserver access control overview"></p><h3 id="Authentication：身份认证"><a href="#Authentication：身份认证" class="headerlink" title="Authentication：身份认证"></a>Authentication：身份认证</h3><ol><li><p>这个环节它面对的输入是整个<code>http request</code>，负责对来自client的请求进行身份校验，支持的方法包括:</p><ul><li><code>basic auth</code></li><li>client证书验证（https双向验证）</li><li><code>jwt token</code>(用于serviceaccount)</li></ul></li><li><p>APIServer启动时，可以指定一种Authentication方法，也可以指定多种方法。如果指定了多种方法，那么APIServer将会逐个使用这些方法对客户端请求进行验证， 只要请求数据通过其中一种方法的验证，APIServer就会认为Authentication成功；</p></li><li><p>使用kubeadm引导启动的k8s集群，apiserver的初始配置中，默认支持<code>client证书</code>验证和<code>serviceaccount</code>两种身份验证方式。 证书认证通过设置<code>--client-ca-file</code>根证书以及<code>--tls-cert-file</code>和<code>--tls-private-key-file</code>来开启。</p></li><li><p>在这个环节，apiserver会通过client证书或 <code>http header</code>中的字段(比如serviceaccount的<code>jwt token</code>)来识别出请求的<code>用户身份</code>，包括”user”、”group”等，这些信息将在后面的<code>authorization</code>环节用到。</p></li></ol><h3 id="Authorization：鉴权，你可以访问哪些资源"><a href="#Authorization：鉴权，你可以访问哪些资源" class="headerlink" title="Authorization：鉴权，你可以访问哪些资源"></a>Authorization：鉴权，你可以访问哪些资源</h3><ol><li>这个环节面对的输入是<code>http request context</code>中的各种属性，包括：<code>user</code>、<code>group</code>、<code>request path</code>（比如：<code>/api/v1</code>、<code>/healthz</code>、<code>/version</code>等）、 <code>request verb</code>(比如：<code>get</code>、<code>list</code>、<code>create</code>等)。</li><li>APIServer会将这些属性值与事先配置好的访问策略(<code>access policy</code>）相比较。APIServer支持多种<code>authorization mode</code>，包括<code>Node、RBAC、Webhook</code>等。</li><li>APIServer启动时，可以指定一种<code>authorization mode</code>，也可以指定多种<code>authorization mode</code>，如果是后者，只要Request通过了其中一种mode的授权， 那么该环节的最终结果就是授权成功。在较新版本kubeadm引导启动的k8s集群的apiserver初始配置中，<code>authorization-mode</code>的默认配置是<code>”Node,RBAC”</code>。</li></ol><h3 id="Admission-Control：准入控制，一个控制链-层层关卡-，用于拦截请求的一种方式。偏集群安全控制、管理方面。"><a href="#Admission-Control：准入控制，一个控制链-层层关卡-，用于拦截请求的一种方式。偏集群安全控制、管理方面。" class="headerlink" title="Admission Control：准入控制，一个控制链(层层关卡)，用于拦截请求的一种方式。偏集群安全控制、管理方面。"></a>Admission Control：<a href="http://docs.kubernetes.org.cn/144.html">准入控制</a>，一个控制链(层层关卡)，用于拦截请求的一种方式。偏集群安全控制、管理方面。</h3><h4 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h4><p>认证与授权获取 http 请求 header 以及证书，无法通过body内容做校验。</p><p>Admission 运行在 API Server 的增删改查 handler 中，可以自然地操作 API resource</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><h5 id="LimitRanger"><a href="#LimitRanger" class="headerlink" title="LimitRanger"></a>LimitRanger</h5><p>修改LimitRanger大小，若集群的命名空间设置了LimitRange对象，且Pod声明时未设置资源值，则按照LimitRange的定义来为Pod添加默认值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mem-limit-range</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">default:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">    <span class="attr">defaultRequest:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">256Mi</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Container</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default-mem-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default-mem-demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br></pre></td></tr></table></figure><p>查看认证情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 namespace</span></span><br><span class="line">$ kubectl -v=7 create namespace demo</span><br><span class="line">I1023 11:45:34.937311 1367593 loader.go:395] Config loaded from file:  /home/aaron/.kube/config</span><br><span class="line">I1023 11:45:34.940024 1367593 round_trippers.go:463] POST https://192.168.100.1:6443/api/v1/namespaces?fieldManager=kubectl-create&amp;fieldValidation=Strict</span><br><span class="line">I1023 11:45:34.940086 1367593 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:45:34.940121 1367593 round_trippers.go:473]     Accept: application/json, */*</span><br><span class="line">I1023 11:45:34.940154 1367593 round_trippers.go:473]     Content-Type: application/json</span><br><span class="line">I1023 11:45:34.940200 1367593 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:45:34.971203 1367593 round_trippers.go:574] Response Status: 201 Created <span class="keyword">in</span> 30 milliseconds</span><br><span class="line">namespace/demo created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 limit range</span></span><br><span class="line">$ kubectl -v=7 apply -f mem-limit-range.yaml</span><br><span class="line">I1023 11:46:54.566053 1368262 loader.go:395] Config loaded from file:  /home/aaron/.kube/config</span><br><span class="line">I1023 11:46:54.568879 1368262 round_trippers.go:463] GET https://192.168.100.1:6443/openapi/v2?<span class="built_in">timeout</span>=32s</span><br><span class="line">I1023 11:46:54.568933 1368262 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:46:54.568987 1368262 round_trippers.go:473]     Accept: application/com.github.proto-openapi.spec.v2@v1.0+protobuf</span><br><span class="line">I1023 11:46:54.569036 1368262 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:46:54.608556 1368262 round_trippers.go:574] Response Status: 200 OK <span class="keyword">in</span> 39 milliseconds</span><br><span class="line">I1023 11:46:54.835559 1368262 round_trippers.go:463] GET https://192.168.100.1:6443/openapi/v3?<span class="built_in">timeout</span>=32s</span><br><span class="line">I1023 11:46:54.835626 1368262 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:46:54.835663 1368262 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:46:54.835713 1368262 round_trippers.go:473]     Accept: application/json, */*</span><br><span class="line">I1023 11:46:54.839142 1368262 round_trippers.go:574] Response Status: 200 OK <span class="keyword">in</span> 3 milliseconds</span><br><span class="line">I1023 11:46:54.842249 1368262 round_trippers.go:463] GET https://192.168.100.1:6443/openapi/v3/api/v1?<span class="built_in">hash</span>=64470CFAF8CA1AC72CDF17D98F7AB1B4FA6357371209C6FBEAA1B607D1B09E70C979B0BA231366442A884E6888CF86F0205FF562FCA388657C7250E472112154&amp;<span class="built_in">timeout</span>=32s</span><br><span class="line">I1023 11:46:54.842307 1368262 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:46:54.842340 1368262 round_trippers.go:473]     Accept: application/json</span><br><span class="line">I1023 11:46:54.842372 1368262 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:46:54.845368 1368262 round_trippers.go:574] Response Status: 200 OK <span class="keyword">in</span> 2 milliseconds</span><br><span class="line">I1023 11:46:55.190015 1368262 round_trippers.go:463] GET https://192.168.100.1:6443/api/v1/namespaces/demo/limitranges/mem-limit-range</span><br><span class="line">I1023 11:46:55.190086 1368262 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:46:55.190179 1368262 round_trippers.go:473]     Accept: application/json</span><br><span class="line">I1023 11:46:55.190253 1368262 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:46:55.195521 1368262 round_trippers.go:574] Response Status: 404 Not Found <span class="keyword">in</span> 5 milliseconds</span><br><span class="line">I1023 11:46:55.196192 1368262 round_trippers.go:463] GET https://192.168.100.1:6443/api/v1/namespaces/demo</span><br><span class="line">I1023 11:46:55.196256 1368262 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:46:55.196290 1368262 round_trippers.go:473]     Accept: application/json</span><br><span class="line">I1023 11:46:55.196319 1368262 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:46:55.200893 1368262 round_trippers.go:574] Response Status: 200 OK <span class="keyword">in</span> 4 milliseconds</span><br><span class="line">I1023 11:46:55.201301 1368262 round_trippers.go:463] POST https://192.168.100.1:6443/api/v1/namespaces/demo/limitranges?fieldManager=kubectl-client-side-apply&amp;fieldValidation=Strict</span><br><span class="line">I1023 11:46:55.201365 1368262 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:46:55.201398 1368262 round_trippers.go:473]     Accept: application/json</span><br><span class="line">I1023 11:46:55.201444 1368262 round_trippers.go:473]     Content-Type: application/json</span><br><span class="line">I1023 11:46:55.201485 1368262 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:46:55.212289 1368262 round_trippers.go:574] Response Status: 201 Created <span class="keyword">in</span> 10 milliseconds</span><br><span class="line">limitrange/mem-limit-range created</span><br><span class="line">I1023 11:46:55.212851 1368262 round_trippers.go:463] GET https://192.168.100.1:6443/api/v1/namespaces/demo/pods/default-mem-demo</span><br><span class="line">I1023 11:46:55.212931 1368262 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:46:55.213019 1368262 round_trippers.go:473]     Accept: application/json</span><br><span class="line">I1023 11:46:55.213077 1368262 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:46:55.217515 1368262 round_trippers.go:574] Response Status: 404 Not Found <span class="keyword">in</span> 4 milliseconds</span><br><span class="line">I1023 11:46:55.217783 1368262 round_trippers.go:463] GET https://192.168.100.1:6443/api/v1/namespaces/demo</span><br><span class="line">I1023 11:46:55.217866 1368262 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:46:55.217903 1368262 round_trippers.go:473]     Accept: application/json</span><br><span class="line">I1023 11:46:55.217958 1368262 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:46:55.222263 1368262 round_trippers.go:574] Response Status: 200 OK <span class="keyword">in</span> 4 milliseconds</span><br><span class="line">I1023 11:46:55.222547 1368262 round_trippers.go:463] POST https://192.168.100.1:6443/api/v1/namespaces/demo/pods?fieldManager=kubectl-client-side-apply&amp;fieldValidation=Strict</span><br><span class="line">I1023 11:46:55.222608 1368262 round_trippers.go:469] Request Headers:</span><br><span class="line">I1023 11:46:55.222657 1368262 round_trippers.go:473]     Content-Type: application/json</span><br><span class="line">I1023 11:46:55.222694 1368262 round_trippers.go:473]     User-Agent: kubectl/v1.28.0 (linux/amd64) kubernetes/855e7c4</span><br><span class="line">I1023 11:46:55.222727 1368262 round_trippers.go:473]     Accept: application/json</span><br><span class="line">I1023 11:46:55.230761 1368262 round_trippers.go:574] Response Status: 201 Created <span class="keyword">in</span> 7 milliseconds</span><br><span class="line">pod/default-mem-demo created</span><br><span class="line">I1023 11:46:55.231543 1368262 apply.go:535] Running apply post-processor <span class="keyword">function</span></span><br></pre></td></tr></table></figure><h5 id="NodeRestriction"><a href="#NodeRestriction" class="headerlink" title="NodeRestriction"></a>NodeRestriction</h5><p>此插件限制kubelet修改Node和Pod对象，这样的kubelets只允许修改绑定到Node的Pod API对象，以后版本可能会增加额外的限制 。开启Node授权策略后，默认会打开该项</p><p>怎么使用？</p><p>APIServer启动时通过 <code>--enable-admission-plugins --disable-admission-plugins</code> 指定需要打开或者关闭的 Admission Controller</p><p>主要使用场景是以下几种：</p><ul><li>自动注入sidecar容器或者initContainer容器</li><li>webhook admission，实现业务自定义的控制需求</li></ul><h2 id="kubectl的认证授权"><a href="#kubectl的认证授权" class="headerlink" title="kubectl的认证授权"></a>kubectl的认证授权</h2><p>kubectl的日志调试级别：</p><table><thead><tr><th align="left">信息</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">v&#x3D;0</td><td align="left">通常，这对操作者来说总是可见的。</td></tr><tr><td align="left">v&#x3D;1</td><td align="left">当您不想要很详细的输出时，这个是一个合理的默认日志级别。</td></tr><tr><td align="left">v&#x3D;2</td><td align="left">有关服务和重要日志消息的有用稳定状态信息，这些信息可能与系统中的重大更改相关。这是大多数系统推荐的默认日志级别。</td></tr><tr><td align="left">v&#x3D;3</td><td align="left">关于更改的扩展信息。</td></tr><tr><td align="left">v&#x3D;4</td><td align="left">调试级别信息。</td></tr><tr><td align="left">v&#x3D;6</td><td align="left">显示请求资源。</td></tr><tr><td align="left">v&#x3D;7</td><td align="left">显示 HTTP 请求头。</td></tr><tr><td align="left">v&#x3D;8</td><td align="left">显示 HTTP 请求内容。</td></tr><tr><td align="left">v&#x3D;9</td><td align="left">显示 HTTP 请求内容，并且不截断内容。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes -v=7</span><br><span class="line">I0329 20:20:08.633065    3979 loader.go:359] Config loaded from file /root/.kube/config</span><br><span class="line">I0329 20:20:08.633797    3979 round_trippers.go:416] GET https://10.209.0.13:6443/api/v1/nodes?<span class="built_in">limit</span>=500</span><br></pre></td></tr></table></figure><p><code>kubeadm init</code>启动完master节点后，会默认输出类似下面的提示内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>这些信息是在告知我们如何配置<code>kubeconfig</code>文件。按照上述命令配置后，master节点上的<code>kubectl</code>就可以直接使用<code>$HOME/.kube/config</code>的信息访问<code>k8s cluster</code>了。 并且，通过这种配置方式，<code>kubectl</code>也拥有了整个集群的管理员(root)权限。</p><p>很多K8s初学者在这里都会有疑问：</p><ul><li>当<code>kubectl</code>使用这种<code>kubeconfig</code>方式访问集群时，<code>Kubernetes</code>的<code>kube-apiserver</code>是如何对来自<code>kubectl</code>的访问进行身份验证(<code>authentication</code>)和授权(<code>authorization</code>)的呢？</li><li>为什么来自<code>kubectl</code>的请求拥有最高的管理员权限呢？</li></ul><p>查看<code>$HOME/.kube/config</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ~/.kube/config</span><br></pre></td></tr></table></figure><p>前面提到过apiserver的authentication支持通过<code>tls client certificate、basic auth、token</code>等方式对客户端发起的请求进行身份校验， 从kubeconfig信息来看，kubectl显然在请求中使用了<code>tls client certificate</code>的方式，即客户端的证书。</p><p>证书base64解码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> xxxxxxxxxxxxxx |<span class="built_in">base64</span> -d &gt; kubectl.crt</span><br></pre></td></tr></table></figure><p>说明在认证阶段，<code>apiserver</code>会首先使用<code>--client-ca-file</code>配置的CA证书去验证kubectl提供的证书的有效性,基本的方式 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  openssl verify -CAfile /etc/kubernetes/pki/ca.crt kubectl.crt</span><br><span class="line">kubectl.crt: OK</span><br></pre></td></tr></table></figure><p>除了认证身份，还会取出必要的信息供授权阶段使用，文本形式查看证书内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -<span class="keyword">in</span> kubectl.crt -text</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 753391350411361453 (0xa7495710a1efcad)</span><br><span class="line">        Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: CN = kubernetes</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Aug 25 07:12:13 2023 GMT</span><br><span class="line">            Not After : Aug 24 07:17:20 2024 GMT</span><br><span class="line">        Subject: O = system:masters, CN = kubernetes-admin</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>认证通过后，提取出签发证书时指定的CN(Common Name),<code>kubernetes-admin</code>，作为请求的用户名 (User Name), 从证书中提取O(Organization)字段作为请求用户所属的组 (Group)，<code>group = system:masters</code>，然后传递给后面的授权模块。</p><p>kubeadm在init初始引导集群启动过程中，创建了许多默认的RBAC规则， 在k8s有关RBAC的官方文档中，我们看到下面一些<code>default clusterrole</code>列表:</p><p><img src="/post/docker/kubeadm-default-cluster-role-list.png" alt="kubeadm default cluster role list"></p><p><img src="/post/docker/kubeadm-default-cluster-role-list-cn.png" alt="kubeadm default cluster role list cn"></p><p>其中第一个cluster-admin这个cluster role binding绑定了system:masters group，这和authentication环节传递过来的身份信息不谋而合。 沿着system:masters group对应的cluster-admin clusterrolebinding“追查”下去，真相就会浮出水面。</p><p>我们查看一下这一binding：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe clusterrolebinding cluster-admin</span><br><span class="line">Name:         cluster-admin</span><br><span class="line">Labels:       kubernetes.io/bootstrapping=rbac-defaults</span><br><span class="line">Annotations:  rbac.authorization.kubernetes.io/autoupdate: <span class="literal">true</span></span><br><span class="line">Role:</span><br><span class="line">  Kind:  ClusterRole</span><br><span class="line">  Name:  cluster-admin</span><br><span class="line">Subjects:</span><br><span class="line">  Kind   Name            Namespace</span><br><span class="line">  ----   ----            ---------</span><br><span class="line">  Group  system:masters</span><br></pre></td></tr></table></figure><p>我们看到在kube-system名字空间中，一个名为cluster-admin的clusterrolebinding将cluster-admin cluster role与system:masters Group绑定到了一起， 赋予了所有归属于system:masters Group中用户cluster-admin角色所拥有的权限。</p><p>我们再来查看一下cluster-admin这个role的具体权限信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe clusterrole cluster-admin</span><br><span class="line">Name:         cluster-admin</span><br><span class="line">Labels:       kubernetes.io/bootstrapping=rbac-defaults</span><br><span class="line">Annotations:  rbac.authorization.kubernetes.io/autoupdate: <span class="literal">true</span></span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources  Non-Resource URLs  Resource Names  Verbs</span><br><span class="line">  ---------  -----------------  --------------  -----</span><br><span class="line">  *.*        []                 []              [*]</span><br><span class="line">             [*]                []              [*]</span><br></pre></td></tr></table></figure><p>非资源类，如查看集群健康状态。</p><p><img src="/post/docker/how-kubectl-be-authorized.png" alt="how kubectl be authorized"></p><h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><p>Role-Based Access Control，基于角色的访问控制， apiserver启动参数添加–authorization-mode&#x3D;RBAC 来启用RBAC认证模式，kubeadm安装的集群默认已开启。<a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">官方介绍</a></p><p>查看开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master节点查看apiserver进程</span></span><br><span class="line">$ ps -ef | grep apiserver</span><br><span class="line">root        6119    5911  7 8月25 ?       4-12:07:50 kube-apiserver --advertise-address=192.168.100.1 --allow-privileged=<span class="literal">true</span> --authorization-mode=Node,RBAC --client-ca-file=/etc/kubernetes/pki/ca.crt --enable-admission-plugins=NodeRestriction --enable-bootstrap-token-auth=<span class="literal">true</span> --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key --etcd-servers=https://127.0.0.1:2379 --kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt --kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.crt --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client.key --requestheader-allowed-names=front-proxy-client --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt --requestheader-extra-headers-prefix=X-Remote-Extra- --requestheader-group-headers=X-Remote-Group --requestheader-username-headers=X-Remote-User --secure-port=6443 --service-account-issuer=https://kubernetes.default.svc.cluster.local --service-account-key-file=/etc/kubernetes/pki/sa.pub --service-account-signing-key-file=/etc/kubernetes/pki/sa.key --service-cluster-ip-range=10.96.0.0/12 --tls-cert-file=/etc/kubernetes/pki/apiserver.crt --tls-private-key-file=/etc/kubernetes/pki/apiserver.key</span><br><span class="line">aaron    1538613 1356648  0 17:55 pts/0    00:00:00 grep --color=auto apiserver</span><br></pre></td></tr></table></figure><p>RBAC模式引入了4个资源类型：</p><h3 id="Role，角色"><a href="#Role，角色" class="headerlink" title="Role，角色"></a>Role，角色</h3><p>一个Role只能授权访问单个namespace</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 示例定义一个名为pod-reader的角色，该角色具有读取demo这个命名空间下的pods的权限</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; indicates the core API group</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## apiGroups: &quot;&quot;,&quot;apps&quot;, &quot;autoscaling&quot;, &quot;batch&quot; =&gt; 通过命令 kubectl api-versions 查看</span></span><br><span class="line"><span class="comment">## resources: &quot;services&quot;, &quot;pods&quot;,&quot;deployments&quot;... =&gt; 通过命令 kubectl api-resources 查看</span></span><br><span class="line"><span class="comment">## verbs: &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;, &quot;exec&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/</span></span><br></pre></td></tr></table></figure><h3 id="ClusterRole"><a href="#ClusterRole" class="headerlink" title="ClusterRole"></a>ClusterRole</h3><p>一个ClusterRole能够授予和Role一样的权限，但是它是集群范围内的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 定义一个集群角色，名为secret-reader，该角色可以读取所有的namespace中的secret资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># &quot;namespace&quot; omitted since ClusterRoles are not namespaced</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># User,Group,ServiceAccount</span></span><br></pre></td></tr></table></figure><h3 id="Rolebinding"><a href="#Rolebinding" class="headerlink" title="Rolebinding"></a>Rolebinding</h3><p>将role中定义的权限分配给用户和用户组。RoleBinding包含主题（users,groups,或service accounts）和授予角色的引用。对于namespace内的授权使用RoleBinding，集群范围内使用ClusterRoleBinding。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 定义一个角色绑定，将pod-reader这个role的权限授予给jane这个User，使得jane可以在读取demo这个命名空间下的所有的pod数据</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span>   <span class="comment">#这里可以是User,Group,ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span> </span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span> <span class="comment">#这里可以是Role或者ClusterRole,若是ClusterRole，则权限也仅限于rolebinding的内部</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span> <span class="comment"># match the name of the Role or ClusterRole you wish to bind to</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p><em>注意：rolebinding既可以绑定role，也可以绑定clusterrole，当绑定rolebinding的时候，subject的权限也会被限定于rolebinding定义的namespace内部，若想跨namespace，需要使用clusterrolebinding</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 定义一个角色绑定，将dave这个用户和secret-reader这个集群角色绑定，虽然secret-reader是集群角色，但是因为是使用rolebinding绑定的，因此dave的权限也会被限制在development这个命名空间内</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="comment"># This role binding allows &quot;dave&quot; to read secrets in the &quot;development&quot; namespace.</span></span><br><span class="line"><span class="comment"># You need to already have a ClusterRole named &quot;secret-reader&quot;.</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># The namespace of the RoleBinding determines where the permissions are granted.</span></span><br><span class="line">  <span class="comment"># This only grants permissions within the &quot;development&quot; namespace.</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dave</span> <span class="comment"># Name is case sensitive</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dave</span> <span class="comment"># Name is case sensitive</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>考虑一个场景：如果集群中有多个namespace分配给不同的管理员，每个namespace的权限是一样的，就可以只定义一个clusterrole，然后通过rolebinding将不同的namespace绑定到管理员身上，否则就需要每个namespace定义一个Role，然后做一次rolebinding。</p><h3 id="ClusterRolebingding"><a href="#ClusterRolebingding" class="headerlink" title="ClusterRolebingding"></a>ClusterRolebingding</h3><p>允许跨namespace进行授权</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="comment"># This cluster role binding allows anyone in the &quot;manager&quot; group to read secrets in any namespace.</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">manager</span> <span class="comment"># Name is case sensitive</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p><img src="/post/docker/k8s-auth-rbac.jpg" alt="k8s auth rbac"></p><h2 id="kubelet的认证授权"><a href="#kubelet的认证授权" class="headerlink" title="kubelet的认证授权"></a>kubelet的认证授权</h2><p>查看kubelet进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status kubelet</span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; preset: disabled)</span><br><span class="line">    Drop-In: /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line">             └─10-kubeadm.conf</span><br><span class="line">     Active: active (running) since Fri 2023-08-25 15:17:30 CST; 1 month 28 days ago</span><br><span class="line">       Docs: https://kubernetes.io/docs/</span><br><span class="line">   Main PID: 6229 (kubelet)</span><br><span class="line">      Tasks: 18 (<span class="built_in">limit</span>: 24810)</span><br><span class="line">     Memory: 57.4M</span><br><span class="line">        CPU: 2d 3h 57min 37.642s</span><br><span class="line">     CGroup: /system.slice/kubelet.service</span><br><span class="line">             └─6229 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --container-runtime-endpoint=unix:///var/ru&gt;</span><br></pre></td></tr></table></figure><p>查看<code>/etc/kubernetes/kubelet.conf</code>，解析证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">cat</span> /etc/kubernetes/kubelet.conf</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: ......</span><br><span class="line">    server: https://192.168.100.1:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: system:node:k8s-master</span><br><span class="line">  name: system:node:k8s-master@kubernetes</span><br><span class="line">current-context: system:node:k8s-master@kubernetes</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line"><span class="built_in">users</span>:</span><br><span class="line">- name: system:node:k8s-master</span><br><span class="line">  user:</span><br><span class="line">    client-certificate: /var/lib/kubelet/pki/kubelet-client-current.pem</span><br><span class="line">    client-key: /var/lib/kubelet/pki/kubelet-client-current.pem</span><br><span class="line"></span><br><span class="line">$ openssl x509 -<span class="keyword">in</span> /var/lib/kubelet/pki/kubelet-client-current.pem -text</span><br><span class="line">$ sudo openssl x509 -<span class="keyword">in</span> /var/lib/kubelet/pki/kubelet-client-current.pem -text</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 625981109107871580 (0x8afee808c7acf5c)</span><br><span class="line">        Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: CN = kubernetes</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Aug 25 07:12:13 2023 GMT</span><br><span class="line">            Not After : Aug 24 07:17:20 2024 GMT</span><br><span class="line">        Subject: O = system:nodes, CN = system:node:k8s-master</span><br></pre></td></tr></table></figure><p>得到我们期望的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Subject: O=system:nodes, CN=system:node:k8s-master</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们知道，k8s会把O作为Group来进行请求，因此如果有权限绑定给这个组，肯定在clusterrolebinding的定义中可以找得到。因此尝试去找一下绑定了system:nodes组的clusterrolebinding</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get clusterrolebinding -oyaml|grep -n10 system:nodes</span><br><span class="line">91-    name: kubeadm:node-autoapprove-certificate-rotation</span><br><span class="line">92-    resourceVersion: <span class="string">&quot;252&quot;</span></span><br><span class="line">93-    uid: 194ef397-1a05-47d8-8672-7d967f5e3d30</span><br><span class="line">94-  roleRef:</span><br><span class="line">95-    apiGroup: rbac.authorization.k8s.io</span><br><span class="line">96-    kind: ClusterRole</span><br><span class="line">97-    name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</span><br><span class="line">98-  subjects:</span><br><span class="line">99-  - apiGroup: rbac.authorization.k8s.io</span><br><span class="line">100-    kind: Group</span><br><span class="line">101:    name: system:nodes</span><br><span class="line">102-- apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">103-  kind: ClusterRoleBinding</span><br><span class="line">104-  metadata:</span><br><span class="line">105-    creationTimestamp: <span class="string">&quot;2023-08-25T07:17:31Z&quot;</span></span><br><span class="line">106-    name: kubeadm:node-proxier</span><br><span class="line">107-    resourceVersion: <span class="string">&quot;282&quot;</span></span><br><span class="line">108-    uid: ff410466-f2ad-47f7-9865-e3cdfbd34e8b</span><br><span class="line">109-  roleRef:</span><br><span class="line">110-    apiGroup: rbac.authorization.k8s.io</span><br><span class="line">111-    kind: ClusterRole</span><br><span class="line"></span><br><span class="line">$ kubectl describe clusterrole system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</span><br><span class="line">Name:         system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</span><br><span class="line">Labels:       kubernetes.io/bootstrapping=rbac-defaults</span><br><span class="line">Annotations:  rbac.authorization.kubernetes.io/autoupdate: <span class="literal">true</span></span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources                                                      Non-Resource URLs  Resource Names  Verbs</span><br><span class="line">  ---------                                                      -----------------  --------------  -----</span><br><span class="line">  certificatesigningrequests.certificates.k8s.io/selfnodeclient  []                 []              [create]</span><br></pre></td></tr></table></figure><p>结局有点意外，除了<code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>外，没有找到system相关的rolebindings，显然和我们的理解不一样。 尝试去找<a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#core-component-roles">资料</a>，发现了这么一段 :</p><table><thead><tr><th align="left">Default ClusterRole</th><th align="left">Default ClusterRoleBinding</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">system:kube-scheduler</td><td align="left">system:kube-scheduler user</td><td align="left">Allows access to the resources required by the <a href="https://kubernetes.io/docs/reference/generated/kube-scheduler/">scheduler</a>component.</td></tr><tr><td align="left">system:volume-scheduler</td><td align="left">system:kube-scheduler user</td><td align="left">Allows access to the volume resources required by the kube-scheduler component.</td></tr><tr><td align="left">system:kube-controller-manager</td><td align="left">system:kube-controller-manager user</td><td align="left">Allows access to the resources required by the <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/">controller manager</a> component. The permissions required by individual controllers are detailed in the <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#controller-roles">controller roles</a>.</td></tr><tr><td align="left">system:node</td><td align="left">None</td><td align="left">Allows access to resources required by the kubelet, <strong>including read access to all secrets, and write access to all pod status objects</strong>. You should use the <a href="https://kubernetes.io/docs/reference/access-authn-authz/node/">Node authorizer</a> and <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a> instead of the <code>system:node</code> role, and allow granting API access to kubelets based on the Pods scheduled to run on them. The <code>system:node</code> role only exists for compatibility with Kubernetes clusters upgraded from versions prior to v1.8.</td></tr><tr><td align="left">system:node-proxier</td><td align="left">system:kube-proxy user</td><td align="left">Allows access to the resources required by the <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a>component.</td></tr></tbody></table><p>大致意思是说：之前会定义system:node这个角色，目的是为了kubelet可以访问到必要的资源，包括所有secret的读权限及更新pod状态的写权限。如果1.8版本后，是建议使用 <a href="https://kubernetes.io/docs/reference/access-authn-authz/node/">Node authorizer</a> and <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a> 来代替这个角色的。</p><p>我们目前使用1.19，查看一下授权策略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps axu|grep apiserver</span><br><span class="line">kube-apiserver --authorization-mode=Node,RBAC  --enable-admission-plugins=NodeRestriction</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看一下官网对Node authorizer的介绍：</p><p><em>Node authorization is a special-purpose authorization mode that specifically authorizes API requests made by kubelets.</em></p><p><em>In future releases, the node authorizer may add or remove permissions to ensure kubelets have the minimal set of permissions required to operate correctly.</em></p><p><em>In order to be authorized by the Node authorizer, kubelets must use a credential that identifies them as being in the <code>system:nodes</code> group, with a username of <code>system:node:&lt;nodeName&gt;</code></em></p><h2 id="Service-Account及-K8S-Api-调用"><a href="#Service-Account及-K8S-Api-调用" class="headerlink" title="Service Account及 K8S Api 调用"></a>Service Account及 K8S Api 调用</h2><p>前面说，认证可以通过证书，也可以通过使用ServiceAccount（服务账户）的方式来做认证。大多数时候，我们在基于k8s做二次开发时都是选择通过ServiceAccount + RBAC 的方式。我们之前访问dashboard的时候，是如何做的？</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 新建一个名为admin的serviceaccount，并且把名为cluster-admin的这个集群角色的权限授予新建的</span></span><br><span class="line"><span class="comment">#serviceaccount</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">rbac.authorization.kubernetes.io/autoupdate:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure><p>我们查看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kubernetes-dashboard get sa admin -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2020-04-01T11:59:21Z&quot;</span></span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">  resourceVersion: <span class="string">&quot;1988878&quot;</span></span><br><span class="line">  selfLink: /api/v1/namespaces/kubernetes-dashboard/serviceaccounts/admin</span><br><span class="line">  uid: 639ecc3e-74d9-11ea-a59b-000c29dfd73f</span><br><span class="line">secrets:</span><br><span class="line">- name: admin-token-lfsrf</span><br></pre></td></tr></table></figure><p>注意到serviceaccount上默认绑定了一个名为admin-token-lfsrf的secret，我们查看一下secret</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kubernetes-dashboard describe secret admin-token-lfsrf</span><br><span class="line">Name:         admin-token-lfsrf</span><br><span class="line">Namespace:    kubernetes-dashboard</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: admin</span><br><span class="line">              kubernetes.io/service-account.uid: 639ecc3e-74d9-11ea-a59b-000c29dfd73f</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1025 bytes</span><br><span class="line">namespace:  4 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZW1vIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImFkbWluLXRva2VuLWxmc3JmIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiNjM5ZWNjM2UtNzRkOS0xMWVhLWE1OWItMDAwYzI5ZGZkNzNmIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OmRlbW86YWRtaW4ifQ.ffGCU4L5LxTsMx3NcNixpjT6nLBi-pmstb4I-W61nLOzNaMmYSEIwAaugKMzNR-2VwM14WbuG04dOeO67niJeP6n8-ALkl-vineoYCsUjrzJ09qpM3TNUPatHFqyjcqJ87h4VKZEqk2qCCmLxB6AGbEHpVFkoge40vHs56cIymFGZLe53JZkhu3pwYuS4jpXytV30Ad-HwmQDUu_Xqcifni6tDYPCfKz2CZlcOfwqHeGIHJjDGVBKqhEeo8PhStoofBU6Y4OjObP7HGuTY-Foo4QindNnpp0QU6vSb7kiOiQ4twpayybH8PTf73dtdFt46UF6mGjskWgevgolvmO8A</span><br></pre></td></tr></table></figure><p><img src="/post/docker/k8s-auth-service-account.jpg" alt="k8s auth service account"></p><p>只允许访问test命名空间的pod资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test-admin-rbac.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pods-admin</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">---</span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">  name: pods-reader-writer</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; indicates the core API group</span></span><br><span class="line">  resources: [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  verbs: [<span class="string">&quot;*&quot;</span>]</span><br><span class="line">---</span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: pods-reader-writer</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount   <span class="comment">#这里可以是User,Group,ServiceAccount</span></span><br><span class="line">  name: test-pods-admin</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role <span class="comment">#这里可以是Role或者ClusterRole,若是ClusterRole，则权限也仅限于rolebinding的内部</span></span><br><span class="line">  name: pods-reader-writer</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><p>演示权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> describe secrets test-pods-admin-token-prr25</span><br><span class="line">...</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6InBtQUZfRl8ycC03TTBYaUUwTnJVZGpvQWU0cXZ5M2FFbjR2ZjkzZVcxOE0ifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJsdWZmeSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJsdWZmeS1hZG1pbi10b2tlbi1wcnIyNSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJsdWZmeS1hZG1pbiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImFhZDA0MTU3LTliNzMtNDJhZC1hMGU4LWVmOTZlZDU3Yzg1ZiIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpsdWZmeTpsdWZmeS1hZG1pbiJ9.YWckylE5wlKITKrVltXY4VPKvZP9ar5quIT5zq9N-0_FnDkLIBX7xOyFvZA5Wef0wSFSZe3e9FwrO1UbPsmK7cZn74bhH8cNdoH_YVbIVT3-6tIOlCA_Bc8YypGE1gl-ZvLOIPV7WnRQsWpWtZtqfKBSkwLAHgWoxcx_d1bOcyTOdPmsW224xcBxjYwi6iRUtjTJST0LzOcAOCPDZq6-lqYUwnxLO_afxwg71BGX4etE48Iny8TxSEIs1VJRahoabC7hVOs17ujEm5loTDSpfuhae51qSDg8xeYwRHdM42aLUmc-wOvBWauHa5EHbH9rWPAnpaGIwF8QvnLszqp4QQ</span><br><span class="line">...</span><br><span class="line">$ curl -k  -H <span class="string">&quot;Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6InBtQUZfRl8ycC03TTBYaUUwTnJVZGpvQWU0cXZ5M2FFbjR2ZjkzZVcxOE0ifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJsdWZmeSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJsdWZmeS1hZG1pbi10b2tlbi1wcnIyNSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJsdWZmeS1hZG1pbiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImFhZDA0MTU3LTliNzMtNDJhZC1hMGU4LWVmOTZlZDU3Yzg1ZiIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpsdWZmeTpsdWZmeS1hZG1pbiJ9.YWckylE5wlKITKrVltXY4VPKvZP9ar5quIT5zq9N-0_FnDkLIBX7xOyFvZA5Wef0wSFSZe3e9FwrO1UbPsmK7cZn74bhH8cNdoH_YVbIVT3-6tIOlCA_Bc8YypGE1gl-ZvLOIPV7WnRQsWpWtZtqfKBSkwLAHgWoxcx_d1bOcyTOdPmsW224xcBxjYwi6iRUtjTJST0LzOcAOCPDZq6-lqYUwnxLO_afxwg71BGX4etE48Iny8TxSEIs1VJRahoabC7hVOs17ujEm5loTDSpfuhae51qSDg8xeYwRHdM42aLUmc-wOvBWauHa5EHbH9rWPAnpaGIwF8QvnLszqp4QQ&quot;</span> https://10.209.0.13:6443/api/v1/namespaces/test/pods?<span class="built_in">limit</span>=500</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://10.209.0.13:6443/api/v1/nodes</span></span><br></pre></td></tr></table></figure><h2 id="认证、鉴权图鉴"><a href="#认证、鉴权图鉴" class="headerlink" title="认证、鉴权图鉴"></a>认证、鉴权图鉴</h2><p><img src="/post/docker/k8s-auth-auth.jpg" alt="k8s auth auth"></p><h2 id="创建用户认证授权的-kubeconfig-文件"><a href="#创建用户认证授权的-kubeconfig-文件" class="headerlink" title="创建用户认证授权的 kubeconfig 文件"></a>创建用户认证授权的 kubeconfig 文件</h2><p>这里我们签发一个用户认证的kubeconfig文件。比如研发、测试想要使用kubectl访问k8s集群，但是又不想给他们root权限，就可以通过这种方式来做，因为一旦kubeconfig文件给出去了，再进行限制就难了。</p><h3 id="签发证书对："><a href="#签发证书对：" class="headerlink" title="签发证书对："></a>签发证书对：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">$ openssl genrsa -out test.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书请求文件</span></span><br><span class="line">$ openssl req -new -key test.key -out test.csr -subj <span class="string">&quot;/O=admin:test/CN=test-admin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 证书拓展属性</span></span><br><span class="line"><span class="comment"># - keyUsage：证书用途</span></span><br><span class="line"><span class="comment">#   - critical：表示必须</span></span><br><span class="line"><span class="comment">#   - digitalSignature：数字签名</span></span><br><span class="line"><span class="comment">#   - keyEncipherment：密钥加密</span></span><br><span class="line"><span class="comment"># - extendedKeyUsage：证书扩展用途</span></span><br><span class="line"><span class="comment">#   - clientAuth：客户端认证</span></span><br><span class="line">$ <span class="built_in">cat</span> extfile.conf</span><br><span class="line">[ v3_ca ]</span><br><span class="line">keyUsage = critical, digitalSignature, keyEncipherment</span><br><span class="line">extendedKeyUsage = clientAuth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成test.crt证书</span></span><br><span class="line">$ openssl x509 -req -<span class="keyword">in</span> test.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -sha256 -out test.crt -extensions v3_ca -extfile extfile.conf -days 3650</span><br></pre></td></tr></table></figure><h3 id="配置kubeconfig文件："><a href="#配置kubeconfig文件：" class="headerlink" title="配置kubeconfig文件："></a>配置kubeconfig文件：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建kubeconfig文件，指定集群名称和地址</span></span><br><span class="line">$ kubectl config set-cluster test-cluster --certificate-authority=/etc/kubernetes/pki/ca.crt --embed-certs=<span class="literal">true</span> --server=https://10.209.0.13:6443 --kubeconfig=test.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为kubeconfig文件添加认证信息</span></span><br><span class="line">$ kubectl config set-credentials test-admin --client-certificate=test.crt --client-key=test.key --embed-certs=<span class="literal">true</span> --kubeconfig=test.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为kubeconfig添加上下文配置</span></span><br><span class="line">$ kubectl config set-context test-context --cluster=test-cluster --user=test-admin --kubeconfig=test.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认的上下文</span></span><br><span class="line">$ kubectl config use-context test-context --kubeconfig=test.kubeconfig</span><br></pre></td></tr></table></figure><h3 id="权限绑定"><a href="#权限绑定" class="headerlink" title="权限绑定"></a>权限绑定</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置当前kubectl使用的config文件</span></span><br><span class="line">$ <span class="built_in">export</span> KUBECONFIG=test.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前不具有任何权限，因为没有为用户或者组设置RBAC规则</span></span><br><span class="line">$ kubectl get po</span><br><span class="line">Error from server (Forbidden): pods is forbidden: User <span class="string">&quot;test-admin&quot;</span> cannot list resource <span class="string">&quot;pods&quot;</span> <span class="keyword">in</span> API group <span class="string">&quot;&quot;</span> <span class="keyword">in</span> the namespace <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure><p>为test-admin用户添加test命名空间访问权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义role，具有test命名空间的所有权限</span></span><br><span class="line">$ <span class="built_in">cat</span> test-admin-role.yaml</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">  name: test-admin</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [<span class="string">&quot;*&quot;</span>] <span class="comment"># &quot;&quot; 指定核心 API 组</span></span><br><span class="line">  resources: [<span class="string">&quot;*&quot;</span>]</span><br><span class="line">  verbs: [<span class="string">&quot;*&quot;</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment">#定义rolebinding，为test用户绑定test-admin这个role，这样test用户就有操作test命名空间的所有权限</span></span><br><span class="line">$ <span class="built_in">cat</span> test-admin-rolebinding.yaml</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: test-admin</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: test-admin <span class="comment"># Name is case sensitive</span></span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role <span class="comment">#this must be Role or ClusterRole</span></span><br><span class="line">  name: test-admin <span class="comment"># 这里的名称必须与你想要绑定的 Role 或 ClusterRole 名称一致</span></span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建role和rolebinding</span></span><br><span class="line">$ kubectl create -f test-admin-role.yaml</span><br><span class="line">$ kubectl create -f test-admin-rolebinding.yaml</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>此时，使用用户test-admin，就可以访问test命名空间的资源了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里因为namespace是default，所以还是没有权限</span></span><br><span class="line">$ kubectl get po</span><br><span class="line">Error from server (Forbidden): pods is forbidden: User <span class="string">&quot;test-admin&quot;</span> cannot list resource <span class="string">&quot;pods&quot;</span> <span class="keyword">in</span> API group <span class="string">&quot;&quot;</span> <span class="keyword">in</span> the namespace <span class="string">&quot;default&quot;</span></span><br><span class="line">$ kubectl get po -n <span class="built_in">test</span></span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">myblog-84985b5b66-jp9gg    1/1     Running   0          54d</span><br><span class="line">myblog-84985b5b66-smpwb    1/1     Running   0          54d</span><br><span class="line">mysql-7f97cb6cc9-vzxpd     1/1     Running   0          55d</span><br><span class="line">testpod-865855cfc5-m2f99   1/1     Running   0          42d</span><br></pre></td></tr></table></figure><h2 id="小技巧总结"><a href="#小技巧总结" class="headerlink" title="小技巧总结"></a>小技巧总结</h2><h3 id="快速反查-ServiceAccount"><a href="#快速反查-ServiceAccount" class="headerlink" title="快速反查 ServiceAccount"></a>快速反查 ServiceAccount</h3><p>比如我们查看system:masters这个集群角色绑定的用户，可以通过以下命令快速找到对应字段并且获取一些相关信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe clusterrolebindings.rbac.authorization.k8s.io -o yaml|grep -n15 system:masters</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> auth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq for python</title>
      <link href="/rabbitmq-for-python/"/>
      <url>/rabbitmq-for-python/</url>
      
        <content type="html"><![CDATA[<p>因为最近在学习rabbitmq，所以这里记录一下rabbitmq的python客户端的使用。</p><span id="more"></span><h1 id="MQ相关的概念"><a href="#MQ相关的概念" class="headerlink" title="MQ相关的概念"></a>MQ相关的概念</h1><p>RabbitMQ 是一种分布式消息中间件，消息中间件也称消息队列MQ</p><h2 id="MQ的基本概念"><a href="#MQ的基本概念" class="headerlink" title="MQ的基本概念"></a>MQ的基本概念</h2><p>什么是MQ？MQ是消息队列的英文缩写，即Message<br>Queue，是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。</p><p><img src="/post/rabbitmq/message-queue.png" alt="message-queue"></p><p>在互联网架构中，MQ是一种非常常见的上下游”逻辑解耦+物理解耦”的消息通信服务，用于上下游传递消息。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务</p><p>常见的MQ消息中间件有很多，例如ActiveMQ、RabbitMQ、Kafka、RocketMQ等等。</p><p>MQ能很好的解决一些复杂特殊的场景：</p><ol><li><p>高并发的流量削峰</p><p>假设某订单系统每秒最多能处理一万次订单，也就是最多承受的10000qps，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><p><img src="/post/rabbitmq/traffic-peak-shaving.png" alt="traffic-peak-shaving"></p></li><li><p>应用解耦</p><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><p><img src="/post/rabbitmq/application-decoupling.png" alt="application-decoupling"></p></li><li><p>异步处理</p><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A<br>过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A<br>服务。这两种方式都不是很优雅，使用消息队列，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B<br>处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback<br>api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="/post/rabbitmq/asynchronous-processing.png" alt="asynchronous-processing"></p></li><li><p>分布式事务</p><p>以订单服务为例，传统的方式为单体应用，支付、修改订单状态、创建物流订单三个步骤集成在一个服务中，因此这三个步骤可以放在一个事务中，要么全成功，要么全失败。而在微服务的环境下，会将三个步骤拆分成三个服务，例如：支付服务，订单服务，物流服务。三者各司其职，相互之间进行服务间调用，但这会带来分布式事务的问题，因为三个步骤操作的不是同一个数据库，导致无法使用事务管理以达到一致性。而<br>MQ<br>能够很好的帮我们解决分布式事务的问题，有一个比较容易理解的方案，就是二次提交。基于MQ的特点，MQ作为二次提交的中间节点，负责存储请求数据，在失败的情况可以进行多次尝试，或者基于MQ中的队列数据进行回滚操作，是一个既能保证性能，又能保证业务一致性的方案，如下图所示：</p><p><img src="/post/rabbitmq/distributed-transaction.png" alt="distributed-transaction"></p></li><li><p>数据分发</p><p>MQ 具有发布订阅机制，不仅仅是简单的上游和下游一对一的关系，还有支持一对多或者广播的模式，并且都可以根据规则选择分发的对象。这样一份上游数据，众多下游系统中，可以根据规则选择是否接收这些数据，能达到很高的拓展性。</p><p><img src="/post/rabbitmq/data-distribution.png" alt="data-distribution"></p></li></ol><h2 id="常用的MQ"><a href="#常用的MQ" class="headerlink" title="常用的MQ"></a>常用的MQ</h2><ol><li><p>Kafka</p><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件，以其百万级 TPS<br>的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber,<br>Twitter, Netflix 等大公司所采纳。</p><ul><li>优点：性能卓越，吞吐量高，单机写入 TPS 约在百万条&#x2F;秒，时效性 ms 级，可用性非常高；其次 kafka<br>是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据导致服务不可用，消费者采用 Pull<br>方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次。此外 kafka 有优秀的第三方 Kafka Web 管理界面<br>Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用；最后 kafka 在功能支持方便面它功能较为简单，主要支持简单的<br>MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</li><li>缺点：Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load<br>越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢；</li><li>选用场景：Kafka 主要特点是基于Pull<br>的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选<br>kafka 了。</li></ul></li><li><p>RocketMQ</p><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了<br>Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p><ul><li>优点：单机吞吐量十万级，可用性非常高，采用分布式架构，消息可以做到 0 丢失，MQ 功能较为完善，扩展性好，支持 10<br>亿级别的消息堆积，不会因为堆积导致性能下降，采用 java 语言实现。</li><li>缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ核心中去实现 JMS<br>等接口，有些系统要迁移需要修改大量代码。</li><li>选用场景：天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ<br>在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择<br>RocketMQ。</li></ul></li><li><p>RabbitMQ</p><p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><ul><li>优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ<br>功能比较完备、健壮、稳定、易用、跨平台、支持多种语言如Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持<br>AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高。</li><li>缺点：商业版需要收费，学习成本较高。</li><li>选用场景：结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的<br>RabbitMQ。</li></ul></li></ol><h2 id="消息队列协议"><a href="#消息队列协议" class="headerlink" title="消息队列协议"></a>消息队列协议</h2><p>协议是在TCP&#x2F;IP协议基础之上构建的种约定成的规范和机制，目的是让客户端进行沟通和通讯。并且这种协议下规范必须具有<code>持久性</code>，<code>高可用</code>，<code>高可靠</code><br>的性能。</p><p>为什么不直接采用TCP&#x2F;IP协议去传递消息？因为TCP&#x2F;IP协议太过于简单，并不能承载消息的内容和载体，因此在此之上增加一些内容，给消息的传递分发高可用提供基础。</p><p>我们知道消息中间件负责数据的传递，存储，和分发消费三个部分，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，是采用底层的TCP&#x2F;IP，UDP协议还是在这基础上自己构建等，而这些约定成俗的规范就称之为：协议。</p><p>消息中间件采用的并不是http协议，而常见的消息中间件协议有：OpenWire、AMQP、MQTT、Kafka、OpenMessage协议</p><blockquote><p>面试题：为什么消息中间件不直接使用http协议呢？</p></blockquote><p>因为http请求报文头和响应报文头是比较复杂的，包含了cookie、数据的加密解密、状态码、晌应码等附加的功能，但是对于个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就够，要追求的是高性能。尽量简洁，快速。</p><blockquote></blockquote><p>大部分情况下http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p><h2 id="常用消息中间件协议"><a href="#常用消息中间件协议" class="headerlink" title="常用消息中间件协议"></a>常用消息中间件协议</h2><ol><li><p>AMQP协议（Advanced Message Queuing Protocol—高级消息队列协议）</p><p>它由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。</p><p>特性：分布式事务支、消息的持久化支持、高性能和高可靠的消息处理优势</p><p>AMQP典型的实现者是RabbitMQ、ACTIVEMQ等</p></li><li><p>MQTT协议（Message Queueing Telemetry Transport—消息队列遥测传输协议）</p><p>它是一种基于发布&#x2F;订阅（publish&#x2F;subscribe）模式的”轻量级”通讯协议，该协议构建于TCP&#x2F;IP协议上，由IBM在1999年发布。</p><p>特点：轻量、结构简单、传输快、不支持事务、没有持久化设计</p><p>应用场景：适用于计算能力有限、低带宽、网络不稳定的场景</p><p>支持者：RabbitMQ、ACTIVEMQ（默认情况下关闭，需要打开）</p></li><li><p>OpenMessage协议</p><p>是近几年由阿里、雅虎和滴滴出行、 Stremalio等公司共同参与创立的分布式消息中间件、流处理等领域的应用开发标准。</p><p>特点：结构简单、解析速度快、支持事务和持久化设计</p></li><li><p>Kafka协议</p><p>基于TCP&#x2F;IP的二进制协议。消息内部是通过长度来分割，由些基本数据类型组成。</p><p>特点：结构简单、解析速度快、无事务支持、有持久化设计</p></li></ol><h2 id="消息队列持久化"><a href="#消息队列持久化" class="headerlink" title="消息队列持久化"></a>消息队列持久化</h2><p>持久化简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。</p><p><img src="/post/rabbitmq/message-queue-persistence.png" alt="message-queue-persistence"></p><p>常见的持久化方式和对比：</p><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>文件存储</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据库</td><td>支持</td><td>&#x2F;</td><td>&#x2F;</td><td>&#x2F;</td></tr></tbody></table><h2 id="消息的分发策略"><a href="#消息的分发策略" class="headerlink" title="消息的分发策略"></a>消息的分发策略</h2><p>MQ消息队列有如下几个角色：</p><ul><li>Producer：消息生产者。负责产生和发送消息到 Broker</li><li>Broker：消息处理中心。负责消息存储、确认、重试等，一般其中会包含多个 queue</li><li>Consumer：消息消费者。负责从 Broker 中获取消息，并进行相应处理</li></ul><p>生产者产生消息后，MQ进行存储，消费者获得消息无外乎外推（push）或者拉（pull）两种方式，典型的git就有推拉机制，我们发送的http请求就是一种典型的拉取数据库数据返回的过程。而消息队列MQ是一种推送过程，而这些推机制会适用到很多的业务场景，也有很多对应的推机制策略</p><h3 id="场景分析一"><a href="#场景分析一" class="headerlink" title="场景分析一"></a>场景分析一</h3><p>比如我在APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被那个系统或者那些服务或者系统进行消费，此时就需要一个消费策略，或称为消费的方法论。</p><p><img src="/post/rabbitmq/message-dispatch-strategy.png" alt="message-dispatch-strategy"></p><h3 id="场景分析二"><a href="#场景分析二" class="headerlink" title="场景分析二"></a>场景分析二</h3><p>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发</p><p><img src="/post/rabbitmq/message-dispatch-strategy-2.png" alt="message-dispatch-strategy-2"></p><h3 id="消息分发策略的机制和对比"><a href="#消息分发策略的机制和对比" class="headerlink" title="消息分发策略的机制和对比"></a>消息分发策略的机制和对比</h3><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>发布订阅</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>轮询分发</td><td>支持</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>公平分发</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>重发</td><td>支持</td><td>支持</td><td>&#x2F;</td><td>支持</td></tr><tr><td>消息拉取</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><h2 id="消息队列的高可用和高可靠"><a href="#消息队列的高可用和高可靠" class="headerlink" title="消息队列的高可用和高可靠"></a>消息队列的高可用和高可靠</h2><p>所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力。</p><p>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU、内存、磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。</p><ol><li><p>Master-slave主从共享数据的部署方式</p><p>该模式将多个消息服务器Broker连接共享一块消息存储空间，其中Master节点负责消息的写入。客户端会将消息写入到Master节点，一旦Master挂掉，slave节点继续服务，从而形成高可用。</p><p><img src="/post/rabbitmq/message-queue-high-availability.png" alt="message-queue-high-availability"></p></li><li><p>Master-slave主从同步部署方式</p><p>该模式写入消息同样在Master节点上，但是主结点会同步数据到slave节点形成副本，和zookeeper或者redis主从机制很类似。这样可以达到负载均衡的效果，如果消费者有多个，就可以到不同的节点进行消费，但是消息的拷贝和同步会占用很大的贷款和网络资源。在rabbitMQ中会有使用。</p><p><img src="/post/rabbitmq/message-queue-high-availability-2.png" alt="message-queue-high-availability-2"></p></li><li><p>多主集群同步部署模式</p><p>和上述方式区别不大，但是该方式任意节点都可以进行写入。</p><p><img src="/post/rabbitmq/message-queue-high-availability-3.png" alt="message-queue-high-availability-3"></p></li><li><p>多主集群转发部署模式</p><p>如果插入的数据是Broker1，元数据信息会存储数据的相关描述和记录存放的位置（队列），它会对描述信息，也就是元数据进行同步；</p><p>如果消费者在Broker2中进行消费，发现自己没有对应的消息，就会在自己的元数据信息中去查询，如果查询到了直接返回。如果没有查询到就会将该消息的信息携带在请求中转发到其他节点去询问，直到找到所需的信息为止。</p><p>场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛没有顾客说要买的演唱会门票，但是他会去联系其他的黄牛询问，如果有就返回</p><p><img src="/post/rabbitmq/message-queue-high-availability-4.png" alt="message-queue-high-availability-4"></p></li><li><p>Master-slave与Broker-cluster组合的方案</p><p>实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到定的阶段的时候，这种使用的频率比较高。</p><p><img src="/post/rabbitmq/message-queue-high-availability-5.png" alt="message-queue-high-availability-5"></p></li></ol><p>这些集群模式最终目的都是为保证：消息服务器不会挂掉，出现了故障依然可以抱着消息服务继续使用。反正终归三句话：</p><ul><li>要么消息共享</li><li>要么消息同步</li><li>要么元数据共享</li></ul><h1 id="RabbitMQ-快速入门"><a href="#RabbitMQ-快速入门" class="headerlink" title="RabbitMQ 快速入门"></a>RabbitMQ 快速入门</h1><h2 id="RabbitMQ的概念"><a href="#RabbitMQ的概念" class="headerlink" title="RabbitMQ的概念"></a>RabbitMQ的概念</h2><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑<br>RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于：它不处理快件而是接收，存储和转发消息数据。</p><h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><p>RabbitMQ是一种遵循AMQP协议的分布式消息中间件。AMQP 全称 “Advanced Message Queuing Protocol”<br>，高级消息队列协议。它是应用层协议的一个开发标准，为面向消息的中间件设计。</p><p>下图是采用 AMQP 协议的生产者和消费者建立和释放连接的流程图：</p><p><img src="/post/rabbitmq/amqp-protocol.png" alt="amqp-protocol"></p><h2 id="RabbitMQ架构组成"><a href="#RabbitMQ架构组成" class="headerlink" title="RabbitMQ架构组成"></a>RabbitMQ架构组成</h2><p><img src="/post/rabbitmq/rabbitmq-architecture.png" alt="rabbitmq-architecture"></p><ul><li>Broker：就是 RabbitMQ 服务，用于接收和分发消息，接受客户端的连接，实现 AMQP 实体服务。</li><li>Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace<br>概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange<br>或 queue 等。</li><li>Connection：连接，生产者&#x2F;消费者与 Broker 之间的 TCP 网络连接。</li><li>Channel：网络信道，如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立连接的开销将是巨大的，效率也较低。Channel<br>是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了<br>channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的Connection<br>极大减少了操作系统建立 TCP connection 的开销。</li><li>Message：消息，服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。</li><li>Virtual Host：虚拟节点，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机理由可以有若干个Exhange和Queue，同一个虚拟主机里面不能有相同名字的Exchange</li><li>Exchange：交换机，是 message 到达 broker 的第一站，用于根据分发规则、匹配查询表中的 routing key，分发消息到 queue<br>中去，不具备消息存储的功能。常用的类型有：direct、topic、fanout。</li><li>Bindings：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于<br>message 的分发依据。</li><li>Routing key：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息</li><li>Queue：消息队列，保存消息并将它们转发给消费者进行消费。</li><li></li></ul><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><ul><li>生产者：产生数据发送消息的程序是生产者。</li><li>交换机：交换机是 RabbitMQ<br>非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个是由交换机类型决定的。</li><li>队列：队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ<br>和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</li><li>消费者：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</li></ul><p><img src="/post/rabbitmq/rabbitmq-core-concepts.png" alt="rabbitmq-core-concepts"></p><h2 id="RabbitMQ角色分类"><a href="#RabbitMQ角色分类" class="headerlink" title="RabbitMQ角色分类"></a>RabbitMQ角色分类</h2><p><img src="/post/rabbitmq/rabbitmq-role-classification.png" alt="rabbitmq-role-classification"></p><ul><li>None：不能访问 management plugin</li><li>Management：查看自己相关节点信息<ul><li>列出自己可以通过AMQP登入的虚拟机</li><li>查看自己的虚拟机节点virtual hosts的queues，exchanges和bindings信息</li><li>查看和关闭自己的channels和connections</li><li>查看有关自己的虚拟机节点virtual hosts的统计信息。包括其他用户在这个节点virtual hosts中的活动信息</li></ul></li><li>Policymaker<ul><li>包含management所有权跟</li><li>查看和创建和删除自己的virtual hosts所属的policies和parameters信息</li></ul></li><li>Monitoring<ul><li>包含management所有权限</li><li>罗列出所有的virtual hosts，包括不能登录的virtual hosts</li><li>查看其他用户的connections和channels信息</li><li>查看节点级别的数据如clustering和memory使用情况</li><li>查看所有的virtual hosts的全局统计信息。</li></ul></li><li>Administrator<ul><li>最高权限</li><li>可以创建和删除 virtual hosts</li><li>可以查看，创建和删除users</li><li>查看创建permissions</li><li>关闭所有用户的connections</li></ul></li></ul><h2 id="RabbitMQ消息模式"><a href="#RabbitMQ消息模式" class="headerlink" title="RabbitMQ消息模式"></a>RabbitMQ消息模式</h2><p>官网：<a href="https://www.rabbitmq.com/getstarted.html">RabbitMQ Tutorials — RabbitMQ</a></p><p><img src="/post/rabbitmq/rabbitmq-message-mode.png" alt="rabbitmq-message-mode"></p><p>RabbitMQ提供6种模式，分别是 Hello World、Work Queues、Publish&#x2F;Subscribe、Routing、Topics、RPC。本文详细讲述了前5种，并给出代码实现和思路。其中<br>Publish&#x2F;Subscribe、Routing、Topics 三种模式可以统一归为 Exchange 模式，只是创建时交换机的类型不一样，分别是<br>fanout、direct、topic 三种交换机类型。</p><blockquote><p>注意：简单模式和工作模式虽然途中没有画出交换机，但是都会有一个默认的交换机，类型为direct</p><p><img src="/post/rabbitmq/rabbitmq-message-mode-2.png" alt="rabbitmq-message-mode-2"></p></blockquote><ol><li><p>简单模式（Hello World）</p><p>一个生产者，一个消费者，一个队列，采用默认交换机。可以理解为生产者P发送消息到队列Q，一个消费者C接收。</p></li><li><p>工作模式（Work Queues）</p><p>一个生产者，多个消费者，一个队列，采用默认交换机。可以理解为生产者P发送消息到队列Q，可以由多个消费者C1、C2进行接收。</p></li><li><p>发布&#x2F;订阅模式（Publish&#x2F;Subscribe）</p><p>功能：一个生产者、一个 fanout 类型的交换机、多个队列、多个消费者。一个生产者发送的消息会被多个消费者获取。其中 fanout<br>类型就是发布订阅模式，只有订阅该生产者的消费者会收到消息。</p></li><li><p>路由模式（Routing）</p><p>功能：一个生产者，一个 direct 类型的交换机，多个队列，交换机与队列之间通过 routing-key<br>进行关联绑定，多个消费者。生产者发送消息到交换机并且要指定routing-key，然后消息根据这交换机与队列之间的 routing-key<br>绑定规则进行路由被指定消费者消费。</p></li><li><p>主题模式（Topics）</p><p>说明：一个生产者，一个 topic 类型的交换机，多个队列，交换机与队列之间通过 routing-key 进行关联绑定，多个消费者。生产者发送消息到交换机并且要指定<br>routing-key，然后消息根据这交换机与队列之间的 routing-key 绑定规则进行路由被指定消费者消费。与路由模式不同是<br>routing-key 有指定的队则，可以更加的通用，满足更过的场景。routing-key 的规则如下：</p><ul><li>#：匹配一个或者多个词，例如lazy.# 可以匹配 lazy.xxx 或者 lazy.xxx.xxx</li><li><em>：只能匹配一个词，例如lazy.</em> 只能匹配 lazy.xxx</li></ul></li><li><p>参数模式（RPC）</p><p>功能：一个生产者，一个消费者，一个队列，采用默认交换机。可以理解为生产者P发送消息到队列Q，一个消费者C接收。不同的是，消费者C接收到消息后，会给生产者P一个反馈。</p><p>作用：可以携带参数，根据参数进行过滤</p></li></ol><h1 id="RabbitMQ-使用"><a href="#RabbitMQ-使用" class="headerlink" title="RabbitMQ 使用"></a>RabbitMQ 使用</h1><h2 id="RabbitMQ-安装"><a href="#RabbitMQ-安装" class="headerlink" title="RabbitMQ 安装"></a>RabbitMQ 安装</h2><p>这里主要介绍使用方法，因此安装并不作为重点。这里使用docker安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin rabbitmq:3.9.11-management</span><br></pre></td></tr></table></figure><p>然后等待docker容器启动完成，访问 <a href="http://localhost:15672/">http://localhost:15672/</a> 即可看到管理界面，输入账号密码（admin&#x2F;admin）即可登录。</p><blockquote><p>注意：这里没有做持久化，因此重启docker容器后，数据会丢失</p></blockquote><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>RabbitMQ中的一些术语：</p><ul><li>生产者：发送消息的程序<br>  <img src="https://www.rabbitmq.com/img/tutorials/producer.png" alt="producer"></li><li>队列：尽管消息流经RabbitMQ和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。<br>  <img src="https://www.rabbitmq.com/img/tutorials/queue.png" alt="queue"></li><li>消费者：等待接收消息的程序<br>  <img src="https://www.rabbitmq.com/img/tutorials/consumer.png" alt="consumer"></li></ul><blockquote><p>注意：生产者、消费者和队列很多时候并不在同一机器上。同一个应用程序既可以是生产者又可以是可以是消费者。</p></blockquote><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>hello world的整体流程如下，生产者将消息发送到”hello”队列中，消费者从”hello”队列中接收消息。</p><p><img src="https://www.rabbitmq.com/img/tutorials/python-one-overall.png" alt="hello-world"></p><p>下面我们使用连接rabbitmq的python客户端pika来进行操作，首先安装pika</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pika --upgrade</span><br></pre></td></tr></table></figure><h3 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h3><p>我们编写一个生产者，发送消息到队列中</p><p><img src="https://www.rabbitmq.com/img/tutorials/sending.png" alt="sending"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建凭证(因为我们在docker中创建了用户admin/admin，因此这里使用这个用户)</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br></pre></td></tr></table></figure><p>这里我们使用了pika的一个阻塞连接，然后使用连接创建一个channel，channel是消息的主要发送和接收对象。</p><p>发送的队列也必须保证存在，因此我们需要先创建一个队列。如果队列不存在，则消息将会被丢弃。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在rabbitmq中，消息并不能直接发送给队列，都需要经过交换机，然后交换机再发送给队列。这里我们使用默认的交换机，交换机名称为空字符串。这个交换机是一个特殊的交换机，它会把消息发送到指定的队列中，指定的队列名称就是routing_key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;hello&#x27;</span>, body=<span class="string">&#x27;Hello World!&#x27;</span>.encode())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure><p>在我们确保消息发送成功后，我们需要关闭连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>完整的生产者代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建凭证</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;hello&#x27;</span>, body=<span class="string">&#x27;Hello World!&#x27;</span>.encode())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><h3 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h3><p>我们编写一个消费者，从队列中接收消息，并打印出来</p><p><img src="https://www.rabbitmq.com/img/tutorials/receiving.png" alt="receiving"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先，需要建立连接，创建channel，这里和生产者一样</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建凭证</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br></pre></td></tr></table></figure><p>创建队列，保证队列存在。这里我们使用了和生产者一样的代码，因为我们不知道生产者是否已经创建了队列（真正的环境不一定生产者先启动，有可能消费者先启动），因此这里也需要创建队列。</p><blockquote><p>这里创建队列使用的queue_declare方法，这个方法是幂等的，可以多次运行。也就是说，如果队列已经存在，那么就不会重复创建，如果不存在，那么就会创建。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p>无论什么时候接收消息后，pika都会调用回调函数callback进行处理。这里我们定义了一个回调函数，用于将消息打印到控制台。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Received %r&quot;</span> % body)</span><br></pre></td></tr></table></figure><p>然后我们需要告诉rabbitmq，我们使用callback来接收消息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告诉rabbitmq使用callback来接收消息</span></span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;hello&#x27;</span>, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>上面的命令需要确保队列存在，之前已经使用了queue_declare方法，因此这里不需要再次调用。如果队列不存在，那么这里会报错。</p><p>auto_ack参数表示是否自动确认消息，如果为True，那么消息一旦被消费者接收，就会被认为是已经被消费，不会再次发送给消费者。如果为False，那么消息不会被认为是已经被消费，那么消息就会一直存在，直到被消费者接收。</p><p>最后，我们需要让消费者一直运行，等待消息的到来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费者一直运行，等待消息的到来</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>主体执行代码如下，获取KeyBoardInterrupt异常，然后退出程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Interrupted&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">except</span> SystemExit:</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>完整的消费者代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika, sys, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Received %r&quot;</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建凭证</span></span><br><span class="line">    credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">    <span class="comment"># 建立连接</span></span><br><span class="line">    connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">    channel = connection.channel()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建队列</span></span><br><span class="line">    channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 告诉rabbitmq使用callback来接收消息</span></span><br><span class="line">    channel.basic_consume(queue=<span class="string">&#x27;hello&#x27;</span>, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者一直运行，等待消息的到来</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">    channel.start_consuming()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Interrupted&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">except</span> SystemExit:</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>首先，我们启动消费者，然后启动生产者，可以看到消费者接收到了消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python consumer.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received b&#x27;Hello World!&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>注意：第二个输出是生产者启动后的输出，这里只是为了说明生产者发送消息成功</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python producer.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line"> [x] Sent &#x27;Hello World!&#x27;</span><br></pre></td></tr></table></figure><h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p>工作队列（又名：任务队列），也就是一个生产者、多个消费者、一个队列。它的主要思想是避免排队等待，避免一个消息处理时间过久而无法处理下一个的问题。因此相比简单模式可以有多个消费者，原理就是把任务封装为消息并将其发送到队列中，这多个消费者可以一起处理队列中的任务。当有多个消费者时，消息会被平均分配给消费者，这样就可以实现负载均衡。</p><p><img src="https://www.rabbitmq.com/img/tutorials/python-two.png" alt="work-queues"></p><p>这个概念在 Web 应用程序中特别有用，因为在 Web 应用程序中不可能在较短的 HTTP<br>请求窗口内处理复杂的任务。此时，可以将任务发送到后端的工作队列中，然后立即响应用户，从而使用户不必等待任务完成。当任务最终完成时，用户可以在<br>Web 页面中获得通知或结果。</p><p>本节中通过使用 time.sleep() 函数假装我们很忙来伪造复杂耗时的操作。我们将字符串中点的个数作为其复杂度；每个点将占一秒钟的”<br>工作时间”。例如，Hello…描述的一个假任务 将需要三秒钟。</p><h3 id="生产者代码-1"><a href="#生产者代码-1" class="headerlink" title="生产者代码"></a>生产者代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建凭证</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;task_queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">message_list = [</span><br><span class="line">    <span class="string">&#x27;First message.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Second message..&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Third message...&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Fourth message....&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Fifth message.....&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> message <span class="keyword">in</span> message_list:</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;task_queue&#x27;</span>, body=message.encode())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Sent <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><h3 id="消费者代码-1"><a href="#消费者代码-1" class="headerlink" title="消费者代码"></a>消费者代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Received <span class="subst">&#123;body.decode()&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(body.count(<span class="string">b&#x27;.&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Done&quot;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建凭证</span></span><br><span class="line">    credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">    <span class="comment"># 建立连接</span></span><br><span class="line">    connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">    channel = connection.channel()</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 创建队列</span></span><br><span class="line">    channel.queue_declare(queue=<span class="string">&#x27;task_queue&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 告诉rabbitmq使用callback来接收消息</span></span><br><span class="line">    channel.basic_consume(queue=<span class="string">&#x27;task_queue&#x27;</span>, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 消费者一直运行，等待消息的到来</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">    channel.start_consuming()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Interrupted&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">except</span> SystemExit:</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h3><p>使用任务队列的优点之一是能够轻松的实现并行工作。如果我们正在生产者消息过多，我们可以方便的添加更多消费者，这样就可以轻松的进行水平扩展。</p><p>我们需要三个终端窗口。首先起两个消费者。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python consumer.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python consumer.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>然后启动生产者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python producer.py</span><br><span class="line"> [x] Sent First message.</span><br><span class="line"> [x] Sent Second message..</span><br><span class="line"> [x] Sent Third message...</span><br><span class="line"> [x] Sent Fourth message....</span><br><span class="line"> [x] Sent Fifth message.....</span><br></pre></td></tr></table></figure><p>可以看到，两个消费者平均接收到了消息，而且每个消息都只被一个消费者接收到。这样就实现了负载均衡。</p><p>第一个窗口显示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python consumer.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received First message.</span><br><span class="line"> [x] Done</span><br><span class="line"> [x] Received Third message...</span><br><span class="line"> [x] Done</span><br><span class="line"> [x] Received Fifth message.....</span><br><span class="line"> [x] Done</span><br></pre></td></tr></table></figure><p>第二个窗口显示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python consumer.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received Second message..</span><br><span class="line"> [x] Done</span><br><span class="line"> [x] Received Fourth message....</span><br><span class="line"> [x] Done</span><br></pre></td></tr></table></figure><p>因此，可以得出扩展消费者十分简单，只需要启动更多的消费者就可以了。</p><h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3><p>一个任务可能需要很长时间完成，使用我们现在的代码，消息一旦被消费者接收，就会被认为是已经被消费，立即将消息标记为删除，不会再次发送给消费者。这种情况下，如果消费者死亡，那么就会丢失正在处理的消息，哪怕这个消息已经被消费者接收，只要还没有处理完，就会丢失。</p><p>一般环境下，我们不希望丢失任何消息，如果一个消费者死亡，那么我们希望将消息发送给另一个消费者。</p><p>为了确保消息永远不会丢失，RabbitMQ支持消息确认。消费者发回 ack 确认，告诉RabbitMQ已收到并处理特定消息，并且RabbitMQ可以自由删除它。</p><p>如果消费者在没有发送 ack 的情况下死了（其通道关闭、连接关闭或 TCP 连接丢失），RabbitMQ<br>将会知道消息未完全处理并将消息重新排队。如果同时有其他消费者在线，那么它会快速将其重新传递给另一个消费者。这样你就可以确保即使消费者偶尔死了也不会丢失任何消息。</p><p>消费者有强制交付的超时时间（默认为 30 分钟），如果程序卡住或其他问题，可以保证消息不会无限期的占用内存。可以在全局配置或者每一个队列中单独配置超时时间。</p><p>消费者交付确认时强制执行超时（默认为 30<br>分钟）。这有助于检测从不确认交付的有问题（卡住）的消费者。您可以按照传送确认超时中所述增加此超时 。</p><p>默认情况下，手动消息确认处于打开状态。在前面的示例中，我们通过<code>auto_ack=True</code><br>标志显式关闭了它们。现在我们将其删除，并在循环中添加一个显式的消息确认调用（只需要修改消费者的callback函数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Received <span class="subst">&#123;body.decode()&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(body.count(<span class="string">b&#x27;.&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Done&quot;</span>)</span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 告诉rabbitmq使用callback来接收消息</span></span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;task_queue&#x27;</span>, on_message_callback=callback)</span><br></pre></td></tr></table></figure><p>使用此代码，您可以确保即使在处理消息时使用 CTRL+C 终止工作程序，也不会丢失任何内容。工作线程终止后不久，所有未确认的消息都会被重新传递。</p><p>注意，ack确认必须在接收交付的同一通道上发送。不同的通道，甚至是不同的连接，不能用来确认交付，否则会导致通道级协议异常。</p><blockquote><p><strong>忘记确认</strong><br>错过 basic_ack 是一个常见的错误。这是一个很容易犯的错误，但后果却很严重。当您的客户端退出时，消息将被重新传送（这可能看起来像随机重新传送），但<br>RabbitMQ 会占用越来越多的内存，因为它无法释放任何未确认的消息。<br>为了调试这种错误，您可以使用<code>rabbitmqctl</code>打印<code>messages_unacknowledged</code>字段：<br>rabbitmqctl list_queues name messages_ready messages_unacknowledged</p></blockquote><h3 id="消息持久性"><a href="#消息持久性" class="headerlink" title="消息持久性"></a>消息持久性</h3><p>我们已经学会了如何确保即使消费者死亡，消息也不会丢失。但是如果 RabbitMQ 服务器停止，我们的消息仍然会丢失。</p><p>当 RabbitMQ 退出或者崩溃时，队列和消息就会丢失，除非显示的指定为持久的。为了保证持久性，我们需要做两件事情：我们需要将队列和消息标记为持久的。</p><p>首先，我们需要确保队列能够在 RabbitMQ 节点重新启动后继续存在。为此，我们需要将其声明为持久的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=<span class="string">&#x27;task_queue&#x27;</span>, durable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>尽管这个命令本身是正确的，但它在我们的设置中不起作用。这是因为我们已经定义了一个名为<code>task_queue</code>的队列 ，它是不持久的。RabbitMQ<br>不允许使用不同的参数重新定义现有队列，并将向任何尝试执行此操作的程序返回错误。但有一个快速的解决方法 -<br>让我们声明一个具有不同名称的队列，例如<code>new_task_queue</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=<span class="string">&#x27;new_task_queue&#x27;</span>, durable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>此<code>queue_declare</code>更改需要应用于生产者和消费者代码。</p><p>这样设置之后，即使 RabbitMQ 重新启动，队列也不会丢失。但是，消息仍然会丢失。尽管它们现在在队列中，但是 RabbitMQ<br>退出时，它们仍然会丢失。我们需要将我们的消息也标记为持久 - 通过提供带有<code>pika.spec.PERSISTENT_DELIVERY_MODE</code><br>值的<code>delivery_mode</code>属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;new_task_queue&#x27;</span>, body=message.encode(), properties=pika.BasicProperties(delivery_mode=pika.spec.PERSISTENT_DELIVERY_MODE))</span><br></pre></td></tr></table></figure><blockquote><p>注意：将消息标记为持久并不能完全保证消息不会丢失。尽管它告诉 RabbitMQ 将消息保存到磁盘，但 RabbitMQ<br>接受消息并将其保存到磁盘之间仍然有一个很小的时间窗口。此外，RabbitMQ 不会对每条消息执行fsync(2) ——</p></blockquote><p>它可能只是保存到缓存中，而不是真正写入磁盘。持久性保证并不强，但对于我们简单的任务队列来说已经足够了。如果您需要更强的保证，那么您可以使用 <a href="rabbitmq.com/confirms.html">publisher confirms</a>。</p><h3 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h3><p>很明显，调度只是平均分配任务给消费者。这种情况下，如果一个消费者比另一个消费者处理消息慢，或者所有奇数消息都很重但是偶数消息都很轻，那么就会导致一个消费者一直很忙，而另一个消费者几乎不做任何工作。RabbitMQ 对此一无所知，并且仍然会均匀地分发消息。</p><p>发生这种情况是因为 RabbitMQ 只是在消息进入队列时才调度该消息。它不会查看消费者未确认消息的数量。它只是盲目地将每条第 n 条消息分派给第 n 个消费者。</p><p><img src="https://www.rabbitmq.com/img/tutorials/prefetch-count.png" alt="fair-dispatch"></p><p>为了解决这个问题，我们可以使用设置为<code>prefetch_count=1</code>的<code>Channel.basic_qos</code>方法。这使用<code>basic.qos</code>协议方法告诉 RabbitMQ 不要一次向消费者提供多于一条消息。或者，换句话说，在消费者处理并确认前一条消息之前，不要向消费者发送新消息。相反，它会将其分派给下一个不忙的消费者。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>关于队列大小的注意事项</strong> :</p></blockquote><p>如果所有消费者都很忙，您的队列可能会被填满。您需要密切关注这一点，也许添加更多消费者，或者使用<a href="rabbitmq.com/ttl.html">消息 TTL</a></p><blockquote><p>来避免这种情况。</p></blockquote><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>生产者代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建凭证</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;new_task_queue&#x27;</span>, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">message_list = [</span><br><span class="line">    <span class="string">&#x27;First message.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Second message..&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Third message...&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Fourth message....&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Fifth message.....&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> message <span class="keyword">in</span> message_list:</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;new_task_queue&#x27;</span>, body=message.encode(), properties=pika.BasicProperties(delivery_mode=pika.spec.PERSISTENT_DELIVERY_MODE))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Sent <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>消费者代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Received <span class="subst">&#123;body.decode()&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(body.count(<span class="string">b&#x27;.&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Done&quot;</span>)</span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建凭证</span></span><br><span class="line">    credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 建立连接</span></span><br><span class="line">    connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">    channel = connection.channel()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建队列</span></span><br><span class="line">    channel.queue_declare(queue=<span class="string">&#x27;new_task_queue&#x27;</span>, durable=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置每个消费者每次只能接收一条消息</span></span><br><span class="line">    channel.basic_qos(prefetch_count=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 告诉rabbitmq使用callback来接收消息</span></span><br><span class="line">    channel.basic_consume(queue=<span class="string">&#x27;new_task_queue&#x27;</span>, on_message_callback=callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者一直运行，等待消息的到来</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">    channel.start_consuming()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Interrupted&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">except</span> SystemExit:</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>使用消息确认和prefetch_count您可以设置工作队列。即使 RabbitMQ 重新启动，持久性选项也能让任务继续存在。</p><h2 id="Publish-x2F-Subscribe"><a href="#Publish-x2F-Subscribe" class="headerlink" title="Publish&#x2F;Subscribe"></a>Publish&#x2F;Subscribe</h2><p>Publish&#x2F;Subscribe、Routing、Topics，这三种模式可以统一归为 Exchange 模式，它们只是创建时交换机的类型不一样，分别是 fanout、direct、topic类型</p><p>这节我们就来深入了解一下交换机 Exchange 以及它的几种工作模式。</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>在前面的教程中，我们已经了解了如何向队列发送消息和从队列接收消息。现在是时候介绍 Rabbit 中完整的消息传递模型了。</p><p>让我们快速回顾一下之前教程中介绍的内容：</p><ol><li>一个生产者应用程序发送消息。</li><li>一个队列存储消息到缓冲区直到它们可以被处理。</li><li>一个消费者应用程序接收消息并处理它们。</li></ol><p>RabbitMQ 消息传递模型的核心思想是生产者从不直接向队列发送任何消息。实际上，生产者通常根本不知道消息是否会被传递到任何队列。</p><p>相反，生产者只能将消息发送到交换器。交换是一件非常简单的事情。一方面，它接收来自生产者的消息，另一方面，它将消息推送到队列中。交换机必须确切地知道如何处理它收到的消息。是否应该将其附加到特定队列？是否应该将其附加到许多队列中？或者应该将其丢弃。其规则由交换类型定义。</p><p><img src="https://www.rabbitmq.com/img/tutorials/exchanges.png" alt="exchange"></p><p>RabbitMQ有几种可用的交换类型：direct、topic、headers 和 fanout。这里我们将重点关注最后一个类型fanout，其他的会在之后说明。让我们创建一个该类型的交换，并将其称为<code>logs</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;logs&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>)</span><br></pre></td></tr></table></figure><p>fanout类型的交换机非常简单，它只是将接收到的所有消息广播到它知道的所有队列。这正是我们的日志记录器所需要的。</p><blockquote><p><strong>列出所有的交换机</strong><br>如果您想要列出服务器上的交换，可以运行以下命令：<code>rabbitmqctl list_exchanges</code></p><p>列表中会有一写amq.*的交换和默认（未命名）交换。这些是默认创建的，但目前您不太可能需要使用它们。</p></blockquote><blockquote><p><strong>默认交换机</strong><br>在之前的部分，我们使用默认的交换机发送消息（程序中是一个空字符串””）。空字符串表示默认或无名交换机。消息将路由到具有routing_key指定名称的队列（如果存在）。</p></blockquote><p>现在我们可以将消息发送到我们的日志交换机上了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;logs&#x27;</span>, routing_key=<span class="string">&#x27;&#x27;</span>, body=message.encode())</span><br></pre></td></tr></table></figure><h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>还记得之前使用过的特定名称的队列吗（比如hello和task_queue）？当我们想要在生产者和消费者之间共享队列时，为队列命名非常重要。</p><p>但是我们的logs显然并非如此。我们希望监听所有的日志消息，而不仅仅是其中的一部分。同时只对当前流动的消息感兴趣，而不是旧的消息。为了解决这个问题，我们需要两件事。</p><p>首先，每当我们连接到 RabbitMQ 时，我们都需要一个新的空队列。为此，我们可以创建一个具有随机名称的队列，或者让服务器为我们选择一个随机队列名称。我们可以通过向queue_declare提供空队列参数来做到这一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里我们使用了随机队列名称，通过将队列名称设置为空字符串，我们告诉服务器为我们选择一个随机队列名称。如果我们想要知道队列的名称，可以通过result.method.queue获得。比如，它可能看起来像amq.gen-JzTY20BRgKO-HjmUJj0wLg。</p><p>其次，一旦消费者连接关闭，队列就应该被删除。有一个专用标志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p><img src="https://www.rabbitmq.com/img/tutorials/bindings.png" alt="bindings"></p><p>现在我们已经准备好将我们的日志消息发送到我们的交换机，交换机需要知道怎么发送消息给队列。交换机和队列之间的关系称为绑定。绑定是交换机和队列之间的关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;logs&#x27;</span>, queue=result.method.queue)</span><br></pre></td></tr></table></figure><p>现在开始，<code>logs</code>交换机将会把消息发送到我们的队列中。</p><blockquote><p><strong>列出绑定</strong><br>如果您想要列出服务器上的绑定，可以运行以下命令：<code>rabbitmqctl list_bindings</code></p></blockquote><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><p><img src="https://www.rabbitmq.com/img/tutorials/python-three-overall.png" alt="publish-subscribe"></p><p>发送消息日志的生产者和之前没有什么区别，主要就是创建了一个交换机，然后发送消息到交换机上。发送时需要提供routing_key，但是fanout类型的交换机会忽略这个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;emit_log.py&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;logs&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message_list = [</span><br><span class="line">    <span class="string">&#x27;First Log Message&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Second Log Message&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Third Log Message&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Fourth Log Message&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Fifth Log Message&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> message <span class="keyword">in</span> message_list:</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;logs&#x27;</span>, routing_key=<span class="string">&#x27;&#x27;</span>, body=message.encode())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Sent <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>如您所见，建立连接后我们声明了交换。此步骤是必要的，因为发布到不存在的交换机是不允许的。</p><p>此时如果还没有队列绑定到交换器，消息将会丢失，但这对我们来说影响不大，如果还没有消费者在监听，我们可以安全地丢弃该消息。</p><p>接收消息的消费者代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;receive_logs.py&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Received <span class="subst">&#123;body.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;logs&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;logs&#x27;</span>, queue=queue_name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>以上就完成了所有的代码。如果希望将日志保存到文件，只需要打开控制台并输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python receive_logs.py&gt;logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>我们完成了。如果要将日志保存到文件中，只需打开控制台并输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python receive_logs.py&gt;logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>如果只是需要在控制台中查看日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python receive_logs.py</span><br></pre></td></tr></table></figure><p>当然，发送消息的生产者也需要启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python emit_log.py</span><br></pre></td></tr></table></figure><p>使用<code>rabbitmqctl list_bindings</code>，您可以验证代码是否确实按照我们的需要创建了绑定和队列。运行两个receive_logs.py程序后，您应该看到类似以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl list_bindings</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; Listing bindings ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; logs    exchange        amq.gen-JzTY20BRgKO-HjmUJj0wLg    queue   []</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; logs    exchange        amq.gen-vso0PVvyiRIL2WoV3i48Yg    queue   []</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; ...<span class="keyword">done</span>.</span></span><br></pre></td></tr></table></figure><p>结果表明，我们的两个队列都绑定到logs交换机上了。当我们停止两个消费者中的一个时，我们会看到绑定消失：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl list_bindings</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; Listing bindings ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; logs    exchange        amq.gen-JzTY20BRgKO-HjmUJj0wLg    queue   []</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; ...<span class="keyword">done</span>.</span></span><br></pre></td></tr></table></figure><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><h3 id="绑定键"><a href="#绑定键" class="headerlink" title="绑定键"></a>绑定键</h3><p>在前面的代码中，我们已经创建了绑定。您可能还记得这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;logs&#x27;</span>, queue=queue_name)</span><br></pre></td></tr></table></figure><p>绑定是交换器和队列之间的关系。这可以简单地理解为：队列对来自此交换的消息感兴趣。</p><p>绑定可以采用额外的routing_key参数。为了避免与basic_publish参数混淆，我们将其称为<code>绑定键</code>。下面创建一个带有绑定键的绑定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;logs&#x27;</span>, queue=queue_name, routing_key=<span class="string">&#x27;black&#x27;</span>)</span><br></pre></td></tr></table></figure><p>绑定键的含义取决于交换类型。我们之前使用的fanout交换机会完全忽略绑定键。</p><h3 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h3><p>之前的日志系统会广播所有的消息给所有的消费者，但是我们可能只想让严重的错误消息发送给日志文件写入磁盘，而不是所有的日志消息浪费磁盘空间。</p><p>fanout交换机并不满足我们的需求，它只能进行无意识的广播。此时我们可以使用direct类型的交换机来实现这个功能。direct交换机背后的路由算法很简单：消息会被推送到绑定键与消息的路由键完全匹配的队列（注意这两个键的区别）。</p><p>为了说明这一点，做了以下设置：</p><p><img src="https://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt="direct-exchange"></p><ol><li>消息发送给direct交换机</li><li>绑定键”error”绑定到队列Q1</li><li>绑定键”info”和”warning”绑定到队列Q2</li><li>其他消息被丢弃</li></ol><h3 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h3><p><img src="https://www.rabbitmq.com/img/tutorials/direct-exchange-multiple.png" alt="multiple-bindings"></p><p>使用相同的绑定键绑定多个队列是完全合法的。在我们的设定中，我们也可以使用绑定键<code>error</code><br>在交换机和Q2之间添加绑定。这种情况下，direct交换机将会把消息发送给两个队列。行为类似于fanout交换机。</p><h3 id="生产者发出日志"><a href="#生产者发出日志" class="headerlink" title="生产者发出日志"></a>生产者发出日志</h3><p>我们将在日志系统中使用下面这个模型。我们将把消息发送到direct交换器，而不是fanout交换机。我们将提供日志严重性作为路由键。这样接收脚本将能够选择它想要接收的严重性。让我们首先关注发出日志的脚本。</p><p>像往常一样，我们需要首先创建一个交换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, exchange_type=<span class="string">&#x27;direct&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后我们可以将消息发送到交换机：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, routing_key=severity, body=message.encode())</span><br></pre></td></tr></table></figure><h3 id="消费者接收日志"><a href="#消费者接收日志" class="headerlink" title="消费者接收日志"></a>消费者接收日志</h3><p>消费者和上一节类似，但是有个例外，我们将为我们感兴趣的每个严重性创建一个新的绑定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> severity <span class="keyword">in</span> severities:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, queue=queue_name, routing_key=severity)</span><br></pre></td></tr></table></figure><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><p><img src="https://www.rabbitmq.com/img/tutorials/python-four.png" alt="routing"></p><p>发送日志的生产者代码如下（emit_log_direct.py）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;emit_log_direct.py&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, exchange_type=<span class="string">&#x27;direct&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message_list = [</span><br><span class="line">    (<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;this is a first info log&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;this is a first warning log&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;this is a first error log&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;this is a second info log&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;this is a second warning log&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;this is a second error log&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;this is a third info log&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;this is a third warning log&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;this is a third error log&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> severity, message <span class="keyword">in</span> message_list:</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, routing_key=severity, body=message.encode())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Sent <span class="subst">&#123;severity&#125;</span>:<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>接收日志的消费者代码如下（receive_logs_direct.py）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;receive_logs_direct.py&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] <span class="subst">&#123;method.routing_key&#125;</span>:<span class="subst">&#123;body.decode()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, exchange_type=<span class="string">&#x27;direct&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">severities = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> severities:</span><br><span class="line">    sys.stderr.write(<span class="string">&quot;Usage: %s [info] [warning] [error]\n&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> severity <span class="keyword">in</span> severities:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, queue=queue_name, routing_key=severity)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>运行如下：</p><ol><li>如果只想保存’info’和’warning’<br>日志信息，只需要打开控制台并输入：<code>python receive_logs_direct.py info warning&gt;logs_from_rabbit.log</code></li><li>如果想在屏幕上查看所有日志消息，打开一个新终端并执行：<code>python receive_logs_direct.py info warning error</code></li><li>如果想发出错误日志消息，只需键入<code>python emit_log_direct.py</code>即可</li></ol><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><p>上面的代码已经实现了根据日志的严重性来过滤日志消息，但是如果我们想根据日志的发生模块来过滤日志消息呢？比如我们想把所有来自”<br>cron”的消息都保存到磁盘，而不是所有的错误日志。这时候就需要使用到Topic交换机了。</p><h3 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h3><p>发送到Topic交换机的消息不能有任意的routing_key -<br>它必须是一个由点分隔的单词列表。这些单词可以是任何内容，但通常它们指定与消息相关的一些功能。有效的路由键示例：”<br>stock.usd.nyse”，”nyse.vmw”，”quick.orange.rabbit”。路由键中可以有任意多个单词，最多255个字节。</p><p>绑定键也必须采用相同的形式。topic交换机背后的逻辑与direct交换机类似，使用特定路由键发送的消息将被传递到与匹配的绑定键绑定的所有队列。</p><p>但是，topic交换机绑定键有两种重要的特殊情况：</p><ul><li>* 可以恰好替代一个单词。</li><li># 可以替代零个或多个单词。</li></ul><p>通过一个例子来解释这一点是最简单的：</p><p><img src="https://www.rabbitmq.com/img/tutorials/python-five.png" alt="topic"></p><p>在此示例中，我们将发送所有描述动物的消息。消息将使用由三个单词（两个点）组成的路由键发送。路由键中的第一个单词将描述速度，第二个单词描述颜色，第三个单词描述物种：”<celerity>.<colour>.<species>“。</p><p>我们创建了三个绑定：Q1与绑定键”<em>.orange.</em>“绑定，Q2与”<em>.</em>.rabbit”和”lazy.#”绑定。</p><p>这些绑定可以概括为：</p><ul><li>Q1 对所有橙色动物都感兴趣。</li><li>Q2 想听听关于兔子的一切，以及关于懒惰动物的一切。</li></ul><p>与路由键的匹配规则如下：</p><ol><li>路由键设置为”quick.orange.rabbit”，那么消息就将被传递到两个队列。</li><li>“lazy.orange.elephant”也将发送给两个队列。</li><li>“quick.orange.fox”只会进入第一个队列。</li><li>“lazy.brown.fox”只会进入第二个队列。</li><li>“lazy.pink.rabbit”只会被传递到第二个队列一次，即使它匹配两个绑定。</li><li>“quick.brown.fox”不匹配任何绑定，因此它将被丢弃。</li><li>如果我们违反规则发送了一个单词或者四个单词的消息（例如”orange”或者”quick.orange.new.rabbit”)<br>，因为全部匹配失败，这些消息将不会被传递到任何队列，它们将会被丢弃。</li><li>而”lazy.orange.new.rabbit”，即使它有四个单词，也会匹配最后一个绑定，并将被传递到第二个队列。</li></ol><blockquote><p>topic exchange是非常强大的，可以实现其他类型的交换机。</p><p>当队列使用”#”绑定键绑定时，它将接收所有消息，无论路由键如何，就像在fanout交换机中一样。<br>当绑定中没有使用特殊字符”*”和”#”时，topic交换机的行为就像direct交换机一样。</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们在日志中使用topic交换机。首先假定日志的路由键有两个单词：”<facility>.<severity>“。</p><p>生产者发送消息的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;emit_log_topic.py&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;topic_logs&#x27;</span>, exchange_type=<span class="string">&#x27;topic&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message_list = [</span><br><span class="line">    (<span class="string">&#x27;kern.critical&#x27;</span>, <span class="string">&#x27;A critical kernel error&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;kern.error&#x27;</span>, <span class="string">&#x27;A kernel error&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;kern.warning&#x27;</span>, <span class="string">&#x27;A kernel warning&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;auth.critical&#x27;</span>, <span class="string">&#x27;A critical auth error&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;auth.error&#x27;</span>, <span class="string">&#x27;A auth error&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;auth.warning&#x27;</span>, <span class="string">&#x27;A auth warning&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;cron.critical&#x27;</span>, <span class="string">&#x27;A critical cron error&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;cron.error&#x27;</span>, <span class="string">&#x27;A cron error&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;cron.warning&#x27;</span>, <span class="string">&#x27;A cron warning&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> routing_key, message <span class="keyword">in</span> message_list:</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;topic_logs&#x27;</span>, routing_key=routing_key, body=message.encode())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Sent <span class="subst">&#123;routing_key&#125;</span>:<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>消费者接收消息的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;receive_logs_topic.py&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] <span class="subst">&#123;method.routing_key&#125;</span>:<span class="subst">&#123;body.decode()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;topic_logs&#x27;</span>, exchange_type=<span class="string">&#x27;topic&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">binding_keys = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> binding_keys:</span><br><span class="line">    sys.stderr.write(<span class="string">&quot;Usage: %s [binding_key]...\n&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> binding_key <span class="keyword">in</span> binding_keys:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">&#x27;topic_logs&#x27;</span>, queue=queue_name, routing_key=binding_key)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>运行如下：</p><ol><li>如果想获取所有的日志消息，只需要打开控制台并输入：<code>python receive_logs_topic.py &quot;#&quot;</code></li><li>如果只想获取来自”cron”的日志消息，只需要打开控制台并输入：<code>python receive_logs_topic.py &quot;cron.*&quot;</code></li><li>如果只想获取”critical”严重性的日志消息，只需要打开控制台并输入：<code>python receive_logs_topic.py &quot;*.critical&quot;</code></li><li>还可以创建多个绑定，如果想获取来自”kern”或者”warning”<br>严重性的日志消息，只需要打开控制台并输入：<code>python receive_logs_topic.py &quot;kern.*&quot;  &quot;*.warning&quot;</code></li><li>如果想发出日志消息，只需键入<code>python emit_log_topic.py</code>即可</li></ol><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>在介绍工作队列的时候，我们初步尝试了怎么在多个消费者中分配耗时的任务。我们使用了一个简单的队列来分发任务。</p><p>但是如果我们需要在远程计算机上运行一个函数并等待结果怎么办？这种模式通常称为远程过程调用或RPC。</p><p>在本节中，我们将使用 RabbitMQ 构建一个 RPC 系统：一个客户端和一个可扩展的 RPC 服务器。由于我们没有任何值得分发的耗时任务，因此我们将创建一个返回斐波那契数的虚拟<br>RPC 服务。</p><h3 id="客户端接口"><a href="#客户端接口" class="headerlink" title="客户端接口"></a>客户端接口</h3><p>为了说明如何使用 RPC 服务，我们将创建一个简单的客户端类。它将公开一个名为call的方法 ，该方法发送 RPC 请求并阻塞，直到收到答案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fibonacci_rpc = FibonacciRpcClient()</span><br><span class="line">result = fibonacci_rpc.call(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;fib(4) is <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>关于RPC</p><p>尽管 RPC 是计算中非常常见的模式，但它经常受到批评。当程序员不知道函数调用是本地函数还是慢速 RPC 时，就会引发问题。<br>类似的混乱会导致系统不可预测，并给调试增加不必要的复杂性。滥用 RPC 不但不会简化软件，反而会导致难以维护的代码。</p><p>考虑到这一点，请考虑以下建议：</p><ul><li>确保清楚地知道哪个函数调用是本地的，哪个是远程的。</li><li>对系统制作文档或记录。明确组件之间的依赖关系。</li><li>处理错误情况。当RPC服务器长时间宕机时，客户端应该如何反应？</li></ul><p>当有疑问的时候请避免使用RPC。如果可以的话，您应该使用异步管道将结果异步推送到下一个计算阶段，而不是类似RPC的阻塞进行计算。</p></blockquote><h3 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h3><p>一般来说，通过 RabbitMQ 进行 RPC 调用很容易。客户端发送请求消息，服务器回复响应消息。为了接收响应，客户端需要随请求发送”回调”<br>队列的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">callback_queue = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;rpc_queue&#x27;</span>, properties=pika.BasicProperties(reply_to=callback_queue), body=request)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... and some code to read a response message from the callback_queue ...</span></span><br></pre></td></tr></table></figure><blockquote><p>消息属性<br>AMQP 0-9-1 协议预定义了消息附带的 14 个属性。大多数属性很少使用，但以下属性除外：</p><ul><li><code>delivery_mode</code>：将消息标记为持久（值为2）或瞬态（任何其他值）。</li><li><code>content_type</code>：用于描述编码的 mime-type。例如，对于经常使用的 JSON 编码，最好将此属性设置为：application&#x2F;json。</li><li><code>reply_to</code>：通常用于命名回调队列。</li><li><code>correlation_id</code>：用于将 RPC 响应与请求关联起来。</li></ul></blockquote><h3 id="Correlation-id"><a href="#Correlation-id" class="headerlink" title="Correlation id"></a>Correlation id</h3><p>使用上面介绍的方法，我们建议为每个 RPC 请求创建一个回调队列。这是相当低效的，但幸运的是有一个更好的方法，就是为每个客户端创建一个回调队列。</p><p>这就产生了一个新的问题，在收到响应之后，我们不知道该响应属于哪个请求。这时候correlation_id属性就派上用场了。我们将为每个请求设置唯一值。然后，当我们在回调队列中收到消息时，我们将查看此属性，并基于此我们将能够将响应与请求进行匹配。如果我们看到未知的correlation_id值，就可以断定，这个响应不属于我们发出的请求，就可以安全的丢弃消息了。</p><p>你可能会问，为什么我们要忽略回调队列中的未知消息，而不是因错误而抛出异常？这是由于服务器端可能存在竞争条件。虽然不太可能，但<br>RPC 服务器有可能在向我们发送答案之后并且在发送请求的确认消息之前就挂掉了。如果发生这种情况，重新启动的 RPC<br>服务器将再次处理该请求。这就是为什么在客户端我们必须优雅地处理重复的响应，并且 RPC 理想情况下应该是幂等的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://www.rabbitmq.com/img/tutorials/python-six.png" alt="rabbitmq-rpc"></p><p>我们的 RPC 将像这样工作：</p><ol><li>当Client启动时，它会创建一个匿名的独占的回调队列。</li><li>对于 RPC 请求，客户端发送一条具有两个属性的消息<ul><li>reply_to：它设置为回调队列。</li><li>correlation_id，它设置为每个请求的唯一值。</li></ul></li><li>请求被发送到rpc_queue队列。</li><li>RPC 工作线程（又名：服务器）正在等待该队列上的请求。当请求出现时，它会执行作业并使用来自reply_to字段的队列将带有结果的消息发送回客户端。</li><li>客户端等待回调队列上的数据。当出现消息时，它会检查correlation_id属性。如果它与请求中的值匹配，它将向应用程序返回响应。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>rpc 服务器(类似于消费者)代码相当简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;rpc_server.py&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;rpc_queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_request</span>(<span class="params">ch, method, props, body</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(body)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [.] fib(<span class="subst">&#123;n&#125;</span>)&quot;</span>)</span><br><span class="line">    response = fib(n)</span><br><span class="line"></span><br><span class="line">    ch.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=props.reply_to, properties=pika.BasicProperties(correlation_id=props.correlation_id), body=<span class="built_in">str</span>(response))</span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line">    </span><br><span class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;rpc_queue&#x27;</span>, on_message_callback=on_request)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Awaiting RPC requests&quot;</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>服务器代码相当简单：</p><ol><li>像往常一样，我们首先建立连接并声明队列rpc_queue。</li><li>我们声明我们的斐波那契函数。它假设仅有效的正整数输入。（不要指望这个适用于大数字，它可能是最慢的递归实现）。</li><li>我们为RPC服务器的核心basic_consume声明一个回调on_request 。当收到请求时执行。它完成工作并发送回响应。</li><li>我们可能想要运行多个服务器进程。为了将负载均匀地分布在多个服务器上，我们需要设置prefetch_count设置。</li></ol><p>RPC 客户端（类似于生产者）代码稍微复杂一些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;rpc_client.py&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciRpcClient</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        credentials = pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=credentials))</span><br><span class="line"></span><br><span class="line">        self.channel = self.connection.channel()</span><br><span class="line"></span><br><span class="line">        result = self.channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">        self.callback_queue = result.method.queue</span><br><span class="line"></span><br><span class="line">        self.channel.basic_consume(queue=self.callback_queue, on_message_callback=self.on_response, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        self.response = <span class="literal">None</span></span><br><span class="line">        self.corr_id = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_response</span>(<span class="params">self, ch, method, props, body</span>):</span><br><span class="line">        <span class="keyword">if</span> self.corr_id == props.correlation_id:</span><br><span class="line">            self.response = body</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.response = <span class="literal">None</span></span><br><span class="line">        self.corr_id = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">        self.channel.basic_publish(</span><br><span class="line">            exchange=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            routing_key=<span class="string">&#x27;rpc_queue&#x27;</span>,</span><br><span class="line">            properties=pika.BasicProperties(reply_to=self.callback_queue, correlation_id=self.corr_id),</span><br><span class="line">            body=<span class="built_in">str</span>(n))</span><br><span class="line">        self.connection.process_data_events(time_limit=<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(self.response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fibonacci_rpc = FibonacciRpcClient()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Requesting fib(30)&quot;</span>)</span><br><span class="line">response = fibonacci_rpc.call(<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [.] Got %r&quot;</span> % response)</span><br></pre></td></tr></table></figure><p>客户端代码稍微复杂一些：</p><ol><li>我们建立一个连接、通道并声明一个专用的回调队列用于回复。</li><li>我们订阅callback_queue ，以便我们可以接收RPC响应。</li><li>在每个响应上执行的on_response回调正在执行一项非常简单的工作，对于每个响应消息，它都会检查correlation_id是否是我们正在寻找的那个。如果是这样，它将响应保存在self.response中并打破消费循环。</li><li>接下来，我们定义主要调用方法,它执行的实际的 RPC 请求。</li><li>在call方法中，我们生成一个唯一的correlation_id数字并保存它，on_response回调函数将使用该值来捕获适当的响应。</li><li>同样在call方法中，我们发布请求消息，具有两个属性：reply_to和correlation_id。</li><li>最后，我们等待正确的响应到达并将响应返回给用户。</li></ol><p>我们的 RPC 服务现已准备就绪。我们可以启动服务器，运行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rpc_server.py</span><br></pre></td></tr></table></figure><p>然后我们可以启动客户端，运行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rpc_client.py</span><br></pre></td></tr></table></figure><p>所提出的设计并不是 RPC 服务唯一可能的实现，但它具有一些重要的优点：</p><ol><li>如果 RPC 服务器太慢，您可以通过运行另一台服务器来进行扩展。比如尝试在新控制台中运行第二个rpc_server.py 。</li><li>在客户端，RPC 仅需要发送和接收一条消息。不需要像queue_declare这样的同步调用 。因此，RPC 客户端对于单个 RPC 请求仅需要一次网络往返。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 调度</title>
      <link href="/k8s-scheduler/"/>
      <url>/k8s-scheduler/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>Kubernetes 调度器是 Kubernetes 集群中的一个核心组件，它负责监控新创建的 Pod，并选择一个 Node 让 Pod 在上面运行。Kubernetes 调度器的核心功能是将 Pod 调度到合适的 Node 上，这里的合适是指满足 Pod 的资源需求和其他的一些调度策略。</p><span id="more"></span><h1 id="Kubernetes调度"><a href="#Kubernetes调度" class="headerlink" title="Kubernetes调度"></a>Kubernetes调度</h1><h2 id="为何要控制Pod应该如何调度"><a href="#为何要控制Pod应该如何调度" class="headerlink" title="为何要控制Pod应该如何调度"></a>为何要控制Pod应该如何调度</h2><ul><li>集群中有些机器的配置高（SSD，更好的内存等），我们希望核心的服务（比如说数据库）运行在上面</li><li>某两个服务的网络传输很频繁，我们希望它们最好在同一台机器上</li><li>……</li></ul><p>Kubernetes Scheduler 的作用是将待调度的 Pod 按照一定的调度算法和策略绑定到集群中一个合适的 Worker Node 上，并将绑定信息写入到 etcd 中，之后目标 Node 中 kubelet 服务通过 API Server 监听到 Scheduler 产生的 Pod 绑定事件获取 Pod 信息，然后下载镜像启动容器。</p><p><img src="/post/docker/kube-scheduler.jpg" alt="kube-scheduler"></p><h2 id="调度的过程"><a href="#调度的过程" class="headerlink" title="调度的过程"></a>调度的过程</h2><p>Scheduler 提供的调度流程分为预选 (Predicates) 和优选 (Priorities) 两个步骤：</p><ul><li>预选，K8S会遍历当前集群中的所有 Node，筛选出其中符合要求的 Node 作为候选</li><li>优选，K8S将对候选的 Node 进行打分</li></ul><p>经过预选筛选和优选打分之后，K8S选择分数最高的 Node 来运行 Pod，如果最终有多个 Node 的分数最高，那么 Scheduler 将从当中随机选择一个 Node 来运行 Pod。</p><p><img src="/post/docker/kube-scheduler-process.png" alt="kube-scheduler-process"></p><p>预选：</p><p><img src="/post/docker/kube-scheduler-pre.jpg" alt="kube-scheduler-pre"></p><p>优选：</p><p><img src="/post/docker/kube-scheduler-pro.jpg" alt="kube-scheduler-pro"></p><h2 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h2><p><code>label</code>是<code>kubernetes</code>中一个非常重要的概念，用户可以非常灵活的利用 label 来管理集群中的资源，POD 的调度可以根据节点的 label 进行特定的部署。</p><p>查看节点的label：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes --show-labels</span><br></pre></td></tr></table></figure><p>为节点打label：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label node k8s-master disktype=ssd</span><br></pre></td></tr></table></figure><p>当 node 被打上了相关标签后，在调度的时候就可以使用这些标签了，只需要在spec字段中添加<code>nodeSelector</code>字段，里面是我们需要被调度的节点的 label。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span><span class="comment"># 声明pod的网络模式为host模式，效果与命令 docker run --net=host 相同</span></span><br><span class="line">  <span class="attr">volumes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mariadb-data</span></span><br><span class="line">    <span class="attr">hostPath:</span> </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/opt/mariadb/data</span></span><br><span class="line">  <span class="attr">nodeSelector:</span>   <span class="comment"># 使用节点选择器将Pod调度到指定label的节点</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">mariadb</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mariadb</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mariadb:11.1</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="nodeAffinity"><a href="#nodeAffinity" class="headerlink" title="nodeAffinity"></a>nodeAffinity</h2><p>节点亲和性，比上面的<code>nodeSelector</code>更加灵活，它可以进行一些简单的逻辑组合，不只是简单的相等匹配。分为两种，硬策略和软策略。</p><ul><li>requiredDuringSchedulingIgnoredDuringExecution：硬策略，如果没有满足条件的节点的话，就不断重试直到满足条件为止，简单说就是你必须满足我的要求，不然我就不会调度Pod。</li><li>preferredDuringSchedulingIgnoredDuringExecution：软策略，如果你没有满足调度要求的节点的话，Pod就会忽略这条规则，继续完成调度过程，说白了就是满足条件最好了，没有满足就忽略掉的策略。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要求 Pod 不能运行在101和102两个节点上，如果有节点满足disktype=ssd或者sas的话就优先调度到这类节点上</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">          <span class="attr">nodeAffinity:</span></span><br><span class="line">            <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">                <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">                      <span class="attr">operator:</span> <span class="string">NotIn</span></span><br><span class="line">                      <span class="attr">values:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.101</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.102</span></span><br><span class="line">            <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">                  <span class="attr">preference:</span></span><br><span class="line">                    <span class="attr">matchExpressions:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">disktype</span></span><br><span class="line">                      <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                      <span class="attr">values:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">ssd</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">sas</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>这里的匹配逻辑是 label 的值在某个列表中，现在<code>Kubernetes</code>提供的操作符有下面的几种：</p><ul><li>“In”：label 的值在某个列表中</li><li>“NotIn”：label 的值不在某个列表中</li><li>“Gt”：label 的值大于某个值</li><li>“Lt”：label 的值小于某个值</li><li>“DoesNotExist”：某个 label 不存在</li><li>“Exists”：某个 label 存在</li></ul><p><em>如果nodeSelectorTerms下面有多个选项的话，满足任何一个条件就可以了；如果matchExpressions有多个选项的话，则必须同时满足这些条件才能正常调度 Pod</em></p><h2 id="pod亲和性和反亲和性"><a href="#pod亲和性和反亲和性" class="headerlink" title="pod亲和性和反亲和性"></a>pod亲和性和反亲和性</h2><p>场景：</p><blockquote><p>myblog 启动多副本，但是期望可以尽量分散到集群的可用节点中</p></blockquote><p>分析：为了让myblog应用的多个pod尽量分散部署在集群中，可以利用pod的反亲和性，告诉调度器，如果某个节点中存在了myblog的pod，则可以根据实际情况，实现如下调度策略：</p><ul><li>不允许同一个node节点，调度两个myblog的副本</li><li>可以允许同一个node节点中调度两个myblog的副本，前提是尽量把pod分散部署在集群中</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">podAntiAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">              <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">myblog</span></span><br><span class="line">            <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># 如果某个节点中，存在了app=myblog的label的pod，那么 调度器一定不要给我调度过去</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">podAntiAffinity:</span></span><br><span class="line">          <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">podAffinityTerm:</span></span><br><span class="line">              <span class="attr">labelSelector:</span></span><br><span class="line">                <span class="attr">matchExpressions:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                  <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                  <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">myblog</span></span><br><span class="line">              <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># 如果某个节点中，存在了app=myblog的label的pod，那么调度器尽量不要调度过去</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/">https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/</a></p></blockquote><h2 id="污点（Taints）与容忍（tolerations）"><a href="#污点（Taints）与容忍（tolerations）" class="headerlink" title="污点（Taints）与容忍（tolerations）"></a>污点（Taints）与容忍（tolerations）</h2><p>对于<code>nodeAffinity</code>无论是硬策略还是软策略方式，都是调度 Pod 到预期节点上，而<code>Taints</code>恰好与之相反，如果一个节点标记为 Taints ，除非 Pod 也被标识为可以容忍污点节点，否则该 Taints 节点不会被调度Pod。</p><p>Taints(污点)是Node的一个属性，设置了Taints(污点)后，因为有了污点，所以Kubernetes是不会将Pod调度到这个Node上的。于是Kubernetes就给Pod设置了个属性Tolerations(容忍)，只要Pod能够容忍Node上的污点，那么Kubernetes就会忽略Node上的污点，就能够(不是必须)把Pod调度过去。</p><p>场景一：私有云服务中，某业务使用GPU进行大规模并行计算。为保证性能，希望确保该业务对服务器的专属性，避免将普通业务调度到部署GPU的服务器。</p><p>场景二：用户希望把 Master 节点保留给 Kubernetes 系统组件使用，或者把一组具有特殊资源预留给某些 Pod，则污点就很有用了，Pod 不会再被调度到 taint 标记过的节点。</p><p>taint 标记节点举例如下：</p><p>设置污点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl taint node [node_name] key=value:[effect]   </span><br><span class="line">      其中[effect] 可取值： [ NoSchedule | PreferNoSchedule | NoExecute ]</span><br><span class="line">       NoSchedule：一定不能被调度。</span><br><span class="line">       PreferNoSchedule：尽量不要调度。</span><br><span class="line">       NoExecute：不仅不会调度，还会驱逐Node上已有的Pod。</span><br><span class="line">  示例：kubectl taint node k8s-node1 smoke=<span class="literal">true</span>:NoSchedule</span><br></pre></td></tr></table></figure><p>去除污点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">去除指定key及其effect：</span><br><span class="line">     kubectl taint nodes [node_name] key:[effect]-    <span class="comment">#这里的key不用指定value</span></span><br><span class="line"> 去除指定key所有的effect: </span><br><span class="line">     kubectl taint nodes node_name key-</span><br><span class="line"> </span><br><span class="line"> 示例：</span><br><span class="line">     kubectl taint node k8s-master smoke=<span class="literal">true</span>:NoSchedule</span><br><span class="line">     kubectl taint node k8s-master smoke:NoExecute-</span><br><span class="line">     kubectl taint node k8s-master smoke-</span><br></pre></td></tr></table></figure><p>污点演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 给k8s-node1打上污点，smoke=true:NoSchedule</span></span><br><span class="line">$ kubectl taint node k8s-master gamble=<span class="literal">true</span>:NoSchedule</span><br><span class="line">$ kubectl taint node k8s-node1 drunk=<span class="literal">true</span>:NoSchedule</span><br><span class="line">$ kubectl taint node k8s-node2 smoke=<span class="literal">true</span>:NoSchedule</span><br><span class="line"></span><br><span class="line"><span class="comment">## 扩容myblog的Pod，观察新Pod的调度情况</span></span><br><span class="line">$ kuebctl -n <span class="built_in">test</span> scale deploy myblog --replicas=3</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po -w    <span class="comment">## pending</span></span><br></pre></td></tr></table></figure><p>Pod容忍污点示例：<code>myblog/deployment/deploy-myblog-taint.yaml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myblog</span><br><span class="line">        image: harbor.mydomain.com/test/myblog:v1</span><br><span class="line">      tolerations: <span class="comment">#设置容忍性</span></span><br><span class="line">      - key: <span class="string">&quot;smoke&quot;</span> </span><br><span class="line">        operator: <span class="string">&quot;Equal&quot;</span>  <span class="comment">#不指定operator，默认为Equal</span></span><br><span class="line">        value: <span class="string">&quot;true&quot;</span></span><br><span class="line">        effect: <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">      - key: <span class="string">&quot;drunk&quot;</span> </span><br><span class="line">        operator: <span class="string">&quot;Exists&quot;</span>  <span class="comment">#如果操作符为Exists，那么value属性可省略,不指定operator，默认为Equal</span></span><br><span class="line">      <span class="comment">#意思是这个Pod要容忍Node的污点key是smoke=true,效果是NoSchedule或者污点key是drunk，无论效果是什么，都要容忍。</span></span><br><span class="line">      <span class="comment">#tolerations属性下各值必须使用引号，容忍的值都是设置Node的taints时给的值。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f deploy-myblog-taint.yaml</span><br></pre></td></tr></table></figure><p>Pod容忍污点示例：<code>myblog/deployment/deploy-myblog-all-taint.yaml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myblog</span><br><span class="line">        image: harbor.mydomain.com/test/myblog:v1</span><br><span class="line">      tolerations:</span><br><span class="line">        - operator: <span class="string">&quot;Exists&quot;</span> <span class="comment">#容忍所有污点，无论污点的key是什么，效果是什么，都要容忍。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f deploy-myblog-all-taint.yaml</span><br></pre></td></tr></table></figure><h2 id="Cordon"><a href="#Cordon" class="headerlink" title="Cordon"></a>Cordon</h2><h3 id="cordon-停止调度"><a href="#cordon-停止调度" class="headerlink" title="cordon 停止调度"></a>cordon 停止调度</h3><p>将节点标记为不可调度，即使该节点上有空闲资源，也不会再将新的 Pod 调度到该节点上。本质上，cordon 只是给节点打上了一个污点，key 为 node.kubernetes.io&#x2F;unschedulable，value 为 true，效果为 NoSchedule。因此，如果节点上已经有了 Pod，那么这些 Pod 不会受到影响，它们依然会在该节点上运行，同时，可以容忍该污点的 Pod 也可以继续被调度到该节点上。</p><p>停止调度命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cordon [node_name]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cordon k8s-node2</span><br></pre></td></tr></table></figure><h3 id="uncordon-恢复调度"><a href="#uncordon-恢复调度" class="headerlink" title="uncordon 恢复调度"></a>uncordon 恢复调度</h3><p>将节点标记为可调度，本质上，uncordon 只是将节点上的污点删除。</p><p>恢复调度命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl uncordon [node_name]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl uncordon k8s-node2</span><br></pre></td></tr></table></figure><h3 id="drain-节点维护"><a href="#drain-节点维护" class="headerlink" title="drain 节点维护"></a>drain 节点维护</h3><p>drain 命令会将节点标记为不可调度，并且驱逐该节点上的所有 Pod。</p><p>drain 本质上做了两件事情，一是将节点标记为不可调度，与cordon类似，打的污点也是一样的，二是驱逐该节点上的所有 Pod。因此，drain 命令会触发 Pod 的删除过程，而不是 Pod 的重建过程。如果节点上有 DaemonSet 类型的 Pod，那么 drain 命令不会驱逐这些 Pod，除非指定了 –ignore-daemonsets 参数。</p><p>安全驱逐的方式允许 pod 中的容器遵循指定的 PodDisruptionBudgets 执行优雅的终止，以确保应用程序的可用性。</p><p>安全驱逐命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl drain k8s-node2</span><br></pre></td></tr></table></figure><p>恢复调度命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令与恢复cordron一样，因为drain本质上就是cordon+驱逐Pod，所以恢复调度也就是uncordon即可</span></span><br><span class="line">$ kubectl uncordon k8s-node2</span><br></pre></td></tr></table></figure><h1 id="Pod驱逐策略"><a href="#Pod驱逐策略" class="headerlink" title="Pod驱逐策略"></a>Pod驱逐策略</h1><p>K8S 有个特色功能叫 pod eviction，它在某些场景下如节点 NotReady，或者资源不足时，把 pod 驱逐至其它节点，这也是出于业务保护的角度去考虑的。</p><ol><li><p>Kube-controller-manager: 周期性检查所有节点状态，当节点处于 NotReady 状态超过一段时间后，驱逐该节点上所有 pod。</p><ul><li><p><code>pod-eviction-timeout</code>：NotReady 状态节点超过该时间后，执行驱逐，默认 5 min，适用于k8s 1.13版本之前</p></li><li><p>1.13版本后，集群开启<code>TaintBasedEvictions</code>与<code>TaintNodesByCondition</code>功能，即<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/">taint-based-evictions</a>，即节点若失联或者出现各种异常情况，k8s会自动为node打上污点，同时为pod默认添加如下容忍设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><p>即各pod可以独立设置驱逐容忍时间。</p></li></ul></li><li><p>Kubelet: 周期性检查本节点资源，当资源不足时，按照优先级驱逐部分 pod</p><ul><li><code>memory.available</code>：节点可用内存</li><li><code>nodefs.available</code>：节点根盘可用存储空间</li><li><code>nodefs.inodesFree</code>：节点inodes可用数量</li><li><code>imagefs.available</code>：镜像存储盘的可用空间</li><li><code>imagefs.inodesFree</code>：镜像存储盘的inodes可用数量</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> scheduler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s etcd</title>
      <link href="/k8s-etcd/"/>
      <url>/k8s-etcd/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>etcd是k8s的核心组件之一，主要用于存储k8s集群的所有数据，包括集群的配置信息、集群状态、集群资源等。etcd是一个分布式的、高可用的、一致性的、高性能的键值存储系统，是k8s集群的数据存储中心。</p><span id="more"></span><h1 id="ETCD命令行工具"><a href="#ETCD命令行工具" class="headerlink" title="ETCD命令行工具"></a>ETCD命令行工具</h1><p>拷贝etcdctl命令行工具(附加启动etcd命令)：</p><h2 id="二进制方式"><a href="#二进制方式" class="headerlink" title="二进制方式"></a>二进制方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ETCD_VER=v3.4.27</span><br><span class="line"></span><br><span class="line"><span class="comment"># choose either URL</span></span><br><span class="line">GOOGLE_URL=https://storage.googleapis.com/etcd</span><br><span class="line">GITHUB_URL=https://github.com/etcd-io/etcd/releases/download</span><br><span class="line">DOWNLOAD_URL=<span class="variable">$&#123;GOOGLE_URL&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f /tmp/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /tmp/etcd-download-test &amp;&amp; <span class="built_in">mkdir</span> -p /tmp/etcd-download-test</span><br><span class="line"></span><br><span class="line">curl -L <span class="variable">$&#123;DOWNLOAD_URL&#125;</span>/<span class="variable">$&#123;ETCD_VER&#125;</span>/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -o /tmp/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz</span><br><span class="line">tar xzvf /tmp/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1</span><br><span class="line"><span class="built_in">rm</span> -f /tmp/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">/tmp/etcd-download-test/etcd --version</span><br><span class="line">/tmp/etcd-download-test/etcdctl version</span><br><span class="line"></span><br><span class="line"><span class="built_in">ln</span> -s /tmp/etcd-download-test/etcdctl /usr/local/bin/</span><br></pre></td></tr></table></figure><p>启动etcd命令（对之后的说明没有影响）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start a local etcd server</span></span><br><span class="line">/tmp/etcd-download-test/etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># write,read to etcd</span></span><br><span class="line">/tmp/etcd-download-test/etcdctl --endpoints=localhost:2379 put foo bar</span><br><span class="line">/tmp/etcd-download-test/etcdctl --endpoints=localhost:2379 get foo</span><br></pre></td></tr></table></figure><h2 id="docker-方式"><a href="#docker-方式" class="headerlink" title="docker 方式"></a>docker 方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull gcr.io/etcd-development/etcd:v3.4.27</span><br><span class="line">docker run --<span class="built_in">rm</span> --name etcd -d gcr.io/etcd-development/etcd:v3.4.27 /usr/local/bin/etcd</span><br><span class="line">docker <span class="built_in">cp</span> etcd:/usr/local/bin/etcdctl /usr/local/bin/</span><br></pre></td></tr></table></figure><p>启动etcd命令(对之后的说明没有影响):   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /tmp/etcd-data.tmp &amp;&amp; <span class="built_in">mkdir</span> -p /tmp/etcd-data.tmp &amp;&amp; \</span><br><span class="line">  docker rmi gcr.io/etcd-development/etcd:v3.4.27 || <span class="literal">true</span> &amp;&amp; \</span><br><span class="line">  docker run \</span><br><span class="line">  -p 2379:2379 \</span><br><span class="line">  -p 2380:2380 \</span><br><span class="line">  --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/tmp/etcd-data.tmp,destination=/etcd-data \</span><br><span class="line">  --name etcd-gcr-v3.4.27 \</span><br><span class="line">  gcr.io/etcd-development/etcd:v3.4.27 \</span><br><span class="line">  /usr/local/bin/etcd \</span><br><span class="line">  --name s1 \</span><br><span class="line">  --data-dir /etcd-data \</span><br><span class="line">  --listen-client-urls http://0.0.0.0:2379 \</span><br><span class="line">  --advertise-client-urls http://0.0.0.0:2379 \</span><br><span class="line">  --listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">  --initial-advertise-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">  --initial-cluster s1=http://0.0.0.0:2380 \</span><br><span class="line">  --initial-cluster-token tkn \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --log-level info \</span><br><span class="line">  --logger zap \</span><br><span class="line">  --log-outputs stderr</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> etcd-gcr-v3.4.27  /usr/local/bin/etcd --version</span><br><span class="line">docker <span class="built_in">exec</span> etcd-gcr-v3.4.27  /usr/local/bin/etcdctl version</span><br><span class="line">docker <span class="built_in">exec</span> etcd-gcr-v3.4.27  /usr/local/bin/etcdctl endpoint health</span><br><span class="line">docker <span class="built_in">exec</span> etcd-gcr-v3.4.27  /usr/local/bin/etcdctl put foo bar</span><br><span class="line">docker <span class="built_in">exec</span> etcd-gcr-v3.4.27  /usr/local/bin/etcdctl get foo</span><br></pre></td></tr></table></figure><h1 id="ETCD常用操作"><a href="#ETCD常用操作" class="headerlink" title="ETCD常用操作"></a>ETCD常用操作</h1><h2 id="查看etcd集群的成员节点"><a href="#查看etcd集群的成员节点" class="headerlink" title="查看etcd集群的成员节点"></a>查看etcd集群的成员节点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">$ etcdctl --endpoints=https://[127.0.0.1]:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt --key=/etc/kubernetes/pki/etcd/healthcheck-client.key member list -w table</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">alias</span> etcdctl=<span class="string">&#x27;etcdctl --endpoints=https://[127.0.0.1]:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt --key=/etc/kubernetes/pki/etcd/healthcheck-client.key&#x27;</span></span><br><span class="line"></span><br><span class="line">$ etcdctl member list -w table</span><br></pre></td></tr></table></figure><h2 id="查看etcd集群节点状态"><a href="#查看etcd集群节点状态" class="headerlink" title="查看etcd集群节点状态"></a>查看etcd集群节点状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl endpoint status -w table</span><br><span class="line"></span><br><span class="line">$ etcdctl endpoint health -w table</span><br></pre></td></tr></table></figure><h2 id="设置key值"><a href="#设置key值" class="headerlink" title="设置key值"></a>设置key值</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl put <span class="built_in">test</span> 1</span><br><span class="line">$ etcdctl get <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="查看所有key值"><a href="#查看所有key值" class="headerlink" title="查看所有key值"></a>查看所有key值</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl get / --prefix --keys-only</span><br></pre></td></tr></table></figure><h2 id="查看具体的key对应的数据"><a href="#查看具体的key对应的数据" class="headerlink" title="查看具体的key对应的数据"></a>查看具体的key对应的数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl get /registry/pods/test/myblog-84985b5b66-jp9gg</span><br></pre></td></tr></table></figure><h2 id="list-watch"><a href="#list-watch" class="headerlink" title="list-watch"></a>list-watch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl watch /test/ --prefix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个终端输入，之前的终端会有输出</span></span><br><span class="line">$ etcdctl put /test/key1 val1</span><br></pre></td></tr></table></figure><h2 id="快照与恢复（重要！）"><a href="#快照与恢复（重要！）" class="headerlink" title="快照与恢复（重要！）"></a>快照与恢复（重要！）</h2><p>添加定时任务做数据快照</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl snapshot save `hostname`-etcd_`<span class="built_in">date</span> +%Y%m%d%H%M`.db</span><br></pre></td></tr></table></figure><p>恢复快照：</p><ol><li><p>停止etcd和apiserver（防止新数据写入）</p></li><li><p>移走当前数据目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> /var/lib/etcd/ /tmp</span><br></pre></td></tr></table></figure></li><li><p>恢复快照</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl snapshot restore `hostname`-etcd_`<span class="built_in">date</span> +%Y%m%d%H%M`.db --data-dir=/var/lib/etcd/</span><br></pre></td></tr></table></figure></li><li><p>集群恢复</p><p><a href="https://github.com/etcd-io/etcd/blob/release-3.3/Documentation/op-guide/recovery.md">https://github.com/etcd-io/etcd/blob/release-3.3/Documentation/op-guide/recovery.md</a></p></li></ol><h2 id="namespace删除问题"><a href="#namespace删除问题" class="headerlink" title="namespace删除问题"></a>namespace删除问题</h2><p>很多情况下，会出现namespace删除卡住的问题，此时可以通过操作etcd来删除数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看namespace相关的数据</span></span><br><span class="line">$ etcdctl get / --prefix --keys-only | grep namespace | grep delete-ns</span><br><span class="line">/registry/namespaces/delete-ns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除namespace相关的数据</span></span><br><span class="line">$ etcdctl del /registry/namespaces/delete-ns</span><br></pre></td></tr></table></figure><h1 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h1><h2 id="etcd集群故障恢复"><a href="#etcd集群故障恢复" class="headerlink" title="etcd集群故障恢复"></a>etcd集群故障恢复</h2><p>因为etcd中存储着最重要的数据，所以etcd集群的故障恢复是最重要的。如果节点故障，无法正常启动则需要添加新节点进行恢复。</p><ol><li><p>将etcd备份数据拷贝到新节点</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /backup/etcd-202109031100.db root@new-etcd:/tmp/</span><br></pre></td></tr></table></figure></li><li><p>将数据恢复到新节点</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl snapshot restore /tmp/etcd-202109031100.db --data-dir=/var/lib/etcd/</span><br></pre></td></tr></table></figure></li><li><p>新节点启动etcd</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ name=<span class="string">&quot;etcd-new&quot;</span></span><br><span class="line">$ host=<span class="string">&quot;etcd-new-ip&quot;</span></span><br><span class="line">$ cluster=<span class="string">&quot;etcd1=http://etcd-new-ip:2380&quot;</span></span><br><span class="line">   </span><br><span class="line">$ docker run -d --privileged=<span class="literal">true</span> \</span><br><span class="line">  -p 2379:2379 \</span><br><span class="line">  -p 2380:2380 \</span><br><span class="line">  -v /var/lib/etcd:/data/etcd \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --name <span class="variable">$&#123;name&#125;</span> \</span><br><span class="line">  --net=host \</span><br><span class="line">  -v /etc/kubernetes/pki/etcd:/etc/kubernetes/pki/etcd \</span><br><span class="line">  gcr.io/coreos/etcd:v3.5.0 \</span><br><span class="line">  /usr/local/bin/etcd \</span><br><span class="line">  --name <span class="variable">$&#123;name&#125;</span> \</span><br><span class="line">  --data-dir /data/etcd \</span><br><span class="line">  --listen-client-urls http://<span class="variable">$&#123;host&#125;</span>:2379 \</span><br><span class="line">  --advertise-client-urls http://<span class="variable">$&#123;host&#125;</span>:2379 \</span><br><span class="line">  --listen-peer-urls http://<span class="variable">$&#123;host&#125;</span>:2380 \</span><br><span class="line">  --initial-advertise-peer-urls http://<span class="variable">$&#123;host&#125;</span>:2380 \</span><br><span class="line">  --initial-cluster <span class="variable">$&#123;cluster&#125;</span> \</span><br><span class="line">  --initial-cluster-token tkn \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --force-new-cluster \</span><br><span class="line">  --log-level info \</span><br><span class="line">  --logger zap \</span><br><span class="line">  --log-outputs stderr</span><br></pre></td></tr></table></figure><p> 虽然已经导入了数据，但是还是需要重新初始化集群，重新建立连接，所以需要加上<code>--force-new-cluster</code>参数。</p></li><li><p>验证集群状态</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">$ <span class="built_in">export</span> ETCD_ENDPOINTS=<span class="string">&quot;http://etcd-new-ip:2379&quot;</span></span><br><span class="line">$ etcdctl --endpoints=<span class="variable">$&#123;ETCD_ENDPOINTS&#125;</span> -w table member list</span><br><span class="line">$ etcdctl --endpoints=<span class="variable">$&#123;ETCD_ENDPOINTS&#125;</span> -w table endpoint status</span><br><span class="line">$ etcdctl --endpoints=<span class="variable">$&#123;ETCD_ENDPOINTS&#125;</span> get / --prefix --keys-only</span><br></pre></td></tr></table></figure></li></ol><h2 id="etcd集群增量恢复"><a href="#etcd集群增量恢复" class="headerlink" title="etcd集群增量恢复"></a>etcd集群增量恢复</h2><p>如果etcd集群中的数据丢失了一部分，可以通过增量恢复的方式来恢复数据。比如有备份数据<code>etcd-backup1.db</code>和备份数据<code>etc-backup2.db</code>，两次备份数据相差1天，我们丢失了数据，可以只恢复这1天的数据。</p><ol><li><p>etcdhelper源码下载</p><p> etcdhelper不提供二进制文件，需要自己编译，所以需要下载源码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/openshift/origin.git</span><br></pre></td></tr></table></figure></li><li><p>编译etcdhelper</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name go-builder golang:1.17 <span class="built_in">sleep</span> 3600</span><br><span class="line">$ docker <span class="built_in">cp</span> origin-master go-builder:/go</span><br><span class="line">$ docker <span class="built_in">exec</span> -ti go-builder bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># cd /go/orign-master</span></span><br><span class="line"><span class="comment"># go env -w GOPROXY=https://goproxy.cn,direct</span></span><br><span class="line"><span class="comment"># CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build tools/etcdhelper/etcdhelper.go</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">cp</span> go-builder:/go/origin-master/etcdhelper .</span><br><span class="line">$ <span class="built_in">cp</span> etcdhelper /usr/local/bin/</span><br></pre></td></tr></table></figure></li><li><p>etcdhelper使用</p><p> etcdhelper使用方式和etcdctl类似，只是etcdhelper是对etcdctl的封装，可以批量操作，比如批量删除等。获取到的数据是json格式，可以直接查看。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">$ <span class="built_in">export</span> ETCD_ENDPOINTS=<span class="string">&quot;http://etcd-new-ip:2379&quot;</span></span><br><span class="line">$ etcdhelper -endpoints=<span class="variable">$&#123;ETCD_ENDPOINTS&#125;</span> <span class="built_in">ls</span></span><br><span class="line">$ etcdhelper -endpoints=<span class="variable">$&#123;ETCD_ENDPOINTS&#125;</span> get /registry/pods/test/myblog-84985b5b66-jp9gg</span><br></pre></td></tr></table></figure></li><li><p>增量恢复</p><p> 比如我们丢失了<code>etcd-backup1.db</code>和<code>etcd-backup2.db</code>之间的数据，我们可以通过etcdhelper获取到这段时间的数据，然后再导入到etcd集群中。这里我们举例误删除了namespace为test下的所有资源情况。</p><p> 首先我们找一台新机器，恢复<code>etcd-backup1.db</code>的数据，因为<code>etcd-backup1.db</code>是完整的数据，包含被删除的数据。恢复方法参考上面的故障恢复。</p></li><li><p>批量操作获取yaml文件</p><p> kubectl没有办法直接使用json格式的文件，因此需要将json格式的文件转换为yaml格式的文件，然后再使用kubectl apply命令。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">$ <span class="built_in">export</span> ETCD_ENDPOINTS=<span class="string">&quot;http://etcd-new-ip:2379&quot;</span></span><br><span class="line">$ etcdctl --endpoints=<span class="variable">$&#123;ETCD_ENDPOINTS&#125;</span> get / --prefix --keys-only | grep <span class="built_in">test</span> &gt; keys.txt</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 使用脚本利用etcdhelper将key转换成为json文件</span></span><br><span class="line"><span class="built_in">cat</span> key_to_json.sh</span><br><span class="line">   </span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">i=0</span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line"><span class="built_in">export</span> ETCD_ENDPOINTS=etcd-new-ip:2379</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> `<span class="built_in">cat</span> keys.txt`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    etcdhelper -endpoint <span class="variable">$ETCD_ENDPOINTS</span> get <span class="variable">$line</span> &gt; <span class="variable">$i</span>.json</span><br><span class="line">    <span class="comment"># 第一行是资源类型和版本，不是json格式，需要删除</span></span><br><span class="line">    sed -i <span class="string">&#x27;1d&#x27;</span> <span class="variable">$i</span>.json</span><br><span class="line">    <span class="built_in">let</span> <span class="string">&#x27;i+=1&#x27;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p> 运行脚本，将key转换成为json文件：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./key_to_json.sh</span><br></pre></td></tr></table></figure><p> 将json文件转换成为yaml文件：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># json to yaml，具体方法就不写了，内容还比较简单</span></span><br><span class="line">$ python3 json_to_yaml.py</span><br></pre></td></tr></table></figure></li><li><p>批量导入操作</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> apply.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">   </span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> `<span class="built_in">cat</span> keys.txt`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    kubectl apply -f <span class="variable">$i</span>.yaml</span><br><span class="line">    <span class="built_in">let</span> <span class="string">&#x27;i+=1&#x27;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">   </span><br><span class="line">$ ./apply.sh</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 服务发现和负载均衡</title>
      <link href="/k8s-service-discovery-and-load-balance/"/>
      <url>/k8s-service-discovery-and-load-balance/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>k8s 服务发现主要使用的是 <code>CoreDNS</code>，服务访问则需要借助于 <code>Ingress</code>，接下来我们来看看这两个组件。</p><span id="more"></span><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><h2 id="服务发现测试"><a href="#服务发现测试" class="headerlink" title="服务发现测试"></a>服务发现测试</h2><p>在k8s集群中，组件之间可以通过定义的Service名称实现通信。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 service</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get svc</span><br><span class="line">NAME        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">myblog      ClusterIP   10.104.58.9     &lt;none&gt;        80/TCP         12d</span><br><span class="line">myblog-np   NodePort    10.98.222.213   &lt;none&gt;        80:31174/TCP   11d</span><br><span class="line">mysql       ClusterIP   10.110.89.44    &lt;none&gt;        3306/TCP       11d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个测试pod，因为只是测试，设置保持hang住即可</span></span><br><span class="line"><span class="built_in">cat</span> &gt; testpod.yaml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: testpod</span></span><br><span class="line"><span class="string">  namespace: test</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 1</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: testpod</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: testpod</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">        - name: testpod</span></span><br><span class="line"><span class="string">          image: alpine:3.18.3</span></span><br><span class="line"><span class="string">          imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">            command: [&quot;/bin/sh&quot;]</span></span><br><span class="line"><span class="string">            args: [&quot;-c&quot;, &quot;while true; do echo hello; sleep 100;done&quot;]</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建测试pod</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create -f testpod.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入测试pod</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -ti testpod-865855cfc5-m2f99 -- sh</span><br><span class="line">/ <span class="comment"># apk add curl</span></span><br><span class="line">/ <span class="comment"># curl http://myblog</span></span><br><span class="line">/ <span class="comment"># exit</span></span><br></pre></td></tr></table></figure><p>可以发现，服务是可以直接通过service名称访问的。</p><p>虽然pod ip和cluster ip都不固定，但是service name是固定的，而且具有完全的跨集群可移植性，因此组件之间调用的同时，完全可以通过service name去通信，这样避免了大量的ip维护成本，使得服务的yaml模板更加简单。因此可以对mysql和myblog的部署进行优化改造。</p><h2 id="blog-优化改造"><a href="#blog-优化改造" class="headerlink" title="blog 优化改造"></a>blog 优化改造</h2><ol><li>mysql可以去掉hostNetwork部署，使得服务只暴漏在k8s集群内部网络</li><li>configMap中数据库地址可以换成Service名称，这样跨环境的时候，配置内容基本上可以保持不用变化</li></ol><p>修改deploy-mysql.yaml，去掉hostNetwork和hostPort</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 指定Pod副本数</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 指定Pod的选择器</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="comment"># 指定Pod的模板，与上一节定义的Pod模板类似</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="comment"># 去掉此行</span></span><br><span class="line">      <span class="comment"># hostNetwork: true</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">      <span class="comment"># 使用节点选择器将Pod调度到指定label的节点</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">mariadb:11.1</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_USER</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">secretKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">MYSQL_USER</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">secretKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">configMapKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>修改configmap.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># 此处替换为mysal</span></span><br><span class="line">  <span class="attr">MYSQL_HOST:</span> <span class="string">&quot;mysql&quot;</span></span><br><span class="line">  <span class="attr">MYSQL_DATABASE:</span> <span class="string">&quot;myblog&quot;</span></span><br><span class="line">  <span class="attr">MYSQL_PORT:</span> <span class="string">&quot;3306&quot;</span></span><br></pre></td></tr></table></figure><p>应用修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新configmap</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> delete -f configmap.yaml</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create -f configmap.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新mysql</span></span><br><span class="line">$ kubeclt -n <span class="built_in">test</span> delete -f deploy-mysql.yaml</span><br><span class="line">$ kubeclt -n <span class="built_in">test</span> create -f deploy-mysql.yaml</span><br></pre></td></tr></table></figure><h2 id="服务发现组件"><a href="#服务发现组件" class="headerlink" title="服务发现组件"></a>服务发现组件</h2><p>在k8s中，服务发现组件使用的是 <code>CoreDNS</code>，组件之间可以通过定义的Service名称实现通信。组件效率非常高，可以达到每秒几万次的解析速度，并且对应用没有任何侵入性，对应用来说，只需要通过service name就可以实现服务发现。</p><p><code>CoreDNS</code>是一个<code>Go</code>语言实现的链式插件<code>DNS服务端</code>，是CNCF成员，是一个高性能、易扩展的<code>DNS服务端</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 test pod</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it  testpod-865855cfc5-m2f99 -- sh</span><br><span class="line">/ <span class="comment"># cat /etc/resolv.conf</span></span><br><span class="line">search test.svc.cluster.local svc.cluster.local cluster.local iluvatar.local</span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">options ndots:5</span><br><span class="line">/ <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到域名解析的nameserver是10.96.0.10，这个地址是kube-dns的service地址，具体怎么找到对应的pod呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有的service</span></span><br><span class="line">$ kubectl -n kube-system get svc -A</span><br><span class="line">NAMESPACE     NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">default       kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP                  24d</span><br><span class="line">kube-system   kube-dns     ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP,9153/TCP   24d</span><br><span class="line"><span class="built_in">test</span>          myblog       ClusterIP   10.104.58.9     &lt;none&gt;        80/TCP                   12d</span><br><span class="line"><span class="built_in">test</span>          myblog-np    NodePort    10.98.222.213   &lt;none&gt;        80:31174/TCP             11d</span><br><span class="line"><span class="built_in">test</span>          mysql        ClusterIP   10.110.89.44    &lt;none&gt;        3306/TCP                 11d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到10.96.0.10这个ip出现在了kube-system这个命名空间，而且是kube-dns这个service的cluster-ip地址，这个地址是固定的，不会变化，因此可以在pod中直接写死这个地址，而不用担心变化的问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看对应svc的selector信息</span></span><br><span class="line">$ kubectl -n kube-system get svc -o wide</span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE   SELECTOR</span><br><span class="line">kube-dns   ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   24d   k8s-app=kube-dns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据selector信息，查看对应的pod</span></span><br><span class="line">$ kubectl -n kube-system get po -o wide -l k8s-app=kube-dns</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-66f779496c-cx2zv   1/1     Running   0          24d   10.244.1.2   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-66f779496c-t5zs2   1/1     Running   0          24d   10.244.1.3   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到coredns是通过deployment部署的，而且有两个pod，这样可以保证高可用，同时也可以提高解析效率。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动pod的时候，会把kube-dns服务的cluster-ip地址注入到pod的resolve解析配置中，同时添加对应的namespace的search域。 因此跨namespace通过service name访问的话，需要添加对应的namespace名称，</span></span><br><span class="line">service_name.namespace</span><br><span class="line">$ kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   26h</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩展：怎么访问其他集群的服务？"><a href="#扩展：怎么访问其他集群的服务？" class="headerlink" title="扩展：怎么访问其他集群的服务？"></a>扩展：怎么访问其他集群的服务？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在default命名空间下创建一个pod作为测试pod</span></span><br><span class="line">$ <span class="built_in">cat</span> &gt; deploy-mynginx.yaml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nginx</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 1</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">        - name: nginx</span></span><br><span class="line"><span class="string">          image: nginx:1.25</span></span><br><span class="line"><span class="string">          imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="string">          ports:</span></span><br><span class="line"><span class="string">            - containerPort: 80</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Service</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nginx</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  ports:</span></span><br><span class="line"><span class="string">  - port: 80</span></span><br><span class="line"><span class="string">    protocol: TCP</span></span><br><span class="line"><span class="string">    targetPort: 80</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    app: nginx</span></span><br><span class="line"><span class="string">  type: ClusterIP</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">$ kubectl create -f deploy-mynginx.yaml</span><br><span class="line">$ kubectl get po</span><br><span class="line">NAME                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-cd5968d5b-66mns   1/1     Running   0          25s</span><br><span class="line">$ kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   24d</span><br><span class="line">nginx        ClusterIP   10.105.117.66   &lt;none&gt;        80/TCP    30s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在主机访问可以访问到</span></span><br><span class="line">$  curl http://10.105.117.66</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">进入<span class="built_in">test</span> po进行访问</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it  testpod-865855cfc5-m2f99 -- sh</span><br><span class="line">/ <span class="comment"># curl http://nginx</span></span><br><span class="line">curl: (6) Could not resolve host: nginx</span><br></pre></td></tr></table></figure><p>进入容器中访问会发现不行了，这是为什么呢？</p><p>这是因为这两个pod不在同一个命名空间，因此需要添加对应的命名空间名称，才能访问到。</p><p>之前查看test pod的resolve配置，可以看到有一个search域，这个域名就是test这个命名空间，因此可以直接访问test命名空间下的服务。</p><p>test pod中的resolve配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search test.svc.cluster.local svc.cluster.local cluster.local iluvatar.local</span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">options ndots:5</span><br></pre></td></tr></table></figure><p>pod访问的时候会根据search域名进行解析，比如我们访问nginx</p><ol><li>首先会尝试访问nginx.test.svc.cluster.local</li><li>如果访问不到，会尝试访问nginx.svc.cluster.local</li><li>如果访问不到，会尝试访问nginx.cluster.local</li><li>如果访问不到，会尝试访问nginx.iluvatar.local</li><li>如果访问不到，会尝试访问nginx</li><li>如果访问不到，会报错</li></ol><p>这是pod访问的时候的解析流程。</p><p>为什么能访问到test命名空间下的服务呢？就是因为第一个域名解析成功了，因此后面的域名就不会再解析了。第一个域名包含着命名空间信息。</p><p>那我们直接使用全域名能访问吗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用全域名访问</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it  testpod-865855cfc5-m2f99 -- sh</span><br><span class="line">/ <span class="comment"># curl http://nginx.default.svc.cluster.local</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>所以使用全域名也是可以访问的。</p><p>那么有没有简便方法直接访问呢？有，就是添加一个namespace就行了，不需要全域名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it  testpod-865855cfc5-m2f99 -- sh</span><br><span class="line">/ <span class="comment"># curl http://nginx.default</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>为什么这样也能访问呢？我们来撸一撸search的过程。</p><ol><li>首先会尝试访问nginx.default.test.svc.cluster.local，此时会发现访问不到</li><li>然后会尝试访问nginx.default.svc.cluster.local，此时会发现这不就是全域名么，于是就访问成功了。</li></ol><h1 id="服务访问之Ingress"><a href="#服务访问之Ingress" class="headerlink" title="服务访问之Ingress"></a>服务访问之Ingress</h1><h2 id="ingress-介绍"><a href="#ingress-介绍" class="headerlink" title="ingress 介绍"></a>ingress 介绍</h2><p>对于Kubernetes的Service，无论是Cluster-Ip还是NodePort均是四层的负载，集群内的服务如何实现七层的负载均衡，这就需要借助于Ingress，Ingress控制器的实现方式有很多，比如nginx, Contour, Haproxy, trafik, Istio。几种常用的ingress功能对比和选型可以参考<a href="https://www.kubernetes.org.cn/5948.html">这里</a></p><p>Ingress-nginx是7层的负载均衡器 ，负责统一管理外部对k8s cluster中Service的请求。主要包含：</p><ul><li>ingress-nginx-controller：根据用户编写的ingress规则（创建的ingress的yaml文件），动态的去更改nginx服务的配置文件，并且reload重载使其生效（是自动化的，通过lua脚本来实现）；</li><li>Ingress资源对象：将Nginx的配置抽象成一个Ingress对象</li></ul><p>比如下面这种配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">ingress-wildcard-host</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;foo.bar.com&quot;</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">&quot;/bar&quot;</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">service:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">          <span class="attr">port:</span></span><br><span class="line">          <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;bar.foo.com&quot;</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">&quot;/foo&quot;</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">service:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">          <span class="attr">port:</span></span><br><span class="line">            <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>对应示意图如下：</p><p><img src="/post/docker/ingress.webp" alt="ingress"></p><h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><ol><li>ingress controller通过和kubernetes api交互，动态的去感知集群中ingress规则变化</li><li>然后读取ingress规则(规则就是写明了哪个域名对应哪个service)，按照自定义的规则，生成一段nginx配置</li><li>再写到nginx-ingress-controller的pod里，这个Ingress controller的pod里运行着一个Nginx服务，控制器把生成的nginx配置写入&#x2F;etc&#x2F;nginx&#x2F;nginx.conf文件中</li><li>然后reload一下使配置生效。以此达到域名分别配置和动态更新的问题。</li></ol><h2 id="ingress安装"><a href="#ingress安装" class="headerlink" title="ingress安装"></a>ingress安装</h2><p><a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md">官方文档</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：这里的逻辑会随着时间推移变老，如果是新集群，建议参考官方文档 https://kubernetes.github.io/ingress-nginx/deploy/#quick-start</span></span><br><span class="line">$ wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改部署节点</span></span><br><span class="line">$ vim deploy.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/component: controller</span><br><span class="line">    app.kubernetes.io/instance: ingress-nginx</span><br><span class="line">    app.kubernetes.io/name: ingress-nginx</span><br><span class="line">    app.kubernetes.io/part-of: ingress-nginx</span><br><span class="line">    app.kubernetes.io/version: 1.9.4</span><br><span class="line">  name: ingress-nginx-controller</span><br><span class="line">  namespace: ingress-nginx</span><br><span class="line">spec:</span><br><span class="line">  minReadySeconds: 0</span><br><span class="line">  ......</span><br><span class="line">  dnsPolicy: ClusterFirst</span><br><span class="line">  nodeSelector:</span><br><span class="line">    kubernetes.io/os: linux</span><br><span class="line">    <span class="comment"># 添加这一行，只有对应label的节点才会部署ingress-nginx</span></span><br><span class="line">    ingress: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 添加这一行，使得ingress-nginx可以访问到宿主机的网络</span></span><br><span class="line">  hostNetwork: <span class="literal">true</span></span><br><span class="line">  serviceAccountName: ingress-nginx</span><br><span class="line">  terminationGracePeriodSeconds: 300</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>创建ingress</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为k8s-master节点添加label</span></span><br><span class="line">$ kubectl label node k8s-master ingress=<span class="literal">true</span></span><br><span class="line">$ kubectl apply -f deploy.yaml</span><br></pre></td></tr></table></figure><h2 id="ingress使用"><a href="#ingress使用" class="headerlink" title="ingress使用"></a>ingress使用</h2><h3 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a>创建资源</h3><p>编写文件 <code>myblog/deployment/ingress.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">myblog.test.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span> </span><br><span class="line">            <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>ingress-nginx动态生成upstream配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">-n</span> <span class="string">ingress-nginx</span> <span class="string">exec</span> <span class="string">-ti</span> <span class="string">ingress-nginx-controller-67f74f8554-scwtp</span> <span class="string">--</span> <span class="string">sh</span></span><br><span class="line"><span class="comment"># ps aux</span></span><br><span class="line"><span class="comment"># cat /etc/nginx/nginx.conf|grep myblog -A10 -B1</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">        <span class="comment">## start server myblog.test.com</span></span><br><span class="line">        <span class="string">server</span> &#123;</span><br><span class="line">                <span class="string">server_name</span> <span class="string">myblog.test.com</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line">                <span class="string">listen</span> <span class="number">80</span>  <span class="string">;</span></span><br><span class="line">                <span class="string">listen</span> [<span class="string">::</span>]<span class="string">:80</span>  <span class="string">;</span></span><br><span class="line">                <span class="string">listen</span> <span class="number">443</span>  <span class="string">ssl</span> <span class="string">http2</span> <span class="string">;</span></span><br><span class="line">                <span class="string">listen</span> [<span class="string">::</span>]<span class="string">:443</span>  <span class="string">ssl</span> <span class="string">http2</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line">                <span class="string">set</span> <span class="string">$proxy_upstream_name</span> <span class="string">&quot;-&quot;</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line">                <span class="string">ssl_certificate_by_lua_block</span> &#123;</span><br><span class="line">                        <span class="string">certificate.call()</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="string">set</span> <span class="string">$namespace</span>      <span class="string">&quot;test&quot;</span><span class="string">;</span></span><br><span class="line">                        <span class="string">set</span> <span class="string">$ingress_name</span>   <span class="string">&quot;myblog&quot;</span><span class="string">;</span></span><br><span class="line">                        <span class="string">set</span> <span class="string">$service_name</span>   <span class="string">&quot;myblog&quot;</span><span class="string">;</span></span><br><span class="line">                        <span class="string">set</span> <span class="string">$service_port</span>   <span class="string">&quot;80&quot;</span><span class="string">;</span></span><br><span class="line">                        <span class="string">set</span> <span class="string">$location_path</span>  <span class="string">&quot;/&quot;</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line">                        <span class="string">rewrite_by_lua_block</span> &#123;</span><br><span class="line">                                <span class="string">lua_ingress.rewrite(</span>&#123;</span><br><span class="line">                                        <span class="string">force_ssl_redirect</span> <span class="string">=</span> <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">ssl_redirect</span> <span class="string">=</span> <span class="literal">true</span>,</span><br><span class="line">                                        <span class="string">force_no_ssl_redirect</span> <span class="string">=</span> <span class="literal">false</span>,</span><br><span class="line">                                        <span class="string">use_port_in_redirects</span> <span class="string">=</span> <span class="literal">false</span>,</span><br><span class="line">                                &#125;<span class="string">)</span></span><br><span class="line"><span class="string">--</span></span><br><span class="line">                                <span class="string">balancer.log()</span></span><br><span class="line"></span><br><span class="line">                                <span class="string">monitor.call()</span></span><br><span class="line"></span><br><span class="line">                                <span class="string">plugins.run()</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="string">port_in_redirect</span> <span class="string">off;</span></span><br><span class="line"></span><br><span class="line">                        <span class="string">set</span> <span class="string">$balancer_ewma_score</span> <span class="number">-1</span><span class="string">;</span></span><br><span class="line">                        <span class="string">set</span> <span class="string">$proxy_upstream_name</span> <span class="string">&quot;test-myblog-80&quot;</span><span class="string">;</span></span><br><span class="line">                        <span class="string">set</span> <span class="string">$proxy_host</span>          <span class="string">$proxy_upstream_name;</span></span><br><span class="line">                        <span class="string">set</span> <span class="string">$pass_access_scheme</span>  <span class="string">$scheme;</span></span><br><span class="line"></span><br><span class="line">                        <span class="string">set</span> <span class="string">$pass_server_port</span>    <span class="string">$server_port;</span></span><br><span class="line"></span><br><span class="line">                        <span class="string">set</span> <span class="string">$best_http_host</span>      <span class="string">$http_host;</span></span><br><span class="line">                        <span class="string">set</span> <span class="string">$pass_port</span>           <span class="string">$pass_server_port;</span></span><br><span class="line"></span><br><span class="line">                        <span class="string">set</span> <span class="string">$proxy_alternative_upstream_name</span> <span class="string">&quot;&quot;</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="string">--</span></span><br><span class="line">                        <span class="string">proxy_next_upstream_timeout</span>             <span class="number">0</span><span class="string">;</span></span><br><span class="line">                        <span class="string">proxy_next_upstream_tries</span>               <span class="number">3</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line">                        <span class="string">proxy_pass</span> <span class="string">http://upstream_balancer;</span></span><br><span class="line"></span><br><span class="line">                        <span class="string">proxy_redirect</span>                          <span class="string">off;</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">## end server myblog.test.com</span></span><br><span class="line"> <span class="string">...</span></span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>域名解析服务，将 <code>myblog.test.com</code>解析到ingress的地址上。ingress是支持多副本的，高可用的情况下，生产的配置是使用lb服务（内网F5设备，公网elb、slb、clb，解析到各ingress的机器，如何域名指向lb地址）</p><p>本机，添加如下hosts记录来演示效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.100.2 myblog.test.com</span><br></pre></td></tr></table></figure><p>然后，访问 <a href="http://myblog.test.com/">http://myblog.test.com/</a></p><p>HTTPS访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自签名证书</span></span><br><span class="line">$ openssl req -x509 -nodes -days 2920 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj <span class="string">&quot;/CN=*.test.com/O=ingress-nginx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 证书信息保存到secret对象中，ingress-nginx会读取secret对象解析出证书加载到nginx配置中</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create secret tls tls-myblog --key tls.key --cert tls.crt</span><br></pre></td></tr></table></figure><p>修改yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">myblog.test.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span> </span><br><span class="line">            <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">myblog.test.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">tls-myblog</span></span><br></pre></td></tr></table></figure><p>然后，访问 <a href="https://myblog.test.com/">https://myblog.test.com/</a></p><h3 id="常用注解说明"><a href="#常用注解说明" class="headerlink" title="常用注解说明"></a>常用注解说明</h3><p>nginx端存在很多可配置的参数，通常这些参数在ingress的定义中被放在annotations中实现，如下为常用的一些：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/force-ssl-redirect:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/proxy-body-size:</span> <span class="string">1000m</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="attr">nginx.org/client-max-body-size:</span> <span class="string">1000m</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">myblog.test.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span> </span><br><span class="line">            <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">myblog.test.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">tls-myblog</span></span><br></pre></td></tr></table></figure><ul><li>nginx.ingress.kubernetes.io&#x2F;force-ssl-redirect: “false”：是否强制重定向到https</li><li>nginx.ingress.kubernetes.io&#x2F;proxy-body-size: 1000m：设置请求体的最大值</li><li>nginx.ingress.kubernetes.io&#x2F;ssl-redirect: “false”：是否重定向到https</li><li>nginx.org&#x2F;client-max-body-size: 1000m：设置请求体的最大值</li><li>nginx.ingress.kubernetes.io&#x2F;proxy-buffering: “on”：是否开启缓冲区</li><li>nginx.ingress.kubernetes.io&#x2F;proxy-buffer-size: 1000m：设置缓冲区大小</li><li>nginx.ingress.kubernetes.io&#x2F;proxy-buffers-number: 1000m：设置缓冲区数量</li><li>nginx.ingress.kubernetes.io&#x2F;proxy-connect-timeout: 1000m：设置连接超时时间</li><li>nginx.ingress.kubernetes.io&#x2F;proxy-read-timeout: 1000m：设置读取超时时间</li><li>nginx.ingress.kubernetes.io&#x2F;proxy-send-timeout: 1000m：设置发送超时时间</li><li>nginx.ingress.kubernetes.io&#x2F;proxy-max-temp-file-size: 1000m：设置临时文件大小</li><li>nginx.ingress.kubernetes.io&#x2F;proxy-request-buffering: “on”：是否开启请求缓冲区</li><li>nginx.ingress.kubernetes.io&#x2F;rewrite-target: &#x2F;$1：重写url</li><li>nginx.ingress.kubernetes.io&#x2F;use-regex: “true”：是否使用正则表达式</li></ul><h3 id="多路径转发及重写的实现"><a href="#多路径转发及重写的实现" class="headerlink" title="多路径转发及重写的实现"></a>多路径转发及重写的实现</h3><h4 id="多path转发示例"><a href="#多path转发示例" class="headerlink" title="多path转发示例"></a>多path转发示例</h4><p>目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bookstore.test.com -&gt; 192.168.100.3 -&gt; /reviews   -&gt; reviews service</span><br><span class="line">                                       /details   -&gt; details service</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> detail.dpl.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: details</span><br><span class="line">  labels:</span><br><span class="line">    app: details</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: details</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: details</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: details</span><br><span class="line">          image: docker.io/istio/examples-bookinfo-details-v1:1.16.2</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 9080</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> detail.svc.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: details</span><br><span class="line">  labels:</span><br><span class="line">    app: details</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 9080</span><br><span class="line">      name: http</span><br><span class="line">  selector:</span><br><span class="line">    app: details</span><br><span class="line"></span><br><span class="line"><span class="comment"># reviews.dpl.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: reviews</span><br><span class="line">  labels:</span><br><span class="line">    app: reviews</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: reviews</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: reviews</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: reviews</span><br><span class="line">        image: docker.io/istio/examples-bookinfo-reviews-v3:1.16.2</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">        - name: LOG_DIR</span><br><span class="line">          value: <span class="string">&quot;/tmp/logs&quot;</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9080</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> reviews.svc.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: reviews</span><br><span class="line">  labels:</span><br><span class="line">    app: reviews</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 9080</span><br><span class="line">    name: http</span><br><span class="line">  selector:</span><br><span class="line">    app: reviews</span><br></pre></td></tr></table></figure><p>准备Ingress文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bookstore.ingress.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookstore</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">bookstore.test.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/reviews</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span> </span><br><span class="line">            <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">9080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/details</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span> </span><br><span class="line">            <span class="attr">name:</span> <span class="string">details</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">9080</span></span><br></pre></td></tr></table></figure><h4 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h4><p>目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bookstore.test.com -&gt; 192.168.100.3 -&gt; /api/reviews -&gt; /reviews -&gt; reviews service</span><br><span class="line">                                       /details     -&gt; /details -&gt; details service</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> bookstore.reviews.ingress.yaml</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: bookstore<span class="literal">-reviews</span></span><br><span class="line">  namespace: default</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/re<span class="built_in">write-target</span>: /reviews/<span class="variable">$1</span></span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: bookstore.test.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /api/reviews/(.*)</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service: </span><br><span class="line">            name: reviews</span><br><span class="line">            port:</span><br><span class="line">              number: <span class="number">9080</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> bookstore.details.ingress.yaml</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: bookstore<span class="literal">-details</span></span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: bookstore.test.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /details</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service: </span><br><span class="line">            name: details</span><br><span class="line">            port:</span><br><span class="line">              number: <span class="number">9080</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s service</title>
      <link href="/k8s-service/"/>
      <url>/k8s-service/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>k8s service是k8s中的一个重要组件，它是k8s中的一个抽象层，用来提供一组pod的访问方式，它可以将一组pod的访问方式抽象为一个service，这样就可以通过service来访问这组pod，而不用关心这组pod的具体情况。</p><span id="more"></span><h1 id="Kubernetes服务访问之Service"><a href="#Kubernetes服务访问之Service" class="headerlink" title="Kubernetes服务访问之Service"></a>Kubernetes服务访问之Service</h1><p>通过以前的学习，我们已经能够通过Deployment来创建一组Pod来提供具有高可用性的服务。虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两个问题：</p><ul><li>Pod IP仅仅是集群内可见的虚拟IP，外部无法访问。</li><li>Pod IP会随着Pod的销毁而消失，当ReplicaSet对Pod进行动态伸缩时，Pod IP可能随时随地都会变化，这样对于我们访问这个服务带来了难度。</li></ul><h1 id="Service-负载均衡之Cluster-IP"><a href="#Service-负载均衡之Cluster-IP" class="headerlink" title="Service 负载均衡之Cluster IP"></a>Service 负载均衡之Cluster IP</h1><p>service是一组pod的服务抽象，相当于一组pod的LB，负责将请求分发给对应的pod。service会为这个LB提供一个IP，一般称为cluster IP 。使用Service对象，通过selector进行标签选择，找到对应的Pod</p><p>创建service的yaml文件如下所示 <code>svc-myblog.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="comment"># 集群内部端口</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="comment"># 容器内部端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure><p>创建 service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建服务</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create -f svc-myblog.yaml</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po --show-labels</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">myblog-84985b5b66-jp9gg   1/1     Running   0          22m   app=myblog,pod-template-hash=84985b5b66</span><br><span class="line">mysql-7f97cb6cc9-vzxpd    1/1     Running   0          13h   app=mysql,pod-template-hash=7f97cb6cc9</span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get svc</span><br><span class="line">NAME     TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">myblog   ClusterIP   10.104.58.9   &lt;none&gt;        80/TCP    54s</span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> describe svc myblog</span><br><span class="line">Name:              myblog</span><br><span class="line">Namespace:         <span class="built_in">test</span></span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=myblog</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP Family Policy:  SingleStack</span><br><span class="line">IP Families:       IPv4</span><br><span class="line">IP:                10.104.58.9</span><br><span class="line">IPs:               10.104.58.9</span><br><span class="line">Port:              &lt;<span class="built_in">unset</span>&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.2.10:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 扩容myblog服务</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> scale deploy myblog --replicas=2</span><br><span class="line">deployment.extensions/myblog scaled</span><br><span class="line"></span><br><span class="line"><span class="comment">## 再次查看</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> describe svc myblog</span><br><span class="line">Name:              myblog</span><br><span class="line">Namespace:         <span class="built_in">test</span></span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=myblog</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP Family Policy:  SingleStack</span><br><span class="line">IP Families:       IPv4</span><br><span class="line">IP:                10.104.58.9</span><br><span class="line">IPs:               10.104.58.9</span><br><span class="line">Port:              &lt;<span class="built_in">unset</span>&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.1.5:80,10.244.2.10:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure><p>Service与Pod如何关联:</p><p>service对象创建的同时，会创建同名的endpoints对象，若服务设置了readinessProbe,当readinessProbe检测失败时，endpoints列表中会剔除掉对应的pod_ip，这样流量就不会分发到健康检测失败的Pod中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -l app=myblog 选择label是app=myblog的pod</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po -o wide -l app=myblog</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE   IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">myblog-84985b5b66-jp9gg   1/1     Running   0          23h   10.244.2.10   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">myblog-84985b5b66-smpwb   1/1     Running   0          23h   10.244.1.5    k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get ep myblog</span><br><span class="line">NAME     ENDPOINTS                      AGE</span><br><span class="line">myblog   10.244.1.5:80,10.244.2.10:80   23h</span><br></pre></td></tr></table></figure><p>Service Cluster-IP如何访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> get svc myblog</span><br><span class="line">NAME     TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">myblog   ClusterIP   10.104.58.9   &lt;none&gt;        80/TCP    23h</span><br><span class="line"></span><br><span class="line">$ curl http://10.104.58.9/</span><br></pre></td></tr></table></figure><p>为mysql服务创建service，创建资源配置文件 <code>svc-mysql.yaml</code>，如下所示，具体的导入k8s参考上一节的内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure><p>访问mysql：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> get svc mysql</span><br><span class="line">kubectl -n <span class="built_in">test</span> get svc mysql</span><br><span class="line">NAME    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">mysql   ClusterIP   10.110.89.44   &lt;none&gt;        3306/TCP   66s</span><br></pre></td></tr></table></figure><p>mysql目前在集群中使用hostNetwork进行部署，通过宿主机ip+port访问，这样有以下几个弊端：</p><ul><li>服务使用hostNetwork，使得宿主机的端口大量暴漏，存在安全隐患</li><li>容易引发端口冲突</li></ul><p>而服务均属于k8s集群，应当尽可能使用k8s的网络访问，由此可以对目前myblog访问mysql的方式做改造：</p><ol><li>为mysql创建一个固定clusterIp的Service，把clusterIp配置在myblog的环境变量中</li><li>利用集群服务发现的能力，组件之间通过service name来访问</li></ol><h1 id="Service负载均衡之NodePort"><a href="#Service负载均衡之NodePort" class="headerlink" title="Service负载均衡之NodePort"></a>Service负载均衡之NodePort</h1><p>cluster-ip为虚拟地址，只能在k8s集群内部进行访问，集群外部如果访问内部服务，实现方式之一为使用NodePort方式。NodePort会默认在 30000-32767 ，不指定的会随机使用其中一个。</p><p>创建资源配置文件 <code>svc-myblog-nodeport.yaml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: myblog-np</span><br><span class="line">  namespace: <span class="built_in">test</span></span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: myblog</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br></pre></td></tr></table></figure><p>查看并访问服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f svc-myblog-nodeport.yaml</span><br><span class="line">service/myblog-np created</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get svc</span><br><span class="line">NAME        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">myblog      ClusterIP   10.104.58.9     &lt;none&gt;        80/TCP         23h</span><br><span class="line">myblog-np   NodePort    10.98.222.213   &lt;none&gt;        80:31174/TCP   38s</span><br><span class="line">mysql       ClusterIP   10.110.89.44    &lt;none&gt;        3306/TCP       8m51s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群内每个节点的NodePort端口都会进行监听</span></span><br><span class="line">$ curl http://k8s-node1:31174/</span><br><span class="line">$ curl http://k8s-node2:31174/</span><br><span class="line"></span><br><span class="line"><span class="comment">## 浏览器访问</span></span><br></pre></td></tr></table></figure><p>思考：</p><ol><li>NodePort的端口监听如何转发到对应的Pod服务？</li><li>CLUSTER-IP为虚拟IP，集群内如何通过虚拟IP访问到具体的Pod服务？</li></ol><h1 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h1><p>运行在每个节点上，监听 API Server 中服务对象的变化，再通过创建流量路由规则来实现网络的转发。<a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">参照</a></p><p>有三种模式：</p><ul><li>User space，让 Kube-Proxy 在用户空间监听一个端口，所有的 Service 都转发到这个端口，然后 Kube-Proxy 在内部应用层对其进行转发，所有报文都走一遍用户态，性能不高，k8s v1.2版本后废弃。</li><li>Iptables，当前默认模式，完全由 IPtables 来实现，通过各个node节点上的iptables规则来实现service的负载均衡，但是随着service数量的增大，iptables模式由于线性查找匹配、全量更新等特点，其性能会显著下降。</li><li>IPVS，与iptables同样基于Netfilter，但是采用的hash表，因此当service数量达到一定规模时，hash查表的速度优势就会显现出来，从而提高service的服务性能。 k8s 1.8版本开始引入，1.11版本开始稳定，需要开启宿主机的ipvs模块。</li></ul><h2 id="IPtables模式"><a href="#IPtables模式" class="headerlink" title="IPtables模式"></a>IPtables模式</h2><p>示意图：</p><p><img src="/post/docker/services-iptables-overview.svg" alt="services-iptables-overview"></p><blockquote><p>以下是理想情况，因为我一开始就是使用的ipvs模式，所以没有iptables的规则，所以这里的规则是我手动添加的，仅供参考。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ iptables-save | grep -v myblog-np |grep <span class="string">&quot;test/myblog&quot;</span></span><br><span class="line">-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.99.174.93/32 -p tcp -m comment --comment <span class="string">&quot;test/myblog: cluster IP&quot;</span> -m tcp --dport 80 -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SERVICES -d 10.99.174.93/32 -p tcp -m comment --comment <span class="string">&quot;test/myblog: cluster IP&quot;</span> -m tcp --dport 80 -j KUBE-SVC-WQNGJ7YFZKCTKPZK</span><br><span class="line"></span><br><span class="line">$ iptables-save | grep KUBE-SVC-WQNGJ7YFZKCTKPZK</span><br><span class="line">-A KUBE-SVC-WQNGJ7YFZKCTKPZK -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-GB5GNOM5CZH7ICXZ</span><br><span class="line">-A KUBE-SVC-WQNGJ7YFZKCTKPZK -j KUBE-SEP-7GWC3FN2JI5KLE47</span><br><span class="line"></span><br><span class="line">$  iptables-save | grep KUBE-SEP-GB5GNOM5CZH7ICXZ</span><br><span class="line">-A KUBE-SEP-GB5GNOM5CZH7ICXZ -p tcp -m tcp -j DNAT --to-destination 10.244.1.158:80</span><br><span class="line"></span><br><span class="line">$ iptables-save | grep KUBE-SEP-7GWC3FN2JI5KLE47</span><br><span class="line">-A KUBE-SEP-7GWC3FN2JI5KLE47 -p tcp -m tcp -j DNAT --to-destination 10.244.1.159:80</span><br></pre></td></tr></table></figure><blockquote><p>面试题： k8s的Service Cluster-IP能不能ping通</p></blockquote><h2 id="IPVS模式"><a href="#IPVS模式" class="headerlink" title="IPVS模式"></a>IPVS模式</h2><p><strong>iptables转换ipvs模式</strong>，注意，这里需要在每个节点都执行，因为kube-proxy是运行在每个节点上的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内核开启ipvs模块，集群各节点都执行</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">ipvs_modules=&quot;ip_vs ip_vs_lc ip_vs_wlc ip_vs_rr ip_vs_wrr ip_vs_lblc ip_vs_lblcr ip_vs_dh ip_vs_sh ip_vs_nq ip_vs_sed ip_vs_ftp nf_conntrack_ipv4&quot;</span></span><br><span class="line"><span class="string">for kernel_module in \$&#123;ipvs_modules&#125;; do</span></span><br><span class="line"><span class="string">    /sbin/modinfo -F filename \$&#123;kernel_module&#125; &gt; /dev/null 2&gt;&amp;1</span></span><br><span class="line"><span class="string">    if [ $? -eq 0 ]; then</span></span><br><span class="line"><span class="string">        /sbin/modprobe \$&#123;kernel_module&#125;</span></span><br><span class="line"><span class="string">    fi</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep ip_vs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装ipvsadm工具</span></span><br><span class="line">$ yum install ipset ipvsadm -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改kube-proxy模式</span></span><br><span class="line">$ kubectl -n kube-system edit cm kube-proxy</span><br><span class="line">...</span><br><span class="line">    kind: KubeProxyConfiguration</span><br><span class="line">    metricsBindAddress: <span class="string">&quot;&quot;</span></span><br><span class="line">    mode: <span class="string">&quot;ipvs&quot;</span></span><br><span class="line">    nodePortAddresses: null</span><br><span class="line">    oomScoreAdj: null</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重建kube-proxy</span></span><br><span class="line">$ kubectl -n kube-system get po | grep kube-proxy | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | xargs kubectl -n kube-system delete po</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志，确认使用了ipvs模式</span></span><br><span class="line">$ kubectl -n kube-system logs -f </span><br><span class="line">I0605 08:47:52.334298       1 node.go:136] Successfully retrieved node IP: 172.21.51.143</span><br><span class="line">I0605 08:47:52.334430       1 server_others.go:142] kube-proxy node IP is an IPv4 address (172.21.51.143), assume IPv4 operation</span><br><span class="line">I0605 08:47:52.766314       1 server_others.go:258] Using ipvs Proxier.</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理iptables规则</span></span><br><span class="line">$ iptables -F -t nat</span><br><span class="line">$ iptables -F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看规则生效</span></span><br><span class="line">$ ipvsadm -<span class="built_in">ln</span></span><br></pre></td></tr></table></figure><p>此时 ping svc 可以通了 （理论上是，但是我这里不行，可能是因为我使用的是虚拟机，没有物理网卡，所以ping不通）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping 10.104.58.9</span><br></pre></td></tr></table></figure><p>为什么呢？为什么之前的iptables模式下，ping不通，而ipvs模式下，ping可以通呢？</p><p>因为ipvs模式下，kube-proxy会在宿主机上创建一个虚拟网卡，service的cluster-ip都会挂到这个网卡上，这样就可以通过ip来访问到service了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ip a s kube-ipvs0</span><br><span class="line">5: kube-ipvs0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default</span><br><span class="line">    <span class="built_in">link</span>/ether da:ef:cb:66:0e:22 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.96.0.1/32 scope global kube-ipvs0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 10.96.0.10/32 scope global kube-ipvs0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 10.104.58.9/32 scope global kube-ipvs0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 10.110.89.44/32 scope global kube-ipvs0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 10.98.222.213/32 scope global kube-ipvs0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s deployment</title>
      <link href="/k8s-deployment/"/>
      <url>/k8s-deployment/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>以下主要介绍 k8s 中的 deployment ，deployment 是 k8s 中最常用的资源类型之一，用于管理 pod 的生命周期。</p><span id="more"></span><h1 id="改造之前的-pod"><a href="#改造之前的-pod" class="headerlink" title="改造之前的 pod"></a>改造之前的 pod</h1><p>之前我们使用 pod 来管理应用，但是 pod 有如下缺点：</p><ul><li>pod 无法实现滚动升级</li><li>pod 无法实现回滚</li><li>pod 无法实现自动伸缩</li><li>pod 无法实现自动恢复</li><li>pod 无法实现自动发布</li><li>pod 无法实现自动扩容</li><li>pod 无法实现自动缩容</li><li>pod 无法实现自动重启</li></ul><p>为了解决这些问题，我们需要使用 deployment 来管理应用。</p><h2 id="创建-deployment-文件"><a href="#创建-deployment-文件" class="headerlink" title="创建 deployment 文件"></a>创建 deployment 文件</h2><p>首先创建数据的文件，将其改造为 deployment 方式 <code>deploy-mysql.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">        <span class="attr">hostPath:</span> </span><br><span class="line">          <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mariadb:11.1</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_USER</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">secretKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">MYSQL_USER</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">secretKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>之后创建业务应用的 deployment 文件 <code>deploy-myblog.yaml</code>，为了更好的实验，我把 blog 的应用换成 wordpress 了.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">wordpress:php8.2-alpine</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_HOST</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">configMapKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_USER</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">secretKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">MYSQL_USER</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_PASSWORD</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">secretKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_NAME</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">configMapKeyRef:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="创建-deployment"><a href="#创建-deployment" class="headerlink" title="创建 deployment"></a>创建 deployment</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f deploy-mysql.yaml</span><br><span class="line">$ kubectl apply -f deploy-myblog.yaml</span><br></pre></td></tr></table></figure><h2 id="查看-deployment"><a href="#查看-deployment" class="headerlink" title="查看 deployment"></a>查看 deployment</h2><h3 id="此时可以通过-kubectl-get-deploy-n-test-查看-deployment-的状态："><a href="#此时可以通过-kubectl-get-deploy-n-test-查看-deployment-的状态：" class="headerlink" title="此时可以通过 kubectl get deploy -n test 查看 deployment 的状态："></a>此时可以通过 <code>kubectl get deploy -n test</code> 查看 deployment 的状态：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy -n <span class="built_in">test</span></span><br><span class="line">NAME     READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">mysql    1/1     1            1           2m</span><br><span class="line">myblog   1/1     1            1           2m</span><br></pre></td></tr></table></figure><ul><li><code>NAME</code> 列出了集群中 Deployments 的名称。</li><li><code>READY</code>显示当前正在运行的副本数&#x2F;期望的副本数。</li><li><code>UP-TO-DATE</code>显示已更新以实现期望状态的副本数。</li><li><code>AVAILABLE</code>显示应用程序可供用户使用的副本数。</li><li><code>AGE</code> 显示应用程序运行的时间量。</li></ul><h3 id="查看-pod"><a href="#查看-pod" class="headerlink" title="查看 pod"></a>查看 pod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po -n <span class="built_in">test</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">mysql-7b4f8f8d5f-4j4q4   1/1     Running   0          2m</span><br><span class="line">myblog-7c96c9f76b-qbbg7  1/1     Running   0          2m</span><br></pre></td></tr></table></figure><h3 id="查看-replicaSet"><a href="#查看-replicaSet" class="headerlink" title="查看 replicaSet"></a>查看 replicaSet</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rs -n <span class="built_in">test</span></span><br><span class="line">NAME               DESIRED   CURRENT   READY   AGE</span><br><span class="line">mysql-7b4f8f8d5f   1         1         1       2m</span><br><span class="line">myblog-7c96c9f76b  1         1         1       2m</span><br></pre></td></tr></table></figure><h3 id="查看-deployment-详细信息"><a href="#查看-deployment-详细信息" class="headerlink" title="查看 deployment 详细信息"></a>查看 deployment 详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe deploy mysql -n <span class="built_in">test</span></span><br><span class="line">Name:                   mysql</span><br><span class="line">Namespace:              <span class="built_in">test</span></span><br><span class="line">CreationTimestamp:      Fri, 03 Sep 2021 23:59:15 +0800</span><br><span class="line">Labels:                 &lt;none&gt;</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               app=mysql</span><br><span class="line">Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=mysql</span><br><span class="line">  Containers:</span><br><span class="line">   mysql:</span><br><span class="line">    Image:      mariadb:11.1</span><br><span class="line">    Port:       3306/TCP</span><br><span class="line">    Host Port:  0/TCP</span><br><span class="line">    Args:</span><br><span class="line">      --character-set-server=utf8mb4</span><br><span class="line">      --collation-server=utf8mb4_unicode_ci</span><br><span class="line">    Environment:</span><br><span class="line">      MYSQL_USER:           &lt;<span class="built_in">set</span> to the key <span class="string">&#x27;MYSQL_USER&#x27;</span> <span class="keyword">in</span> secret <span class="string">&#x27;myblog-secret&#x27;</span>&gt;    Optional: <span class="literal">false</span></span><br><span class="line">      MYSQL_ROOT_PASSWORD:  &lt;<span class="built_in">set</span> to the key <span class="string">&#x27;MYSQL_PASSWD&#x27;</span> <span class="keyword">in</span> secret <span class="string">&#x27;myblog-secret&#x27;</span>&gt;  Optional: <span class="literal">false</span></span><br><span class="line">      MYSQL_DATABASE:       &lt;<span class="built_in">set</span> to the key <span class="string">&#x27;MYSQL_DATABASE&#x27;</span> of config map <span class="string">&#x27;myblog&#x27;</span>&gt;   Optional: <span class="literal">false</span></span><br><span class="line">    Mounts:</span><br><span class="line">      /var/lib/mysql from mysql-data (rw)</span><br><span class="line">  Volumes:</span><br><span class="line">   mysql-data:</span><br><span class="line">    Type:          HostPath (bare host directory volume)</span><br><span class="line">    Path:          /opt/mysql/data</span><br><span class="line">    HostPathType:</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">  Progressing    True    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   mysql-7f97cb6cc9 (1/1 replicas created)</span><br><span class="line">Events:          &lt;none&gt;</span><br></pre></td></tr></table></figure><h2 id="副本保障机制"><a href="#副本保障机制" class="headerlink" title="副本保障机制"></a>副本保障机制</h2><p>controller实时检测pod状态，并保障副本数一直处于期望的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除pod，观察pod状态变化</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> delete pod myblog-7c96c9f76b-qbbg7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观察pod</span></span><br><span class="line">$ kubectl get pods -o wide -n <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置两个副本, 或者通过 kubectl -n test edit deploy myblog 的方式，最好通过修改文件，然后 apply 的方式，这样 yaml 文件可以保持同步</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> scale deploy myblog --replicas=2</span><br><span class="line">deployment.extensions/myblog scaled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观察pod</span></span><br><span class="line">$ kubectl get pods -o wide -n <span class="built_in">test</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">mysql-7b4f8f8d5f-4j4q4    1/1     Running   0          3m18s</span><br><span class="line">myblog-7c96c9f76b-qbbg7   1/1     Running   0          11m</span><br><span class="line">myblog-7c96c9f76b-s6brm   1/1     Running   0          3m18s</span><br></pre></td></tr></table></figure><h2 id="Pod驱逐策略"><a href="#Pod驱逐策略" class="headerlink" title="Pod驱逐策略"></a>Pod驱逐策略</h2><p>K8S 有个特色功能叫 pod eviction，它在某些场景下如节点 NotReady，或者资源不足时，把 pod 驱逐至其它节点，这也是出于业务保护的角度去考虑的。</p><ol><li><p>Kube-controller-manager: 周期性检查所有节点状态，当节点处于 NotReady 状态超过一段时间后，驱逐该节点上所有 pod。</p><ul><li><p><code>pod-eviction-timeout</code>：NotReady 状态节点超过该时间后，执行驱逐，默认 5 min，适用于k8s 1.13版本之前</p></li><li><p>1.13版本后，集群开启<code> TaintBasedEvictions 与TaintNodesByCondition</code> 功能，即<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/">taint-based-evictions</a>，即节点若失联或者出现各种异常情况，k8s会自动为node打上污点，同时为pod默认添加如下容忍设置：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><p> 即各pod可以独立设置驱逐容忍时间。</p></li></ul></li><li><p>Kubelet: 周期性检查本节点资源，当资源不足时，按照优先级驱逐部分 pod</p><ul><li><code>memory.available</code>：节点可用内存</li><li><code>nodefs.available</code>：节点根盘可用存储空间</li><li><code>nodefs.inodesFree</code>：节点inodes可用数量</li><li><code>imagefs.available</code>：镜像存储盘的可用空间</li><li><code>imagefs.inodesFree</code>：镜像存储盘的inodes可用数量</li></ul></li></ol><h2 id="服务更新方法"><a href="#服务更新方法" class="headerlink" title="服务更新方法"></a>服务更新方法</h2><p>修改服务，重新打tag模拟服务更新至下一个版本。</p><p>更新方式：</p><ol><li>修改yaml文件，使用<code>kubectl -n test apply -f deploy-myblog.yaml</code>来应用更新</li><li><code>kubectl -n test edit deploy myblog</code>在线更新</li><li><code>kubectl -n test set image deploy myblog myblog=wordpress:php8.2 --record</code></li></ol><h2 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">    <span class="comment">#指定更新方式为滚动更新，默认策略，通过get deploy yaml查看</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><p><img src="/post/docker/update.png" alt="update"></p><p>策略控制：</p><ul><li>maxSurge：最大激增数, 指更新过程中, 最多可以比replicas预先设定值多出的pod数量, 可以为固定值或百分比,默认为desired Pods数的25%。计算时向上取整(比如3.4，取4)，更新过程中最多会有replicas + maxSurge个pod</li><li>maxUnavailable： 指更新过程中, 最多有几个pod处于无法服务状态 , 可以为固定值或百分比，默认为desired Pods数的25%。计算时向下取整(比如3.6，取3)</li></ul><p><em>在Deployment rollout时，需要保证Available(Ready) Pods数不低于 desired pods number - maxUnavailable; 保证所有的非异常状态Pods数不多于 desired pods number + maxSurge</em>。</p><p>以myblog为例，使用默认的策略，更新过程:</p><ol><li>maxSurge 25%，2个实例，向上取整，则maxSurge为1，意味着最多可以有2+1&#x3D;3个Pod，那么此时会新创建1个ReplicaSet，RS-new，把副本数置为1，此时呢，副本控制器就去创建这个新的Pod</li><li>同时，maxUnavailable是25%，副本数2*25%，向下取整，则为0，意味着，滚动更新的过程中，不能有少于2个可用的Pod，因此，旧的Replica（RS-old）会先保持不动，等RS-new管理的Pod状态Ready后，此时已经有3个Ready状态的Pod了，那么由于只要保证有2个可用的Pod即可，因此，RS-old的副本数会有2个变成1个，此时，会删掉一个旧的Pod</li><li>删掉旧的Pod的时候，由于总的Pod数量又变成2个了，因此，距离最大的3个还有1个Pod可以创建，所以，RS-new把管理的副本数由1改成2，此时又会创建1个新的Pod，等RS-new管理了2个Pod都ready后，那么就可以把RS-old的副本数由1置为0了，这样就完成了滚动更新</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看滚动更新事件</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> describe deploy myblog</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  11s   deployment-controller  Scaled up replica <span class="built_in">set</span> myblog-6cf56fc848 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  11s   deployment-controller  Scaled down replica <span class="built_in">set</span> myblog-6fdcf98f9 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  11s   deployment-controller  Scaled up replica <span class="built_in">set</span> myblog-6cf56fc848 to 2</span><br><span class="line">  Normal  ScalingReplicaSet  6s    deployment-controller  Scaled down replica <span class="built_in">set</span> myblog-6fdcf98f9 to 0</span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME                     DESIRED   CURRENT   READY   AGE</span><br><span class="line">myblog-6cf56fc848   2         2         2       16h</span><br><span class="line">myblog-6fdcf98f9    0         0         0       16h</span><br></pre></td></tr></table></figure><p>除了滚动更新以外，还有一种策略是Recreate，直接在当前的pod基础上先删后建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  strategy:</span><br><span class="line">    <span class="built_in">type</span>: Recreate</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们的mysql服务应该使用Recreate来管理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> edit deploy mysql</span><br><span class="line">...</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: mysql</span><br><span class="line">  strategy:</span><br><span class="line">    <span class="built_in">type</span>: Recreate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: mysql</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="服务回滚"><a href="#服务回滚" class="headerlink" title="服务回滚"></a>服务回滚</h2><p>通过滚动升级的策略可以平滑的升级Deployment，若升级出现问题，需要最快且最好的方式回退到上一次能够提供正常工作的版本。为此K8S提供了回滚机制。</p><p><strong>revision</strong>：更新应用时，K8S都会记录当前的版本号，即为revision，当升级出现问题时，可通过回滚到某个特定的revision，默认配置下，K8S只会保留最近的几个revision，可以通过Deployment配置文件中的spec.revisionHistoryLimit属性增加revision数量，默认是10。</p><p>查看当前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> rollout <span class="built_in">history</span> deploy myblog <span class="comment">##CHANGE-CAUSE为空</span></span><br><span class="line">$ kubectl delete -f deploy-myblog.yaml <span class="comment">## 方便演示到具体效果，删掉已有deployment</span></span><br></pre></td></tr></table></figure><p>记录回滚：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f deploy-myblog.yaml --record</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">set</span> image deploy myblog myblog=wordpress:php8.2 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>查看deployment更新历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> rollout <span class="built_in">history</span> deploy myblog</span><br><span class="line">deployment.extensions/myblog</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl create --filename=deploy-myblog.yaml --record=<span class="literal">true</span></span><br><span class="line">2         kubectl <span class="built_in">set</span> image deploy myblog myblog=wordpress:php8.2-apache --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>回滚到具体的REVISION:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n <span class="built_in">test</span> rollout undo deploy myblog --to-revision=1</span><br><span class="line">deployment.extensions/myblog rolled back</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问应用测试</span></span><br><span class="line">curl 10.244.1.150:8002/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pod 常用设置和配置</title>
      <link href="/pod-settings-and-config/"/>
      <url>/pod-settings-and-config/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>以下主要是介绍数据持久化、健康检查、重启策略、镜像拉取策略、资源限制等常用设置、 confingmap&amp;secret 以及 Pod 生命周期的配置的使用。</p><span id="more"></span><p>本节所有的内容都基于假设我们创建了一个mysql的数据库以及一个基于 Django 的 web 服务的 Pod 之后的操作。</p><h1 id="Pod-数据持久化"><a href="#Pod-数据持久化" class="headerlink" title="Pod 数据持久化"></a>Pod 数据持久化</h1><p>如果我们因为各种原因删除了 Pod，由于 mysql 的数据都在容器内部，会造成数据丢失，因此需要数据进行持久化，数据持久化的数据会保存在对应的硬盘上，不随容器的关闭而删除。</p><h2 id="使用-hostpath-挂载"><a href="#使用-hostpath-挂载" class="headerlink" title="使用 hostpath 挂载"></a>使用 hostpath 挂载</h2><p>因为保存在对应的宿主机上，所以需要使用 nodeSelector 定点，下面是 pod-with-volume.yaml 的文件内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">myblog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 声明挂载的卷</span></span><br><span class="line">  <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">hostPath:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">  <span class="comment"># 使用节点选择器将 Pod 调度到指定label的节点</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;myblog&quot;</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="comment"># 使用上面声明的卷挂载到容器内部</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">          <span class="comment"># 挂载到容器内部的路径</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>有了上面的文件就可以进行创建了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若存在旧的同名服务，先删除掉</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> delete pod myblog</span><br><span class="line"><span class="comment">## 创建 Pod</span></span><br><span class="line">$ kubectl create -f pod-with-volume.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 Pod 状态Pending</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po</span><br><span class="line">NAME     READY   STATUS    RESTARTS   AGE</span><br><span class="line">myblog   0/2     Pending   0          32s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看原因，提示调度失败，因为节点不满足node selector</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> describe po myblog</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age                From               Message</span><br><span class="line">  ----     ------            ----               ----               -------</span><br><span class="line">  Warning  FailedScheduling  12s (x2 over 12s)  default-scheduler  0/3 nodes are available: 3 node(s) didn<span class="string">&#x27;t match node selector.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"># 为节点打标签</span></span><br><span class="line"><span class="string">$ kubectl label node k8s-node1 component=mysql</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 再次查看，已经运行成功</span></span><br><span class="line"><span class="string">$ kubectl -n test get po</span></span><br><span class="line"><span class="string">NAME     READY   STATUS    RESTARTS   AGE     IP             NODE</span></span><br><span class="line"><span class="string">myblog   2/2     Running   0          3m54s   10.244.1.150   k8s-node1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 到 k8s-node1 节点，查看 /opt/mysql/data</span></span><br><span class="line"><span class="string">$ ll /opt/mysql/data/</span></span><br><span class="line"><span class="string">total 188484</span></span><br><span class="line"><span class="string">-rw-r----- 1 polkitd input       56 Mar 29 09:20 auto.cnf</span></span><br><span class="line"><span class="string">-rw------- 1 polkitd input     1676 Mar 29 09:20 ca-key.pem</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 polkitd input     1112 Mar 29 09:20 ca.pem</span></span><br><span class="line"><span class="string">drwxr-x--- 2 polkitd input     8192 Mar 29 09:20 sys</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 执行 migrate，创建数据库表，然后删掉 Pod，再次创建后验证数据是否存在</span></span><br><span class="line"><span class="string">$ kubectl -n test exec -ti myblog python3 manage.py migrate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 访问服务，正常</span></span><br><span class="line"><span class="string">$ curl 10.244.1.150:8002/blog/index/ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 删除 Pod</span></span><br><span class="line"><span class="string">$ kubectl delete -f pod-with-volume.yaml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 再次创建 Pod</span></span><br><span class="line"><span class="string">$ kubectl create -f pod-with-volume.yaml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看 Pod ip并访问服务</span></span><br><span class="line"><span class="string">$ kubectl -n test get po -o wide</span></span><br><span class="line"><span class="string">NAME     READY   STATUS    RESTARTS   AGE   IP             NODE  </span></span><br><span class="line"><span class="string">myblog   2/2     Running   0          7s    10.244.1.151   k8s-node1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 未重新做migrate，服务正常</span></span><br><span class="line"><span class="string">$ curl 10.244.1.151:8002/blog/index/</span></span><br></pre></td></tr></table></figure><h2 id="使用-PV-PVC连接分布式存储解决方案"><a href="#使用-PV-PVC连接分布式存储解决方案" class="headerlink" title="使用 PV+PVC连接分布式存储解决方案"></a>使用 PV+PVC连接分布式存储解决方案</h2><p>hostpath 方式只能将 Pod 固定在特定的机器上，但是 k8s 支持网络存储，可以将数据存储在网络存储上，这样就可以实现 Pod 的迁移，下面是支持 PV+PVC 的协议方式。</p><ul><li>ceph</li><li>glusterfs</li><li>nfs</li></ul><p>具体关于 PV+PVC 的用法会在之后介绍，具体目录可以参考 <a href="https://realtiger.github.io/k8s-learning">k8s 学习笔记</a>。</p><h1 id="服务健康检查"><a href="#服务健康检查" class="headerlink" title="服务健康检查"></a>服务健康检查</h1><p>检测容器服务是否健康的手段，若不健康，会根据设置的重启策略（restartPolicy）进行操作，三种检测机制可以分别单独设置，若不设置，默认认为 Pod 是健康的。</p><p>以下是两种机制的介绍。</p><h2 id="LivenessProbe-探针-（存活探针）"><a href="#LivenessProbe-探针-（存活探针）" class="headerlink" title="LivenessProbe 探针 （存活探针）"></a>LivenessProbe 探针 （存活探针）</h2><p>存活性探测：用于判断容器是否存活，即 Pod 是否为 running 状态，如果 LivenessProbe 探针探测到容器不健康，则 kubelet 将 kill 掉容器，并根据容器的重启策略是否重启，如果一个容器不包含 LivenessProbe 探针，则 Kubelet 认为容器的 LivenessProbe 探针的返回值永远成功。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>  <span class="comment"># 容器启动后第一次执行探测是需要等待多少秒</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span>  <span class="comment"># 执行探测的频率</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">2</span>  <span class="comment"># 探测超时时间</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>可配置的参数如下：</p><ol><li>initialDelaySeconds：容器启动后第一次执行探测是需要等待多少秒。</li><li>periodSeconds：执行探测的频率。默认是10秒，最小1秒。</li><li>timeoutSeconds：探测超时时间。默认1秒，最小1秒。</li><li>successThreshold：探测失败后，最少连续探测成功多少次才被认定为成功。默认是1。</li><li>failureThreshold：探测成功后，最少连续探测失败多少次。默认是3，最小值是1。</li></ol><p>上面例子配置的情况，健康检查的逻辑为：K8S 将在 Pod 开始启动 20s(initialDelaySeconds) 后探测 Pod 内的 8000 端口是否可以建立 TCP 连接，并且每 15 秒钟探测一次，如果连续 3 次探测失败，则 kubelet 重启该容器</p><h2 id="ReadinessProbe-探针-（就绪探针）"><a href="#ReadinessProbe-探针-（就绪探针）" class="headerlink" title="ReadinessProbe 探针 （就绪探针）"></a>ReadinessProbe 探针 （就绪探针）</h2><p>可用性探测：用于判断容器是否正常提供服务，即容器的 Ready 是否为 True，是否可以接收请求，如果 ReadinessProbe 探测失败，则容器的 Ready 将为 False， Endpoint Controller 控制器将此 Pod 的 Endpoint 从对应的 service 的 Endpoint 列表中移除，不再将任何请求调度此 Pod 上，直到下次探测成功。（剔除此 Pod 不参与接收请求不会将流量转发给此 Pod）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">readinessProbe:</span> </span><br><span class="line">      <span class="attr">httpGet:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">10</span> </span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>上面例子配置的情况，健康检查的逻辑为：K8S 将在 Pod 开始启动 10s(initialDelaySeconds) 后利用 HTTP 访问 8002 端口的 &#x2F;blog&#x2F;index&#x2F;，如果超过 2s 或者返回码不在 200~399 内，则健康检查失败</p><h2 id="StartupProbe-探针-（启动探针）"><a href="#StartupProbe-探针-（启动探针）" class="headerlink" title="StartupProbe 探针 （启动探针）"></a>StartupProbe 探针 （启动探针）</h2><p>启动探针：kubelet 使用 startup probe 来指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被禁用，直到该探针成功为止。此探针主要用于判断容器是否已经启动完成，如果 StartupProbe 探针探测失败，则 kubelet 将 kill 掉容器，并根据容器的重启策略是否重启，如果一个容器不包含 StartupProbe 探针，则 Kubelet 认为容器的 StartupProbe 探针的返回值永远成功。</p><p>如果你的容器需要在启动期间加载大型数据、配置文件等操作，那么这个时候我们可以使用启动探针。</p><p>该探针在 Kubernetes v1.20 版本才变成稳定状态，对于所包含的容器需要较长时间才能启动就绪的 Pod 而言，启动探针是有用的。你不再需要配置一个较长的存活态探测时间间隔，只需要设置另一个独立的配置选项，对启动期间的容器执行探测，从而允许使用远远超出存活态时间间隔所允许的时长。</p><p>如果你的容器启动时间通常超出 initialDelaySeconds + failureThreshold × periodSeconds 总值，你应该设置一个启动探针，对存活态探针所使用的同一端点执行检查。 periodSeconds 的默认值是 10 秒，还应该将其failureThreshold 设置得足够高，以便容器有充足的时间完成启动，并且避免更改存活态探针所使用的默认值。 这一设置有助于减少死锁状况的发生。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">startupProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">30</span> <span class="comment"># 尽量设置大一点，避免死锁</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="检查方式"><a href="#检查方式" class="headerlink" title="检查方式"></a>检查方式</h2><p>probe 是由 kubelet 对容器执行的定期诊断，要执行诊断，kubelet 既可以在容器内执行代码，也可以发出一个网络请求。使用探针来检查容器有四种不同的方法。每个探针都必须准确定义为这四种机制中的一种：</p><ul><li><p>exec：通过执行命令来检查服务是否正常，返回值为0则表示容器健康</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  livenessProbe:</span><br><span class="line">    <span class="built_in">exec</span>:</span><br><span class="line">      <span class="built_in">command</span>:</span><br><span class="line">      - <span class="built_in">cat</span></span><br><span class="line">      - /tmp/healthy</span><br><span class="line">    initialDelaySeconds: 5</span><br><span class="line">    periodSeconds: 5</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>httpGet方式：通过发送http请求检查服务是否正常，返回200-399状态码则表明容器健康，如上面的例子</p></li><li><p>tcpSocket：通过容器的IP和Port执行TCP检查，如果能够建立TCP连接，则表明容器健康。实际上就是检查容器的端口。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  livenessProbe:</span><br><span class="line">    tcpSocket:</span><br><span class="line">      port: 8002</span><br><span class="line">    initialDelaySeconds: 10  <span class="comment"># 容器启动后第一次执行探测是需要等待多少秒</span></span><br><span class="line">    periodSeconds: 10     <span class="comment"># 执行探测的频率</span></span><br><span class="line">    timeoutSeconds: 2        <span class="comment"># 探测超时时间</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>grpc：使用 gRPC 执行一个远程过程调用，目标应该实现 gRPC 健康检查。如果响应的状态是 SERVING，则认为诊断成功。不过需要注意 gRPC 探针是一个 Alpha 特性，只有在启用了 GRPCContainerProbe 特性门户时才可用。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    livenessProbe:</span><br><span class="line">      grpc:</span><br><span class="line">        port: 8002</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>另外，对于 HTTP 和 TCP 存活检测可以使用命名的 port</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-port</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="attr">hostPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line"></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">liveness-port</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br></pre></td></tr></table></figure><p>每次探测都将获得以下三种结果之一：</p><ul><li>Success（成功）：容器通过了诊断。</li><li>Failure（失败）：容器未通过诊断。</li><li>Unknown（未知）：诊断失败，因此不会采取任何行动。</li></ul><p>不过需要注意应尽量避免使用 TCP 探测，因为 TCP 探测实际就是 kubelet 向指定端口发送 TCP SYN 握手包，当端口被监听内核就会直接响应 ACK，探测就会成功。当程序死锁或 hang 住的情况，这些并不影响端口监听，所以探测结果还是健康，流量打到表面健康但实际不健康的 Pod 上，就无法处理请求，从而引发业务故障。</p><h2 id="健康检查示例"><a href="#健康检查示例" class="headerlink" title="健康检查示例"></a>健康检查示例</h2><p>比如上面的 <code>pod-with-volume.yaml</code> 文件，我们改造一下，添加上面的探针配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">myblog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 声明挂载的卷</span></span><br><span class="line">  <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">hostPath:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">  <span class="comment"># 使用节点选择器将 Pod 调度到指定label的节点</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>  <span class="comment"># 容器启动后第一次执行探测是需要等待多少秒</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span> <span class="comment"># 执行探测的频率</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span><span class="comment"># 探测超时时间</span></span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;myblog&quot;</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="comment"># 使用上面声明的卷挂载到容器内部</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">          <span class="comment"># 挂载到容器内部的路径</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>上面的文件已经给 myblog-api 添加了探针配置， K8S 将在 Pod 开始<strong>启动 10s(initialDelaySeconds)后</strong>利用 HTTP 访问 8002 端口的 &#x2F;blog&#x2F;index&#x2F; ，如果<strong>超过2s</strong>或者返回码不在 200~399 内，则健康检查失败</p><blockquote><p>Readiness 决定了 Service 是否将流量导入到该 Pod，Liveness 决定了容器是否需要被重启</p></blockquote><h1 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h1><p>Pod 的重启策略（RestartPolicy）应用于 Pod 内的所有容器，并且仅在 Pod 所处的 Node 上由 kubelet 进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet 将根据 RestartPolicy 的设置来进行相应的操作。</p><p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值为 Always。</p><ul><li>Always：当容器进程退出后，由kubelet自动重启该容器；</li><li>OnFailure：当容器终止运行且退出码不为0时，由kubelet自动重启该容器；</li><li>Never：不论容器运行状态如何，kubelet都不会重启该容器。</li></ul><p>演示重启策略：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-restart-policy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><ol><li>使用默认的重启策略，即 restartPolicy: Always ，无论容器是否是正常退出，都会自动重启容器</li><li>使用OnFailure的策略时<ul><li>如果把exit 1，去掉，即让容器的进程正常退出的话，则不会重启</li><li>只有非正常退出状态才会重启</li></ul></li><li>使用Never时，退出了就不再重启</li></ol><p>可以看出，若容器正常退出，Pod 的状态会是Completed，非正常退出，状态为CrashLoopBackOff</p><h1 id="镜像拉取策略"><a href="#镜像拉取策略" class="headerlink" title="镜像拉取策略"></a>镜像拉取策略</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure><p>设置镜像的拉取策略，默认为IfNotPresent</p><ul><li>Always，总是拉取镜像，即使本地有镜像也从仓库拉取</li><li>IfNotPresent ，本地有则使用本地镜像，本地没有则去仓库拉取</li><li>Never，只使用本地镜像，本地没有则报错</li></ul><h1 id="Pod-资源限制"><a href="#Pod-资源限制" class="headerlink" title="Pod 资源限制"></a>Pod 资源限制</h1><p>为了保证充分利用集群资源，且确保重要容器在运行周期内能够分配到足够的资源稳定运行，因此平台需要具备 Pod 的资源限制的能力。 对于一个 Pod 来说，资源最基础的2个的指标就是：CPU和内存。</p><p>Kubernetes 提供了个采用 requests 和 limits 两种类型参数对资源进行预分配和使用限制。</p><p>将最开始的文件加上目前的所有字段，完整文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">myblog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 重启策略</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">hostPath:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">      <span class="comment"># 镜像拉取策略</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment"># 资源限制</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;myblog&quot;</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="comment"># 使用上面声明的卷挂载到容器内部</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">          <span class="comment"># 挂载到容器内部的路径</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><ul><li><p>requests：</p><ul><li>容器使用的最小资源需求,作用于 schedule 阶段，作为容器调度时资源分配的判断依赖</li><li>只有当前节点上可分配的资源量 &gt;&#x3D; request 时才允许将容器调度到该节点</li><li>request 参数不限制容器的最大可使用资源</li><li>requests.cpu 被转成 docker 的 –cpu-shares 参数，与 cgroup cpu.shares 功能相同 (无论宿主机有多少个 cpu 或者内核，–cpu-shares 选项都会按照比例分配 cpu 资源）</li><li>requests.memory 没有对应的 docker 参数，仅作为 k8s 调度依据</li></ul></li><li><p>limits：</p><ul><li>容器能使用资源的最大值</li><li>设置为 0 表示对使用的资源不做限制, 可无限的使用</li><li>当 Pod 内存超过 limit 时，会被 oom</li><li>当 cpu 超过 limit 时，不会被 kill，但是会限制不超过 limit 值</li><li>limits.cpu 会被转换成 docker 的 –cpu-quota 参数。与 cgroup cpu.cfs_quota_us 功能相同</li><li>limits.memory 会被转换成 docker 的 –memory 参数。用来限制容器使用的最大内存</li></ul></li></ul><p>对于 CPU，我们知道计算机里 CPU 的资源是按 <code>“时间片”</code> 的方式来进行分配的，系统里的每一个操作都需要 CPU 的处理，所以，哪个任务要是申请的 CPU 时间片越多，那么它得到的 CPU 资源就越多。</p><p>然后还需要了解下 CGroup 里面对于 CPU 资源的单位换算：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 CPU =  1000 millicpu（1 Core = 1000m）</span><br></pre></td></tr></table></figure><p>这里的 <code>m</code> 就是毫、毫核的意思，Kubernetes 集群中的每一个节点可以通过操作系统的命令来确认本节点的 CPU 内核数量，然后将这个数量乘以1000，得到的就是节点总 CPU 总毫数。比如一个节点有四核，那么该节点的 CPU 总毫量为 4000m。</p><p><code>docker run</code>命令和 CPU 限制相关的所有选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>--cpuset-cpus=&quot;&quot;</code></td><td>允许使用的 CPU 集，值可以为 0-3,0,1</td></tr><tr><td><code>-c</code>,<code>--cpu-shares=0</code></td><td>CPU 共享权值（相对权重）</td></tr><tr><td><code>cpu-period=0</code></td><td>限制 CPU CFS 的周期，范围从 100ms~1s，即[1000, 1000000]</td></tr><tr><td><code>--cpu-quota=0</code></td><td>限制 CPU CFS 配额，必须不小于1ms，即 &gt;&#x3D; 1000，绝对限制</td></tr></tbody></table><p>举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpu-period=50000 --cpu-quota=25000 ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure><p>将 CFS 调度的周期设为 50000，将容器在每个周期内的 CPU 配额设置为 25000，表示该容器每 50ms 可以得到 50% 的 CPU 运行时间。</p><blockquote><p>注意：若内存使用超出限制，会引发系统的 OOM 机制，因 CPU 是可压缩资源，不会引发 Pod 退出或重建</p></blockquote><h1 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h1><p>yaml 的环境变量中有很多敏感的信息，比如账号密码，直接暴漏在 yaml 文件中存在安全性问题。对于开发、测试、生产环境，由于配置均不同，每套环境部署的时候都要修改yaml，带来额外的开销。</p><p>k8s提供了两类资源，<code>configMap</code> 和 <code>Secret</code>，可以用来实现业务配置的统一管理， 允许将配置文件与镜像文件分离，以使容器化的应用程序具有可移植性 。</p><h2 id="configMap"><a href="#configMap" class="headerlink" title="configMap"></a>configMap</h2><p>通常用来管理应用的配置文件或者环境变量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">MYSQL_HOST:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="attr">MYSQL_DATABASE:</span> <span class="string">&quot;myblog&quot;</span></span><br></pre></td></tr></table></figure><p>创建并查看configmap：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f configmap.yaml</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get configmap myblog -oyaml</span><br></pre></td></tr></table></figure><p>或者可以使用命令的方式，从文件中创建，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> env-configs.txt</span><br><span class="line">MYSQL_HOST=127.0.0.1</span><br><span class="line">MYSQL_DATABASE=myblog</span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create configmap myblog --from-env-file=env-configs.txt</span><br></pre></td></tr></table></figure><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>管理敏感类的信息，默认会base64编码存储，有三种类型</p><ul><li>Service Account ：用来访问 Kubernetes API ，由 Kubernetes 自动创建，并且会自动挂载到 Pod 的 &#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount 目录中；创建 ServiceAccount 后，Pod 中指定 serviceAccount 后，自动创建该 ServiceAccount 对应的 secret；</li><li>Opaque ： base64编码格式的 Secret，用来存储密码、密钥等；</li><li>kubernetes.io&#x2F;dockerconfigjson ：用来存储私有docker registry的认证信息。</li></ul><p>secret的创建和configmap类似，可以通过文件或者命令的方式创建，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span>  </span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># 获取方法，shell下执行：注意加-n参数， echo -n root|base64</span></span><br><span class="line">  <span class="comment"># 解析方法，shell下执行：echo cm9vdA==|base64 -d</span></span><br><span class="line">  <span class="attr">MYSQL_USER:</span> <span class="string">cm9vdA==</span></span><br><span class="line">  <span class="comment"># echo -n 123456|base64</span></span><br><span class="line">  <span class="attr">MYSQL_PASSWD:</span> <span class="string">MTIzNDU2</span></span><br></pre></td></tr></table></figure><p>创建并查看secret：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f secret.yaml</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get secret myblog-secret -oyaml</span><br></pre></td></tr></table></figure><p>或者可以使用命令的方式，从文件中创建，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> env-secret.txt</span><br><span class="line">MYSQL_USER=root</span><br><span class="line">MYSQL_PASSWD=MTIzNDU2</span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> create secret generic myblog-secret --from-env-file=env-secret.txt</span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get secret myblog-secret -oyaml</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>在配置中使用 configmap 和 secret：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">myblog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">hostPath:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/mysql/data</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="comment"># 环境变量全部使用 configmap 和 secret 中的配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blog/index/</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment"># 资源限制</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="comment"># 环境变量全部使用 configmap 和 secret 中的配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="comment"># 使用上面声明的卷挂载到容器内部</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">          <span class="comment"># 挂载到容器内部的路径</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在部署不同的环境时，Pod 的 yaml 无须再变化，只需要在每套环境中维护一套 <code>ConfigMap</code> 和 <code>Secret</code> 即可。但是注意 <code>configmap</code> 和 <code>secret</code> 不能跨 <code>namespace</code> 使用，且更新后，Pod 内的 env 不会自动更新，重建后才会更新。</p><h1 id="如何编写资源yaml"><a href="#如何编写资源yaml" class="headerlink" title="如何编写资源yaml"></a>如何编写资源yaml</h1><p>这里主要说一下如何编写资源yaml，主要是一些技巧。</p><ol><li><p>从机器中已有的资源中提取yaml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取系统命名空间的所有资源，根据资源本身的yaml文件，可以进行修改</span></span><br><span class="line">$ kubectl -n kube-system -o yaml get po,deployment,ds</span><br></pre></td></tr></table></figure></li><li><p>学会在官网查找， <a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a></p></li><li><p>从kubernetes-api文档中查找， <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#pod-v1-core">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#pod-v1-core</a></p></li><li><p>kubectl explain 查看具体字段含义</p></li></ol><h1 id="Pod-状态与生命周期"><a href="#Pod-状态与生命周期" class="headerlink" title="Pod 状态与生命周期"></a>Pod 状态与生命周期</h1><p>下图展示了一个 Pod 的完整生命周期过程，其中包含 <code>Init Container</code>、<code>Pod Hook</code>、<code>健康检查</code> 三个主要部分。</p><p>生命周期示意图：</p><p><img src="/post/docker/pod-lifecycle-status.svg" alt="pod-lifecycle-status"></p><p>启动和关闭示意：</p><p><img src="/post/docker/pod-lifecycle-start-stop.svg" alt="pod-lifecycle-start-stop"></p><p>Pod 的基本状态如下表所示，这些信息都是集群自动维护的：</p><table><thead><tr><th>状态值</th><th>描述</th></tr></thead><tbody><tr><td>Pending</td><td>API Server已经创建该 Pod，等待调度器调度</td></tr><tr><td>ContainerCreating</td><td>拉取镜像启动容器中</td></tr><tr><td>Running</td><td>Pod 内容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态</td></tr><tr><td>Succeeded|Completed</td><td>Pod 内所有容器均已成功执行退出，且不再重启</td></tr><tr><td>Failed|Error</td><td>Pod 内所有容器均已退出，但至少有一个容器退出为失败状态</td></tr><tr><td>CrashLoopBackOff</td><td>Pod 内有容器启动失败，比如配置文件丢失导致主进程启动失败</td></tr><tr><td>Unknown</td><td>由于某种原因无法获取该 Pod 的状态，可能由于网络通信不畅导致</td></tr></tbody></table><h2 id="初始化容器"><a href="#初始化容器" class="headerlink" title="初始化容器"></a>初始化容器</h2><p>Init Container：顾名思义，用于初始化工作，执行完就结束，可以理解为一次性任务。可以是一个或者多个，如果有多个的话，这些容器会按定义的顺序依次执行。我们知道一个 Pod 里面的所有容器是共享数据卷和 Network Namespace的，所以 Init Container 里面产生的数据可以被主容器使用到。从上面的 Pod 生命周期的图中可以看出初始化容器是独立与主容器之外的，只有所有的初始化容器执行完之后，主容器才会被启动。</p><p>含有以下特点：</p><ul><li>支持大部分应用容器配置，但不支持健康检查</li><li>优先应用容器执行</li></ul><p>主要用来实现如下目的：</p><ul><li>验证业务应用依赖的组件是否均已启动</li><li>修改目录的权限</li><li>调整系统参数</li><li>初始化应用配置，比如集群的配置信息等</li><li>比如将 Pod 注册到注册中心、配置中心等</li></ul><p>参考配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-init</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">pod-init</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api-init</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/sbin/sysctl</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-w</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vm.max_map_count=262144</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">alpine:3.6</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api-change-permission</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;chown -R 1000:1000 /var/www/html&quot;</span>]</span><br><span class="line">      <span class="attr">image:</span> <span class="string">alpine:3.6</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myblog-api</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/myblog:v1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">configMapKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">MYSQL_HOST</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">secretKeyRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">myblog-secret</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/var/www/htm</span></span><br><span class="line">  <span class="attr">volumes:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125; <span class="comment"># emptyDir&#123;&#125; 是一个临时的目录，数据会保存在 kubelet 的工作目录下面，生命周期等同于 Pod 的生命周期</span></span><br></pre></td></tr></table></figure><h2 id="Pod-Hook"><a href="#Pod-Hook" class="headerlink" title="Pod Hook"></a>Pod Hook</h2><p>我们知道 Pod 是 Kubernetes 集群中的最小单元，而 Pod 是由容器组成的，所以在讨论 Pod 的生命周期的时候我们可以先来讨论下容器的生命周期。</p><p>实际上 Kubernetes 为我们的容器提供了生命周期的钩子，就是我们说的 Pod Hook。Pod Hook 是由 kubelet 发起的，当容器中的进程启动前或者容器中的进程终止之前运行，这是包含在容器的生命周期之中。我们可以同时为 Pod 中的所有容器都配置 hook。</p><p>Kubernetes 为我们提供了两种钩子函数：</p><ul><li>PostStart：Kubernetes 在容器创建后立即发送 postStart 事件，然而 postStart 处理函数的调用不保证早于容器的入口点（entrypoint） 的执行。 postStart 处理函数与容器的代码是异步执行的，但 Kubernetes的容器管理逻辑会一直阻塞等待 postStart 处理函数执行完毕。只有 postStart 处理函数执行完毕，容器的状态才会变成 RUNNING 。</li><li>PreStop：这个钩子在容器终止之前立即被调用。它是阻塞的，所以它必须在删除容器的调用发出之前完成。主要用于优雅关闭应用程序、通知其他系统等。</li></ul><blockquote><p>PostStart用的不是很多，而PreStop用的相对很多.<br>Kubernetes 只有在 Pod 结束（Terminated）的时候才会发送 preStop 事件，这意味着在 Pod 完成（Completed）时 preStop 的事件处理逻辑不会被触发</p></blockquote><h2 id="验证Pod生命周期"><a href="#验证Pod生命周期" class="headerlink" title="验证Pod生命周期"></a>验证Pod生命周期</h2><p>编写以下 yaml 文件，包括 initContainer、lifecycle、readinessProbe、livenessProbe、preStop、postStart的配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-lifecycle</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">pod-lifecycle</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): INIT &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">record</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/record/record.txt</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): START &gt;&gt; /record/record.txt; sleep 10; echo $(date +%s): END &gt;&gt; /record/record.txt;&#x27;</span>]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">record</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/record/record.txt</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): LIVENESS &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">      <span class="attr">readinessProbe:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): READINESS &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">      <span class="attr">lifecycle:</span></span><br><span class="line">        <span class="attr">postStart:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): POST-START &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">        <span class="attr">preStop:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo $(date +%s): PRE-STOP &gt;&gt; /record/record.txt&#x27;</span>]</span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">record</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp/record</span></span><br></pre></td></tr></table></figure><p>创建 Pod 测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f pod-lifecycle.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看demo状态</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po -o wide -w</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看调度节点的/tmp/record/record.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> /tmp/record/record.txt</span><br><span class="line">1585424708: INIT</span><br><span class="line">1585424746: START</span><br><span class="line">1585424746: POST-START</span><br><span class="line">1585424754: READINESS</span><br><span class="line">1585424756: LIVENESS</span><br><span class="line">1585424756: END</span><br></pre></td></tr></table></figure><p>上面的输出没有 <code>PRE-STOP</code> 是因为必须主动杀掉 Pod 才会触发 <code>pre-stop hook</code>，如果是 Pod 自己 Down 掉，则不会执行 <code>pre-stop hook</code> ,且杀掉Pod进程前，进程必须是正常运行状态，否则不会执行pre-stop钩子。</p><p>Hook 调用的日志没有暴露给 Pod，如果处理程序由于某种原因失败，它将产生一个事件。对于 PostStart，这是FailedPostStartHook 事件，对于 PreStop，是 FailedPreStopHook 事件，我们可以通过运行 kubectl -n test describe pod pod-lifecycle 来查看事件。</p><h2 id="Pod-的终止"><a href="#Pod-的终止" class="headerlink" title="Pod 的终止"></a>Pod 的终止</h2><p>Pod 的终止有两种方式：正常终止和强制终止。</p><h3 id="正常终止"><a href="#正常终止" class="headerlink" title="正常终止"></a>正常终止</h3><p>终止流程如下：</p><ol><li>用户发出删除 Pod 指令，Pod 被删除，状态变为 Terminating，从 API 层面看就是 Pod metadata 中的deletionTimestamp 字段会被标记上删除时间。</li><li>kube-proxy watch 到了就开始更新转发规则，将 Pod 从 service 的 endpoints 列表中摘除掉，新的流量不再转发到该 Pod。</li><li>kubelet watch 到了就开始销毁 Pod。</li><li>如果 Pod 中有 container 配置了 preStop Hook ，则 Pod 被标记为 Terminating 状态时，以同步的方式启动执行；若宽限期结束后 preStop 仍未执行结束，则会额外获得一个 2 秒的小宽限期。</li><li>发送 SIGTERM 信号给容器内主进程以通知容器进程开始优雅停止。</li><li>等待 container 中的主进程完全停止，如果在宽限期结束后还未完全停止，就发送 SIGKILL 信号将其强制杀死。</li><li>所有容器进程终止，清理 Pod 资源。</li><li>通知 APIServer Pod 销毁完成，完成 Pod 删除。</li></ol><p>对于长连接类型的业务，比如游戏类应用，我们可以将 terminationGracePeriodSeconds 设置大一点，避免过早的被 SIGKILL 杀死，但是具体多长时间是不好预估的，所以最好在业务层面进行优化。比如 Pod 销毁时的优雅终止逻辑里面主动通知下客户端，让客户端连到新的后端，然后客户端来保证这两个连接的平滑切换。等旧 Pod 上所有客户端连接都连切换到了新 Pod 上，才最终退出。</p><h3 id="强制终止-Pod"><a href="#强制终止-Pod" class="headerlink" title="强制终止 Pod"></a>强制终止 Pod</h3><p>默认情况下，所有的删除操作都会有 30 秒钟的宽限期限。kubectl delete 命令支持 <code>grace-period=&lt;seconds&gt;</code> 选项，允许你重载默认值，设定自己希望的期限值。</p><p>将宽限期限强制设置为 0 意味着立即从 APIServer 删除 Pod，如果 Pod 仍然运行于某节点上，强制删除操作会触发 kubelet 立即执行清理操作。 注意：你必须在设置 grace-period&#x3D;0 的同时额外设置 force 参数才能发起强制删除请求。</p><p>执行强制删除操作时，APIServer 不再等待来自 kubelet 关于 Pod 已经在原来运行的节点上终止执行的确认消息。APIServer 直接删除 Pod 对象，这样新的与之同名的 Pod 即可以被创建。在节点侧，被设置为立即终止的 Pod 仍然会在被强行杀死之前获得一点点的宽限时间。</p><p>对于已失败的 Pod 而言，对应的 API 对象仍然会保留在集群的 API 服务器上，直到用户或者控制器进程显式地将其删除。</p><p>控制器组件会在 Pod 个数超出所配置的阈值 （根据 kube-controller-manager 的 terminated-pod-gc-threshold 设置）时删除已终止的 Pod（phase 值为 Succeeded 或 Failed）。这一行为会避免随着时间不断创建和终止 Pod 而引起的资源泄露问题。</p><p>当然，这种方法伴随着一些风险，所以用强制删除 Pod 的命令需要慎用。</p><h3 id="业务代码处理-SIGTERM-信信号"><a href="#业务代码处理-SIGTERM-信信号" class="headerlink" title="业务代码处理 SIGTERM 信信号"></a>业务代码处理 SIGTERM 信信号</h3><p>要实现优雅退出，我们需要业务代码得支持下优雅退出的逻辑，在业务代码里面处理下 SIGTERM 信号，一般主要逻辑就是”排水”，即等待存量的任务或连接完全结束，再退出进程。下面我们给出几种常用编程语言实现优雅退出的示例。</p><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//registers the channel</span></span><br><span class="line">    signal.Notify(sigs, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sig := &lt;-sigs</span><br><span class="line">        fmt.Println(<span class="string">&quot;Caught SIGTERM, shutting down&quot;</span>)</span><br><span class="line">        <span class="comment">// Finish any outstanding requests, then...</span></span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Starting application&quot;</span>)</span><br><span class="line">    <span class="comment">// Main logic goes here</span></span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">&quot;exiting&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> signal, time, os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shutdown</span>(<span class="params">signum, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Caught SIGTERM, shutting down&#x27;</span>)</span><br><span class="line">    <span class="comment"># Finish any outstanding requests, then...</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Register handler</span></span><br><span class="line">    signal.signal(signal.SIGTERM, shutdown)</span><br><span class="line">    <span class="comment"># Main logic goes here</span></span><br></pre></td></tr></table></figure><h4 id="Node-JS"><a href="#Node-JS" class="headerlink" title="Node JS"></a>Node JS</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;SIGTERM&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;SIGTERM signal received.&#x27;</span>);</span><br><span class="line">    <span class="comment">// Finish any outstanding requests, then...</span></span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Signal;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SignalHandler;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleSignalHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String<span class="string">&quot;&quot;</span>. args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">Signal.handle(<span class="keyword">new</span> <span class="title class_">Signal</span>(<span class="string">&quot;TERM&quot;</span>), <span class="keyword">new</span> <span class="title class_">SignalHandler</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Signal sig)</span> &#123;</span><br><span class="line">System.out.format(<span class="string">&quot;\nProgram execution took %f seconds\n&quot;</span>,</span><br><span class="line">(System.nanoTime() - start) / <span class="number">1e9f</span>);</span><br><span class="line"> System.exit(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">System.out.println(counter<span class="string">&quot;2);</span></span><br><span class="line"><span class="string">Thread.sleep(500);</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;   </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Signal;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SignalHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleSignalHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        Signal.handle(<span class="keyword">new</span> <span class="title class_">Signal</span>(<span class="string">&quot;TERM&quot;</span>), <span class="keyword">new</span> <span class="title class_">SignalHandler</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Signal sig)</span> &#123;</span><br><span class="line">                System.out.format(<span class="string">&quot;\nProgram execution took %f seconds\n&quot;</span>,</span><br><span class="line">                        (System.nanoTime() - start) / <span class="number">1e9f</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(counter++);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redirecting Filehanders</span></span><br><span class="line"><span class="built_in">ln</span> -sf /proc/$$/fd/1 /log/stdout.log</span><br><span class="line"><span class="built_in">ln</span> -sf /proc/$$/fd/2 /log/stderr.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre execution handler</span></span><br><span class="line"><span class="function"><span class="title">pre_execution_handler</span></span>() &#123;</span><br><span class="line">  <span class="comment"># Pre Execution</span></span><br><span class="line">  <span class="comment"># put your pre execution steps here</span></span><br><span class="line">    : <span class="comment"># delete this nop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Post execution handler</span></span><br><span class="line"><span class="function"><span class="title">post_execution_handler</span></span>() &#123;</span><br><span class="line">  <span class="comment"># Post Execution</span></span><br><span class="line">  <span class="comment"># put your post execution steps here</span></span><br><span class="line">    : <span class="comment"># delete this nop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sigterm Handler</span></span><br><span class="line"><span class="function"><span class="title">sigterm_handler</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$pid</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># the above if statement is important because it ensures</span></span><br><span class="line">    <span class="comment"># that the application has already started. without it you</span></span><br><span class="line">    <span class="comment"># could attempt cleanup steps if the application failed to</span></span><br><span class="line">    <span class="comment"># start, causing errors.</span></span><br><span class="line">    <span class="built_in">kill</span> -15 <span class="string">&quot;<span class="variable">$pid</span>&quot;</span></span><br><span class="line">    <span class="built_in">wait</span> <span class="string">&quot;<span class="variable">$pid</span>&quot;</span></span><br><span class="line">    post_execution_handler</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">exit</span> 143; <span class="comment"># 128 + 15 = SIGTERM</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup signal trap</span></span><br><span class="line"><span class="comment"># on callback execute the specified handler</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;sigterm_handler&#x27;</span> SIGTERM</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Initialization</span></span><br><span class="line">pre_execution_handler</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start Process</span></span><br><span class="line"><span class="comment"># run process in background and record PID</span></span><br><span class="line">&gt;/log/stdout.log 2&gt;/log/stderr.log <span class="string">&quot;<span class="variable">$@</span>&quot;</span> &amp;</span><br><span class="line">pid=<span class="string">&quot;$!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application can log to stdout/stderr, /log/stdout.log or /log/stderr.log</span></span><br><span class="line"><span class="comment"># Wait forever until app dies</span></span><br><span class="line"><span class="built_in">wait</span> <span class="string">&quot;<span class="variable">$pid</span>&quot;</span></span><br><span class="line">return_code=<span class="string">&quot;$?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cleanup</span></span><br><span class="line">post_execution_handler</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo the return code of the application</span></span><br><span class="line"><span class="built_in">exit</span> <span class="variable">$return_code</span></span><br></pre></td></tr></table></figure><h3 id="收不到-SIGTERM-信信号"><a href="#收不到-SIGTERM-信信号" class="headerlink" title="收不到 SIGTERM 信信号"></a>收不到 SIGTERM 信信号</h3><p>上面我们给出了几种常见的捕捉 SIGTERM 信号的代码，然后我们就可以执行停止逻辑以实现优雅退出了。在 Kubernetes环境中，业务发版时经常会对工作负载进行滚动更新，当旧版本 Pod 被删除时，K8s 会对 Pod 中各个容器中的主进程发送 SIGTERM 信号，当达到退出宽限期后进程还未完全停止的话，就会发送 SIGKILL 信号将其强制杀死。但是有的场景下在 Kubernetes 环境中实际运行时，有时候可能会发现在滚动更新时，我们业务的优雅终止逻辑并没有被执行，现象是在等了较长时间后，业务进程直接被 SIGKILL 强制杀死了。</p><p>这是什么原因造成的呢？通常情况下这都是因为容器启动入口使用了 shell，比如使用了类似 &#x2F;bin&#x2F;sh -c my-app 这样的启动入口。或者使用 &#x2F;entrypoint.sh 这样的脚本文件作为入口，在脚本中再启动业务进程，比如下面的entrypoint.sh 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">python /app/my-app.py</span><br></pre></td></tr></table></figure><p>这就可能就会导致容器内的业务进程收不到 SIGTERM 信号，原因是:</p><ol><li>容器主进程是 shell，业务进程是在 shell 中启动的，变成了 shell 进程的子进程了。</li><li>shell 进程默认会忽略 SIGTERM 信号，父进程不退出，子进程也不会退出，导致业务逻辑不会触发停止逻辑。</li><li>等到 k8s 的 terminationGracePeriodSeconds 时间（默认30秒）到了，shell 进程被 SIGKILL 强制杀死，子进程也会被 SIGKILL 强制杀死。</li></ol><p>怎么解决这个问题呢？解决方法有几种：</p><ol><li><p>使用 exec 启动</p><p> 在 shell 中启动二进制的命令前加一个 exec 命令即可让该二进制启动的进程代替当前 shell 进程，即让新启动的进程成为主进程:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> python /app/my-app.py</span><br></pre></td></tr></table></figure><p> 然后业务进程就可以正常接收所有信号了，实现优雅退出当然也可以了。</p></li><li><p>多进程场景</p><p> 通常我们一个容器只会有一个进程，但有些时候我们不得不启动多个进程，比如从传统部署迁移到 Kubernetes 的过渡期间，使用了富容器，即单个容器中需要启动多个业务进程，这时候我们可以通过 shell 来启动，但却无法使用上面的 exec 方式来传递信号了，因为 exec 只能让一个进程替代当前 shell 成为主进程。</p><p> 这个时候我们可以在 shell 中使用 trap 来捕获信号，当收到信号后触发回调函数来将信号通过 kill 命令传递给业务进程。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">   </span><br><span class="line">/bin/app1 &amp; pid1=<span class="string">&quot;$!&quot;</span> <span class="comment"># 启动第一个业务进程并记录 pid</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;app1 started with pid <span class="variable">$pid1</span>&quot;</span></span><br><span class="line">   </span><br><span class="line">/bin/app2 &amp; pid2=<span class="string">&quot;$!&quot;</span> <span class="comment"># 启动第二个业务进程并记录 pid</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;app2 started with pid <span class="variable">$pid2</span>&quot;</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="title">handle_sigterm</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[INFO] Received SIGTERM&quot;</span></span><br><span class="line">    <span class="built_in">kill</span> -SIGTERM <span class="variable">$pid1</span> <span class="variable">$pid2</span> <span class="comment"># 传递 SIGTERM 给业务进程</span></span><br><span class="line">    <span class="built_in">wait</span> <span class="variable">$pid1</span> <span class="variable">$pid2</span> <span class="comment"># 等待所有业务进程完全终止</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">trap</span> handle_sigterm SIGTERM <span class="comment"># 捕获 SIGTERM 信号并回调 handle_sigterm 函数</span></span><br><span class="line"><span class="built_in">wait</span> <span class="comment"># 等待回调执行完，主进程再退出</span></span><br></pre></td></tr></table></figure></li><li><p>使用 tini</p><p> 前面一种方案实际是用脚本实现了一个极简的 init 系统 (或 supervisor ) 来管理所有子进程，只不过它的逻辑很简陋，仅仅简单的透传指定信号给子进程，其实社区有更完善的方案，dumb-init (<a href="https://github.com/Yelp/dumb-init)%E5%92%8C">https://github.com/Yelp/dumb-init)和</a> tini (<a href="https://github.com/krallin/tini)%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA">https://github.com/krallin/tini)都可以作为</a> init 进程，作为主进程 (PID 1) 在容器中启动，然后它再运行 shell 来执行我们指定的脚本 (shell 作为子进程)，shell 中启动的业务进程也成为它的子进程，当它收到信号时会将其传递给所有的子进程，从而也能完美解决 shell 无法传递信号问题，并且还有回收僵尸进程的能力，这也是我们强烈推荐的一种方式。</p><p> 如下所示是一个以 dumb-init 制作镜像的 Dockerfile 示例:</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y dumb-init</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> start.sh /</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> app1 /bin/app1</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> app2 /bin/app2</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;dumb-init&quot;</span>, <span class="string">&quot;*&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/start.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p> 下面则是以 tini 为例制作镜像的 Dockerfile 示例:</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">ENV</span> TINI_VERSION v0.<span class="number">19.0</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/krallin/tini/releases/download/<span class="variable">$&#123;TINI_VERSION&#125;</span>/tini /tini</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> entrypoint.sh /entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /tini /entrypoint.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/tini&quot;</span>, <span class="string">&quot;*&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/start.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p> 此时 start.sh 脚本中当然也可以是多个进程：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">/bin/app1 &amp;</span><br><span class="line">/bin/app2 &amp;</span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure></li></ol><p>优雅退出是 K8s 中非常重要的一个特性，对于实现应用零宕机滚动更新非常重要。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li>实现 k8s 平台与特定的容器运行时解耦，提供更加灵活的业务部署方式，引入了 Pod 概念</li><li>k8s 使用 yaml 格式定义资源文件，yaml比json更加简洁</li><li>通过kubectl apply | get | exec | logs | delete 等操作k8s资源，必须指定 namespace</li><li>每启动一个 Pod ，为了实现网络空间共享，会先创建 Infra 容器（也就是 pause 容器），并把其他容器网络加入该容器，实现Pod内所有容器使用同一个网络空间</li><li>通过 livenessProbe和readinessProbe 实现 Pod 的存活性和就绪健康检查</li><li>通过 requests 和 limit 分别限定容器初始资源申请与最高上限资源申请</li><li>Pod 通过 initContainer 和 lifecycle 分别来执行初始化、Pod 启动和删除时候的操作，使得功能更加全面和灵活</li><li>编写 yaml 讲究方法，学习 k8s，养成从官方网站查询知识的习惯</li></ol><p>那么只使用 Pod ，会有哪些问题呢？</p><ol><li>业务应用启动多个副本怎么做？</li><li>Pod重建后IP会变化，外部如何访问Pod服务？</li><li>运行业务Pod的某个节点挂了，可以自动帮我把Pod转移到集群中的可用节点启动起来？</li><li>我的业务应用功能是收集节点监控数据,需要把Pod运行在k8集群的各个节点上？</li></ol><p>为了解决上面的问题，k8s 需要使用Controller来管理Pod，比如Deployment、StatefulSet、DaemonSet、Job、CronJob等，下面就会详细介绍其中的几类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 强制删除 pod/pvc/pv/ns 的方法</title>
      <link href="/k8s-force-delete-resource/"/>
      <url>/k8s-force-delete-resource/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意：强制删除的操作具有一定的风险，建议在生产环境中慎用。</p></blockquote><span id="more"></span><p>如果namespace、pod、pv、pvc 处于 “Terminating” 状态时，可能是因为kubelet 阻塞，此时为了完成之后的操作，就需要进行强制删除。</p><p>典型的应用场景是 statefulset 的 pod 无法删除，导致 statefulset 无法更新。</p><p>如果所有资源都处于 “Terminating” 状态，需要按照 pod -&gt; pvc -&gt; pv -&gt; ns 的顺序进行强制删除。</p><h2 id="强制删除-pod"><a href="#强制删除-pod" class="headerlink" title="强制删除 pod"></a>强制删除 pod</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 pod 状态</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; get pod -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除 pod</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; delete pod &lt;pod_name&gt; --grace-period=0 --force</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>--grace-period</code>：表示等待多少秒后强制删除，默认是30秒，在删除pod时，会给pod发送一个信号，让pod自己进行清理工作，如果超过了这个时间，pod还没有清理完，就会强制删除。如果设置为0，表示不等待，直接强制删除。</li><li><code>--force</code>：表示强制删除</li></ul><h2 id="强制删除-pvc-amp-pv"><a href="#强制删除-pvc-amp-pv" class="headerlink" title="强制删除 pvc &amp; pv"></a>强制删除 pvc &amp; pv</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 pvc &amp; pv 状态</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; get pvc -o wide</span><br><span class="line">$ kubectl -n &lt;namespace&gt; get pv -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除 pvc &amp; pv</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; patch pvc &lt;pvc_name&gt; -p <span class="string">&#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:null&#125;&#125;&#x27;</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; patch pv &lt;pv_name&gt; -p <span class="string">&#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:null&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>patch</code>：表示修改资源的内容</li><li><code>&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:null&#125;&#125;</code>：表示将资源的 finalizers 字段设置为 null，finalizers 字段是用来阻止资源被删除的，如果设置为 null，就可以强制删除了。</li><li>设置之后，即直接删除了etcd中的记录。</li></ul><h2 id="强制删除-namespace"><a href="#强制删除-namespace" class="headerlink" title="强制删除 namespace"></a>强制删除 namespace</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 namespace 状态</span></span><br><span class="line">$ kubectl get namespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 namespace 中的 finalizers 字段</span></span><br><span class="line">$ kubectl get namespace &lt;namespace&gt; -o yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出信息如下：</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2023-06-17T05:29:36Z&quot;</span></span><br><span class="line">  deletionTimestamp: <span class="string">&quot;2023-08-19T12:50:32Z&quot;</span></span><br><span class="line">  name: &lt;terminating-namespace&gt;</span><br><span class="line">  resourceVersion: <span class="string">&quot;226501792&quot;</span></span><br><span class="line">  uid: 3249789c-6db7-4995-9f88-a562546dbfdb</span><br><span class="line">spec:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">status:</span><br><span class="line">  phase: Active</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 导出 json 格式的 namespace 信息到文件中</span></span><br><span class="line">$ kubectl get namespace &lt;namespace&gt; -o json &gt; namespace.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 namespace.json 文件，删除 finalizers 字段</span></span><br><span class="line">$ <span class="built_in">cat</span> namespace.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: 以下内容的 finalizers 字段已经被清空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Namespace&quot;</span>,</span><br><span class="line">    <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;creationTimestamp&quot;</span>: <span class="string">&quot;2023-06-17T05:29:36Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;deletionTimestamp&quot;</span>: <span class="string">&quot;2023-08-19T12:50:32Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;&lt;terminating-namespace&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceVersion&quot;</span>: <span class="string">&quot;226501792&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uid&quot;</span>: <span class="string">&quot;3249789c-6db7-4995-9f88-a562546dbfdb&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;spec&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;finalizers&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;status&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;phase&quot;</span>: <span class="string">&quot;Active&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启代理</span></span><br><span class="line">$ kubectl proxy</span><br></pre></td></tr></table></figure><p>执行完成以上命令后，终端会 hang 住，此时不要关闭终端，打开一个新的终端，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新 namespace 信息，注意：这里的 &lt;namespace&gt; 是指上面的 &lt;terminating-namespace&gt;，文件 namespace.json 是指上面生成的文件，访问的 url 是上面的 proxy 代理的地址</span></span><br><span class="line">$ curl -k -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X PUT --data-binary @namespace.json http://127.0.0.1:8001/api/v1/namespaces/&lt;namespace&gt;/finalize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出信息如下：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Namespace&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;&lt;terminating-namespace&gt;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;selfLink&quot;</span>: <span class="string">&quot;/api/v1/namespaces/&lt;terminating-namespace&gt;/finalize&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: <span class="string">&quot;3249789c-6db7-4995-9f88-a562546dbfdb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;resourceVersion&quot;</span>: <span class="string">&quot;226501792&quot;</span>,</span><br><span class="line">    <span class="string">&quot;creationTimestamp&quot;</span>: <span class="string">&quot;2023-06-17T05:29:36Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;deletionTimestamp&quot;</span>: <span class="string">&quot;2023-08-19T12:50:32Z&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;spec&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;finalizers&quot;</span>: null</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;phase&quot;</span>: <span class="string">&quot;Terminating&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 namespace 状态，确认 namespace 已经被删除</span></span><br><span class="line">$ kubectl get namespace</span><br></pre></td></tr></table></figure><p>之后两个终端都可以关闭了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中systemd及其service文件</title>
      <link href="/linux-systemd-service-file/"/>
      <url>/linux-systemd-service-file/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是systemd-service"><a href="#什么是systemd-service" class="headerlink" title="什么是systemd service"></a>什么是systemd service</h1><p>systemd是一个Linux系统初始化的系统和服务管理器，它为系统的引导和服务管理提供了新的解决方案。systemd service是systemd管理下的服务，是一种与传统init.d脚本不同的服务管理方式。</p><p>与init.d脚本相比，systemd service具有以下优势：</p><ol><li>支持并行启动服务，加快系统启动速度；</li><li>支持前置和后置依赖关系，有利于服务的启动顺序管理；</li><li>支持动态的服务控制，如启动、停止、重启和重载配置等；</li></ol><span id="more"></span><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>对于那些支持 systemd 的软件，安装的时候，会自动在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录添加一个配置文件。</p><p>如果你想让该软件开机启动，就执行下面的命令（以nginx.service为例）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><p>上面的命令相当于在&#x2F;etc&#x2F;systemd&#x2F;system目录添加一个符号链接，指向&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system里面的nginx.service文件。</p><p>这是因为开机时，systemd只执行&#x2F;etc&#x2F;systemd&#x2F;system目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。</p><p>设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行<code>systemctl start</code>命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start nginx</span><br></pre></td></tr></table></figure><p>执行上面的命令以后，有可能启动失败，因此要用systemctl status命令查看一下该服务的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status nginx</span><br><span class="line">● nginx.service - A high performance web server and a reverse proxy server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2023-08-18 15:33:59 UTC; 44s ago</span><br><span class="line">     Docs: man:nginx(8)</span><br><span class="line"> Main PID: 27882 (nginx)</span><br><span class="line">    Tasks: 9 (limit: 4915)</span><br><span class="line">   CGroup: /system.slice/nginx.service</span><br><span class="line">           ├─27882 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">           ├─27885 nginx: worker process</span><br><span class="line">           ├─27887 nginx: worker process</span><br><span class="line">           ├─27889 nginx: worker process</span><br><span class="line">           ├─27890 nginx: worker process</span><br><span class="line">           ├─27892 nginx: worker process</span><br><span class="line">           ├─27893 nginx: worker process</span><br><span class="line">           ├─27894 nginx: worker process</span><br><span class="line">           └─27895 nginx: worker process</span><br><span class="line"></span><br><span class="line">Aug 18 15:33:59 ubuntu systemd[1]: Starting A high performance web server and a reverse proxy server...</span><br><span class="line">Aug 18 15:33:59 ubuntu systemd[1]: Started A high performance web server and a reverse proxy server.</span><br></pre></td></tr></table></figure><p>上面的输出结果含义如下。</p><ul><li>Loaded行：配置文件的位置，是否设为开机启动</li><li>Active行：表示正在运行</li><li>Main PID行：主进程ID</li><li>Status行：由应用本身（这里是 nginx ）提供的软件当前状态</li><li>CGroup块：应用的所有子进程</li><li>日志块：应用的日志</li></ul><h2 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h2><p>终止正在运行的服务，需要执行systemctl stop命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop nginx.service</span><br></pre></td></tr></table></figure><p>有时候，该命令可能没有响应，服务停不下来。这时候就不得不”杀进程”了，向正在运行的进程发出kill信号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl kill nginx.service</span><br></pre></td></tr></table></figure><p>此外，重启服务要执行systemctl restart命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nginx.service</span><br></pre></td></tr></table></figure><h1 id="service文件"><a href="#service文件" class="headerlink" title="service文件"></a>service文件</h1><p>一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。</p><p>第三方软件编写的配置文件主要放在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录，我们自己写的配置文件最好放在&#x2F;etc&#x2F;systemd&#x2F;system目录。</p><p>systemctl cat命令可以用来查看配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl cat sshd</span><br><span class="line"># /lib/systemd/system/ssh.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=OpenBSD Secure Shell server</span><br><span class="line">After=network.target auditd.service</span><br><span class="line">ConditionPathExists=!/etc/ssh/sshd_not_to_be_run</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/etc/default/ssh</span><br><span class="line">ExecStartPre=/usr/sbin/sshd -t</span><br><span class="line">ExecStart=/usr/sbin/sshd -D $SSHD_OPTS</span><br><span class="line">ExecReload=/usr/sbin/sshd -t</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartPreventExitStatus=255</span><br><span class="line">Type=notify</span><br><span class="line">RuntimeDirectory=sshd</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=sshd.service</span><br><span class="line"></span><br><span class="line">$ sudo systemctl cat nginx</span><br><span class="line"># /lib/systemd/system/nginx.service</span><br><span class="line"># Stop dance for nginx</span><br><span class="line"># =======================</span><br><span class="line">#</span><br><span class="line"># ExecStop sends SIGSTOP (graceful stop) to the nginx process.</span><br><span class="line"># If, after 5s (--retry QUIT/5) nginx is still running, systemd takes control</span><br><span class="line"># and sends SIGTERM (fast shutdown) to the main process.</span><br><span class="line"># After another 5s (TimeoutStopSec=5), and if nginx is alive, systemd sends</span><br><span class="line"># SIGKILL to all the remaining processes in the process group (KillMode=mixed).</span><br><span class="line">#</span><br><span class="line"># nginx signals reference doc:</span><br><span class="line"># http://nginx.org/en/docs/control.html</span><br><span class="line">#</span><br><span class="line">[Unit]</span><br><span class="line">Description=A high performance web server and a reverse proxy server</span><br><span class="line">Documentation=man:nginx(8)</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">ExecStartPre=/usr/sbin/nginx -t -q -g &#x27;daemon on; master_process on;&#x27;</span><br><span class="line">ExecStart=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27;</span><br><span class="line">ExecReload=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27; -s reload</span><br><span class="line">ExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid</span><br><span class="line">TimeoutStopSec=5</span><br><span class="line">KillMode=mixed</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>上面我们查看了sshd和nginx的配置文件，可以看到，配置文件主要分为3个区块，每个区块包含若干条键值对。</p><p>接下来我们看看这些区块的含义，这里以sshd.service为例。</p><h2 id="Unit-区块：启动顺序与依赖关系。"><a href="#Unit-区块：启动顺序与依赖关系。" class="headerlink" title="[Unit] 区块：启动顺序与依赖关系。"></a><code>[Unit]</code> 区块：启动顺序与依赖关系。</h2><p><code>[Unit]</code>部分：指定服务描述、启动顺序、依赖关系，包括 Description、Documentation、After、Before、Wants、Requires</p><h3 id="Description字段"><a href="#Description字段" class="headerlink" title="Description字段"></a>Description字段</h3><p>给出当前服务的简单描述</p><h3 id="Documentation字段"><a href="#Documentation字段" class="headerlink" title="Documentation字段"></a>Documentation字段</h3><p>指定服务的文档，可以是一个或多个文档的URL，可选，一般不用配置该项。</p><h3 id="After字段"><a href="#After字段" class="headerlink" title="After字段"></a>After字段</h3><p>接下来的设置是启动顺序和依赖关系，都比较重要。</p><p>After字段表示如果network.target或auditd.service需要启动，那么sshd.service应该在它们之后启动。可以指定多个服务，以空格隔开。</p><h3 id="Before字段"><a href="#Before字段" class="headerlink" title="Before字段"></a>Before字段</h3><p>相应地，还有一个Before字段，定义sshd.service应该在哪些服务之前启动。可以设置多个，以空格隔开，可选，根据实际需要配置。</p><p>注意，After和Before字段只涉及启动顺序，不涉及依赖关系。</p><p>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</p><h3 id="Wants字段和Requires字段"><a href="#Wants字段和Requires字段" class="headerlink" title="Wants字段和Requires字段"></a>Wants字段和Requires字段</h3><p>设置依赖关系，需要使用Wants字段和Requires字段。想要添加多个服务，可以多次使用此选项，也可以设置一个空格分隔的服务列表。</p><ol><li><p>Wants字段</p><p> 比如 <code>Wants=sshd-keygen.service</code> 就表示当前服务与sshd-keygen.service之间存在”弱依赖”关系，即如果”sshd-keygen.service”启动失败或停止运行，不影响sshd.service继续执行。</p></li><li><p>Requires字段则表示”强依赖”关系，比如 <code>Requires=sshd-keygen.service</code> ，即如果sshd-keygen.service启动失败或异常退出，那么当前服务也必须退出。</p></li></ol><p>注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p><h2 id="Service-区块：启动行为"><a href="#Service-区块：启动行为" class="headerlink" title="[Service] 区块：启动行为"></a><code>[Service]</code> 区块：启动行为</h2><p>Service区块定义如何启动当前服务。</p><h3 id="EnvironmentFile字段"><a href="#EnvironmentFile字段" class="headerlink" title="EnvironmentFile字段"></a>EnvironmentFile字段</h3><p>许多软件都有自己的环境参数文件，该文件可以用EnvironmentFile字段读取。 该文件内部的key&#x3D;value键值对，可以用$key的形式，在当前配置文件中获取。</p><h3 id="ExecStart字段"><a href="#ExecStart字段" class="headerlink" title="ExecStart字段"></a>ExecStart字段</h3><p>配置文件里面最重要的字段是ExecStart，它定义启动进程时执行的命令。</p><p>在ssh.service中，启动sshd执行的命令是<code>/usr/sbin/sshd -D $SSHD_OPTS</code>，其中的变量$SSHD_OPTS就来自EnvironmentFile字段指定的环境参数文件。</p><p>与之作用相似的，还有如下这些字段。</p><ol><li>ExecReload字段：重启服务时执行的命令。还有一个特殊的环境变量 $MAINPID 可用于表示主进程的PID，例如可以这样使用：<code>/bin/kill -HUP $MAINPID</code>。强烈建议将 <code>ExecReload=</code> 设为一个能够确保重新加载配置文件的操作同步完成的命令行。</li><li>ExecStop字段：停止服务时执行的命令</li><li>ExecStartPre字段：启动服务之前执行的命令</li><li>ExecStartPost字段：启动服务之后执行的命令</li><li>ExecStopPost字段：停止服务之后执行的命令</li></ol><p>请看下面的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=/bin/echo execstart1</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/bin/echo execstart2</span><br><span class="line">ExecStartPost=/bin/echo post1</span><br><span class="line">ExecStartPost=/bin/echo post2</span><br></pre></td></tr></table></figure><p>上面这个配置文件，第二行ExecStart设为空值，等于取消了第一行的设置，运行结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execstart2</span><br><span class="line">post1</span><br><span class="line">post2</span><br></pre></td></tr></table></figure><p>所有的启动设置之前，都可以加上一个连词号（-），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile&#x3D;-&#x2F;etc&#x2F;default&#x2F;ssh（注意等号后面的那个连词号），就表示即使&#x2F;etc&#x2F;default&#x2F;ssh文件不存在，也不会抛出错误。</p><h3 id="Type字段"><a href="#Type字段" class="headerlink" title="Type字段"></a>Type字段</h3><p>Type字段定义启动类型。它可以设置的值如下。</p><ul><li>simple（默认值）：ExecStart字段启动的进程为主进程</li><li>exec：exec与simple类似，不同之处在于，只有在该服务的主服务进程执行完成之后，systemd才会认为该服务启动完成。 其他后继单元必须一直阻塞到这个时间点之后才能继续启动。</li><li>forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程</li><li>oneshot：类似于simple，但只执行一次，只有在该服务的主服务进程退出之后，systemd才会认为该服务启动完成，才会开始启动后继单元。此种类型的服务通常需要设置RemainAfterExit&#x3D;选项。当Type&#x3D; 与 ExecStart&#x3D;都没有设置时，Type&#x3D;oneshot 就是默认值。</li><li>dbus：类似于simple，但会等待 D-Bus 信号后启动</li><li>notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li><li>idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li></ul><p>建议对长时间持续运行的服务尽可能使用Type&#x3D;simple(这是最简单和速度最快的选择)。</p><blockquote><p>注意，因为simple类型的服务无法报告启动失败，也无法在服务完成初始化后对其他单元进行排序，所以，当客户端需要通过仅由该服务本身创建的IPC通道(而非由systemd创建的套接字或D-bus之类)连接到该服务的时候，simple类型并不是最佳选择。<br>在这种情况下， notify或dbus(该服务必须提供D-Bus接口)才是最佳选择， 因为这两种类型都允许服务进程精确的安排何时算是服务启动成功、何时可以继续启动后继单元。<br>notify类型需要服务进程明确使用sd_notify()函数或类似的API，否则，可以使用forking作为替代(它支持传统的UNIX服务启动协议)。<br>最后，如果能够确保服务进程调用成功、服务进程自身不做或只做很少的初始化工作(且不大可能初始化失败)，那么exec将是最佳选择。</p><p>注意，因为使用任何 simple 之外的类型都需要等待服务完成初始化，所以可能会减慢系统启动速度。 因此，应该尽可能避免使用 simple 之外的类型(除非必须)。<br>另外，也不建议对长时间持续运行的服务使用 idle 或 oneshot 类型。</p></blockquote><p>下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>上面的配置文件，启动类型设为oneshot，就表明这个服务只要运行一次就够了，不需要长期运行。</p><p>如果关闭以后，将来某个时候还想打开，配置文件修改如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off start</span><br><span class="line">ExecStop=/usr/bin/touchpad-off stop</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>上面配置文件中，RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用systemctl stop命令停止服务，ExecStop指定的命令就会执行，从而重新开启触摸板。</p><h3 id="KillMode字段、Restart字段和RestartSec字段"><a href="#KillMode字段、Restart字段和RestartSec字段" class="headerlink" title="KillMode字段、Restart字段和RestartSec字段"></a>KillMode字段、Restart字段和RestartSec字段</h3><p>Service区块有一些字段，定义了重启行为。</p><ol><li><p>KillMode字段：定义 Systemd 如何停止 sshd 服务。</p><p> 在ssh.service定义中，将KillMode设为process，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。</p><p> KillMode字段可以设置的值如下。</p><ul><li>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</li><li>process：只杀主进程</li><li>mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li><li>none：没有进程会被杀掉，只是执行服务的 stop 命令。</li></ul></li><li><p>Restart字段：定义了 sshd 退出后，systemd 的重启方式。</p><p> 在ssh.service定义中，Restart设为on-failure，表示任何意外的失败，都将重启sshd。如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。</p><p> Restart字段可以设置的值如下。</p><ul><li>no（默认值）：退出后不会重启</li><li>on-success：只有正常退出时（退出状态码为0），才会重启</li><li>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</li><li>on-abnormal：只有被信号终止和超时，才会重启</li><li>on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li><li>on-watchdog：超时退出，才会重启</li><li>always：不管是什么退出原因，总是重启</li></ul><p> 对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal。</p></li><li><p>RestartSec字段</p></li></ol><p>最后是RestartSec字段。</p><p>RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。</p><h2 id="Install-区块"><a href="#Install-区块" class="headerlink" title="[Install] 区块"></a><code>[Install]</code> 区块</h2><p>Install区块，定义如何安装这个配置文件，即怎样做到开机启动。只有在systemctl的enable与disable命令在启用&#x2F;停用单元时才会使用此部分。</p><h3 id="WantedBy字段"><a href="#WantedBy字段" class="headerlink" title="WantedBy字段"></a>WantedBy字段</h3><p>表示该服务所在的 Target。</p><p>Target的含义是服务组，表示一组服务。WantedBy&#x3D;multi-user.target指的是 sshd 所在的 Target 是multi-user.target。</p><p>这个设置非常重要，因为执行<code>systemctl enable sshd.service</code>命令时，<code>sshd.service</code>的一个符号链接，就会放在<code>/etc/systemd/system</code>目录下面的<code>multi-user.target.wants</code>子目录之中。</p><p>Systemd 有默认的启动 Target。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl get-default</span><br><span class="line">multi-user.target</span><br></pre></td></tr></table></figure><p>上面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么systemctl enable命令能设置开机启动的原因。</p><p>使用 Target 的时候，<code>systemctl list-dependencies</code>命令和<code>systemctl isolate</code>命令也很有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看 multi-user.target 包含的所有服务</span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"># 切换到另一个 target</span><br><span class="line"># shutdown.target 就是关机状态</span><br><span class="line">$ sudo systemctl isolate shutdown.target</span><br></pre></td></tr></table></figure><p>一般来说，常用的 Target 有两个：一个是multi-user.target，表示多用户命令行状态；另一个是graphical.target，表示图形用户状态，它依赖于multi-user.target。官方文档有一张非常清晰的 Target 依赖关系图。</p><h2 id="修改配置文件后重启"><a href="#修改配置文件后重启" class="headerlink" title="修改配置文件后重启"></a>修改配置文件后重启</h2><p>修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重新加载配置文件</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 重启相关服务</span><br><span class="line">$ sudo systemctl restart foobar</span><br></pre></td></tr></table></figure><h1 id="Target-的配置文件"><a href="#Target-的配置文件" class="headerlink" title="Target 的配置文件"></a>Target 的配置文件</h1><p>Target 也有自己的配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl cat multi-user.target</span><br><span class="line"># /lib/systemd/system/multi-user.target</span><br><span class="line">#  SPDX-License-Identifier: LGPL-2.1+</span><br><span class="line">#</span><br><span class="line">#  This file is part of systemd.</span><br><span class="line">#</span><br><span class="line">#  systemd is free software; you can redistribute it and/or modify it</span><br><span class="line">#  under the terms of the GNU Lesser General Public License as published by</span><br><span class="line">#  the Free Software Foundation; either version 2.1 of the License, or</span><br><span class="line">#  (at your option) any later version.</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Multi-User System</span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line">Requires=basic.target</span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line">After=basic.target rescue.service rescue.target</span><br><span class="line">AllowIsolate=yes</span><br></pre></td></tr></table></figure><blockquote><p>注意，Target 配置文件里面没有启动命令。</p></blockquote><p>上面输出结果中，主要字段含义如下。</p><ul><li>Requires字段：要求basic.target一起运行。</li><li>Conflicts字段：冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。</li><li>After：表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。</li><li>AllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 信号介绍</title>
      <link href="/linux-signals/"/>
      <url>/linux-signals/</url>
      
        <content type="html"><![CDATA[<p>Linux中有许多处于不同状态的进程。这些进程属于用户应用程序或操作系统。我们需要一种机制让内核和这些进程协调它们的活动。其中一种方式是在一个进程有重大改变时通知其他进程，因此我们有了 <strong>信号</strong> 的概念。</p><span id="more"></span><p>Linux 信号的常见来源如图所示：<br><img src="/post/linux/signal.png" alt="signal"></p><p>信号基本上是一种单向通知。信号可以由内核发送给一个进程，或由一个进程发送给另一个进程，或者一个进程发送给它自己。</p><p>Linux信号的概念来源于Unix。在后来的Linux版本中，加入了实时（real-time）信号。信号是一种简单和轻量级的进程间通信形式，因此适用于嵌入式系统。</p><p>总共有 31 个标准信号，编号为 1-31。每个信号命名为“SIG”开头，后跟一个后缀（如INT、HUP、KILL等）。从 2.2 版开始，Linux 内核支持 33 种不同的实时信号，编号为 32-64，但应用程序应改为使用 SIGRTMIN + n 表示法。标准信号有特定用途，但 SIGUSR1 和 SIGUSR2 的使用可以由程序自定义。实时信号也可由程序定义。</p><p>Linux 信号的列表如下：</p><table><thead><tr><th>信号编号</th><th>信号名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>控制终端挂起或者断开连接</td></tr><tr><td>2</td><td>SIGINT</td><td>中断信号，通常由 Ctrl+C 发送</td></tr><tr><td>3</td><td>SIGQUIT</td><td>退出信号，通常由 Ctrl+\ 发送</td></tr><tr><td>4</td><td>SIGILL</td><td>非法指令信号</td></tr><tr><td>5</td><td>SIGTRAP</td><td>跟踪异常信号</td></tr><tr><td>6</td><td>SIGABRT</td><td>中止信号</td></tr><tr><td>7</td><td>SIGBUS</td><td>总线错误信号</td></tr><tr><td>8</td><td>SIGFPE</td><td>浮点错误信号</td></tr><tr><td>9</td><td>SIGKILL</td><td>强制退出信号（无法忽略或捕获）</td></tr><tr><td>10</td><td>SIGUSR1</td><td>用户定义信号1</td></tr><tr><td>11</td><td>SIGSEGV</td><td>段错误信号</td></tr><tr><td>12</td><td>SIGUSR2</td><td>用户定义信号2</td></tr><tr><td>13</td><td>SIGPIPE</td><td>管道破裂信号</td></tr><tr><td>14</td><td>SIGALRM</td><td>闹钟信号</td></tr><tr><td>15</td><td>SIGTERM</td><td>终止信号（无法忽略或捕获）</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>协处理器栈错误信号</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程状态改变信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>继续执行信号</td></tr><tr><td>19</td><td>SIGSTOP</td><td>暂停进程信号（无法忽略或捕获）</td></tr><tr><td>20</td><td>SIGTSTP</td><td>终端停止信号，通常由 Ctrl+Z 发送</td></tr><tr><td>21</td><td>SIGTTIN</td><td>后台进程尝试读取终端输入信号</td></tr><tr><td>22</td><td>SIGTTOU</td><td>后台进程尝试写入终端输出信号</td></tr><tr><td>23</td><td>SIGURG</td><td>套接字上的紧急数据可读信号</td></tr><tr><td>24</td><td>SIGXCPU</td><td>超时信号</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>文件大小限制超出信号</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>虚拟定时器信号</td></tr><tr><td>27</td><td>SIGPROF</td><td>分析器定时器信号</td></tr><tr><td>28</td><td>SIGWINCH</td><td>窗口大小变化信号</td></tr><tr><td>29</td><td>SIGIO</td><td>文件描述符上就绪信号</td></tr><tr><td>30</td><td>SIGPWR</td><td>电源失效信号</td></tr><tr><td>31</td><td>SIGSYS</td><td>非法系统调用信号</td></tr><tr><td>32</td><td>SIGRTMIN</td><td>实时信号最小编号</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>64</td><td>SIGRTMAX</td><td>实时信号最大编号</td></tr></tbody></table><p>0号信号，即 POSIX.1 标准中所说的null信号，一般不使用，但在 kill 函数中有个特殊的用途。使用时没有信号被发送，但可以用来（相当不可靠）检查进程是否仍然存在。</p><p>Linux中的信号实现完全符合 POSIX 标准。最新的实现应该倾向于使用 sigaction 而不是传统的信号接口。</p><p>正如硬件子系统可以中断处理器一样，信号可以中断进程的执行。因此，它们被看作是软件中断。一般来说，中断处理程序(interrupt handlers)处理硬件中断，而信号处理程序(signal handlers)则处理信号导致的中断。</p><p>通常信号被映射到特定的按键输入，比如，SIGINT代表ctrl+c，SIGSTOP代表ctrl+z，SIGQUIT代表ctrl+\。</p><h1 id="信号如何影响进程的状态？"><a href="#信号如何影响进程的状态？" class="headerlink" title="信号如何影响进程的状态？"></a>信号如何影响进程的状态？</h1><p><img src="/post/linux/signal-affect.png" alt="signal affect"></p><p>一些信号会终止正在接受信号的进程：SIGHUP、SIGINT、SIGTERM、SIGKILL。有一些信号不仅可以终止进程还会输出一些内核信息，以帮助程序员调试出错的地方，如SIGABRT（abort）、SIGBUS（bus error）、SIGILL（illegal instruction）、SIGSEGV（invalid memory reference无效内存引用）、SIGSYS（bad system call错误的系统调用） ）。用于停止进程的信号有：SIGSTOP、SIGTSTP。 SIGCONT 是恢复已停止的进程。</p><p>一个程序可以覆盖信号的默认行为。例如，一个交互式程序可以忽略SIGINT（由ctrl+c输入产生）。不过有两个例外需要注意，SIGKILL和SIGSTOP，它们不能被忽略、阻止或用这种方式覆盖。</p><p>让我们看一个父进程和其子进程的例子。假设子进程向自己发送了SIGSTOP，子进程将被停止。这反过来又会触发SIGCHLD到父进程。然后，父进程可以使用SIGCONT向子进程发出继续运行的信号。当子进程从停止状态重新运行时，另一个SIGCHLD被发送到父进程。如果后来，子进程退出了，最后的SIGCHLD会被发送到父进程。</p><h1 id="信号类似于异常-exception-吗？"><a href="#信号类似于异常-exception-吗？" class="headerlink" title="信号类似于异常(exception)吗？"></a>信号类似于异常(exception)吗？</h1><p>一些编程语言能够使用诸如try-throw-catch这样的结构进行异常处理。<br>但信号与异常并不类似。相反，失败的系统或库调用会返回非零的退出代码。当一个进程被终止时，它的退出代码是128加信号编号。例如，一个被SIGKILL杀死的进程将返回137（128+9）。</p><h1 id="信号是同步还是异步的？"><a href="#信号是同步还是异步的？" class="headerlink" title="信号是同步还是异步的？"></a>信号是同步还是异步的？</h1><p>信号既可以是同步，也可以是异步。</p><p>同步信号的出现是由于指令导致了一个无法恢复的错误，如非法地址访问。这些信号被发送到导致它的线程。这些信号也被称为陷阱(trap)，因为它们也会导致陷阱进入内核的陷阱处理程序(trap handler)。</p><p>异步信号是对当前执行环境的外部信号。从另一个进程中发送 SIGKILL 就是这样一个例子。这些也被称为软件中断。</p><h1 id="信号的生命周期是什么？"><a href="#信号的生命周期是什么？" class="headerlink" title="信号的生命周期是什么？"></a>信号的生命周期是什么？</h1><p><img src="/post/linux/signal-life-cycle.png" alt="signal life cycle"></p><p>一个信号经历三个阶段：</p><ul><li>Generation（生成）：信号可以由内核或任何进程生成，生成后会将其发送给特定的进程。信号由其编号表示，没有额外的数据或参数。因此，信号是轻量级的。但是，POSIX 实时信号传递额外的数据。可以生成信号的系统调用和函数包括 raise、kill、killpg、pthread_kill、tgkill 和 sigqueue。</li><li>Delivery（传递）：信号在传递之前一直处于待处理状态。通常，内核会尽快将信号传递给进程。但是，如果对应的进程阻塞了信号，它将保持未处理状态直到解除阻塞。</li><li>Processing（处理）：一旦信号被传递到，就会以多种方式中其中一种进行处理。每个信号都有一个默认的行为：忽略信号；或终止进程，有时使用核心转储(core dump)；或停止&#x2F;继续该过程。对于非默认行为，对应的处理函数会被调用。通过 sigaction 函数指定究竟采用哪一种处理方式。</li></ul><h1 id="什么是信号阻塞和解除阻塞？"><a href="#什么是信号阻塞和解除阻塞？" class="headerlink" title="什么是信号阻塞和解除阻塞？"></a>什么是信号阻塞和解除阻塞？</h1><p><img src="/post/linux/signal-block.gif" alt="signal block"></p><p>信号打断了程序执行的正常流程。当进程正在执行一些关键代码或更新与信号处理程序共享的数据时，这是不希望看到的。阻断的引入解决了这个问题。不过代价是，信号处理被延迟了。</p><p>每个进程都可以指定它是否要阻塞一个特定的信号。如果被阻断，而信号确实发生了，操作系统将把该信号作为待处理信号。一旦进程解除阻断，该信号将被传递。当前被屏蔽的信号集合被称为信号屏蔽(signal mask)。</p><p>无限期地阻断一个信号是没有意义的。为了这个目的，进程可以在接受到信号后选择忽略它，被一个进程屏蔽的信号不会影响其他进程，他们可以正常接收信号。</p><p>信号屏蔽(Signal mask)可以用 sigprocmask（单线程）或 pthread_sigmask（多线程）来设置。 当一个进程有多个线程时，信号可以针对每个线程分别设置是否屏蔽。信号将被传递给任何一个没有阻断它的线程。从本质上讲，信号处理程序是针对某个进程的，信号掩码是针对某个线程的。</p><h1 id="一个进程可以有多个待处理的信号吗？"><a href="#一个进程可以有多个待处理的信号吗？" class="headerlink" title="一个进程可以有多个待处理的信号吗？"></a>一个进程可以有多个待处理的信号吗？</h1><p>是的，许多标准信号可以在进程中被挂起。然而，一个给定的信号类型只能有一个实例被挂起。这是因为信号的挂起和阻塞是作为位掩码(bitmask)实现的，每个信号类型只有一个位。例如，我们可以让 SIGALRM 和 SIGTERM 同时挂起，但我们不能有两个 SIGALRM<br>信号挂起。进程将只收到一个SIGALRM信号，即使是多次抛出。</p><p>通过实时信号，信号可以和数据一起排队，这样每个信号的实例都可以单独传递和处理。</p><p>POSIX没有规定标准信号的传递顺序，也没有规定如果标准信号和实时信号都在等待中会如何处理。然而在Linux中，会优先处理标准信号。对于实时信号，编号较低的信号首先被传递，如果一个信号类型有很多在排队，最早的一个会被首先传递。</p><h1 id="信号历史发展"><a href="#信号历史发展" class="headerlink" title="信号历史发展"></a>信号历史发展</h1><ol><li>1990 信号在 POSIX.1-1990 标准中得到了描述。可以追溯至 IEEE标准1003.1-1988。</li><li>1993 实时扩展作为 POSIX.1b 发布。其中包含实时信号。</li><li>1999 随着内核版本 2.2 的发布，Linux 开始支持实时信号。</li><li>2001 POSIX.1-2001 标准中增加了更多信号：SIGBUS、SIGPOLL、SIGPROF、SIGSYS、SIGTRAP、SIGURG、SIGVTALRM、SIGXCPU、SIGXFSZ。<br>  <img src="/post/linux/list-linux-signals.png" alt="list linux signals"></li></ol><h1 id="简单-C-语言信号处理程序"><a href="#简单-C-语言信号处理程序" class="headerlink" title="简单 C 语言信号处理程序"></a>简单 C 语言信号处理程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example shows a custom handler for SIGINT</span></span><br><span class="line"><span class="comment">// but the handler reverts to default action for future signals.</span></span><br><span class="line"><span class="comment">// Thus, first ctrl+c will allow program to continue </span></span><br><span class="line"><span class="comment">// and second ctrl+c will terminate the program.</span></span><br><span class="line"><span class="comment">// 以下示例展示了对SIGINT信号的自定义处理程序</span></span><br><span class="line"><span class="comment">// 但是，处理程序会恢复为将来信号的默认操作。</span></span><br><span class="line"><span class="comment">// 因此，第一次按下Ctrl+C将允许程序继续执行</span></span><br><span class="line"><span class="comment">// 而第二次按下Ctrl+C将终止程序。</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler1</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You are here becoz of signal: %d\n&quot;</span>, num);</span><br><span class="line">signal(SIGINT, SIG_DFL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">signal(SIGINT, sig_handler1);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 学习笔记总目录</title>
      <link href="/k8s-learning/"/>
      <url>/k8s-learning/</url>
      
        <content type="html"><![CDATA[<p>这里总结了一些k8s的学习笔记，主要是从docker开始，到k8s的一些基础知识，以及k8s的一些基础组件的介绍，以及k8s的一些基础资源的使用。</p><span id="more"></span><h2 id="一、-认识docker"><a href="#一、-认识docker" class="headerlink" title="一、 认识docker"></a>一、 认识docker</h2><h3 id="1-docker介绍"><a href="#1-docker介绍" class="headerlink" title="1. docker介绍"></a>1. <a href="https://realtiger.github.io/docker-introduction/">docker介绍</a></h3><h3 id="2-docker-file"><a href="#2-docker-file" class="headerlink" title="2. docker file"></a>2. <a href="https://realtiger.github.io/docker-file/">docker file</a></h3><h3 id="3-docker运行原理"><a href="#3-docker运行原理" class="headerlink" title="3. docker运行原理"></a>3. <a href="https://realtiger.github.io/docker-service-running-principle/">docker运行原理</a></h3><h3 id="4-docker网络"><a href="#4-docker网络" class="headerlink" title="4. docker网络"></a>4. <a href="https://realtiger.github.io/docker-network/">docker网络</a></h3><h3 id="5-containerd介绍与docker总结"><a href="#5-containerd介绍与docker总结" class="headerlink" title="5. containerd介绍与docker总结"></a>5. <a href="https://realtiger.github.io/containerd-introduction/">containerd介绍与docker总结</a></h3><ul><li>containerd</li><li>containerd操作 (ctr&#x2F;nerdctl&#x2F;crictl)</li></ul><h2 id="二、-认识k8s"><a href="#二、-认识k8s" class="headerlink" title="二、 认识k8s"></a>二、 认识k8s</h2><h3 id="1-k8s-介绍"><a href="#1-k8s-介绍" class="headerlink" title="1. k8s 介绍"></a>1. <a href="https://realtiger.github.io/k8s-introduction/">k8s 介绍</a></h3><h3 id="2-pod-常用设置和配置"><a href="#2-pod-常用设置和配置" class="headerlink" title="2. pod 常用设置和配置"></a>2. <a href="https://realtiger.github.io/pod-settings-and-config/">pod 常用设置和配置</a></h3><ul><li>Pod 数据持久化</li><li>服务健康检查(ReadinessProbe, LivenessProbe, StartupProbe)</li><li>重启策略</li><li>镜像拉取策略</li><li>Pod 资源限制</li><li>ConfigMap 和 Secret</li><li>Pod 状态与生命周期</li></ul><h3 id="3-k8s-deployment"><a href="#3-k8s-deployment" class="headerlink" title="3. k8s deployment"></a>3. <a href="https://realtiger.github.io/k8s-deployment/">k8s deployment</a></h3><ul><li>deployment</li><li>副本保障</li><li>驱逐策略</li><li>更新策略</li><li>服务回滚</li></ul><h3 id="4-k8s-service"><a href="#4-k8s-service" class="headerlink" title="4. k8s service"></a>4. <a href="https://realtiger.github.io/k8s-service/">k8s service</a></h3><ul><li>Service</li><li>ClusterIP</li><li>NodePort</li><li>kube-proxy (iptables, ipvs)</li></ul><h3 id="5-k8s-服务发现和负载均衡"><a href="#5-k8s-服务发现和负载均衡" class="headerlink" title="5. k8s 服务发现和负载均衡"></a>5. <a href="https://realtiger.github.io/k8s-service-discovery-and-load-balance/">k8s 服务发现和负载均衡</a></h3><ul><li>CoreDNS</li><li>ingress</li></ul><h2 id="三、-k8s组件或原理"><a href="#三、-k8s组件或原理" class="headerlink" title="三、 k8s组件或原理"></a>三、 k8s组件或原理</h2><h3 id="1-k8s-etcd"><a href="#1-k8s-etcd" class="headerlink" title="1. k8s etcd"></a>1. <a href="https://realtiger.github.io/k8s-etcd/">k8s etcd</a></h3><ul><li>etcd 命令行工具</li><li>常用操作</li></ul><h3 id="2-k8s-调度"><a href="#2-k8s-调度" class="headerlink" title="2. k8s 调度"></a>2. <a href="https://realtiger.github.io/k8s-scheduler/">k8s 调度</a></h3><ul><li>NodeSelector</li><li>NodeAffinity</li><li>PodAffinity</li><li>Taints and Tolerations</li><li>Cordon and Drain</li></ul><h3 id="3-k8s-认证和授权"><a href="#3-k8s-认证和授权" class="headerlink" title="3. k8s 认证和授权"></a>3. <a href="https://realtiger.github.io/k8s-auth/">k8s 认证和授权</a></h3><ul><li>APIServer安全控制</li><li>kubectl的认证授权</li><li>RBAC</li><li>kubelet的认证授权</li><li>创建用户认证授权的 kubeconfig 文件</li></ul><h3 id="4-k8s-动态扩缩容"><a href="#4-k8s-动态扩缩容" class="headerlink" title="4. k8s 动态扩缩容"></a>4. <a href="https://realtiger.github.io/k8s-hpa/">k8s 动态扩缩容</a></h3><ul><li>Metrics Server</li><li>Horizontal Pod Autoscaler</li><li>实现原理</li></ul><h3 id="5-k8s-持久卷"><a href="#5-k8s-持久卷" class="headerlink" title="5. k8s 持久卷"></a>5. <a href="https://realtiger.github.io/k8s-persistent-volume/">k8s 持久卷</a></h3><ul><li>持久卷方式</li><li>PV</li><li>PVC</li><li>StorageClass</li></ul><h3 id="6-k8s-容器网络接口"><a href="#6-k8s-容器网络接口" class="headerlink" title="6. k8s 容器网络接口"></a>6. <a href="https://realtiger.github.io/k8s-cni/">k8s 容器网络接口</a></h3><ul><li>IP唯一性</li><li>POD配置网络流程</li><li>kube-flannel</li><li>跨主机通信</li></ul><h3 id="7-k8s-helm"><a href="#7-k8s-helm" class="headerlink" title="7. k8s helm"></a>7. <a href="https://realtiger.github.io/k8s-helm/">k8s helm</a></h3><ul><li>helm</li><li>helm chart</li><li>helm 部署 harbor 仓库</li><li>helm 部署 Ingress Controller</li></ul><h2 id="四、-prometheus监控"><a href="#四、-prometheus监控" class="headerlink" title="四、 prometheus监控"></a>四、 prometheus监控</h2><h3 id="1-k8s-prometheus监控"><a href="#1-k8s-prometheus监控" class="headerlink" title="1. k8s prometheus监控"></a>1. <a href="https://realtiger.github.io/k8s-prometheus-introduction-install/">k8s prometheus监控</a></h3><ul><li>prometheus</li><li>prometheus-operator</li><li>prometheus-adapter</li><li>grafana</li></ul><h3 id="2-k8s-prometheus-添加监控目标"><a href="#2-k8s-prometheus-添加监控目标" class="headerlink" title="2. k8s prometheus 添加监控目标"></a>2. <a href="https://realtiger.github.io/k8s-prometheus-add-targets/">k8s prometheus 添加监控目标</a></h3><ul><li>添加coreDNS监控<ul><li>static_configs</li></ul></li><li>监控api-server等系统组件<ul><li>scheme</li><li>tls_config</li><li>bearer_token</li></ul></li><li>监控宿主机指标<ul><li>node-exporter</li><li>kubernetes_sd_configs</li><li>relabeling</li><li>cadvisor</li></ul></li><li>集群Service服务的监控指标采集</li><li>kube-state-metrics监控<ul><li>relabeling的keep功能</li></ul></li></ul><h3 id="3-k8s-prometheus-展示与告警"><a href="#3-k8s-prometheus-展示与告警" class="headerlink" title="3. k8s prometheus 展示与告警"></a>3. <a href="https://realtiger.github.io/k8s-prometheus-grafana/">k8s prometheus 展示与告警</a></h3><ul><li>grafana</li><li>alertmanager</li><li>prometheus-adapter</li></ul><h2 id="DEVOPS平台"><a href="#DEVOPS平台" class="headerlink" title="DEVOPS平台"></a>DEVOPS平台</h2><h3 id="1-jenkins-初体验"><a href="#1-jenkins-初体验" class="headerlink" title="1. jenkins 初体验"></a>1. <a href="https://realtiger.github.io/k8s-devops-jenkins/">jenkins 初体验</a></h3><ul><li>jenkins</li><li>gogs</li><li>coredns添加域名解析</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s 介绍</title>
      <link href="/k8s-introduction/"/>
      <url>/k8s-introduction/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>接下来学习kubernetes的架构及工作流程，重点介绍如何使用Workload管理业务应用的生命周期，实现服务不中断的滚动更新，通过服务发现和集群内负载均衡来实现集群内部的服务间访问，并通过ingress实现外部使用域名访问集群内部的服务。</p><span id="more"></span><h1 id="k8s-介绍"><a href="#k8s-介绍" class="headerlink" title="k8s 介绍"></a>k8s 介绍</h1><ol><li><p>纯容器模式的问题</p><ol><li>业务容器数量庞大，哪些容器部署在哪些节点，使用了哪些端口，如何记录、管理，需要登录到每台机器去管理？</li><li>跨主机通信，多个机器中的容器之间相互调用如何做，iptables规则手动维护？</li><li>跨主机容器间互相调用，配置如何写？写死固定IP+端口？</li><li>如何实现业务高可用？多个容器对外提供服务如何实现负载均衡？</li><li>容器的业务中断了，如何可以感知到，感知到以后，如何自动启动新的容器?</li><li>如何实现滚动升级保证业务的连续性？</li><li>……</li></ol></li><li><p>容器调度管理平台</p><ul><li>Docker Swarm</li><li>Mesos</li><li>Google Kubernetes</li></ul><p>2017年开始Kubernetes凭借强大的容器集群管理功能, 逐步占据市场,目前在容器编排领域一枝独秀 <a href="https://kubernetes.io/">https://kubernetes.io/</a></p></li></ol><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>如何设计一个容器管理平台？需要满足以下几个需求：</p><ul><li>集群架构，管理节点分发容器到数据节点</li><li>如何部署业务容器到各数据节点</li><li>N个数据节点，业务容器如何选择部署在最合理的节点</li><li>容器如何实现多副本，如何满足每个机器部署一个容器的模型</li><li>多副本如何实现集群内负载均衡</li></ul><p>分布式系统，一般包含两类角色：管理节点和工作节点</p><p><img src="/post/docker/architecture.png" alt="architecture"></p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>k8s核心主要包括以下几个组件：</p><ul><li>ETCD：分布式高性能键值数据库,存储整个集群的所有元数据</li><li>ApiServer:  API服务器,集群资源访问控制入口,提供restAPI及安全访问控制</li><li>Scheduler：调度器,负责把业务容器调度到最合适的Node节点</li><li>Controller Manager：控制器管理,确保集群资源按照期望的方式运行<ul><li>Replication Controller</li><li>Node controller</li><li>ResourceQuota Controller</li><li>Namespace Controller</li><li>ServiceAccount Controller</li><li>Token Controller</li><li>Service Controller</li><li>Endpoints Controller</li><li>……</li></ul></li><li>kubelet：运行在每个节点上的主要的“节点代理”，主要干脏活累活<ul><li>pod 管理：kubelet 定期从所监听的数据源获取节点上 pod&#x2F;container<br>的期望状态（运行什么容器、运行的副本数量、网络或者存储如何配置等等），并调用对应的容器平台接口达到这个状态。</li><li>容器健康检查：kubelet 创建了容器之后还要查看容器是否正常运行，如果容器运行出错，就要根据 pod 设置的重启策略进行处理.</li><li>容器监控：kubelet 会监控所在节点的资源使用情况，并定时向 master 报告，资源使用数据都是通过 cAdvisor<br>获取的。知道整个集群所有节点的资源情况，对于 pod 的调度和正常运行至关重要</li></ul></li><li>kube-proxy：维护节点中的iptables或者ipvs规则</li><li>kubectl: 命令行接口，用于对 Kubernetes 集群运行命令  <a href="https://kubernetes.io/zh/docs/reference/kubectl/">https://kubernetes.io/zh/docs/reference/kubectl/</a></li></ul><p>根据k8s部署的方式不同，组件的运行方式也是不同的。</p><ol><li>如果是通过kubeadmin方式部署的，组件运行方式是以静态Pod的方式运行的，静态Pod是通过kubelet启动的，kubelet会定期检查&#x2F;etc&#x2F;kubernetes&#x2F;manifests目录下的yaml文件，如果有新的yaml文件，kubelet会启动一个Pod，如果yaml文件被删除，kubelet会删除对应的Pod。</li></ol> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## etcd、apiserver、controller-manager、kube-scheduler</span></span><br><span class="line"><span class="comment"># kubectl 是一个二进制的命令行工具，用于与 Kubernetes 集群进行通信。kubectl 通过 RESTful API 与 Kubernetes API Server 交互，从而管理集群。</span></span><br><span class="line"><span class="comment"># k8s 安装完成后，kubectl 会被主动安装到 /usr/local/bin 目录下，可以直接使用。</span></span><br><span class="line">$ kubectl -n kube-system get po</span><br></pre></td></tr></table></figure><ol start="2"><li><p>如果是二进制方式部署的，组件运行方式通常是以systemd服务的方式运行的，systemd服务的配置文件在&#x2F;etc&#x2F;systemd&#x2F;system目录下，可以通过systemctl命令查看服务的运行状态。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## etcd、apiserver、controller-manager、kube-scheduler</span></span><br><span class="line">$ systemctl status etcd</span><br><span class="line">$ systemctl status kube-apiserver</span><br><span class="line">$ systemctl status kube-controller-manager</span><br><span class="line">$ systemctl status kube-scheduler</span><br><span class="line">$ systemctl status kubelet</span><br></pre></td></tr></table></figure></li></ol><h2 id="集群资源"><a href="#集群资源" class="headerlink" title="集群资源"></a>集群资源</h2><p>组件是为了支撑k8s平台的运行，安装好的软件。资源是如何去使用k8s的能力的定义。</p><p>比如，k8s可以使用Pod来管理业务应用，那么Pod就是k8s集群中的一类资源，集群中的所有资源可以提供如下方式查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl api-resources</span><br></pre></td></tr></table></figure><p>namespace 也是 k8s 的一类资源，那么该如何理解 namespace 呢？</p><p>namespace 就是 k8s 的命名空间，是集群内一个虚拟的概念，类似于资源池的概念，一个池子里可以有各种资源类型，绝大多数的资源都必须属于某一个 namespace 。集群初始化安装好之后，会默认有如下几个 namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get namespaces</span><br><span class="line">NAME                   STATUS   AGE</span><br><span class="line">default                Active   84m</span><br><span class="line">kube-node-lease        Active   84m</span><br><span class="line">kube-public            Active   84m</span><br><span class="line">kube-system            Active   84m</span><br><span class="line">kubernetes-dashboard   Active   71m</span><br></pre></td></tr></table></figure><ul><li>所有 NAMESPACED 的资源，在创建的时候都需要指定 namespace ，若不指定，默认会在 default 命名空间下</li><li>相同 namespace 下的同类资源不可以重名，不同类型的资源可以重名</li><li>不同 namespace 下的同类资源可以重名</li><li>通常在项目使用的时候，我们会创建带有业务含义的 namespace 来做逻辑上的整合</li></ul><h2 id="kubectl的使用"><a href="#kubectl的使用" class="headerlink" title="kubectl的使用"></a>kubectl的使用</h2><p>类似于docker，kubectl是命令行工具，用于与APIServer交互，内置了丰富的子命令，功能极其强大。 <a href="https://kubernetes.io/docs/reference/kubectl/overview/">https://kubernetes.io/docs/reference/kubectl/overview/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -h</span><br><span class="line">$ kubectl get -h</span><br><span class="line">$ kubectl create -h</span><br><span class="line">$ kubectl create namespace -h</span><br></pre></td></tr></table></figure><h1 id="最小调度单元-Pod"><a href="#最小调度单元-Pod" class="headerlink" title="最小调度单元 Pod"></a>最小调度单元 Pod</h1><p>docker调度的是容器，在k8s集群中，最小的调度单元是Pod（豆荚）</p><p><img src="/post/docker/pod-demo.png" alt="pod-demo"></p><h2 id="为什么引入Pod"><a href="#为什么引入Pod" class="headerlink" title="为什么引入Pod"></a>为什么引入Pod</h2><ul><li>与容器引擎解耦。平台设计与引擎的具体的实现解耦。</li><li>多容器共享网络|存储|进程 空间, 支持的业务场景更加灵活。</li></ul><h2 id="pod-定义"><a href="#pod-定义" class="headerlink" title="pod 定义"></a>pod 定义</h2><h3 id="使用yaml格式定义Pod"><a href="#使用yaml格式定义Pod" class="headerlink" title="使用yaml格式定义Pod"></a>使用yaml格式定义Pod</h3><p>k8s中定义pod的方式一种是通过yaml文件。</p><p>下面是一个 mariadb 数据库的 yaml 文档的示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">blog</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">blog</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">harbor.mydomain.com/test/blog:v1</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_HOST</span>   <span class="comment">#  指定root用户的用户名</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_PASSWD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8002</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_DATABASE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;blog&quot;</span></span><br></pre></td></tr></table></figure><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>k8s创建的 pod 等都成为一种资源，资源有对应的种类和版本信息。</p><table><thead><tr><th align="left">apiVersion</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">alpha</td><td align="left">进入K8s功能的早期候选版本，可能包含Bug，最终不一定进入K8s</td></tr><tr><td align="left">beta</td><td align="left">已经过测试的版本，最终会进入K8s，但功能、对象定义可能会发生变更。</td></tr><tr><td align="left">stable</td><td align="left">可安全使用的稳定版本</td></tr><tr><td align="left">v1</td><td align="left">stable 版本之后的首个版本，包含了更多的核心对象</td></tr><tr><td align="left">apps&#x2F;v1</td><td align="left">使用最广泛的版本，像Deployment、ReplicaSets都已进入该版本</td></tr></tbody></table><p>资源类型与apiVersion对照表</p><table><thead><tr><th align="left">Kind</th><th align="left">apiVersion</th></tr></thead><tbody><tr><td align="left">ClusterRoleBinding</td><td align="left">rbac.authorization.k8s.io&#x2F;v1</td></tr><tr><td align="left">ClusterRole</td><td align="left">rbac.authorization.k8s.io&#x2F;v1</td></tr><tr><td align="left">ConfigMap</td><td align="left">v1</td></tr><tr><td align="left">CronJob</td><td align="left">batch&#x2F;v1beta1</td></tr><tr><td align="left">DaemonSet</td><td align="left">extensions&#x2F;v1beta1</td></tr><tr><td align="left">Node</td><td align="left">v1</td></tr><tr><td align="left">Namespace</td><td align="left">v1</td></tr><tr><td align="left">Secret</td><td align="left">v1</td></tr><tr><td align="left">PersistentVolume</td><td align="left">v1</td></tr><tr><td align="left">PersistentVolumeClaim</td><td align="left">v1</td></tr><tr><td align="left">Pod</td><td align="left">v1</td></tr><tr><td align="left">Deployment</td><td align="left">v1、apps&#x2F;v1、apps&#x2F;v1beta1、apps&#x2F;v1beta2</td></tr><tr><td align="left">Service</td><td align="left">v1</td></tr><tr><td align="left">Ingress</td><td align="left">extensions&#x2F;v1beta1</td></tr><tr><td align="left">ReplicaSet</td><td align="left">apps&#x2F;v1、apps&#x2F;v1beta2</td></tr><tr><td align="left">Job</td><td align="left">batch&#x2F;v1</td></tr><tr><td align="left">StatefulSet</td><td align="left">apps&#x2F;v1、apps&#x2F;v1beta1、apps&#x2F;v1beta2</td></tr></tbody></table><p>快速获得资源和版本可以在终端通过命令行获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl explain pod</span><br><span class="line">$ kubectl explain Pod.apiVersion</span><br></pre></td></tr></table></figure><h2 id="pod对外暴露服务"><a href="#pod对外暴露服务" class="headerlink" title="pod对外暴露服务"></a>pod对外暴露服务</h2><h3 id="创建和访问Pod"><a href="#创建和访问Pod" class="headerlink" title="创建和访问Pod"></a>创建和访问Pod</h3><p>我们创建pod的最终目的是为了访问pod中的服务，所以我们需要将pod中的服务暴露出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建namespace, namespace是逻辑上的资源池</span></span><br><span class="line">$ kubectl create namespace <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用指定文件创建Pod</span></span><br><span class="line">$ kubectl create -f pod.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看pod，可以简写po</span></span><br><span class="line"><span class="comment">## 所有的操作都需要指定namespace，如果是在default命名空间下，则可以省略</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get pods -o wide</span><br><span class="line">NAME     READY   STATUS    RESTARTS   AGE    IP             NODE</span><br><span class="line">blog   2/2     Running   0          3m     10.244.1.146   k8s-slave1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 回顾流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用 Pod Ip 访问服务 3306 和 8002，此时因为是新启动的环境，所以还无法正常访问</span></span><br><span class="line">$ curl 10.244.1.120:8002/blog/index/</span><br><span class="line"></span><br><span class="line"><span class="comment">## 进入容器,执行初始化, 不必到对应的主机执行 docker exec</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c mysql bash</span><br><span class="line">/ <span class="comment"># mysql -p123456</span></span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c blog bash</span><br><span class="line">/ <span class="comment"># env</span></span><br><span class="line">/ <span class="comment"># python3 manage.py migrate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 再次访问服务 3306 和 8002</span></span><br><span class="line">$ curl 10.244.1.120:8002/blog/index/</span><br></pre></td></tr></table></figure><h2 id="Infra容器"><a href="#Infra容器" class="headerlink" title="Infra容器"></a>Infra容器</h2><p>登录<code>k8s-slave1</code>节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a | grep blog  <span class="comment">## 发现有三个容器</span></span><br><span class="line"><span class="comment">## 其中包含 mysql 和 blog 程序以及 Infra 容器</span></span><br><span class="line"><span class="comment">## 为了实现 Pod 内部的容器可以通过 localhost 通信，每个 Pod 都会启动 Infra 容器，然后 Pod 内部的其他容器的网络空间会共享该 Infra 容器的网络空间(Docker网络的container模式)， Infra 容器只需要 hang 住网络空间，不需要额外的功能，因此资源消耗极低。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 登录 master 节点，查看 pod 内部的容器 ip 均相同，为 pod ip</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c blog bash</span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c mysql bash</span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br></pre></td></tr></table></figure><h2 id="pod-操作"><a href="#pod-操作" class="headerlink" title="pod 操作"></a>pod 操作</h2><p>k8s 中 pod 容器的命名有一套固定的规则：<code>k8s_&lt;container_name&gt;_&lt;pod_name&gt;_&lt;namespace&gt;_&lt;random_string&gt;</code></p><h3 id="查看pod详细信息"><a href="#查看pod详细信息" class="headerlink" title="查看pod详细信息"></a>查看pod详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看 pod 调度节点及 pod_ip</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get pods -o wide</span><br><span class="line"><span class="comment">## 查看完整的 yaml</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get po blog -o yaml</span><br><span class="line"><span class="comment">## 查看 pod 的明细信息及事件</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> describe pod blog</span><br></pre></td></tr></table></figure><h3 id="Troubleshooting-and-Debugging"><a href="#Troubleshooting-and-Debugging" class="headerlink" title="Troubleshooting and Debugging"></a>Troubleshooting and Debugging</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入Pod内的容器</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; <span class="built_in">exec</span> &lt;pod_name&gt; -c &lt;container_name&gt; -it /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pod内容器日志,显示标准或者错误输出日志</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; logs -f &lt;pod_name&gt; -c &lt;container_name&gt;</span><br></pre></td></tr></table></figure><h3 id="更新服务版本"><a href="#更新服务版本" class="headerlink" title="更新服务版本"></a>更新服务版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f demo-pod.yaml</span><br></pre></td></tr></table></figure><h3 id="删除Pod服务"><a href="#删除Pod服务" class="headerlink" title="删除Pod服务"></a>删除Pod服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据文件删除</span></span><br><span class="line">$ kubectl delete -f demo-pod.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据 pod_name 删除</span></span><br><span class="line">$ kubectl -n &lt;namespace&gt; delete pod &lt;pod_name&gt;</span><br></pre></td></tr></table></figure><h2 id="Pod-启动多容器"><a href="#Pod-启动多容器" class="headerlink" title="Pod 启动多容器"></a>Pod 启动多容器</h2><p>这里我们使用一个 pod 启动两个容器，并且将镜像仓库设置为私有，需要登录才能拉取镜像，我们使用 secret 来管理镜像仓库的登录信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建 secret</span></span><br><span class="line"><span class="comment">## 注意：这种方式创建的 secret 只能在当前 namespace 下使用，跨 namespace 无法使用</span></span><br><span class="line">$ kubectl create secret docker-registry harbor-registry --docker-server=harbor.mydomain.com:10443 --docker-username=admin --docker-password=Harbor12345 --docker-email=admin@mydomain.com</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看 secret</span></span><br><span class="line">$ kubectl get secret harbor-registry -o yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 编写多个 pod 的 yaml 文件</span></span><br><span class="line">$ <span class="built_in">cat</span> &gt; pods.yaml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Pod</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: blog</span></span><br><span class="line"><span class="string">  namespace: test</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    component: blog</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  containers:</span></span><br><span class="line"><span class="string">    - name: blog-api</span></span><br><span class="line"><span class="string">      image: harbor.mydomain.com:10443/test/blog-backend:v1</span></span><br><span class="line"><span class="string">      env:</span></span><br><span class="line"><span class="string">          - name: DB_HOST</span></span><br><span class="line"><span class="string">            value: &quot;my-mysql&quot;</span></span><br><span class="line"><span class="string">          - name: DB_USER</span></span><br><span class="line"><span class="string">            value: &quot;root&quot;</span></span><br><span class="line"><span class="string">          - name: DB_PASSWD</span></span><br><span class="line"><span class="string">            value: &quot;123456&quot;</span></span><br><span class="line"><span class="string">      ports:</span></span><br><span class="line"><span class="string">          - containerPort: 8000   </span></span><br><span class="line"><span class="string">    - name: blog-web</span></span><br><span class="line"><span class="string">        image: harbor.mydomain.com:10443/test/blog-frontend:v1</span></span><br><span class="line"><span class="string">        ports:</span></span><br><span class="line"><span class="string">            - containerPort: 80</span></span><br><span class="line"><span class="string">  imagePullSecrets:   </span></span><br><span class="line"><span class="string">    - name: harbor-registry</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建 pod</span></span><br><span class="line">$ kubectl create -f pods.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看 pod</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> get pods -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment">## 访问服务</span></span><br><span class="line">$ curl http://&lt;pod_ip&gt;:80</span><br><span class="line"></span><br><span class="line"><span class="comment">## 进入指定容器需要添加 -c 参数指定容器名称，如果不指定，默认进入第一个容器</span></span><br><span class="line">$ kubectl -n <span class="built_in">test</span> <span class="built_in">exec</span> -it blog -c blog-web -- bash</span><br></pre></td></tr></table></figure><h1 id="k8s-工作流程"><a href="#k8s-工作流程" class="headerlink" title="k8s 工作流程"></a>k8s 工作流程</h1><h2 id="流程图与过程描述"><a href="#流程图与过程描述" class="headerlink" title="流程图与过程描述"></a>流程图与过程描述</h2><p><img src="/post/docker/process.png" alt="process"></p><ol><li>用户准备一个资源文件（记录了业务应用的名称、镜像地址等信息），通过调用APIServer执行创建Pod</li><li>APIServer收到用户的Pod创建请求，将Pod信息写入到etcd中</li><li>调度器通过list-watch的方式，发现有新的pod数据，但是这个pod还没有绑定到某一个节点中</li><li>调度器通过调度算法，计算出最适合该pod运行的节点，并调用APIServer，把信息更新到etcd中</li><li>kubelet同样通过list-watch方式，发现有新的pod调度到本机的节点了，因此调用容器运行时，去根据pod的描述信息，拉取镜像，启动容器，同时生成事件信息</li><li>同时，把容器的信息、事件及状态也通过APIServer写入到etcd中</li></ol><h2 id="架构设计的思考"><a href="#架构设计的思考" class="headerlink" title="架构设计的思考"></a>架构设计的思考</h2><ol><li>系统各个组件分工明确(APIServer是所有请求入口，CM是控制中枢，Scheduler主管调度，而Kubelet负责运行)，配合流畅，整个运行机制一气呵成。</li><li>除了配置管理和持久化组件ETCD，其他组件并不保存数据。意味 <strong>除ETCD外</strong> 其他组件都是无状态的。因此从架构设计上对kubernetes系统高可用部署提供了支撑。</li><li>同时因为组件无状态，组件的升级，重启，故障等并不影响集群最终状态，只要组件恢复后就可以从中断处继续运行。</li><li>各个组件和kube-apiserver之间的数据推送都是通过list-watch机制来实现。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>containerd 介绍 与 docker 总结</title>
      <link href="/containerd-introduction/"/>
      <url>/containerd-introduction/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>本节主要介绍containerd的基本概念，以及docker的一些总结。</p><span id="more"></span><h1 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h1><p>容器运行时（ContainerRuntime），运行于 kubernetes（k8s）集群的每个节点中，负责容器的整个生命周期，其中 docker 是目前应用最广的。</p><p>随着容器云的发展，越来越多的容器运行时涌现。为了解决这些容器运行时和 k8s 的集成问题，在 k8s 1.5 版本中，社区推出了<br>CRI（ContainerRuntimeInterface,容器运行时接口），以支持更多的容器运行时。</p><p>Kubelet 通过 CRI 和容器运行时进行通信，使得容器运行时能够像插件一样单独运行。可以说每个容器运行时都有自己的优势，这就允许用户更容易选择和替换自己的容器运行时。</p><p><img src="/post/docker/cri-k8s.drawio.svg" alt="cri-k8s"></p><h2 id="CRI-amp-OCI"><a href="#CRI-amp-OCI" class="headerlink" title="CRI &amp; OCI"></a>CRI &amp; OCI</h2><p>OCI（OpenContainerInitiative，开放容器计划）定义了创建容器的格式和运行时的开源行业标准，包括镜像规范（ImageSpecification）和运行时规范(<br>RuntimeSpecification)。</p><p>镜像规范定义了 OCI 镜像的标准。高层级运行时将会下载一个 OCI 镜像，并把它解压成 OCI 运行时文件系统包（filesystembundle）。</p><p><img src="/post/docker/oci+cri.drawio.svg" alt="oci+cri"></p><p>运行时规范则描述了如何从 OCI 运行时文件系统包运行容器程序，并且定义它的配置、运行环境和生命周期。如何为新容器设置命名空间(<br>namepsaces)和控制组(cgroups)，以及挂载根文件系统等等操作，都是在这里定义的。它的一个参考实现是runC。我们称其为低层级运行时（Low-levelRuntime）。除<br>runC 以外，也有很多其他的运行时遵循 OCI 标准，例如 kata-runtime。</p><h2 id="为什么弃用Docker"><a href="#为什么弃用Docker" class="headerlink" title="为什么弃用Docker"></a>为什么弃用Docker</h2><p>目前 docker 仍是 kubernetes 默认的容器运行时。那为什么会选择换掉 docker 呢？主要的原因是它的复杂性。</p><p>我们总结了 docker,containerd 以及 cri-o 的详细调用层级。Docker<br>的多层封装和调用，导致其在可维护性上略逊一筹，增加了线上问题的定位难度（貌似除了重启docker，我们就毫无他法了）。Containerd 和<br>cri-o 的方案比起 docker 简洁很多。因此我们更偏向于选用更加简单和纯粹的 containerd 和 cri-o 作为我们的容器运行时。</p><p><img src="/post/docker/kubelet-cri.drawio.svg" alt="kubelet-cri"></p><p>我们对 containerd 和 cri-o 进行了一组性能测试，包括创建、启动、停止和删除容器，以比较它们所耗的时间。containerd<br>在各个方面都表现良好，除了启动容器这项。从总用时来看，containerd 的用时还是要比 cri-o 要短的。</p><p><img src="/post/docker/runcPerformance.webp" alt="runcPerformance"></p><p>从功能性来讲，containerd 和 cri-o 都符合 CRI 和 OCI 的标准。从稳定性来说，单独使用 containerd 和 cri-o<br>都没有足够的生产环境经验。但庆幸的是，containerd 一直在 docker 里使用，而 docker 的生产环境经验可以说比较充足。可见在稳定性上<br>containerd 略胜一筹。所以我们最终选用了 containerd</p><h1 id="containerd操作"><a href="#containerd操作" class="headerlink" title="containerd操作"></a>containerd操作</h1><p>更换 containerd 后，常用的 docker 命令也不再有用，containerd 命令行客户端如下图所示：</p><p><img src="/post/docker/containerd-client.drawio.svg" alt="containerd"></p><ul><li>ctr -v 输出的是 containerd 的版本，crictl -v 输出的是当前 k8s 的版本，从结果显而易见你可以认为 crictl 是用于 k8s 的。</li><li>一般来说你某个主机安装了 k8s 后，命令行才会有 crictl 命令。而 ctr 是跟 k8s 无关的，你主机安装了 containerd 服务后就可以操作<br>ctr 命令。</li><li>用 crictl 运行 Pod 沙盒对容器运行时排错很有帮助。 在运行的 Kubernetes 集群中，沙盒会随机地被 kubelet 停止和删除。因此<br>crictl 尽量不要在单独起容器的情况下使用，因为容器会被停止和删除。</li></ul><p>先提前放出docker&#x2F;ctr&#x2F;crictl之间命令的对比，后面会详细介绍。</p><table><thead><tr><th>命令</th><th>docker</th><th>ctr（containerd）</th><th>crictl（kubernetes）</th></tr></thead><tbody><tr><td>查看运行的容器</td><td>docker ps</td><td>ctr task ls&#x2F;ctr container ls</td><td>crictl ps</td></tr><tr><td>查看镜像</td><td>docker images</td><td>ctr image ls</td><td>crictl images</td></tr><tr><td>查看容器日志</td><td>docker logs</td><td>无</td><td>crictl logs</td></tr><tr><td>查看容器数据信息</td><td>docker inspect</td><td>ctr container info</td><td>crictl inspect</td></tr><tr><td>查看容器资源</td><td>docker stats</td><td>无</td><td>crictl stats</td></tr><tr><td>启动&#x2F;关闭已有的容器</td><td>docker start&#x2F;stop</td><td>ctr task start&#x2F;kill</td><td>crictl start&#x2F;stop</td></tr><tr><td>运行一个新的容器</td><td>docker run</td><td>ctr run</td><td>无（最小单元为pod）</td></tr><tr><td>打标签</td><td>docker tag</td><td>ctr image tag</td><td>无</td></tr><tr><td>创建一个新的容器</td><td>docker create</td><td>ctr container create</td><td>crictl create</td></tr><tr><td>导入镜像</td><td>docker load</td><td>ctr image import</td><td>无</td></tr><tr><td>导出镜像</td><td>docker save</td><td>ctr image export</td><td>无</td></tr><tr><td>删除容器</td><td>docker rm</td><td>ctr container rm</td><td>crictl rm</td></tr><tr><td>删除镜像</td><td>docker rmi</td><td>ctr image rm</td><td>crictl rmi</td></tr><tr><td>拉取镜像</td><td>docker pull</td><td>ctr image pull</td><td>ctictl pull</td></tr><tr><td>推送镜像</td><td>docker push</td><td>ctr image push</td><td>无</td></tr><tr><td>登录或在容器内部执行命令</td><td>docker exec</td><td>无</td><td>crictl exec</td></tr><tr><td>清空不用的容器</td><td>docker image prune</td><td>无</td><td>crictl rmi –prune</td></tr></tbody></table><p>更多命令操作，可以直接在命令行输入命令查看帮助。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br><span class="line">ctr --help</span><br><span class="line">crictl --help</span><br></pre></td></tr></table></figure><p>以下是各种客户端操作 containerd 的命令，因为之后会安装 k8s，很多操作通过 k8s 直接就完成了，所以对应命令可以先做了解即可。</p><h2 id="containerd-客户端-ctr"><a href="#containerd-客户端-ctr" class="headerlink" title="containerd 客户端 ctr"></a>containerd 客户端 ctr</h2><p>ctr 是 containerd 项目的一部分提供的命令行客户端。如果一台机器上运行了 containerd，那么ctr二进制文件也一般会进行安装。</p><p>由于 containerd 有 namespaces 的概念，对于上层编排系统的支持，ctr 客户端主要区分了3个命名空间分别是k8s.io、moby和default，以上我们用<br>crictl 操作的均在 k8s.io 命名空间，使用 ctr 看镜像列表就需要加上 -n 参数。crictl 只有一个 k8s.io 命名空间，但是没有 -n 参数。</p><p>我们知道 Docker 也是默认调用的 containerd， Docker 使用的命名空间默认是 moby，而不是 default，所以假如我们用 docker<br>启动容器，那么我们也可以通过 ctr -n moby 来定位容器信息。</p><blockquote><p>【温馨提示】ctr images pull 拉取的镜像默认放在default，而 crictl pull 和 kubelet 默认拉取的镜像都在 k8s.io 命名空间下。所以通过<br>ctr 导入镜像的时候特别注意一点，最好指定命名空间。</p></blockquote><h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 注意 -n 不能放在命令最后面，下面查看的镜像是一样的</span><br><span class="line">ctr -n=k8s.io image ls</span><br><span class="line">ctr -n k8s.io image ls</span><br><span class="line"></span><br><span class="line"># 使用ctr命令指定命名空间导入镜像</span><br><span class="line">ctr -n=k8s.io image import dashboard.tar</span><br></pre></td></tr></table></figure><h3 id="ctr-命令"><a href="#ctr-命令" class="headerlink" title="ctr 命令"></a>ctr 命令</h3><p>ctr 命令的参数和全局参数如下。</p><p>参数命令的格式为：<code>ctr [global options] command [command options] [arguments...]</code></p><p>全局参数可以在任何命令后面使用，并且可以多个参数组合使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">COMMANDS:</span><br><span class="line">   plugins, plugin            provides information about containerd plugins</span><br><span class="line">   version                    print the client and server versions</span><br><span class="line">   containers, c, container   manage containers</span><br><span class="line">   content                    manage content</span><br><span class="line">   events, event              display containerd events</span><br><span class="line">   images, image, i           manage images</span><br><span class="line">   leases                     manage leases</span><br><span class="line">   namespaces, namespace, ns  manage namespaces</span><br><span class="line">   pprof                      provide golang pprof outputs for containerd</span><br><span class="line">   run                        run a container</span><br><span class="line">   snapshots, snapshot        manage snapshots</span><br><span class="line">   tasks, t, task             manage tasks</span><br><span class="line">   install                    install a new package</span><br><span class="line">   oci                        OCI tools</span><br><span class="line">   shim                       interact with a shim directly</span><br><span class="line">   help, h                    Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">--debug                      enable debug output in logs</span><br><span class="line">--address value, -a value    address for containerd&#x27;s GRPC server (default: &quot;/run/containerd/containerd.sock&quot;) [$CONTAINERD_ADDRESS]</span><br><span class="line">--timeout value              total timeout for ctr commands (default: 0s)</span><br><span class="line">--connect-timeout value      timeout for connecting to containerd (default: 0s)</span><br><span class="line">--namespace value, -n value  namespace to use with commands (default: &quot;default&quot;) [$CONTAINERD_NAMESPACE]</span><br><span class="line">--help, -h                   show help</span><br><span class="line">--version, -v                print the version</span><br></pre></td></tr></table></figure><ol><li><p>查看版本</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr -v</span><br><span class="line">ctr --version</span><br></pre></td></tr></table></figure></li><li><p>指定空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr -n k8s.io image ls</span><br></pre></td></tr></table></figure></li></ol><h3 id="namespace-相关操作"><a href="#namespace-相关操作" class="headerlink" title="namespace 相关操作"></a>namespace 相关操作</h3><p>ctr 所有的命令都支持 -n 参数，用于指定命名空间，如果不指定命名空间，默认为default命名空间。命名空间的概念类似于 docker<br>的仓库，但是不同的是，docker 的仓库是一个集中的仓库，而 ctr 的命名空间是分布式的，每个命名空间都是一个独立的仓库。</p><p>命令 <code>ctr namespace</code> 用于管理命名空间，包括查看、创建和删除命名空间。可以简化为 <code>ctr ns</code>。</p><ol><li><p>查看命名空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr namespace ls</span><br></pre></td></tr></table></figure></li><li><p>创建命名空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr namespace create k8s.io</span><br></pre></td></tr></table></figure></li><li><p>删除命名空间</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr namespace rm k8s.io</span><br></pre></td></tr></table></figure></li></ol><h3 id="镜像相关操作"><a href="#镜像相关操作" class="headerlink" title="镜像相关操作"></a>镜像相关操作</h3><p>镜像相关命令如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># ctr image -h</span><br><span class="line">NAME:</span><br><span class="line">   ctr images - manage images</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr images command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line"></span><br><span class="line">   check       check existing images to ensure all content is available locally</span><br><span class="line">   export      export images</span><br><span class="line">   import      import images</span><br><span class="line">   list, ls    list images known to containerd</span><br><span class="line">   mount       mount an image to a target path</span><br><span class="line">   unmount     unmount the image from the target</span><br><span class="line">   pull        pull an image from a remote</span><br><span class="line">   push        push an image to a remote</span><br><span class="line">   remove, rm  remove one or more images by reference</span><br><span class="line">   tag         tag an image</span><br><span class="line">   label       set and clear labels for an image</span><br><span class="line">   convert     convert an image</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br></pre></td></tr></table></figure><ol><li><p>拉取推送镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 拉取镜像</span><br><span class="line"># docker默认是docker.io官网去找镜像，所以docker拉去镜像可以这样写：docker pull nginx:alpine，而containerd没有默认仓库，所以必须写完整的镜像名字才能拉去镜像</span><br><span class="line">ctr i pull docker.io/library/nginx:alpine</span><br><span class="line">   </span><br><span class="line"># 推送镜像到harbor</span><br><span class="line">#</span><br><span class="line"># --namespace=k8s.io 指定命名空间，不是必须，根据环境而定</span><br><span class="line"># --skip-verify 跳过认证</span><br><span class="line"># --user 指定harbor用户名及密码</span><br><span class="line">ctr --namespace=k8s.io images push harbor.mydomain.com/k8s/pause:1.25.1 --skip-verify --user admin:Harbor12345</span><br><span class="line"></span><br><span class="line"># 不想 -u user:password 可以在配置文件进行配置，也可以使用 nerdctl ，下面有介绍</span><br><span class="line">   </span><br><span class="line"># 拉取带认证的镜像</span><br><span class="line">ctr images pull --user admin:Harbor12345 --tlscacert=/etc/containerd/harbor.mydomain.com/ca.crt harbor.mydomain.com/k8s/pause:1.25.1</span><br></pre></td></tr></table></figure></li><li><p>检查镜像列表，确认镜像是否存在以及镜像的完整性，主要查看其中的 <code>STATUS</code>，<code>complete</code> 表示镜像是完整可用的状态。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr image check</span><br><span class="line">ctr i check</span><br></pre></td></tr></table></figure></li><li><p>导入&#x2F;导出镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr i export nginx.tar.gz docker.io/library/nginx:alpine</span><br><span class="line">ctr i import nginx.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>查看镜像列表</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctr i ls</span><br><span class="line">ctr i list</span><br><span class="line"># 只查看镜像名称</span><br><span class="line">ctr i ls -q</span><br></pre></td></tr></table></figure></li><li><p>挂载&#x2F;卸载镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ctr 支持将镜像挂载到指定目录，这样就可以直接访问镜像中的文件了，而不需要启动容器，可以确认镜像中的文件是否正确</span><br><span class="line">ctr i mount docker.io/library/nginx:alpine /tmp/nginx</span><br><span class="line">ctr i unmount /tmp/nginx</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr i rm nginx:alpine</span><br><span class="line">ctr i remove nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>打标签</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># crictl 没有 tag 命令，只能使用 nerdctl 和 ctr，必须指定命名空间，要不然 kubelet 无法使用。</span><br><span class="line">ctr -n k8s.io i tag my-nginx:v1 harbor.mydomain.com/my-nginx:v1</span><br></pre></td></tr></table></figure></li><li><p>镜像转换</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ctr 支持将镜像转换为 OCI 格式，这样就可以使用其他容器运行时运行镜像了，比如 runc</span><br><span class="line">ctr i convert --oci nginx:alpine nginx:alpine-oci</span><br><span class="line"># 也支持将 OCI 格式的镜像转换为 docker 格式</span><br><span class="line">ctr i convert nginx:alpine nginx:alpine-docker</span><br></pre></td></tr></table></figure></li><li><p>镜像构建</p><p>containerd 不提供开箱即用的镜像构建支持。一般使用更高级别的工具用来构建镜像，比如 docker。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; Dockerfile &lt;&lt;EOF</span><br><span class="line">FROM nginx:alpine</span><br><span class="line">RUN echo &#x27;Build Image From Containerd&#x27; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 可以使用docker构建镜像，然后导出到本地，再使用ctr导入到containerd</span><br><span class="line">docker build -t my-nginx:v1 .</span><br><span class="line">docker save -o my-nginx.tar my-nginx:v1</span><br><span class="line"> </span><br><span class="line">ctr images import my-nginx.tar</span><br><span class="line"></span><br><span class="line"># 或者使用nerdctl进行构建，与docker功能一样</span><br><span class="line"># 不加-n指定命名空间，crictl看不到，kubelet也不能使用它，默认在default命名空间下</span><br><span class="line">nerdctl -n k8s.io build -t nginx:nerctl -f ./Dockerfile .</span><br><span class="line"></span><br><span class="line"># 参数解释：(下一节会有 nerctl 介绍)</span><br><span class="line"># -t：指定镜像名称</span><br><span class="line"># . ：当前目录Dockerfile</span><br><span class="line"># -f：指定Dockerfile路径</span><br><span class="line">#  --no-cache：不缓存</span><br></pre></td></tr></table></figure></li></ol><h3 id="容器相关操作"><a href="#容器相关操作" class="headerlink" title="容器相关操作"></a>容器相关操作</h3><p>容器相关操作，包括创建、启动、停止、删除等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">:~# ctr container --help</span><br><span class="line">NAME:</span><br><span class="line">   ctr containers - manage containers</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr containers command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   create           create container</span><br><span class="line">   delete, del, rm  delete one or more existing containers</span><br><span class="line">   info             get info about a container</span><br><span class="line">   list, ls         list containers</span><br><span class="line">   label            set and clear labels for a container</span><br><span class="line">   checkpoint       checkpoint a container</span><br><span class="line">   restore          restore a container from checkpoint</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br></pre></td></tr></table></figure><ol><li><p>创建容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># container 只是创建了静态容器，此时容器还未启动运行。如果要启动容器，需要使用 task start 命令。</span><br><span class="line">ctr c create docker.io/library/nginx:alpine my-nginx</span><br></pre></td></tr></table></figure></li><li><p>删除容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctr c rm my-nginx</span><br><span class="line">ctr c delete my-nginx</span><br><span class="line">ctr c del my-nginx</span><br></pre></td></tr></table></figure></li><li><p>查看指定容器的信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr c info my-nginx</span><br></pre></td></tr></table></figure></li><li><p>查看所有容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr c ls</span><br><span class="line">ctr c list</span><br></pre></td></tr></table></figure></li><li><p>容器标签</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 容器标签可以用来标记容器，方便管理（只能通过 ctr c info 查看， ctr ls 不会显示）</span><br><span class="line">ctr c label my-nginx mylabel=nginx</span><br></pre></td></tr></table></figure></li><li><p>容器检查点</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 容器检查点可以用来备份容器，方便恢复 （没有测试）</span><br><span class="line">ctr c checkpoint my-nginx mycheckpoint</span><br><span class="line">ctr c restore my-nginx mycheckpoint</span><br></pre></td></tr></table></figure></li></ol><h3 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h3><p>管理任务，包括创建、启动、停止、删除等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># ctr task --help</span><br><span class="line">NAME:</span><br><span class="line">   ctr tasks - manage tasks</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr tasks command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   attach           attach to the IO of a running container</span><br><span class="line">   checkpoint       checkpoint a container</span><br><span class="line">   delete, rm       delete one or more tasks</span><br><span class="line">   exec             execute additional processes in an existing container</span><br><span class="line">   list, ls         list tasks</span><br><span class="line">   kill             signal a container (default: SIGTERM)</span><br><span class="line">   pause            pause an existing container</span><br><span class="line">   ps               list processes for container</span><br><span class="line">   resume           resume a paused container</span><br><span class="line">   start            start a container that has been created</span><br><span class="line">   metrics, metric  get a single data point of metrics for a task with the built-in Linux runtime</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --help, -h  show help</span><br></pre></td></tr></table></figure><ol><li><p>启动已经创建的容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr t start my-nginx</span><br><span class="line">ctr t start -d my-nginx</span><br></pre></td></tr></table></figure></li><li><p>查看任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr t ls</span><br><span class="line">ctr t list</span><br></pre></td></tr></table></figure></li><li><p>查看任务中的进程</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意：这里的进程是指容器中进程在宿主机上的进程号。</span><br><span class="line">ctr t ps my-nginx</span><br></pre></td></tr></table></figure></li><li><p>任务中执行命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctr t exec my-nginx ls /</span><br><span class="line"># 进入容器内部终端，997，是随便指定的，只要不重复就行</span><br><span class="line">ctr t exec --exec-id 997 -t my-nginx /bin/sh</span><br></pre></td></tr></table></figure></li><li><p>暂停&#x2F;回复任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctr t pause my-nginx</span><br><span class="line">ctr t resume my-nginx</span><br></pre></td></tr></table></figure></li><li><p>杀死&#x2F;删除任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 只是给任务发送了 SIGTERM 信号，任务还是存在的，状态为 stopped</span><br><span class="line">ctr t kill my-nginx</span><br><span class="line"># 删除任务，任务必须是 stopped 状态</span><br><span class="line">ctr t rm my-nginx</span><br><span class="line">ctr t delete my-nginx</span><br><span class="line">   </span><br><span class="line"># 给特定进程发送信号，这里是把刚刚创建的进程强制杀死</span><br><span class="line">ctr t kill --exec-id 999 -s SIGTERM my-nginx</span><br></pre></td></tr></table></figure><p>关于信号量相关的内容，可以参考这篇文章 <a href="https://realtiger.github.io/linux-signals/">Linux 信号量详解</a>。</p></li><li><p>获取任务的指标</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 我们可以通过metric命令获取容器关于cgroup相关的信息，包括CPU、内存、PID的限额和使用情况等。</span><br><span class="line">ctr t metric my-nginx</span><br></pre></td></tr></table></figure></li></ol><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>容器运行需要进行两步，第一步是创建容器，第二步是启动容器。</p><p>使用 <code>ctr run</code> 命令可以一步到位，创建并启动容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># ctr run --help</span><br><span class="line">NAME:</span><br><span class="line">   ctr run - run a container</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   ctr run [command options] [flags] Image|RootFS ID [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --rm                                    remove the container after running</span><br><span class="line">   --null-io                               send all IO to /dev/null</span><br><span class="line">   --log-uri value                         log uri</span><br><span class="line">   --detach, -d                            detach from the task after it has started execution</span><br><span class="line">   --fifo-dir value                        directory used for storing IO FIFOs</span><br><span class="line">   --cgroup value                          cgroup path (To disable use of cgroup, set to &quot;&quot; explicitly)</span><br><span class="line">   --platform value                        run image for specific platform</span><br><span class="line">   --runc-binary value                     specify runc-compatible binary</span><br><span class="line">   --runc-root value                       specify runc-compatible root</span><br><span class="line">   --runc-systemd-cgroup                   start runc with systemd cgroup manager</span><br><span class="line">   --uidmap container-uid:host-uid:length  run inside a user namespace with the specified UID mapping range; specified with the format container-uid:host-uid:length</span><br><span class="line">   --gidmap container-gid:host-gid:length  run inside a user namespace with the specified GID mapping range; specified with the format container-gid:host-gid:length</span><br><span class="line">   --remap-labels                          provide the user namespace ID remapping to the snapshotter via label options; requires snapshotter support</span><br><span class="line">   --cpus value                            set the CFS cpu quota (default: 0)</span><br><span class="line">   --cni                                   enable cni networking for the container</span><br><span class="line">   --snapshotter value                     snapshotter name. Empty value stands for the default value. [$CONTAINERD_SNAPSHOTTER]</span><br><span class="line">   --config value, -c value                path to the runtime-specific spec config file</span><br><span class="line">   --cwd value                             specify the working directory of the process</span><br><span class="line">   --env value                             specify additional container environment variables (e.g. FOO=bar)</span><br><span class="line">   --env-file value                        specify additional container environment variables in a file(e.g. FOO=bar, one per line)</span><br><span class="line">   --label value                           specify additional labels (e.g. foo=bar)</span><br><span class="line">   --mount value                           specify additional container mount (e.g. type=bind,src=/tmp,dst=/host,options=rbind:ro)</span><br><span class="line">   --net-host                              enable host networking for the container</span><br><span class="line">   --privileged                            run privileged container</span><br><span class="line">   --read-only                             set the containers filesystem as readonly</span><br><span class="line">   --runtime value                         runtime name (default: &quot;io.containerd.runc.v2&quot;)</span><br><span class="line">   --runtime-config-path value             optional runtime config path</span><br><span class="line">   --tty, -t                               allocate a TTY for the container</span><br><span class="line">   --with-ns value                         specify existing Linux namespaces to join at container runtime (format &#x27;&lt;nstype&gt;:&lt;path&gt;&#x27;)</span><br><span class="line">   --pid-file value                        file path to write the task&#x27;s pid</span><br><span class="line">   --gpus value                            add gpus to the container (default: 0)</span><br><span class="line">   --allow-new-privs                       turn off OCI spec&#x27;s NoNewPrivileges feature flag</span><br><span class="line">   --memory-limit value                    memory limit (in bytes) for the container (default: 0)</span><br><span class="line">   --device value                          file path to a device to add to the container; or a path to a directory tree of devices to add to the container</span><br><span class="line">   --seccomp                               enable the default seccomp profile</span><br><span class="line">   --seccomp-profile value                 file path to custom seccomp profile. seccomp must be set to true, before using seccomp-profile</span><br><span class="line">   --apparmor-default-profile value        enable AppArmor with the default profile with the specified name, e.g. &quot;cri-containerd.apparmor.d&quot;</span><br><span class="line">   --apparmor-profile value                enable AppArmor with an existing custom profile</span><br><span class="line">   --rootfs                                use custom rootfs that is not managed by containerd snapshotter</span><br><span class="line">   --no-pivot                              disable use of pivot-root (linux only)</span><br><span class="line">   --cpu-quota value                       Limit CPU CFS quota (default: -1)</span><br><span class="line">   --cpu-period value                      Limit CPU CFS period (default: 0)</span><br></pre></td></tr></table></figure><p>创建并启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr run -d -t --net-host docker.io/library/nginx:alpine my-nginx</span><br></pre></td></tr></table></figure><h2 id="containerd-客户端-nerdctl"><a href="#containerd-客户端-nerdctl" class="headerlink" title="containerd 客户端 nerdctl"></a>containerd 客户端 nerdctl</h2><p>推荐使用 nerdctl，使用效果与 docker 命令的语法一致<br>二进制包的 github 下载链接：<a href="https://github.com/containerd/nerdctl/releases">https://github.com/containerd/nerdctl/releases</a></p><ul><li>精简 (nerdctl-{version}-linux-amd64.tar.gz): 只包含nerdctl</li><li>完整 (nerdctl-full-{version}-linux-amd64.tar.gz): 包含 containerd, runc, and CNI等依赖</li></ul><p>nerdctl 的目标并不是单纯地复制 docker 的功能，它还实现了很多 docker 不具备的功能，例如延迟拉取镜像（lazy-pulling）、镜像加密（imgcrypt）等。</p><p><img src="/post/docker/nerdctl.png" alt="nerdctl"></p><h3 id="安装-nerdctl"><a href="#安装-nerdctl" class="headerlink" title="安装 nerdctl"></a>安装 nerdctl</h3><p>精简版只包含nerdctl，完整版包含nerdctl和CNI插件等依赖，k8s的网络插件会在&#x2F;opt&#x2F;cni&#x2F;bin&#x2F;下会生成cni插件目录。这里选择完整版进行安装，因为启动容器的时候配置网络需要cni网络插件的支持。</p><ol><li><p>精简版 nerdctl 安装</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/containerd/nerdctl/releases/download/v0.22.2/nerdctl-0.22.2-linux-amd64.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar -xf nerdctl-0.22.2-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 查看解压后的文件，可以看见除了nerdctl还有containerd-rootless-setuptool.sh、containerd-rootless.sh，另外两个文件是用来在非root用户下使用nerdctl的</span><br><span class="line">ls -l</span><br><span class="line"></span><br><span class="line">total 37624</span><br><span class="line">-rwxr-xr-x 1 root root    21562 Aug  1  2022 containerd-rootless-setuptool.sh</span><br><span class="line">-rwxr-xr-x 1 root root     7032 Aug  1  2022 containerd-rootless.sh</span><br><span class="line">-rwxr-xr-x 1 root root 27807744 Aug  1  2022 nerdctl</span><br><span class="line">-rw-r--r-- 1 root root 10685899 Aug  1  2022 nerdctl-0.22.2-linux-amd64.tar.gz</span><br><span class="line">   </span><br><span class="line"># 将nerdctl复制到/usr/local/bin/目录下，这样就可以直接使用nerdctl命令了。具体目录根据机器上的PATH环境变量来定。</span><br><span class="line">cp nerdctl /usr/local/bin/</span><br></pre></td></tr></table></figure></li><li><p>完整版 nerdctl 安装</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/containerd/nerdctl/releases/download/v0.22.2/nerdctl-full-0.22.2-linux-amd64.tar.gz</span><br><span class="line"># 解压后还有如下4个目录 </span><br><span class="line"># 1. bin（二进制模式，包括 nerdctl buildkitd runc tini等）</span><br><span class="line"># 2. lib（systemctl 的 service 文件）</span><br><span class="line"># 3. libexec（cni组件）</span><br><span class="line"># 4. share（说明文档）</span><br><span class="line">tar -xf nerdctl-full-0.22.2-linux-amd64.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line"># 将service文件复制到/etc/systemd/system/目录下</span><br><span class="line">cp /usr/local/lib/systemd/system/*.service /etc/systemd/system/</span><br><span class="line"></span><br><span class="line"># 启动服务buildkit</span><br><span class="line">systemctl enable buildkit containerd --now</span><br><span class="line">systemctl status buildkit containerd</span><br></pre></td></tr></table></figure></li><li><p>安装 buildkit 支持构建镜像</p><p>buildkit GitHub地址： <a href="https://github.com/moby/buildkit">https://github.com/moby/buildkit</a></p><p>使用精简版 nerdctl 无法直接通过 containerd 构建镜像，需要与 buildkit 组全使用以实现镜像构建。当然你也可以安装上面的完整<br>nerdctl，完整版可以直接使用 nerdctl build 命令构建镜像，是因为完整版已经有现成的 buildkit.service 服务了。</p><p>buildkit项目是Docker公司开源出来的一个构建工具包，支持OCI标准的镜像构建。它主要包含以下部分:</p><ul><li>服务端buildkitd，当前支持runc和containerd作为worker，默认是runc；</li><li>客户端buildctl，负责解析Dockerfile，并向服务端buildkitd发出构建请求。</li><li>buildkit是典型的C&#x2F;S架构，client和server可以不在一台服务器上。而nerdctl在构建镜像方面也可以作为buildkitd的客户端。</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 下载地址 https://github.com/moby/buildkit/releases</span><br><span class="line">wget https://github.com/moby/buildkit/releases/download/v0.10.4/buildkit-v0.10.4.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压之后只有一个bin目录，里面有buildkit所需要的二进制文件</span><br><span class="line"># 以下的命令会将buildkit的二进制文件合并到/usr/local/bin/目录下</span><br><span class="line">tar -xf buildkit-v0.10.4.linux-amd64.tar.gz  -C /usr/local/</span><br><span class="line"></span><br><span class="line"># buildkit需要配置两个文件:</span><br><span class="line"># 1. /usr/lib/systemd/system/buildkit.socket</span><br><span class="line"># 2. /usr/lib/systemd/system/buildkit.service</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/systemd/system/buildkit.socket &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=BuildKit</span><br><span class="line">Documentation=https://github.com/moby/buildkit</span><br><span class="line">[Socket]</span><br><span class="line">ListenStream=%t/buildkit/buildkitd.sock</span><br><span class="line">SocketMode=0660</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sockets.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/systemd/system/buildkit.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=BuildKit</span><br><span class="line">Requires=buildkit.socket</span><br><span class="line">After=buildkit.socket</span><br><span class="line">Documentation=https://github.com/moby/buildkit</span><br><span class="line">[Service]</span><br><span class="line"># Replace runc builds with containerd builds  </span><br><span class="line">ExecStart=/usr/local/bin/buildkitd --addr fd://</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 启动buildkit</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable buildkit --now</span><br></pre></td></tr></table></figure></li><li><p>设置nerdctl自动补全</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编辑文件</span><br><span class="line">vim /etc/profile</span><br><span class="line">source &lt;(nerdctl completion bash)</span><br><span class="line"># 让其生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><h3 id="namespace-相关操作-1"><a href="#namespace-相关操作-1" class="headerlink" title="namespace 相关操作"></a>namespace 相关操作</h3><ol><li><p>创建 namespace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl namespace create mynamespace</span><br></pre></td></tr></table></figure></li><li><p>列出 namespace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl namespace ls</span><br></pre></td></tr></table></figure></li><li><p>删除 namespace</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl namespace rm mynamespace</span><br></pre></td></tr></table></figure></li></ol><h3 id="镜像相关操作-1"><a href="#镜像相关操作-1" class="headerlink" title="镜像相关操作"></a>镜像相关操作</h3><ol><li><p>拉取镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl pull nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>列出镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl image ls</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl image rm nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>拉取推送镜像</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 拉取镜像</span><br><span class="line">nerdctl pull nginx:alpine</span><br><span class="line"># 重命名镜像</span><br><span class="line">nerdctl image tag nginx:alpine harbor.mydomain.com/library/nginx:alpine</span><br><span class="line"># 推送镜像</span><br><span class="line">nerdctl push harbor.mydomain.com/library/nginx:alpine</span><br></pre></td></tr></table></figure><p>更详细的镜像拉取操作请参考下面的内容：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># http方式，配置如下：</span><br><span class="line">mkdir -p /etc/containerd/harbor.mydomain.com</span><br><span class="line">cat &gt; /etc/containerd/certs.d/harbor.mydomain.com/hosts.toml &lt;&lt;EOF</span><br><span class="line">server = &quot;https://docker.io&quot;</span><br><span class="line"></span><br><span class="line">[host.&quot;http://myharbor-minio.com&quot;]</span><br><span class="line">capabilities = [&quot;pull&quot;, &quot;resolve&quot;,&quot;push&quot;]</span><br><span class="line"># skip_verify = true</span><br><span class="line"># ca = &quot;ca.crt&quot; #相对路径</span><br><span class="line"># ca = &quot;/opt/auth/ca.crt&quot; #绝对路径</span><br><span class="line"># ca = [&quot;/opt/auth/ca.crt&quot;]</span><br><span class="line"># ca = [&quot;ca.crt&quot;]</span><br><span class="line"># client = [[&quot;/opt/auth/nginx.cclinux.cn.crt&quot;, &quot;/opt/auth/nginx.cclinux.cn.key&quot;]]</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"># https方式，配置如下：</span><br><span class="line">mkdir -p /etc/containerd/certs.d/harbor.secure.mydomain.com:443</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/containerd/certs.d/harbor.secure.mydomain.com\:443/hosts.toml &lt;&lt;EOF</span><br><span class="line">server = &quot;https://docker.io&quot;</span><br><span class="line"></span><br><span class="line">[host.&quot;https://harbor.secure.mydomain.com:443&quot;]</span><br><span class="line">capabilities = [&quot;pull&quot;, &quot;resolve&quot;,&quot;push&quot;]</span><br><span class="line">skip_verify = true</span><br><span class="line"># ca = &quot;ca.crt&quot; #相对路径</span><br><span class="line"># ca = &quot;/opt/auth/ca.crt&quot; #绝对路径</span><br><span class="line"># ca = [&quot;/opt/auth/ca.crt&quot;]</span><br><span class="line">ca = [&quot;/etc/containerd/harbor.secure.mydomain.com/ca.crt&quot;]</span><br><span class="line"># client = [[&quot;/opt/auth/nginx.cclinux.cn.crt&quot;, &quot;/opt/auth/nginx.cclinux.cn.key&quot;]]</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"># 可以通过 nerdctl 登录</span><br><span class="line">echo Harbor12345 | nerdctl login --username &quot;admin&quot; --password-stdin harbor.secure.mydomain.com:443</span><br><span class="line">   </span><br><span class="line"># 登出命令</span><br><span class="line"># nerdctl logout harbor.secure.mydomain.com:443</span><br><span class="line">   </span><br><span class="line"># 推送到私有仓库</span><br><span class="line">nerdctl --insecure-registry --namespace=k8s.io push harbor.secure.mydomain.com:443/k8s/pause:1.25.1</span><br></pre></td></tr></table></figure></li><li><p>镜像构建</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 从Dockerfile构建镜像</span><br><span class="line">nerdctl build -t nginx:my-alpine -f Dockerfile .</span><br><span class="line"># 从Dockerfile构建镜像并推送到私有仓库</span><br><span class="line">nerdctl build -t harbor.secure.mydomain.com:443/k8s/nginx:alpine -f Dockerfile .</span><br></pre></td></tr></table></figure></li></ol><h3 id="容器相关操作-1"><a href="#容器相关操作-1" class="headerlink" title="容器相关操作"></a>容器相关操作</h3><ol><li><p>创建容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl run -d --name mynginx -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>列出容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nerdctl ps -a</span><br><span class="line">nerdctl container ls -a</span><br></pre></td></tr></table></figure></li><li><p>删除容器(停止容器后才能删除)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nerdctl stop mynginx</span><br><span class="line">nerdctl rm mynginx</span><br><span class="line">   </span><br><span class="line">nerdctl container stop mynginx</span><br><span class="line">nerdctl container rm mynginx</span><br></pre></td></tr></table></figure></li><li><p>进入容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nerdctl exec -it mynginx sh</span><br><span class="line"></span><br><span class="line">nerdcrl container exec -it mynginx sh</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nerdctl logs mynginx</span><br><span class="line">   </span><br><span class="line">nerdctl container logs mynginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器详细信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nerdctl inspect mynginx</span><br><span class="line">   </span><br><span class="line">nerdctl container inspect mynginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器内进程</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nerdctl top mynginx</span><br></pre></td></tr></table></figure></li></ol><h2 id="k8s-操作-containerd-的客户端-crictl"><a href="#k8s-操作-containerd-的客户端-crictl" class="headerlink" title="k8s 操作 containerd 的客户端 crictl"></a>k8s 操作 containerd 的客户端 crictl</h2><h3 id="crictl-命令"><a href="#crictl-命令" class="headerlink" title="crictl 命令"></a>crictl 命令</h3><p>这里我使用的是 crictl v1.26.0 版本，命令里面有些是与 pod 相关的，暂时略过，这里只介绍与 container 相关的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">crictl -h</span><br><span class="line">NAME:</span><br><span class="line">   crictl - client for CRI</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   crictl [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   v1.26.0</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   attach              Attach to a running container</span><br><span class="line">   create              Create a new container</span><br><span class="line">   exec                Run a command in a running container</span><br><span class="line">   version             Display runtime version information</span><br><span class="line">   images, image, img  List images</span><br><span class="line">   inspect             Display the status of one or more containers</span><br><span class="line">   inspecti            Return the status of one or more images</span><br><span class="line">   imagefsinfo         Return image filesystem info</span><br><span class="line">   inspectp            Display the status of one or more pods</span><br><span class="line">   logs                Fetch the logs of a container</span><br><span class="line">   port-forward        Forward local port to a pod</span><br><span class="line">   ps                  List containers</span><br><span class="line">   pull                Pull an image from a registry</span><br><span class="line">   run                 Run a new container inside a sandbox</span><br><span class="line">   runp                Run a new pod</span><br><span class="line">   rm                  Remove one or more containers</span><br><span class="line">   rmi                 Remove one or more images</span><br><span class="line">   rmp                 Remove one or more pods</span><br><span class="line">   pods                List pods</span><br><span class="line">   start               Start one or more created containers</span><br><span class="line">   info                Display information of the container runtime</span><br><span class="line">   stop                Stop one or more running containers</span><br><span class="line">   stopp               Stop one or more running pods</span><br><span class="line">   update              Update one or more running containers</span><br><span class="line">   config              Get and set crictl client configuration options</span><br><span class="line">   stats               List container(s) resource usage statistics</span><br><span class="line">   statsp              List pod resource usage statistics</span><br><span class="line">   completion          Output shell completion code</span><br><span class="line">   checkpoint          Checkpoint one or more running containers</span><br><span class="line">   help, h             Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --config value, -c value            Location of the client config file. If not specified and the default does not exist, the program&#x27;s directory is searched as well (default: &quot;/etc/crictl.yaml&quot;) [$CRI_CONFIG_FILE]</span><br><span class="line">   --debug, -D                         Enable debug mode (default: false)</span><br><span class="line">   --image-endpoint value, -i value    Endpoint of CRI image manager service (default: uses &#x27;runtime-endpoint&#x27; setting) [$IMAGE_SERVICE_ENDPOINT]</span><br><span class="line">   --runtime-endpoint value, -r value  Endpoint of CRI container runtime service (default: uses in order the first successful one of [unix:///var/run/dockershim.sock unix:///run/containerd/containerd.sock unix:///run/crio/crio.sock unix:///var/run/cri-dockerd.sock]). Default is now deprecated and the endpoint should be set instead. [$CONTAINER_RUNTIME_ENDPOINT]</span><br><span class="line">   --timeout value, -t value           Timeout of connecting to the server in seconds (e.g. 2s, 20s.). 0 or less is set to default (default: 2s)</span><br><span class="line">   --help, -h                          show help (default: false)</span><br><span class="line">   --version, -v                       print the version (default: false)</span><br></pre></td></tr></table></figure><h3 id="命令示例-1"><a href="#命令示例-1" class="headerlink" title="命令示例"></a>命令示例</h3><p>使用 crictl 命令之前，需要先配置 <code>/etc/crictl.yaml</code> 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/crictl.yaml</span><br><span class="line"></span><br><span class="line">runtime-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">timeout: 10</span><br><span class="line">debug: false</span><br><span class="line"></span><br><span class="line"># 也可以通过命令进行设置</span><br><span class="line">crictl config runtime-endpoint unix:///run/containerd/containerd.sock</span><br><span class="line">crictl config image-endpoint unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>命令行示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># crictl 没有 -n 参数，操作都在 k8s.io 命名空间下。</span><br><span class="line">crictl image ls</span><br><span class="line">crictl images</span><br><span class="line"># crictl image list = ctr -n k8s.io image list</span><br><span class="line"># crictl image ls = ctr -n k8s.io image ls</span><br><span class="line"># crictl images = ctr -n k8s.io image list</span><br><span class="line"># crictl images = ctr -n k8s.io image ls</span><br></pre></td></tr></table></figure><h3 id="image-相关操作"><a href="#image-相关操作" class="headerlink" title="image 相关操作"></a>image 相关操作</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的 image</span><br><span class="line">crictl image list</span><br><span class="line"># 拉取 image</span><br><span class="line"># 注意：回车之后屏幕会卡住，不要着急，正常现象。crictl 没有进度条，拉取镜像的过程中，会一直卡在这里，直到拉取完成，只能耐心等待完成。</span><br><span class="line">crictl pull nginx:1.25</span><br><span class="line"># 删除 image</span><br><span class="line">crictl rmi nginx:1.25</span><br></pre></td></tr></table></figure></code></pre><h3 id="container-相关操作"><a href="#container-相关操作" class="headerlink" title="container 相关操作"></a>container 相关操作</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的 container</span><br><span class="line">crictl ps -a</span><br></pre></td></tr></table></figure>crictl 运行一个容器比较复杂，需要书写两个 json 文件比如以下两个文件，一个是 pod-config.json，一个是 container-config.json，其中 pod-config.json 是 pod 的配置，container-config.json 是 container 的配置。pod 的概念是 k8s 中有的，这里先知道即可。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cat pod-config.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;metadata&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;nginx-sandbox&quot;,</span><br><span class="line">        &quot;namespace&quot;: &quot;default&quot;,</span><br><span class="line">        &quot;attempt&quot;: 1,</span><br><span class="line">        &quot;uid&quot;: &quot;hdishd83djaidwnduwk28bcsb&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;log_directory&quot;: &quot;/tmp&quot;,</span><br><span class="line">    &quot;linux&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat container-config.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;metadata&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;busybox&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;image&quot;:&#123;</span><br><span class="line">        &quot;image&quot;: &quot;busybox&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;command&quot;: [</span><br><span class="line">        &quot;top&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;log_path&quot;:&quot;busybox.0.log&quot;,</span><br><span class="line">    &quot;linux&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 根据以上两个文件创建 container， 注意如果 k8s 没有安装好可能会报错，因为 crictl 是 k8s 的客户端，需要 k8s 的环境。</span><br><span class="line">crictl run container-config.json pod-config.json</span><br><span class="line"># 删除 container</span><br><span class="line">crictl rm mynginx</span><br><span class="line"># 进入 container，注意这里的 container id 是 crictl ps -a 查看到的</span><br><span class="line">crictl exec -it &lt;container id&gt; sh</span><br><span class="line"># 查看 container 日志</span><br><span class="line">crictl logs &lt;container id&gt;</span><br><span class="line"># 查看 container 详细信息</span><br><span class="line">crictl inspect &lt;container id&gt;</span><br></pre></td></tr></table></figure></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 k8s 后，对于容器的操作，基本上都是通过 kubelet 完成，这个之后会使用到。</li><li>镜像的构建推荐使用 <code>docker build</code> 等方式，推送到镜像仓库后，再通过 containerd 进行使用。</li><li>查看容器中的日志，使用 <code>crictl logs</code> 命令。</li><li>常规的对于 containerd 的操作，推荐使用 <code>nerdctl</code> 命令，使用效果与 docker 命令的语法一致。</li></ul><h1 id="docker-总结"><a href="#docker-总结" class="headerlink" title="docker 总结"></a>docker 总结</h1><h2 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h2><ol><li><p>清理主机上所有退出的容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">rm</span>  $(docker ps -aq)</span><br></pre></td></tr></table></figure></li><li><p>调试或者排查容器启动错误</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 若有时遇到容器启动失败的情况，可以先使用相同的镜像启动一个临时容器，先进入容器</span></span><br><span class="line">$ docker run --<span class="built_in">rm</span> -ti &lt;image_id&gt; sh</span><br><span class="line"><span class="comment">## 进入容器后，手动执行该容器对应的ENTRYPOINT或者CMD命令，这样即使出错，容器也不会退出，因为bash作为1号进程，我们只要不退出容器，该容器就不会自动退出</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="docker总结"><a href="#docker总结" class="headerlink" title="docker总结"></a>docker总结</h2><p><img src="/post/docker/Docker.png" alt="Docker"></p><ol><li>为了解决软件交付过程中的环境依赖，同时提供一种更加轻量的虚拟化技术，Docker出现了。</li><li>2013年诞生，15年开始迅速发展，从17.03月开始，使用时间日期管理版本，稳定版以每季度为准。</li><li>Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理。</li><li>使用yum部署docker，启动后通过操作docker这个命令行，自动调用docker daemon完成容器相关操作。</li><li>常用操作，围绕<code>镜像|容器|仓库</code>三大核心要素<ul><li>systemctl start|stop|restart docker</li><li>docker build | pull -&gt; docker tag -&gt; docker push</li><li>docker run –name my-demo -d -p 8080:80 -v &#x2F;opt&#x2F;data:&#x2F;data demo:v20200327 ping xx.com</li><li>docker cp &#x2F;path&#x2F;a.txt mycontainer:&#x2F;opt</li><li>docker exec -ti mycontainer &#x2F;bin&#x2F;sh</li><li>docker logs -f –tail&#x3D;100 mycontainer</li></ul></li><li>通过dockerfile构建业务镜像，先使用基础镜像，然后通过一系列的指令把我们的业务应用所需要的运行环境和依赖都打包到镜像中，然后通过CMD或者ENTRYPOINT指令把镜像启动时的入口制定好，完成封装即可。有点类似于，先找来一个集装箱模板(<br>基础镜像)，然后把项目依赖的服务都扔到集装箱中，然后设置好服务的启动入口，关闭箱门，即完成了业务镜像的制作。</li><li>容器的实现依赖于内核模块提供的namespace和control-group的功能，通过namespace创建一块虚拟空间，空间内实现了各类资源(<br>进程、网络、文件系统)的隔离，提供control-group实现了对隔离的空间的资源使用的限制。</li><li>docker镜像使用分层的方式进行存储，根据主机的存储驱动的不同，实现方式会不同，kernel在3.10.0-514以上自动支持overlay2存储驱动，也是目前Docker推荐的方式。</li><li>得益于分层存储的模式，多个容器可以通过copy-on-write的策略，在镜像的最上层加一个可写层，同时利用存储驱动的UnionFS的能力，实现一个镜像快速启动多个容器的场景。</li><li>docker的网络模式分为4种，最常用的为bridge和host模式。bridge模式通过docker0网桥，启动容器的时候通过创建一对虚拟网卡，将容器连接在桥上，同时维护了虚拟网卡与网桥端口的关系，实现容器间的通信。容器与宿主机之间的通信通过iptables端口映射的方式，docker利用iptables的PREROUTING和POSTROUTING的nat功能，实现了SNAT与DNAT，使得容器内部的服务被完美的保护起来。</li><li>本章重点内容是docker的核心要素及基础的操作，实现原理以及docker的网络模式为选修包，目的为了帮助有docker基础及经验的同学更好的进一步理解docker。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> containerd </tag>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络</title>
      <link href="/docker-network/"/>
      <url>/docker-network/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><p>docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间，</p><ul><li>多个容器之间是如何实现通信的呢？</li><li>容器和宿主机之间又是如何实现的通信呢？</li><li>使用-p参数是怎么实现的端口映射?</li></ul><p>带着这些问题，我们来学习一下docker的网络模型，最后我会通过抓包的方式，给大家演示一下数据包在容器和宿主机之间的转换过程。</p><span id="more"></span><h1 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h1><p>我们在使用 docker run 创建 Docker 容器时，可以用 –net 选项指定容器的网络模式，Docker 有以下4种网络模式：</p><ul><li>bridge模式，使用 –net&#x3D;bridge 指定，默认设置</li><li>host模式，使用 –net&#x3D;host 指定，容器内部网络空间共享宿主机的空间，效果类似直接在宿主机上启动一个进程，端口信息和宿主机共用</li><li>container模式，使用 –net&#x3D;container:NAME_or_ID 指定，指定容器与特定容器共享网络命名空间</li><li>none模式，使用 –net&#x3D;none 指定，网络模式为空，即仅保留网络命名空间，但是不做任何网络相关的配置(网卡、IP、路由等)</li></ul><h2 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h2><p>那我们之前在演示创建docker容器的时候其实是没有指定的网络模式的，如果不指定的话默认就会使用bridge模式，bridge本意是桥的意思，其实就是网桥模式。</p><p>那我们怎么理解网桥，如果需要做类比的话，我们可以把网桥看成一个二层的交换机设备。网桥模式示意图：</p><p><img src="/post/docker/docker-network-bridge.jpeg" alt="docker 网桥示意图"></p><p>Linux 中，能够起到<strong>虚拟交换机作用</strong>的网络设备，是网桥（Bridge）。它是一个工作在<strong>数据链路层</strong>（Data Link）的设备，主要功能是<strong>根据 MAC 地址将数据包转发到网桥的不同端口上</strong>。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y bridge-utils</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge <span class="built_in">id</span>               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242b5fbe57b       no              veth3a496ed</span><br></pre></td></tr></table></figure><p>有了网桥之后，那我们看下docker在启动一个容器的时候做了哪些事情才能实现容器间的互联互通</p><p>Docker 创建一个容器的时候，会执行如下操作：</p><ul><li>创建一对虚拟接口&#x2F;网卡，也就是veth pair网卡对；</li><li>veth pair的一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxxx；</li><li>veth pair的另一端放到新启动的容器内部，并修改名字作为 eth0，这个网卡&#x2F;接口只在容器的命名空间可见；</li><li>从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0</li><li>配置容器的默认路由</li></ul><p>那整个过程其实是docker自动帮我们完成的，清理掉所有容器，来验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 清掉所有容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f `docker ps -aq`</span><br><span class="line">$ docker ps</span><br><span class="line">$ brctl show <span class="comment"># 查看网桥中的接口，目前没有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建测试容器test1</span></span><br><span class="line">$ docker run -d --name test1 nginx:alpine</span><br><span class="line">$ brctl show <span class="comment"># 查看网桥中的接口，已经把test1的veth端接入到网桥中</span></span><br><span class="line">$ ip a |grep veth <span class="comment"># 已在宿主机中可以查看到</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test1 sh </span><br><span class="line">/ <span class="comment"># ifconfig  # 查看容器的eth0网卡及分配的容器ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再来启动一个测试容器，测试容器间的通信</span></span><br><span class="line">$ docker run -d --name test2 nginx:alpine</span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test2 sh</span><br><span class="line">/ <span class="comment"># sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apk/repositories</span></span><br><span class="line">/ <span class="comment"># apk add curl</span></span><br><span class="line">/ <span class="comment"># curl 172.17.0.8:80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为啥可以通信？</span></span><br><span class="line">/ <span class="comment"># route -n  # </span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. eth0 网卡是这个容器里的默认路由设备；所有对 172.17.0.0/16 网段的请求，也会被交给 eth0 来处理（第二条 172.17.0.0 路由规则），这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：凡是匹配到这条规则的 IP 包，应该经过本机的 eth0 网卡，通过二层网络(数据链路层)直接发往目的主机。</span></span><br><span class="line"><span class="comment"># 2. 而要通过二层网络到达 test1 容器，就需要有 172.17.0.8 这个 IP 地址对应的 MAC 地址。所以test2容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过 IP 地址查找对应的 MAC 地址。</span></span><br><span class="line"><span class="comment"># 3. 这个 eth0 网卡，是一个 Veth Pair，它的一端在这个 test2 容器的 Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上。网桥设备的一个特点是插在桥上的网卡都会被当成桥上的一个端口来处理，而端口的唯一作用就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥设备处理。</span></span><br><span class="line"><span class="comment"># 4. 因此ARP的广播请求也会由docker0来负责转发，这样网桥就维护了一份端口与mac的信息表，因此针对test2的eth0拿到mac地址后发出的各类请求，同样走到docker0网桥中由网桥负责转发到对应的容器中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网桥会维护一份mac映射表，我们可以在宿主机大概通过命令来看一下</span></span><br><span class="line">$ brctl showmacs docker0</span><br><span class="line"><span class="comment">## 这些mac地址是主机端的veth网卡对应的mac，可以查看一下</span></span><br><span class="line">$ ip a</span><br></pre></td></tr></table></figure><p><img src="/post/docker/bridge-network.png" alt="网桥网络"></p><p>我们如何知道网桥上的这些虚拟网卡与容器端是如何对应？</p><p>通过ifindex，网卡索引号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看test1容器的网卡索引</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti test1 <span class="built_in">cat</span> /sys/class/net/eth0/ifindex</span><br><span class="line"></span><br><span class="line"><span class="comment">## 主机中找到虚拟网卡后面这个@ifxx的值，如果是同一个值，说明这个虚拟网卡和这个容器的eth0网卡是配对的。</span></span><br><span class="line">$ ip a |grep @<span class="keyword">if</span></span><br></pre></td></tr></table></figure><p>整理脚本，快速查看对应：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> container <span class="keyword">in</span> $(docker ps -q); <span class="keyword">do</span></span><br><span class="line">    iflink=`docker <span class="built_in">exec</span> -it <span class="variable">$container</span> sh -c <span class="string">&#x27;cat /sys/class/net/eth0/iflink&#x27;</span>`</span><br><span class="line">    iflink=`<span class="built_in">echo</span> <span class="variable">$iflink</span>|<span class="built_in">tr</span> -d <span class="string">&#x27;\r&#x27;</span>`</span><br><span class="line">    veth=`grep -l <span class="variable">$iflink</span> /sys/class/net/veth*/ifindex`</span><br><span class="line">    veth=`<span class="built_in">echo</span> <span class="variable">$veth</span>|sed -e <span class="string">&#x27;s;^.*net/\(.*\)/ifindex$;\1;&#x27;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$container</span>:<span class="variable">$veth</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上面我们讲解了容器之间的通信，那么容器与宿主机的通信是如何做的？</p><p>添加端口映射：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动容器的时候通过-p参数添加宿主机端口与容器内部服务端口的映射</span></span><br><span class="line">$ docker run --name <span class="built_in">test</span> -d -p 8088:80 nginx:alpine</span><br><span class="line">$ curl localhost:8088</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>端口映射如何实现的？先来回顾iptables链表图</p><p><img src="/post/docker/iptables.png" alt="iptables"></p><blockquote><p>iptables运维 <a href="https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables">https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables</a></p></blockquote><p>访问本机的8088端口，数据包会从流入方向进入本机，因此涉及到PREROUTING和INPUT链，我们是通过做宿主机与容器之间加的端口映射，所以肯定会涉及到端口转换，那哪个表是负责存储端口转换信息的呢，就是nat表，负责维护网络地址转换信息的。因此我们来查看一下PREROUTING链的nat表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL PREROUTING</span><br><span class="line">Chain PREROUTING (policy ACCEPT 159 packets, 20790 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    3   156 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><p>规则利用了iptables的addrtype拓展，匹配网络类型为本地的包，如何确定哪些是匹配本地，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show table <span class="built_in">local</span> <span class="built_in">type</span> <span class="built_in">local</span></span><br><span class="line">127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1</span><br><span class="line">127.0.0.1 dev lo proto kernel scope host src 127.0.0.1</span><br><span class="line">172.17.0.1 dev docker0 proto kernel scope host src 172.17.0.1</span><br><span class="line">172.21.51.143 dev eth0 proto kernel scope host src 172.21.51.143</span><br></pre></td></tr></table></figure><p>也就是说目标地址类型匹配到这些的，会转发到我们的TARGET中，TARGET是动作，意味着对符合要求的数据包执行什么样的操作，最常见的为ACCEPT或者DROP，此处的TARGET为DOCKER，很明显DOCKER不是标准的动作，那DOCKER是什么呢？我们通常会定义自定义的链，这样把某类对应的规则放在自定义链中，然后把自定义的链绑定到标准的链路中，因此此处DOCKER 是自定义的链。那我们现在就来看一下DOCKER这个自定义链上的规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL DOCKER</span><br><span class="line">Chain DOCKER (2 references)                                                                                                </span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination                                            </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0                                             </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8088 to:172.17.0.2:80 </span><br></pre></td></tr></table></figure><p>此条规则就是对主机收到的目的端口为8088的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，172.17.0.2地址是不是就是我们上面创建的Docker容器的ip地址，流量走到网桥上了，后面就走网桥的转发就ok了。<br>所以，外界只需访问172.21.51.143:8088就可以访问到容器中的服务了。</p><p><img src="/post/docker/docker-network-request.drawio.png" alt="docker网络访问"></p><p>数据包在出口方向走POSTROUTING链，我们查看一下规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nvL POSTROUTING</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 1099 packets, 67268 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">   86  5438 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       172.17.0.4           172.17.0.4           tcp dpt:80</span><br></pre></td></tr></table></figure><p>大家注意MASQUERADE这个动作是什么意思，其实是一种更灵活的SNAT，把源地址转换成主机的出口ip地址，那解释一下这条规则的意思:</p><p>这条规则会将源地址为172.17.0.0&#x2F;16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。大概的过程就是ACK的包在容器里面发出来，会路由到网桥docker0，网桥根据宿主机的路由规则会转给宿主机网卡eth0，这时候包就从docker0网卡转到eth0网卡了，并从eth0网卡发出去，这时候这条规则就会生效了，把源地址换成了eth0的ip地址。</p><blockquote><p>注意一下，刚才这个过程涉及到了网卡间包的传递，那一定要打开主机的ip_forward转发服务，要不然包转不了，服务肯定访问不到。</p></blockquote><h3 id="抓包演示"><a href="#抓包演示" class="headerlink" title="抓包演示"></a>抓包演示</h3><p>我们先想一下，我们要抓哪个网卡的包</p><ul><li><p>首先访问宿主机的8088端口，我们抓一下宿主机的eth0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i eth0 port 8088 -w host.cap</span><br></pre></td></tr></table></figure></li><li><p>然后最终包会流入容器内，那我们抓一下容器内的eth0网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器内安装一下tcpdump</span></span><br><span class="line">$ sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27;</span> /etc/apk/repositories</span><br><span class="line">$ apk add tcpdump</span><br><span class="line">$ tcpdump -i eth0 port 80 -w container.cap</span><br></pre></td></tr></table></figure></li></ul><p>到另一台机器访问一下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl 172.21.51.143:8088/</span><br></pre></td></tr></table></figure><p>停止抓包，拷贝容器内的包到宿主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">cp</span> <span class="built_in">test</span>:/root/container.cap /root/</span><br></pre></td></tr></table></figure><p>把抓到的内容拷贝到本地，使用wireshark进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp root@172.21.51.143:/root/*.<span class="built_in">cap</span> /d/packages</span><br></pre></td></tr></table></figure><p>（wireshark合并包进行分析）</p><p><img src="/post/docker/docker-dnat.jpeg" alt="docker dnat"></p><p><img src="/post/docker/docker-snat.jpeg" alt="docker snat"></p><p>进到容器内的包做DNAT，出去的包做SNAT，这样对外面来讲，根本就不知道机器内部是谁提供服务，其实这就和一个内网多个机器公用一个外网IP地址上网的效果是一样的，那这也属于NAT功能的一个常见的应用场景。</p><h2 id="Host模式"><a href="#Host模式" class="headerlink" title="Host模式"></a>Host模式</h2><p>容器内部不会创建网络空间，共享宿主机的网络空间。比如直接通过host模式创建mysql容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --net host -d --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure><p>容器启动后，会默认监听3306端口，由于网络模式是host，因为可以直接通过宿主机的3306端口进行访问服务，效果等同于在宿主机中直接启动mysqld的进程。</p><h2 id="Conatiner模式"><a href="#Conatiner模式" class="headerlink" title="Conatiner模式"></a>Conatiner模式</h2><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p><img src="/post/docker/docker-network-container.jpeg" alt="docker container网络"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动测试容器，共享mysql的网络空间</span></span><br><span class="line">$ docker run -ti --<span class="built_in">rm</span> --net=container:mysql busybox sh</span><br><span class="line">/ <span class="comment"># ip a</span></span><br><span class="line">/ <span class="comment"># netstat -tlp|grep 3306</span></span><br><span class="line">/ <span class="comment"># telnet localhost 3306</span></span><br></pre></td></tr></table></figure><p>在一些特殊的场景中非常有用，例如，kubernetes的pod，kubernetes为pod创建一个基础设施容器，同一pod下的其他容器都以container模式共享这个基础设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。</p><h2 id="None模式"><a href="#None模式" class="headerlink" title="None模式"></a>None模式</h2><p>只会创建对应的网络空间，不会配置网络堆栈（网卡、路由等）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建none的容器</span></span><br><span class="line">$ docker run -it  --name=network-none --net=none nginx:alpine sh</span><br><span class="line"><span class="comment"># ifconfig</span></span><br></pre></td></tr></table></figure><p>为了能让这个模式的docker容器能够访问外部网络，我们需要手动的创建虚拟网卡对，并将一端插入到docker0网桥中，另一端插入到容器的网络空间中。其本质就是bridge模式的实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟网卡对</span></span><br><span class="line">$ ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line"><span class="comment"># A端插入到docker0网桥</span></span><br><span class="line">$ brctl addif docker0 A</span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br><span class="line"></span><br><span class="line"><span class="comment"># B端插入到network-none容器中，需要借助ip netns,因此需要显示的创建命名network namespace</span></span><br><span class="line">$ PID=$(docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> network-none)</span><br><span class="line">$ <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ <span class="built_in">ln</span> -s /proc/<span class="variable">$PID</span>/ns/net /var/run/netns/<span class="variable">$PID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># B端放到容器的命名空间</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> B netns <span class="variable">$PID</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev B name eth0  <span class="comment"># 修改设备名称为eth0，和docker默认行为一致</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置ip</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip addr add 172.17.0.100/16 dev eth0</span><br><span class="line"><span class="comment"># 添加默认路由，指定给docker0网桥</span></span><br><span class="line">$ ip netns <span class="built_in">exec</span> <span class="variable">$PID</span> ip route add default via 172.17.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试容器间通信</span></span><br></pre></td></tr></table></figure><p>前置知识：</p><ul><li>ip netns 命令用来管理 network namespace。它可以创建命名的 network namespace，然后通过名字来引用 network namespace</li><li>network namespace 在逻辑上是网络堆栈的一个副本，它有自己的路由、防火墙规则和网络设备。<br>默认情况下，子进程继承其父进程的 network namespace。也就是说，如果不显式创建新的 network namespace，所有进程都从 init 进程继承相同的默认 network namespace。</li><li>根据约定，命名的 network namespace 是可以打开的 <strong>&#x2F;var&#x2F;run&#x2F;netns&#x2F;</strong> 目录下的一个对象。比如有一个名称为 net1 的 network namespace 对象，则可以由打开 &#x2F;var&#x2F;run&#x2F;netns&#x2F;net1 对象产生的文件描述符引用 network namespace net1。通过引用该文件描述符，可以修改进程的 network namespace。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 运行原理</title>
      <link href="/docker-service-running-principle/"/>
      <url>/docker-service-running-principle/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>docker优势主要是轻量级的虚拟化以及容器快速启停。</p><p>而虚拟化核心需要解决两个问题：资源隔离与资源限制</p><ul><li>虚拟机硬件虚拟化技术， 通过一个 hypervisor 层实现对资源的彻底隔离。</li><li>容器则是操作系统级别的虚拟化，利用的是内核的 Cgroup 和 Namespace 特性，此功能完全通过软件实现。</li></ul><span id="more"></span><h2 id="Namespace-资源隔离"><a href="#Namespace-资源隔离" class="headerlink" title="Namespace 资源隔离"></a>Namespace 资源隔离</h2><p>命名空间是全局资源的一种抽象，将资源放到不同的命名空间中，各个命名空间中的资源是相互隔离的。</p><table><thead><tr><th><strong>分类</strong></th><th><strong>系统调用参数</strong></th><th><strong>相关内核版本</strong></th></tr></thead><tbody><tr><td>Mount namespaces</td><td>CLONE_NEWNS</td><td><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux 2.4.19</a></td></tr><tr><td>UTS namespaces</td><td>CLONE_NEWUTS</td><td><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td></tr><tr><td>IPC namespaces</td><td>CLONE_NEWIPC</td><td><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td></tr><tr><td>PID namespaces</td><td>CLONE_NEWPID</td><td><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td></tr><tr><td>Network namespaces</td><td>CLONE_NEWNET</td><td><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td></tr><tr><td>User namespaces</td><td>CLONE_NEWUSER</td><td><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于 Linux 3.8</a></td></tr></tbody></table><p>我们知道，docker容器对于操作系统来讲其实是一个进程，我们可以通过原始的方式来模拟一下容器实现资源隔离的基本原理：</p><p>linux系统中，通常可以通过<code>clone()</code>实现进程创建的系统调用 ，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*child_func)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>child_func</strong> : 传入子进程运行的程序主函数。</li><li><strong>child_stack</strong> : 传入子进程使用的栈空间。</li><li><strong>flags</strong> : 表示使用哪些 <code>CLONE_*</code> 标志位。</li><li><strong>args</strong> : 用于传入用户参数。</li></ul><p>示例一：实现进程独立的UTS空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">  <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">  sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">  execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD , <span class="literal">NULL</span>);</span><br><span class="line">  waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行编译并测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o ns_uts ns_uts.c</span><br><span class="line">$ ./ns_uts</span><br><span class="line">$ hostname</span><br></pre></td></tr></table></figure><p>示例二：实现容器独立的进程空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">  <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line">  sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">  execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">  <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD , <span class="literal">NULL</span>);</span><br><span class="line">  waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行编译并测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o ns_pid ns_pid.c</span><br><span class="line">$ ./ns_pid</span><br><span class="line">$ <span class="built_in">echo</span> $$</span><br></pre></td></tr></table></figure><p>如何确定进程是否属于同一个namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ./ns_pid</span><br><span class="line">Parent [ 8061] - start a container!</span><br><span class="line">$ pstree -p 8061</span><br><span class="line">pid1(8061)───bash(8062)───pstree(8816)</span><br><span class="line">$ <span class="built_in">ls</span> -l /proc/8061/ns</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 net -&gt; net:[4026531968]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 uts -&gt; uts:[4026531838]</span><br><span class="line">$ <span class="built_in">ls</span> -l /proc/8062/ns</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 net -&gt; net:[4026531968]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 pid -&gt; pid:[4026534845]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 24 12:51 uts -&gt; uts:[4026534844]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 发现pid和uts是和父进程使用了不同的ns，其他的则是继承了父进程的命名空间</span></span><br></pre></td></tr></table></figure><p>综上：通俗来讲，docker在启动一个容器的时候，会调用Linux Kernel<br>Namespace的接口，来创建一块虚拟空间，创建的时候，可以支持设置下面这几种（可以随意选择）,docker默认都设置。</p><ul><li>pid：用于进程隔离（PID：进程ID）</li><li>net：管理网络接口（NET：网络）</li><li>ipc：管理对 IPC 资源的访问（IPC：进程间通信（信号量、消息队列和共享内存））</li><li>mnt：管理文件系统挂载点（MNT：挂载）</li><li>uts：隔离主机名和域名</li><li>user：隔离用户和用户组</li></ul><blockquote><p>linux namespace 可以支持创建进程的时候，通过参数传递（CLONE_NEW*）来确定这个新启动的进程以及进程衍生的子进程是否拥有独立的进程空间，网络空间，文件系统空间，用户空间等等。<br>docker容器对于宿主机来说，其实就是一个进程，创建容器时，给这个容器进程指定了独立的进程空间，网络空间，文件系统空间，用户空间等等，这样就实现了容器的资源隔离。</p></blockquote><h2 id="CGroup-资源限制"><a href="#CGroup-资源限制" class="headerlink" title="CGroup 资源限制"></a>CGroup 资源限制</h2><p>通过namespace可以保证容器之间的隔离，但是无法控制每个容器可以占用多少资源， 如果其中的某一个容器正在执行 CPU<br>密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题。</p><p><img src="/post/docker/cgroup.png" alt="cgroup"></p><p>Control Groups（简称 CGroups）</p><blockquote><p>cgroups是Linux内核提供的一种机制，这种机制可以根据需求吧一系列系统任务及其子任务整合(或分隔)<br>到按资源划分等级的不同组中，从而为系统资源管理提供一个统一的框架。</p></blockquote><p>CGroups能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I&#x2F;O 。每一个 CGroup<br>都是一组被相同的标准和参数限制的进程。而我们需要做的，其实就是把容器这个进程加入到指定的Cgroup中。</p><p>验证cgroup的内存限制：</p><ul><li><p>准备一个程序，每秒钟申请1MB的内存, <code>mem-allocate.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MB (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MB);</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, MB);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dM memory allocated\n&quot;</span>, ++i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建cgroup文件及脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/fs/cgroup/memory/</span><br><span class="line"><span class="built_in">mkdir</span> -p memory-process &amp;&amp; <span class="built_in">cd</span> memory-process</span><br><span class="line"><span class="built_in">echo</span> 30M &gt; memory.limit_in_bytes </span><br><span class="line">gcc mem-allocate.c -o mem-allocate</span><br></pre></td></tr></table></figure></li><li><p>准备脚本<code>cgroup-test.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> 30</span><br><span class="line">./mem-allocate</span><br></pre></td></tr></table></figure></li><li><p>用cgroup限制进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动程序</span></span><br><span class="line">./cgroup-test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看程序进程</span></span><br><span class="line">ps aux|grep cgroup-test</span><br><span class="line"><span class="built_in">echo</span> 16079 &gt; /sys/fs/cgroup/memory/memory-process/cgroup.procs</span><br></pre></td></tr></table></figure></li></ul><h2 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS 联合文件系统"></a>UnionFS 联合文件系统</h2><p>Linux namespace和cgroup分别解决了容器的资源隔离与资源限制，那么容器是很轻量的，通常每台机器中可以运行几十上百个容器，<br>这些个容器是共用一个image，还是各自将这个image复制了一份，然后各自独立运行呢？</p><p>如果每个容器之间都是全量的文件系统拷贝，那么会导致至少如下问题：</p><ul><li>运行容器的速度会变慢</li><li>容器和镜像对宿主机的磁盘空间的压力</li></ul><p>怎么解决这个问题呢？这就需要联合文件系统（UnionFS）了。</p><p>Docker使用了UnionFS的存储驱动。</p><ul><li>镜像分层存储 + 写时复制</li><li>UnionFS</li></ul><p>Docker 镜像是由一系列的层组成的，每层代表 Dockerfile 中的一条指令，比如下面的 Dockerfile 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">15.04</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> python /app/app.py</span></span><br></pre></td></tr></table></figure><p>这里的 Dockerfile 包含4条命令，其中每一行就创建了一层，下面显示了上述Dockerfile构建出来的镜像运行的容器层的结构。</p><p><img src="/post/docker/container-layers.jpg" alt="container-layers"></p><p>镜像就是由这些层一层一层堆叠起来的，镜像中的这些层都是只读的，当我们运行容器的时候，就可以在这些基础层至上添加新的可写层，也就是我们通常说的<code>容器层</code><br>，对于运行中的容器所做的所有更改（比如写入新文件、修改现有文件、删除文件）都将写入这个容器层。</p><p>对容器层的操作，主要利用了写时复制（CoW）技术。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景。<br>CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论有多少个容器共享同一个image，所做的写操作都是对从image中复制到自己的文件系统中的复本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离，相互不影响。使用CoW可以有效的提高磁盘的利用率。</p><p><img src="/post/docker/sharing-layers.jpg" alt="sharing-layers"></p><p><strong>镜像中每一层的文件都是分散在不同的目录中的，如何把这些不同目录的文件整合到一起呢？</strong></p><p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统联合到同一个挂载点的文件系统服务。它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，整个联合的过程被称为联合挂载（Union<br>Mount）。</p><p><img src="/post/docker/aufs.png" alt="aufs"></p><p>上图是AUFS的实现，AUFS是作为Docker存储驱动的一种实现，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和<br>Btrfs 等等，在最新的 Docker 中，overlay2 取代了 aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs<br>作为 Docker 的默认驱动。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sphinx - python文档生成器</title>
      <link href="/sphinx-python-documentation-generator/"/>
      <url>/sphinx-python-documentation-generator/</url>
      
        <content type="html"><![CDATA[<h1 id="Sphinx"><a href="#Sphinx" class="headerlink" title="Sphinx"></a>Sphinx</h1><p>Sphinx 是一个python第三方库，它将一组纯文本源文件转换为各种输出格式的工具，自动生成交叉引用、索引等，也就是说，如果您有一个包含 reStructuredText 或 Markdown 的源代码注释等，Sphinx可以生成一系列HTML文件、PDF文件（通过LaTeX）、手册页等等。</p><p>Sphinx专注于文档，特别是手写文档，然而，Sphinx也可以用来生成博客、主页甚至书籍。Sphinx的大部分功能来自其默认纯文本标记格式（reStructuredText）的丰富性。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先我们先安装它，使用pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sphinx</span><br></pre></td></tr></table></figure><p>安装之后可以替换主题，如果你有一个特定的主题，你可以使用pip安装它，例如，我们使用sphinx_rtd_theme主题，主题会主动安装sphinx，所以如果我们直接安装主题，上一步的安装可以省略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install sphinx_rtd_theme</span><br></pre></td></tr></table></figure><p>安装完成后可以使用命令sphinx-build查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-build --version</span><br><span class="line">sphinx-build 6.2.1</span><br></pre></td></tr></table></figure><h2 id="设置文档源"><a href="#设置文档源" class="headerlink" title="设置文档源"></a>设置文档源</h2><p>Sphinx纯文本文档源集合的根目录称为 source directory . 此目录还包含sphinx配置文件 conf.py ，在这里您可以配置Sphinx如何读取源代码和构建文档的所有方面。 </p><p>Sphinx有一个命令叫 sphinx-quickstart 设置源目录并创建默认 conf.py 从几个问题中配置最有用的配置值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sphinx-quickstart docs</span><br></pre></td></tr></table></figure><p>以下是我创建的时候的信息，其中 &gt; 表示输入，[] 表示默认值。这里可以根据需要进行设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-quickstart docs</span><br><span class="line">欢迎使用 Sphinx 6.2.1 快速配置工具。</span><br><span class="line"></span><br><span class="line">请输入接下来各项设定的值（如果方括号中指定了默认值，直接</span><br><span class="line">按回车即可使用默认值）。</span><br><span class="line"></span><br><span class="line">已选择根路径：docs</span><br><span class="line"></span><br><span class="line">有两种方式来设置用于放置 Sphinx 输出的构建目录：</span><br><span class="line">一是在根路径下创建“_build”目录，二是在根路径下创建“<span class="built_in">source</span>”</span><br><span class="line">和“build”两个独立的目录。</span><br><span class="line">&gt; 独立的源文件和构建目录（y/n） [n]: y</span><br><span class="line"></span><br><span class="line">项目名称将会出现在文档的许多地方。</span><br><span class="line">&gt; 项目名称: Lumache</span><br><span class="line">&gt; 作者名称: aaron</span><br><span class="line">&gt; 项目发行版本 []: 1.0</span><br><span class="line"></span><br><span class="line">如果用英语以外的语言编写文档，</span><br><span class="line">你可以在此按语言代码选择语种。</span><br><span class="line">Sphinx 会把内置文本翻译成相应语言的版本。</span><br><span class="line"></span><br><span class="line">支持的语言代码列表见：</span><br><span class="line">https://www.sphinx-doc.org/en/master/usage/configuration.html<span class="comment">#confval-language。</span></span><br><span class="line">&gt; 项目语种 [en]:</span><br><span class="line"></span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/source/conf.py。</span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/source/index.rst。</span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/Makefile。</span><br><span class="line">正在创建文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/make.bat。</span><br><span class="line"></span><br><span class="line">完成：已创建初始目录结构。</span><br><span class="line"></span><br><span class="line">你现在可以填写主文档文件 /home/aaron/projects/PycharmProjects/TheM78Nebula/docs/source/index.rst 然后创建其他文档源文件了。 像这样用 Makefile 构建文档：</span><br><span class="line">  make builder</span><br><span class="line">此处的“builder”代指支持的构建器名称，比如 html、latex 或 linkcheck。</span><br></pre></td></tr></table></figure><p>全部完成之后，我们可以看到docs目录下的文件结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docs</span><br><span class="line">├── build</span><br><span class="line">├── make.bat</span><br><span class="line">├── Makefile</span><br><span class="line">└── <span class="built_in">source</span></span><br><span class="line">    ├── conf.py</span><br><span class="line">    ├── index.rst</span><br><span class="line">    ├── _static</span><br><span class="line">    └── _templates</span><br></pre></td></tr></table></figure><p>这些文件中的每个文件的目的是：</p><ul><li>build&#x2F; 一个空目录(目前)，它将保存呈现的文档。</li><li>make.bat and Makefile 方便的脚本可以简化一些常见的Sphinx操作，比如呈现内容。</li><li>source&#x2F;conf.py 保存Sphinx项目配置的一个Python脚本。它包含您为指定的项目名称和版本 sphinx-quickstart ，以及一些额外的配置密钥。</li><li>source&#x2F;index.rst 这个 root document 作为欢迎页面，并包含“目录树”的根(或 toctree )。</li></ul><p>现在运行以下命令，这样我们就可以得到一个空白的HTML文档了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sphinx-build -b html docs/source/ docs/build/html</span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在创建输出目录... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 1 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[新配置] 有 1 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] index                                                     </span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[100%] index                                                       </span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 docs/build/html 目录。</span><br></pre></td></tr></table></figure><p>然后在浏览器中打开 docs&#x2F;build&#x2F;html&#x2F;index.html ，你就可以看到一个简单的欢迎页面了。</p><p><img src="/post/sphinx/sphinx-first-show.png" alt="sphinx简单欢迎页"></p><h2 id="构建文档"><a href="#构建文档" class="headerlink" title="构建文档"></a>构建文档</h2><p>这里显示的首页就是docs&#x2F;source&#x2F;index.rst中的内容，我们可以在这里添加一些内容，然后重新构建文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.. Lumache documentation master file, created by</span><br><span class="line">   sphinx-quickstart on Mon May 22 23:33:09 2023.</span><br><span class="line">   You can adapt this file completely to your liking, but it should at least</span><br><span class="line">   contain the root `toctree` directive.</span><br><span class="line"></span><br><span class="line">Welcome to Lumache<span class="string">&#x27;s documentation!</span></span><br><span class="line"><span class="string">===================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.. toctree::</span></span><br><span class="line"><span class="string">   :maxdepth: 2</span></span><br><span class="line"><span class="string">   :caption: Contents:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**Lumache** (/lu&#x27;</span>make/) is a Python library <span class="keyword">for</span> cooks and food lovers that</span><br><span class="line">creates recipes mixing random ingredients.  It pulls data from the `Open Food</span><br><span class="line">Facts database &lt;https://world.openfoodfacts.org/&gt;`_ and offers a *simple* and</span><br><span class="line">*intuitive* API.</span><br><span class="line"></span><br><span class="line">.. note::</span><br><span class="line"></span><br><span class="line">   This project is under active development.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>它展示了reStrutiredText语法的几个功能，包括：</p><pre><code>- 使用 === 标记了一个标题- 以下两个示例的内联标记：**strong emphasis** (通常为粗体)和 *emphasis* (通常为斜体)- 一个行内的链接 (用于链接到 Open Food Facts)- 一个 note 提示</code></pre><p>现在，要使用新内容，可以使用刚才用过的 sphinx-build 命令，或者按如下方式利用make脚本生成，注意，这种方式需要系统中安装有make程序：、</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> docs</span><br><span class="line">$ make html</span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 1 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[新配置] 有 1 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] index                                                                                                                                                          </span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[100%] index                                                                                                                                                            </span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 build/html 目录。</span><br></pre></td></tr></table></figure><p>运行完成之后，再次打开docs&#x2F;build&#x2F;html&#x2F;index.html，你就可以看到新的内容了。</p><p><img src="/post/sphinx/index-new-content.png" alt="欢迎页新内容"></p><p>当然，sphinx还支持其他的文档格式，比如PDF，ePub等，这里就不再赘述了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># epub 格式生成方式</span><br><span class="line">$ make epub</span><br></pre></td></tr></table></figure><h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><p>sphinx还有很多内置的扩展来定制化功能。</p><h3 id="内置扩展"><a href="#内置扩展" class="headerlink" title="内置扩展"></a>内置扩展</h3><p>比如我们找到 docs&#x2F;source&#x2F;conf.py 添加一个扩展，这个扩展可以显示页面集成的时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docs/source/conf.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add any Sphinx extension module names here, as strings. They can be</span></span><br><span class="line"><span class="comment"># extensions coming with Sphinx (named &#x27;sphinx.ext.*&#x27;) or your custom</span></span><br><span class="line"><span class="comment"># ones.</span></span><br><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>添加扩展之后，就能在控制台输出的末尾看到页面生成的时间了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ make html</span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 0 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[扩展发生了变化 (<span class="string">&#x27;sphinx.ext.duration&#x27;</span>)] 有 1 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] index</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[100%] index</span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line"></span><br><span class="line">====================== 最长读取耗时 =======================</span><br><span class="line">0.030 index</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 build/html 目录。</span><br></pre></td></tr></table></figure><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>还记得我们在刚开始创建项目的时候，我们安装一个第三方的主题吗？这里我们可以修改 conf.py 来更换主题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The theme to use for HTML and HTML Help pages.  See the documentation for</span></span><br><span class="line"><span class="comment"># a list of builtin themes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">html_theme = <span class="string">&#x27;sphinx_rtd_theme&#x27;</span></span><br></pre></td></tr></table></figure><p>更改后，我们重新生成页面，就能看到新的主题了。</p><p>!(new theme)[&#x2F;post&#x2F;sphinx&#x2F;new-theme.png]</p><h2 id="叙事性文档"><a href="#叙事性文档" class="headerlink" title="叙事性文档"></a>叙事性文档</h2><h3 id="跨多页组织文档"><a href="#跨多页组织文档" class="headerlink" title="跨多页组织文档"></a>跨多页组织文档</h3><p>终于开始写文档了，我们可以在 docs&#x2F;source 目录下创建一个新的文件，比如 usage.rst ，然后在 index.rst 中添加一个链接到这个文件。</p><p>首先编写 usage.rst 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>这个新文件包含两个 section 页眉、普通段落文本和 code-block 指令</p><p>code-block 指令将内容块呈现为源代码，并使用适当的语法突出显示(在本例中为泛型 console 文本)。</p><p>文档的结构由一系列标题样式决定，这意味着通过使用 — 的 “Installation” 以及之后的部分，对于使用 &#x3D;&#x3D;&#x3D; 的 “Usage” 部分，您已经将 “Installation” 声明为 subsection “用法”的概念。</p><p>要为了完成显示，您还需要在 index.rst 添加一个 usage.rst 的链接，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Lumache&#x27;s documentation!</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   usage</span><br><span class="line">   </span><br><span class="line">**Lumache** (/lu&#x27;make/) is a Python library for cooks and food lovers that</span><br><span class="line">creates recipes mixing random ingredients.  It pulls data from the `Open Food</span><br><span class="line">Facts database &lt;https://world.openfoodfacts.org/&gt;`_ and offers a *simple* and</span><br><span class="line">*intuitive* API.</span><br><span class="line"></span><br><span class="line">.. note::</span><br><span class="line"></span><br><span class="line">   This project is under active development.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>更新页面，就能看到新的内容了。</p><blockquote><p>警告</p><p>外部文档 toctree 将导致 WARNING: document isn’t included in any toctree 消息，并且用户将无法访问。</p></blockquote><p><img src="/post/sphinx/doc-link01.png" alt="跨多页组织链接01"></p><p><img src="/post/sphinx/doc-link02.png" alt="跨多页组织链接02"></p><h3 id="添加交叉引用"><a href="#添加交叉引用" class="headerlink" title="添加交叉引用"></a>添加交叉引用</h3><p>Sphinx的一个强大功能是能够无缝地添加 cross-references 文档的特定部分：文档、章节、图形、代码对象等。</p><p>要添加交叉引用，请将这句话添加到 index.rst 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.. Lumache documentation master file, created by</span><br><span class="line">   sphinx-quickstart on Mon May 22 23:33:09 2023.</span><br><span class="line">   You can adapt this file completely to your liking, but it should at least</span><br><span class="line">   contain the root `toctree` directive.</span><br><span class="line"></span><br><span class="line">Welcome to Lumache&#x27;s documentation!</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   usage</span><br><span class="line"></span><br><span class="line">Check out the :doc:`usage` section for further information.</span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>这个 doc 会自动引用项目中的特定文档，在本例中为 usage.rst 。</p><p>当然也可以添加对项目任意部分的交叉引用。为此，需要使用 ref 角色，并添加显式 label ，它的作用就是 a target 。</p><p>例如，修改 usage.rst 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br></pre></td></tr></table></figure><p>并且将 label 添加到 index.rst 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.. Lumache documentation master file, created by</span><br><span class="line">   sphinx-quickstart on Mon May 22 23:33:09 2023.</span><br><span class="line">   You can adapt this file completely to your liking, but it should at least</span><br><span class="line">   contain the root `toctree` directive.</span><br><span class="line"></span><br><span class="line">Welcome to Lumache&#x27;s documentation!</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   usage</span><br><span class="line"></span><br><span class="line">Check out the :doc:`usage` section for further information, including how to</span><br><span class="line">:ref:`install &lt;installation&gt;` the project.</span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>重新生成页面，就能看到新的内容了。</p><h2 id="使用Sphinx描述代码"><a href="#使用Sphinx描述代码" class="headerlink" title="使用Sphinx描述代码"></a>使用Sphinx描述代码</h2><h3 id="记录Python对象"><a href="#记录Python对象" class="headerlink" title="记录Python对象"></a>记录Python对象</h3><p>Sphinx提供了几个角色和指令来记录Python对象，所有这些对象都集中在 <a href="https://www.osgeo.cn/sphinx/usage/restructuredtext/domains.html#python-domain">the Python domain</a> 。例如，可以使用 py:function 指令来记录一个Python函数，这里我们修改usage.rst，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br></pre></td></tr></table></figure><p><img src="/post/sphinx/describing-code01.png" alt="python对象描述"></p><p>请注意以下几点：</p><ul><li>Sphinx解析了 .. py:function 指令，并相应地突出显示模块、函数名和参数。</li><li>指令内容包括对该函数的一行描述，以及 info field list 包含函数参数、其预期类型、返回值和返回类型。</li></ul><blockquote><p>备注</p><p>这个 py: 前缀指定 domain 。您可以配置默认域，以便可以省略前缀，或者全局使用 primary_domain 配置，或使用 default-domain 指令将其从被调用的位置更改到文件的末尾。例如，如果将其设置为 py (默认设置)，您可以编写 .. function:: 直接去吧。</p></blockquote><h3 id="交叉引用Python对象"><a href="#交叉引用Python对象" class="headerlink" title="交叉引用Python对象"></a>交叉引用Python对象</h3><p>默认情况下，这些指令中的大多数生成可以从文档的任何部分交叉引用的实体 (a corresponding role)[<a href="https://www.osgeo.cn/sphinx/usage/restructuredtext/domains.html#python-roles]">https://www.osgeo.cn/sphinx/usage/restructuredtext/domains.html#python-roles]</a> 。对于函数，可以使用 py:func，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br></pre></td></tr></table></figure><p>在生成代码文档时，Sphinx只使用对象的名称自动生成交叉引用，而不必显式使用角色，页面表现为一个链接跳转。</p><p>我们也可以使用属性来描述函数引发的自定义异常，比如py:exception 指令：</p><p>首先定义一个异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.. py:exception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">   Raised if the kind is invalid.</span><br></pre></td></tr></table></figure><p>然后在函数的原始描述中引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :raise lumache.InvalidKindError: If the kind is invalid.</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br></pre></td></tr></table></figure><p>usage.rst 完整内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :raise lumache.InvalidKindError: If the kind is invalid.</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br><span class="line"></span><br><span class="line">.. py:exception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">   Raised if the kind is invalid.</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br></pre></td></tr></table></figure><p>重新更新页面，等待构建完成，就可以看到新的效果了，效果如下所示。</p><p><img src="/post/sphinx/describing-code02.png" alt="python异常描述"></p><h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><p>Sphinx 不仅提供了一种在文档中编写代码示例的方法，还提供了在文档中编写测试的方法。</p><p>这些测试可以在构建文档时运行，以确保文档中的示例代码仍然有效。这些测试称为文档测试，它们使用 <a href="https://docs.python.org/3/library/doctest.html">doctest</a> 模块。</p><p>对于代码描述和正常的代码实现逻辑保持一致是很重要的。在Sphinx中实现这一点的方法之一是在文档中包含代码片段，称为 doctests ，在构建文档时执行。</p><p>要显示这个功能，需要 Sphinx 需要能够导入代码。为了要做到这一点，请在 conf.py 中头部添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If extensions (or modules to document with autodoc) are in another directory,</span></span><br><span class="line"><span class="comment"># add these directories to sys.path here.</span></span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, pathlib.Path(__file__).parents[<span class="number">2</span>].resolve().as_posix())</span><br></pre></td></tr></table></figure><p>这句话的意思是，将项目的根目录添加到 sys.path 中，这样就可以将项目根目录添加到 python 的查找路径，以便在 Sphinx 中执行 Python 命令可以导入项目中的任何模块。</p><blockquote><p>备注</p><p>一种替代更改 sys.path 变量的目的是创建一个 pyproject.toml 文件，并使代码可安装，这样它的行为就像任何其他的Python库一样。然而， sys.path 方法更简单。</p></blockquote><p>然后，再启用 doctest 功能，需要在 conf.py 中添加扩展：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>整体的 conf.py 文件内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ cat source/conf.py</span><br><span class="line"><span class="comment"># Configuration file for the Sphinx documentation builder.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For the full list of built-in configuration values, see the documentation:</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If extensions (or modules to document with autodoc) are in another directory,</span></span><br><span class="line"><span class="comment"># add these directories to sys.path here.</span></span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, pathlib.Path(__file__).parents[<span class="number">2</span>].resolve().as_posix())</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Project information -----------------------------------------------------</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information</span></span><br><span class="line"></span><br><span class="line">project = <span class="string">&#x27;Lumache&#x27;</span></span><br><span class="line">copyright = <span class="string">&#x27;2023, aaron&#x27;</span></span><br><span class="line">author = <span class="string">&#x27;aaron&#x27;</span></span><br><span class="line">release = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- General configuration ---------------------------------------------------</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration</span></span><br><span class="line"></span><br><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">templates_path = [<span class="string">&#x27;_templates&#x27;</span>]</span><br><span class="line">exclude_patterns = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Options for HTML output -------------------------------------------------</span></span><br><span class="line"><span class="comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output</span></span><br><span class="line"></span><br><span class="line">html_theme = <span class="string">&#x27;sphinx_rtd_theme&#x27;</span></span><br><span class="line">html_static_path = [<span class="string">&#x27;_static&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在 source&#x2F;usage.rst 文件中添加一个 doctest 块，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import lumache</span><br><span class="line">&gt;&gt;&gt; lumache.get_random_ingredients()</span><br><span class="line">[&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br></pre></td></tr></table></figure><p>这里我将测试块添加到最后，你也可以根据需要在对应的位置进行添加，整体的 usage.rst 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. py:function:: lumache.get_random_ingredients(kind=None)</span><br><span class="line"></span><br><span class="line">   Return a list of random ingredients as strings.</span><br><span class="line"></span><br><span class="line">   :param kind: Optional &quot;kind&quot; of ingredients.</span><br><span class="line">   :type kind: list[str] or None</span><br><span class="line">   :raise lumache.InvalidKindError: If the kind is invalid.</span><br><span class="line">   :return: The ingredients list.</span><br><span class="line">   :rtype: list[str]</span><br><span class="line"></span><br><span class="line">.. py:exception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">   Raised if the kind is invalid.</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import lumache</span><br><span class="line">&gt;&gt;&gt; lumache.get_random_ingredients()</span><br><span class="line">[&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br></pre></td></tr></table></figure><p>doctest 包括要运行的 Python 指令，前面有 &gt;&gt;&gt; 标准的 Python 解释器提示符，以及每条指令的预期输出。通过这种方式，Sphinx 可以检查实际输出是否与预期输出匹配。</p><p>为了观察 doctest 失败是什么样子(而不是上面的代码错误)，让我们首先不正确地编写返回值。在项目根目录（也就是docs的上级目录）中创建一个 lumache.py 文件，文件内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_ingredients</span>(<span class="params">kind=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a list of random ingredients as strings.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;bacon&quot;</span>, <span class="string">&quot;spam&quot;</span>]</span><br></pre></td></tr></table></figure><p>现在可以运行测试语句来执行文档的测试，显然，这个测试会失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有make程序也可以使用这个语句进行测试 sphinx-build -b doctest <span class="built_in">source</span> build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make doctest</span></span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在创建输出目录... 完成</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [doctest]： 2 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：[扩展发生了变化 (&#x27;sphinx.ext.doctest&#x27;)] 有 2 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[ 50%] index</span><br><span class="line">正在读取源文件……[100%] usage</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">running tests...</span><br><span class="line"></span><br><span class="line">Document: usage</span><br><span class="line">---------------</span><br><span class="line">**********************************************************************</span><br><span class="line">File &quot;usage.rst&quot;, line 42, in default</span><br><span class="line">Failed example:</span><br><span class="line">    lumache.get_random_ingredients()</span><br><span class="line">Expected:</span><br><span class="line">    [&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br><span class="line">Got:</span><br><span class="line">    [&#x27;eggs&#x27;, &#x27;bacon&#x27;, &#x27;spam&#x27;]</span><br><span class="line">**********************************************************************</span><br><span class="line">1 items had failures:</span><br><span class="line">   1 of   2 in default</span><br><span class="line">2 tests in 1 items.</span><br><span class="line">1 passed and 1 failed.</span><br><span class="line">***Test Failed*** 1 failures.</span><br><span class="line"></span><br><span class="line">Doctest summary</span><br><span class="line">===============</span><br><span class="line">    2 tests</span><br><span class="line">    1 failure in tests</span><br><span class="line">    0 failures in setup code</span><br><span class="line">    0 failures in cleanup code</span><br><span class="line"></span><br><span class="line">====================== 最长读取耗时 =======================</span><br><span class="line">0.030 usage</span><br><span class="line">0.027 index</span><br><span class="line">构建完成但存在问题。</span><br><span class="line">make: *** [Makefile:20：doctest] 错误 1</span><br></pre></td></tr></table></figure><p>现在，我们将代码进行修改，使其通过测试，修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_ingredients</span>(<span class="params">kind=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a list of random ingredients as strings.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;shells&quot;</span>, <span class="string">&quot;gorgonzola&quot;</span>, <span class="string">&quot;parsley&quot;</span>]</span><br></pre></td></tr></table></figure><p>再次运行测试，可以看到测试通过了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [doctest]： 2 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：有 0 个新增文件，有 0 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">running tests...</span><br><span class="line"></span><br><span class="line">Document: usage</span><br><span class="line">---------------</span><br><span class="line">1 items passed all tests:</span><br><span class="line">   2 tests in default</span><br><span class="line">2 tests in 1 items.</span><br><span class="line">2 passed and 0 failed.</span><br><span class="line">Test passed.</span><br><span class="line"></span><br><span class="line">Doctest summary</span><br><span class="line">===============</span><br><span class="line">    2 tests</span><br><span class="line">    0 failures in tests</span><br><span class="line">    0 failures in setup code</span><br><span class="line">    0 failures in cleanup code</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">已完成源文件的文档测试，结果保存在 build/doctest/output.txt 中，请查阅。</span><br></pre></td></tr></table></figure><h2 id="自动生成文档"><a href="#自动生成文档" class="headerlink" title="自动生成文档"></a>自动生成文档</h2><p>Sphinx 可以根据代码中的 docstring 自动生成文档，这样可以减少文档的编写工作量，同时也可以保证文档与代码的一致性。</p><h3 id="文档字符串自动生成文档"><a href="#文档字符串自动生成文档" class="headerlink" title="文档字符串自动生成文档"></a>文档字符串自动生成文档</h3><p>要使用这个功能，需要先启动 Sphinx 的 autodoc 扩展。在 conf.py 文件中添加如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.autodoc&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接下来我们先将 lumache.py 文件中的代码进行修改，添加一个异常类以及函数的docstring，修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InvalidKindError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Raised if the kind is invalid.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_ingredients</span>(<span class="params">kind=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return a list of random ingredients as strings.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param kind: Optional &quot;kind&quot; of ingredients.</span></span><br><span class="line"><span class="string">    :type kind: list[str] or None</span></span><br><span class="line"><span class="string">    :raise lumache.InvalidKindError: If the kind is invalid.</span></span><br><span class="line"><span class="string">    :return: The ingredients list.</span></span><br><span class="line"><span class="string">    :rtype: list[str]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;shells&quot;</span>, <span class="string">&quot;gorgonzola&quot;</span>, <span class="string">&quot;parsley&quot;</span>]</span><br></pre></td></tr></table></figure><p>然后，将 .. py:function 和 .. py:exception 标记指向原始的 python 文件，使用自动生成字段 autofunction 、 autoexception 添加到文档中，这样 Sphinx 就会自动将这些内容添加到文档中。</p><p>修改后的 usage.rst 文档如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Usage</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">.. _installation:</span><br><span class="line"></span><br><span class="line">Installation</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">To use Lumache, first install it using pip:</span><br><span class="line"></span><br><span class="line">.. code-block:: console</span><br><span class="line"></span><br><span class="line">   (.venv) $ pip install lumache</span><br><span class="line"></span><br><span class="line">Creating recipes</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">To retrieve a list of random ingredients,</span><br><span class="line">you can use the ``lumache.get_random_ingredients()`` function:</span><br><span class="line"></span><br><span class="line">.. autofunction:: lumache.get_random_ingredients</span><br><span class="line"></span><br><span class="line">.. autoexception:: lumache.InvalidKindError</span><br><span class="line"></span><br><span class="line">The ``kind`` parameter should be either ``&quot;meat&quot;``, ``&quot;fish&quot;``,</span><br><span class="line">or ``&quot;veggies&quot;``. Otherwise, :py:func:`lumache.get_random_ingredients`</span><br><span class="line">will raise an exception.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import lumache</span><br><span class="line">&gt;&gt;&gt; lumache.get_random_ingredients()</span><br><span class="line">[&#x27;shells&#x27;, &#x27;gorgonzola&#x27;, &#x27;parsley&#x27;]</span><br></pre></td></tr></table></figure><p>现在，运行 make html 命令，可以看到文档中已经包含了我们添加的内容，和之前手写的文档没有什么不同：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make html</span></span><br><span class="line">正在运行 Sphinx v6.2.1</span><br><span class="line">正在加载 Pickle 序列化的环境... 完成</span><br><span class="line">正在构建 [mo]： 0 个 po 文件的目标文件已过期</span><br><span class="line">正在写入输出……</span><br><span class="line">正在构建 [html]： 0 个源文件的目标文件已过期</span><br><span class="line">正在更新环境：有 0 个新增文件，有 1 个文件已被修改，有 0 个文件已被移除</span><br><span class="line">正在读取源文件……[100%] usage</span><br><span class="line">正在查找当前已过期的文件……没有找到已过期文件</span><br><span class="line">正在 Pickle 序列化环境... 完成</span><br><span class="line">正在校验一致性... 完成</span><br><span class="line">正在准备写入文档... 完成</span><br><span class="line">正在写入输出……[ 50%] index</span><br><span class="line">正在写入输出……[100%] usage</span><br><span class="line">正在生成索引... genindex 完成</span><br><span class="line">正在写入附加页面... search 完成</span><br><span class="line">正在复制静态文件... 完成</span><br><span class="line">正在复制额外文件... 完成</span><br><span class="line">正在导出 English (code: en) 的搜索索引... 完成</span><br><span class="line">正在导出对象清单... 完成</span><br><span class="line"></span><br><span class="line">====================== 最长读取耗时 =======================</span><br><span class="line">0.049 usage</span><br><span class="line">构建成功。</span><br><span class="line"></span><br><span class="line">HTML 页面保存在 build/html 目录。</span><br></pre></td></tr></table></figure><p><img src="/post/sphinx/autodoc.png" alt="使用签名和文档字符串自动生成文档"></p><h3 id="生成全面的API参考"><a href="#生成全面的API参考" class="headerlink" title="生成全面的API参考"></a>生成全面的API参考</h3><p>在使用时 sphinx.ext.autodoc 使代码和文档保持同步变得容易得多，但它仍然需要您编写 auto* 指令为您要记录的每个对象指定。Sphinx提供了另一个级别的自动化： autosummary 。</p><p>这个 autosummary 指令生成的文档包含所有使用 autodoc 指令的地方。</p><p>要使用它，需要先启用扩展：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.duration&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.doctest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.autodoc&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sphinx.ext.autosummary&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着，创建一个新的 rst 文件，命名为 api.rst ，并添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">API reference</span><br><span class="line">=============</span><br><span class="line">.. autosummary::</span><br><span class="line">   :toctree: _autosummary</span><br><span class="line"></span><br><span class="line">   lumache.get_random_ingredients</span><br><span class="line">   lumache.InvalidKindError</span><br></pre></td></tr></table></figure><p>别忘了将 api.rst 文件添加到 index.rst 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: Contents:</span><br><span class="line"></span><br><span class="line">   installation</span><br><span class="line">   usage</span><br><span class="line">   api</span><br></pre></td></tr></table></figure><p>最后，在构建完运行 make html ，它将包含两个新页面：</p><ul><li>api.html ，对应于 docs&#x2F;source&#x2F;api.rst 并包含一个表，其中包含您在 autosummary 指令(在本例中，只有一个)。</li><li>generated&#x2F;lumache.html ，对应于自动创建的文件 generated&#x2F;lumache.rst 并包含模块成员的摘要，在本例中为一个函数和一个异常。</li></ul><p>摘要页面中的每个链接都会将您带到您最初使用相应 autodoc 指令，在本例中为 usage.rst 文件。</p><p><img src="/post/sphinx/autosummary.png" alt="自动生成摘要首页"></p><p><img src="/post/sphinx/autosummary_api.png" alt="自动生成摘要api"></p><p><img src="/post/sphinx/autosummary_lumache.png" alt="自动生成摘要lumache"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了 Sphinx 的基本用法，包括安装、配置、使用、自定义主题、自动化文档生成等。Sphinx 是一个非常强大的文档生成工具，可以帮助我们快速生成文档，提高文档的质量，减少文档的维护成本。</p><p>主要的内容均来自于 Sphinx 官方文档中的 《使用sphinx》一节，本文只是对官方文档的一个简单翻译和总结，希望能够帮助到大家。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.sphinx-doc.org/en/master/">Sphinx官方文档</a></li><li><a href="https://www.sphinx-doc.org/zh_CN/master/">Sphinx官方文档中文版</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos8 升级 python 版本</title>
      <link href="/centos8-python-upgrade/"/>
      <url>/centos8-python-upgrade/</url>
      
        <content type="html"><![CDATA[<p>经常遇到给linux升级python的需求，这里记录一下</p><p>linux版本：centos8</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"># init</span><br><span class="line"># 修改centos8的yum源</span><br><span class="line">find /etc/yum.repos.d/ -type f | xargs -i sed -i &#x27;s#http://mirror.centos.org/$contentdir/$releasever/#https://mirrors.aliyun.com/centos/8-stream/#g&#x27; &#123;&#125;</span><br><span class="line"></span><br><span class="line">sudo sed -i &#x27;s/SELINUX=\w*/SELINUX=disabled/&#x27; /etc/selinux/config</span><br><span class="line">sudo dnf -y install epel-release</span><br><span class="line">sudo dnf install -y bash-com* bzip2-devel bind-utils cmake dkms dos2unix drpm expect gcc gcc-c++ gdb gdm git kernel-devel kernel-headers libffi libffi-devel lrzsz make ncurses-devel nfs-utils nmap openssl-devel rsync sqlite-devel sysstat tar telnet tmux traceroute tree unzip vim wget yum-utils zlib-devel xz-devel</span><br><span class="line">sudo touch /etc/profile.d/custom.sh</span><br><span class="line"></span><br><span class="line"># 安装rust</span><br><span class="line">sudo curl https://sh.rustup.rs -sSf | sh</span><br><span class="line"></span><br><span class="line"># 安装python</span><br><span class="line">python_version=&quot;3.9.1&quot;</span><br><span class="line">wget https://www.python.org/ftp/python/$&#123;python_version&#125;/Python-$&#123;python_version&#125;.tar.xz</span><br><span class="line">sudo dnf install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel gcc libffi make libffi-devel -y</span><br><span class="line">tar Jxvf Python-$&#123;python_version&#125;.tar.xz</span><br><span class="line">cd Python-$&#123;python_version&#125;/</span><br><span class="line">sudo ./configure --prefix=/usr/local/python3 --enable-shared  --enable-optimizations --with-ssl</span><br><span class="line">sudo make</span><br><span class="line">sudo make altinstall</span><br><span class="line"></span><br><span class="line">sudo bash -c &#x27;echo &quot;/usr/local/python3/lib&quot; &gt; /etc/ld.so.conf.d/python3.conf&#x27;</span><br><span class="line">sudo ldconfig</span><br><span class="line">sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python</span><br><span class="line">sudo ln -s /usr/local/python3/bin/pip3 /usr/bin/pip</span><br><span class="line">python -V</span><br><span class="line">pip -V</span><br><span class="line"></span><br><span class="line">user=&quot;aaron&quot;</span><br><span class="line">home_path=&quot;/home/$&#123;user&#125;/&quot;</span><br><span class="line">root_path=&quot;/root/&quot;</span><br><span class="line"></span><br><span class="line">sudo bash -c &#x27;echo -e &quot;[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n&quot; &gt; /etc/pip.conf&#x27;</span><br><span class="line">sudo pip install --upgrade pip</span><br><span class="line">sudo pip install ipython</span><br><span class="line">sudo ln -s /usr/local/python3/bin/ipython /usr/bin/</span><br><span class="line">sudo pip install virtualenv</span><br><span class="line">sudo ln -s /usr/local/python3/bin/virtualenv /usr/bin/</span><br><span class="line">sudo pip install virtualenvwrapper</span><br><span class="line">sudo ln -s /usr/local/python3/bin/virtualenvwrapper /usr/bin/</span><br><span class="line">sudo mkdir $&#123;home_path&#125;.virtualenvs $&#123;root_path&#125;.virtualenvs</span><br><span class="line">grep -q &#x27;^if \[ ! -d &quot;$HOME/.virtualenvs&quot; ];then$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;if [ ! -d \&quot;\$HOME/.virtualenvs\&quot; ];then\n  mkdir \$HOME/.virtualenvs\nfi&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^export WORKON_HOME=$HOME/.virtualenvs$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;export WORKON_HOME=\$HOME/.virtualenvs&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^export PROJECT_HOME=$HOME/.workspaces$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;export PROJECT_HOME=\$HOME/.workspaces&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^source /usr/local/python3/bin/virtualenvwrapper.sh$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;source /usr/local/python3/bin/virtualenvwrapper.sh&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line"></span><br><span class="line"># vimrc</span><br><span class="line">sudo mkdir -p $&#123;home_path&#125;.undodir $&#123;root_path&#125;.undodir $&#123;home_path&#125;.vim $&#123;root_path&#125;.vim</span><br><span class="line">sudo chown -R $&#123;user&#125;: $&#123;home_path&#125;</span><br><span class="line"># 参考vimrc</span><br><span class="line">vim  $&#123;home_path&#125;.vim/vimrc</span><br><span class="line">sudo cp  $&#123;home_path&#125;.vim/vimrc $&#123;root_path&#125;.vim/</span><br><span class="line">grep -q &#x27;^export EDITOR=/usr/bin/vim$&#x27; /etc/profile.d/custom.sh &amp;&amp; sudo sed -i &#x27;s/^export EDITOR.*$/export EDITOR=/usr/bin/vim/&#x27; /etc/profile.d/custom.sh || sudo bash -c &#x27;echo &quot;EDITOR=/usr/bin/vim/&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line">grep -q &#x27;^if \[ ! -d &quot;$HOME/.undodir&quot; ];then$&#x27; /etc/profile.d/custom.sh || sudo sh -c &#x27;echo -e &quot;if [ ! -d \&quot;\$HOME/.undodir\&quot; ];then\n  mkdir \$HOME/.undodir\nfi\n&quot; &gt;&gt; /etc/profile.d/custom.sh&#x27;</span><br><span class="line"># 参考init.sh</span><br><span class="line">sudo vim /etc/init.sh</span><br><span class="line">ln -s /etc/init.sh $&#123;home_path&#125;.init.sh</span><br><span class="line">sudo ln -s /etc/init.sh $&#123;root_path&#125;.init.sh</span><br><span class="line">grep -q &#x27;^if \[ -f ~/.init.sh ]; then$&#x27; $&#123;home_path&#125;.bash_profile || sh -c &#x27;echo -e &quot;if [ -f ~/.init.sh ]; then\n    . ~/.init.sh login\nfi\n&quot; &gt;&gt; $&#123;home_path&#125;.bash_profile&#x27;</span><br><span class="line">sudo grep -q &#x27;^if \[ -f ~/.init.sh ]; then$&#x27; $&#123;root_path&#125;.bash_profile || sudo sh -c &#x27;echo -e &quot;if [ -f ~/.init.sh ]; then\n    . ~/.init.sh login\nfi\n&quot; &gt;&gt; $&#123;root_path&#125;.bash_profile&#x27;</span><br><span class="line"># 参考ssh_banner</span><br><span class="line">sudo vim /etc/ssh_banner</span><br><span class="line">sudo grep -q &#x27;^Banner .*$&#x27; /etc/ssh/sshd_config || sudo sh -c &#x27;echo -e &quot;Banner /etc/ssh_banner&quot; &gt;&gt; /etc/ssh/sshd_config&#x27;</span><br><span class="line"></span><br><span class="line"># docker</span><br><span class="line">sudo dnf remove docker docker-common docker-selinux docker-engine -y</span><br><span class="line">sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo dnf install device-mapper-persistent-data lvm2 -y</span><br><span class="line">sudo dnf install docker-ce --nobest -y</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo usermod -aG docker $&#123;user&#125;</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"># 注意修改权限</span><br><span class="line">sudo chown -R $&#123;user&#125;: $&#123;home_path&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo pip install jupyter</span><br><span class="line">ll $&#123;home_path&#125;.jupyter/jupyter_notebook_config.py</span><br><span class="line">sudo ln -s /usr/local/python3/bin/jupyter-notebook /usr/bin/</span><br><span class="line">jupyter-notebook --generate-config</span><br><span class="line">mkdir -p $&#123;home_path&#125;project/ipython</span><br><span class="line">vim $&#123;home_path&#125;.jupyter/jupyter_notebook_config.py</span><br><span class="line">    c.NotebookApp.ip = &#x27;192.168.100.10&#x27;</span><br><span class="line">    c.NotebookApp.notebook_dir = &#x27;/home/aaron/project/ipython&#x27;</span><br><span class="line">    c.NotebookApp.open_browser = False</span><br><span class="line">    # jupyter</span><br><span class="line">    c.NotebookApp.password = &#x27;argon2:$argon2id$v=19$m=10240,t=10,p=8$ZyZnmpT3p/nmdXpgVV3mQw$JWkHVEJos0t/XQNix9uwvQ&#x27;</span><br><span class="line">    c.NotebookApp.password_required = True</span><br><span class="line">    c.NotebookApp.port = 8880</span><br><span class="line">    </span><br><span class="line"># 添加系统systemd</span><br><span class="line">sudo vim /usr/lib/systemd/system/jupyter-notebook.service</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker file</title>
      <link href="/docker-file/"/>
      <url>/docker-file/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><h1 id="Dockerfile介绍"><a href="#Dockerfile介绍" class="headerlink" title="Dockerfile介绍"></a>Dockerfile介绍</h1><p>Dockerfile是一堆指令，在docker build的时候，按照该指令进行操作，最终生成我们期望的镜像</p><span id="more"></span><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><ul><li><p>FROM 指定基础镜像，必须为第一个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  FROM &lt;image&gt;</span><br><span class="line">  FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">示例：</span><br><span class="line">  FROM mysql:5.7</span><br><span class="line">注意：</span><br><span class="line">  tag是可选的，如果不使用tag时，会使用latest版本的基础镜像</span><br></pre></td></tr></table></figure></li><li><p>MAINTAINER 镜像维护者的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  MAINTAINER &lt;name&gt;</span><br><span class="line">示例：</span><br><span class="line">  MAINTAINER Yongxin Li</span><br><span class="line">  MAINTAINER inspur_lyx@hotmail.com</span><br><span class="line">  MAINTAINER Yongxin Li &lt;inspur_lyx@hotmail.com&gt;</span><br></pre></td></tr></table></figure><p>查看镜像的MAINTAINER</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 通过docker inspect命令查看镜像Author的值。</span><br><span class="line"></span><br><span class="line">docker inspect -f &#123;&#123;&quot;.Author&quot;&#125;&#125; &lt;镜像ID&gt;</span><br></pre></td></tr></table></figure></li><li><p>LABEL 镜像元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line">示例：</span><br><span class="line">  LABEL &quot;email&quot;=&quot;Securitit@13.com&quot;</span><br><span class="line">  LABEL email-host=&quot;www.host.com&quot;</span><br><span class="line">  LABEL email-version=&quot;1.0&quot;</span><br><span class="line">  LABEL email-description=&quot;This is my \</span><br><span class="line">        persional email.&quot;</span><br><span class="line">  LABEL multi.label-1=&quot;value-1&quot; multi.label-2=&quot;value-2&quot; multi.label-3=&quot;value-3&quot;</span><br><span class="line">  LABEL multi.label-4=&quot;value-4&quot; \</span><br><span class="line">        multi.label-5=&quot;value-5&quot; \</span><br><span class="line">        multi.label-6=&quot;value-6&quot;</span><br></pre></td></tr></table></figure><ul><li>基础镜像或父镜像中包含的元数据由当前镜像继承。如果元数据已经存在，但具有不同的值，则最近应用的值将覆盖以前设置的任何值。</li><li>可以使用LABEL maintainer&#x3D;”xxx”代替MAINTAINER xxx，两者设置的值，在镜像的描述文件中所处位置是不一样的。<ul><li>MAINTAINER xxx位于顶层Author属性中。</li><li>LABEL maintainer&#x3D;”xxx”位于Config.Labels.maintainer属性中，查看镜像的 LABEL <code>docker inspect -f &#123;&#123;".Config.Labels"&#125;&#125; &lt;镜像ID&gt;</code></li></ul></li><li>MAINTAINER已经过时，在新版本已不推荐使用，推荐使用LABEL完成元数据设置。</li></ul></li><li><p>COPY|ADD 添加本地文件到镜像中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">示例：</span><br><span class="line">  ADD hom* /mydir/          # 添加所有以&quot;hom&quot;开头的文件</span><br><span class="line">  ADD test relativeDir/     # 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/</span><br><span class="line">  ADD test /absoluteDir/    # 添加 &quot;test&quot; 到 /absoluteDir/</span><br></pre></td></tr></table></figure></li><li><p>WORKDIR 工作目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  WORKDIR /path/to/workdir</span><br><span class="line">示例：</span><br><span class="line">  WORKDIR /a  (这时工作目录为/a)</span><br><span class="line">注意：</span><br><span class="line">  通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行</span><br></pre></td></tr></table></figure></li><li><p>RUN 构建镜像过程中执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  RUN &lt;command&gt;</span><br><span class="line">示例：</span><br><span class="line">  RUN yum install nginx</span><br><span class="line">  RUN pip install django</span><br><span class="line">  RUN mkdir test &amp;&amp; rm -rf /var/lib/unusedfiles</span><br><span class="line">注意：</span><br><span class="line">  RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</span><br></pre></td></tr></table></figure></li><li><p>CMD 构建容器后调用，也就是在容器启动时才进行调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (执行可执行文件，优先)</span><br><span class="line">  CMD [&quot;param1&quot;,&quot;param2&quot;] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)</span><br><span class="line">  CMD command param1 param2 (执行shell内部命令)</span><br><span class="line">示例：</span><br><span class="line">  CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</span><br><span class="line">  CMD ping www.baidu.com</span><br><span class="line">注意：</span><br><span class="line">  CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</span><br></pre></td></tr></table></figure></li><li><p>ENTRYPOINT 设置容器初始化命令，使其可执行化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (可执行文件, 优先)</span><br><span class="line">  ENTRYPOINT command param1 param2 (shell内部命令)</span><br><span class="line">示例：</span><br><span class="line">  ENTRYPOINT [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</span><br><span class="line">注意：</span><br><span class="line">  ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令</span><br></pre></td></tr></table></figure></li><li><p>ENV</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">  ENV &lt;key&gt;=&lt;value&gt;</span><br><span class="line">示例：</span><br><span class="line">  ENV myName John</span><br><span class="line">  ENV myCat=Tom</span><br></pre></td></tr></table></figure></li><li><p>EXPOSE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">  EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line">示例：</span><br><span class="line">  EXPOSE 80 443</span><br><span class="line">  EXPOSE 8080</span><br><span class="line">  EXPOSE 11211/tcp 11211/udp</span><br><span class="line">注意：</span><br><span class="line">  EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口</span><br></pre></td></tr></table></figure></li></ul><h2 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h2><ul><li><p>基础环境镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --update ca-certificates &amp;&amp; <span class="built_in">rm</span> -rf /var/cache/apk/* &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  find /usr/share/ca-certificates/mozilla/ -name <span class="string">&quot;*.crt&quot;</span> -<span class="built_in">exec</span> keytool -import -trustcacerts \</span></span><br><span class="line"><span class="language-bash">  -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts -storepass changeit -noprompt \</span></span><br><span class="line"><span class="language-bash">  -file &#123;&#125; -<span class="built_in">alias</span> &#123;&#125; \; &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  keytool -list -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts --storepass changeit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> MAVEN_VERSION <span class="number">3.5</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">ENV</span> MAVEN_HOME /usr/lib/mvn</span><br><span class="line"><span class="keyword">ENV</span> PATH $MAVEN_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget http://archive.apache.org/dist/maven/maven-3/<span class="variable">$MAVEN_VERSION</span>/binaries/apache-maven-<span class="variable">$MAVEN_VERSION</span>-bin.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  tar -zxvf apache-maven-<span class="variable">$MAVEN_VERSION</span>-bin.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  <span class="built_in">rm</span> apache-maven-<span class="variable">$MAVEN_VERSION</span>-bin.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  <span class="built_in">mv</span> apache-maven-<span class="variable">$MAVEN_VERSION</span> /usr/lib/mvn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span></span><br></pre></td></tr></table></figure></li><li><p>前端镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.19</span>.<span class="number">0</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;mritd &lt;mritd@linux.com&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> TZ=<span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="keyword">ENV</span> TZ $&#123;TZ&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk upgrade --update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add bash tzdata curl wget ca-certificates \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">ln</span> -sf /usr/share/zoneinfo/<span class="variable">$&#123;TZ&#125;</span> /etc/localtime \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;TZ&#125;</span> &gt; /etc/timezone \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /usr/share/nginx/html /var/cache/apk/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> dist /usr/share/nginx/html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">443</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>java镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>u111</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS <span class="string">&quot;\</span></span><br><span class="line"><span class="string">-Xmx4096m \</span></span><br><span class="line"><span class="string">-XX:MetaspaceSize=256m \</span></span><br><span class="line"><span class="string">-XX:MaxMetaspaceSize=256m&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/java/jdk</span><br><span class="line"><span class="keyword">ENV</span> PATH $&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/myapp.jar myapp.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> java <span class="variable">$&#123;JAVA_OPTS&#125;</span> -jar myapp.jar</span></span><br></pre></td></tr></table></figure></li><li><p>golang镜像</p><p>使用多阶段构建，请查看本文下面出现的《多阶段构建》章节。</p></li></ul><h2 id="1号进程"><a href="#1号进程" class="headerlink" title="1号进程"></a>1号进程</h2><p>接下来通过1号进程理解容器的本质</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it nginx:1.19.0-alpine /bin/sh</span><br><span class="line"><span class="comment">#/ ps aux</span></span><br></pre></td></tr></table></figure><p>容器启动的时候可以通过命令去覆盖默认的CMD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name xxx nginx:alpine &lt;自定义命令&gt;</span><br><span class="line"><span class="comment"># &lt;自定义命令&gt;会覆盖镜像中指定的CMD指令，作为容器的1号进程启动。</span></span><br><span class="line"></span><br><span class="line">$ docker run -d --name test-3 nginx:alpine <span class="built_in">echo</span> 123</span><br><span class="line"></span><br><span class="line">$ docker run -d --name test-4 nginx:alpine ping www.baidu.com</span><br></pre></td></tr></table></figure><p>本质上讲容器是利用namespace和cgroup等技术在宿主机中创建的独立的虚拟空间，这个空间内的网络、进程、挂载等资源都是隔离的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it nginx:1.19.0-alpine /bin/sh</span><br><span class="line"><span class="comment">#/ ip addr</span></span><br><span class="line"><span class="comment">#/ ls -l /</span></span><br><span class="line"><span class="comment">#/ apt install xxx</span></span><br><span class="line"><span class="comment">#/ #安装的软件对宿主机和其他容器没有任何影响，和虚拟机不同的是，容器间共享一个内核，所以容器内没法升级内核</span></span><br></pre></td></tr></table></figure><h2 id="多阶构建"><a href="#多阶构建" class="headerlink" title="多阶构建"></a>多阶构建</h2><h3 id="java项目"><a href="#java项目" class="headerlink" title="java项目"></a>java项目</h3><p>这里先使用java镜像为例，介绍多阶构建的使用。</p><p>项目地址：(springboot-app)[<a href="https://gitee.com/agagin/springboot-app.git]">https://gitee.com/agagin/springboot-app.git]</a></p><h4 id="原始构建："><a href="#原始构建：" class="headerlink" title="原始构建："></a>原始构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> srinivasansekar/javamvn</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/springboot-app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">  . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -jar /opt/springboot-app/target/sample.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t sample:v1 -f Dockerfile</span><br></pre></td></tr></table></figure><h4 id="多阶构建："><a href="#多阶构建：" class="headerlink" title="多阶构建："></a>多阶构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> maven as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/springboot-app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">  . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /opt/springboot-app/target/sample.jar sample.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -jar /sample.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t sample:v2 -f Dockerfile.multi</span><br></pre></td></tr></table></figure><h3 id="golang项目"><a href="#golang项目" class="headerlink" title="golang项目"></a>golang项目</h3><p>项目地址：(href-counter)[<a href="https://gitee.com/agagin/href-counter.git]">https://gitee.com/agagin/href-counter.git]</a></p><h4 id="原始构建：-1"><a href="#原始构建：-1" class="headerlink" title="原始构建："></a>原始构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> vendor vendor</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"><span class="keyword">ENV</span> GOPROXY https://goproxy.cn</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t href-counter:v1 -f Dockerfile</span><br></pre></td></tr></table></figure><h4 id="多阶构建：-1"><a href="#多阶构建：-1" class="headerlink" title="多阶构建："></a>多阶构建：</h4><p>dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.13</span> AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> vendor vendor</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go.</span></span><br><span class="line"><span class="keyword">ENV</span> GOPROXY https://goproxy.cn</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.10</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder  /go/src/github.com/alexellis/href-counter/app    .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>镜像构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t href-counter:v2 -f Dockerfile.multi</span><br></pre></td></tr></table></figure><h3 id="虚悬镜像-dangling-image"><a href="#虚悬镜像-dangling-image" class="headerlink" title="虚悬镜像 dangling image"></a>虚悬镜像 dangling image</h3><p>我们多阶构建完成后，通过 docker image ls (与 docker images相同)查看镜像时会发现一个或多个镜像ID和标签都为 none 关键字的镜像，这称为虚悬镜像(dangling image)，也就是我们多阶构建的中间镜像。再构建同名且同tag的镜像的时候，原本的镜像也会变为虚悬镜像。</p><p>虚悬镜像，我们并不需要它们，但是它们还占用存储空间。该如何删除呢？可以查找出镜像id进行删除，也可以通过docker命令删除。</p><ol><li>列出虚悬镜像 <code>docker image ls -f dangling=true</code></li><li>删除虚悬镜像 <code>docker image prune</code></li></ol><h3 id="多阶构建原则"><a href="#多阶构建原则" class="headerlink" title="多阶构建原则"></a>多阶构建原则</h3><ul><li>不必要的内容不要放在镜像中</li><li>减少不必要的层文件</li><li>减少网络传输操作</li><li>可以适当的包含一些调试命令</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yaml 入门</title>
      <link href="/yaml-introduction/"/>
      <url>/yaml-introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="yaml介绍"><a href="#yaml介绍" class="headerlink" title="yaml介绍"></a>yaml介绍</h1><p>官网介绍如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%YAML 1.2</span><br><span class="line">---</span><br><span class="line">YAML: YAML Ain&#x27;t Markup Language™</span><br><span class="line"></span><br><span class="line">What It Is:</span><br><span class="line">  YAML is a human-friendly data serialization</span><br><span class="line">  language for all programming languages.</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>这里的语法使用python举例，python使用的库是PyYAML</p><p>所有的 YAML 文件开始行都应该是 —。这是 YAML 格式的一部分, 表明一个文件的开始。</p><p>基本语法规则如下:</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li># 表示注释，从这个字符一直到行尾，都会被解析器忽略。</li></ul><p>YAML 支持的数据结构有三种:</p><ol><li>对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hashes） &#x2F; 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</li><li>纯量（scalars）：单个的、不可再分的值</li></ol><h2 id="对象-key-value键值对"><a href="#对象-key-value键值对" class="headerlink" title="对象 key-value键值对"></a>对象 key-value键值对</h2><p>使用格式为key: value。冒号后面要加一个空格。</p><h3 id="简单展示"><a href="#简单展示" class="headerlink" title="简单展示"></a>简单展示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 表示url属性值</span></span><br><span class="line"><span class="string">url: https://www.iluvatar.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 yaml 文件</span></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(value))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;url&#x27;: &#x27;https://www.iluvatar.com&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用缩进代表层级结构"><a href="#使用缩进代表层级结构" class="headerlink" title="使用缩进代表层级结构"></a>使用缩进代表层级结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 可以使用缩进表示层级结构</span></span><br><span class="line"><span class="string">host:</span></span><br><span class="line"><span class="string">    # 这样没有层级结构，所以解析的时候会报错</span></span><br><span class="line"><span class="string">    # ip:</span></span><br><span class="line"><span class="string">    # 172.16.0.1</span></span><br><span class="line"><span class="string">    ip:</span></span><br><span class="line"><span class="string">        172.16.0.1</span></span><br><span class="line"><span class="string">    # 定义相同的key并不报错，而是覆盖之前的相同key中的value</span></span><br><span class="line"><span class="string">    ip:</span></span><br><span class="line"><span class="string">        172.16.0.2</span></span><br><span class="line"><span class="string">    # 没有空格的话会被认为是一个键，并且报错没有检测到: 以及value</span></span><br><span class="line"><span class="string">    # ip:172.16.0.3</span></span><br><span class="line"><span class="string">    mask: 255.255.255.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 yaml 文件</span></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(value))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;host&#x27;: &#123;&#x27;ip&#x27;: &#x27;172.16.0.2&#x27;, &#x27;mask&#x27;: &#x27;255.255.255.0&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="一行显示"><a href="#一行显示" class="headerlink" title="一行显示"></a>一行显示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># yaml 也支持将所有的对象写在一行的写法</span></span><br><span class="line"><span class="string"># 注意： 如果键值对没有使用空格分开会被认为是一个键</span></span><br><span class="line"><span class="string">host: &#123;ip: 172.16.0.1,ip: 172.16.0.2, ip:172.16.0.3 ,mask: 255.255.255.0&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 yaml 文件</span></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(value))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;host&#x27;: &#123;&#x27;ip&#x27;: &#x27;172.16.0.2&#x27;, &#x27;ip:172.16.0.3&#x27;: None, &#x27;mask&#x27;: &#x27;255.255.255.0&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="数组-Array-x2F-List"><a href="#数组-Array-x2F-List" class="headerlink" title="数组 Array&#x2F;List"></a>数组 Array&#x2F;List</h2><h3 id="简单展示-1"><a href="#简单展示-1" class="headerlink" title="简单展示"></a>简单展示</h3><p>列表中的所有成员都开始于相同的缩进级别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml 文件内容</span></span><br><span class="line">yaml_context = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">ipaddr:</span></span><br><span class="line"><span class="string"># IP地址列表</span></span><br><span class="line"><span class="string">- 192.168.10.1</span></span><br><span class="line"><span class="string">- 192.168.10.2</span></span><br><span class="line"><span class="string">- 192.168.10.3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;ipaddr&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;</span><br></pre></td></tr></table></figure><h3 id="缩进显示"><a href="#缩进显示" class="headerlink" title="缩进显示"></a>缩进显示</h3><p>子成员是一个数组，则可以在该项下面缩进一个空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line">import yaml</span><br><span class="line"></span><br><span class="line"># yaml 文件内容</span><br><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">ipaddr:</span><br><span class="line">- ens192:</span><br><span class="line">  # 下一级的定义要空两个空格以上</span><br><span class="line">  - 192.168.10.1</span><br><span class="line">  - 192.168.10.2</span><br><span class="line">  - 192.168.10.3</span><br><span class="line">file:</span><br><span class="line">  # 数组的子成员还是一个数组，空一个空格即可</span><br><span class="line">  -</span><br><span class="line">   - etc</span><br><span class="line">   - sysconfig</span><br><span class="line">   - network-scripts</span><br><span class="line">   - ifcfg-ens192</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">value = yaml.safe_load(yaml_context)</span><br><span class="line"></span><br><span class="line">print(value)</span><br><span class="line"># 这里使用pprint打印稍微美观一些</span><br><span class="line">pprint(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;ipaddr&#x27;: [&#123;&#x27;ens192&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;], &#x27;file&#x27;: [[&#x27;etc&#x27;, &#x27;sysconfig&#x27;, &#x27;network-scripts&#x27;, &#x27;ifcfg-ens192&#x27;]]&#125;</span><br><span class="line">&#123;&#x27;file&#x27;: [[&#x27;etc&#x27;, &#x27;sysconfig&#x27;, &#x27;network-scripts&#x27;, &#x27;ifcfg-ens192&#x27;]],</span><br><span class="line"> &#x27;ipaddr&#x27;: [&#123;&#x27;ens192&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="行内表示"><a href="#行内表示" class="headerlink" title="行内表示"></a>行内表示</h3><p>因为程序差不多，之后只提供yaml文件内容以及pprint打印的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">ipaddr:</span><br><span class="line"># 行内表示格式正确就行，中间的空格位数不影响</span><br><span class="line">- ens192: [ 192.168.10.1, 192.168.10.2, 192.168.10.3 ]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;ipaddr&#x27;: [&#123;&#x27;ens192&#x27;: [&#x27;192.168.10.1&#x27;, &#x27;192.168.10.2&#x27;, &#x27;192.168.10.3&#x27;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>yaml中的常量包含以下几种</p><ul><li>字符串</li><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul><p>具体看以下示例应该就清楚了，不过多解释了</p><p>其中字符串有几个规则需要注意</p><ul><li>字符串默认不使用引号表示，如：<code>str: 这是一行字符串</code></li><li>如果字符串之中包含空格或特殊字符，需要放在引号之中，如：<code>str: &#39;内容：字符串&#39;</code></li><li>单引号和双引号都可以使用，双引号不会对特殊字符转义，如：<code>str: &#123;s1: &#39;内容\n字符串&#39;, s2: &quot;内容\n字符串&quot;&#125;</code></li><li>单引号之中如果还有单引号，必须连续使用两个单引号转义，如：<code>str: &#39;labor&#39;&#39;s day&#39;</code></li><li>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格</li><li>多行字符串可以使用 | 保留换行符，也可以使用 &gt; 折叠换行，下一节会介绍</li><li><ul><li>表示保留文字块末尾的换行，- 表示删除字符串末尾的换行，下一节会介绍</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">boolean:</span><br><span class="line">    # true,True都可以</span><br><span class="line">    - TRUE</span><br><span class="line">    # false，False都可以</span><br><span class="line">    - FALSE</span><br><span class="line">float:</span><br><span class="line">    - 3.14</span><br><span class="line">    # 可以使用科学计数法</span><br><span class="line">    - 6.8523015e+5</span><br><span class="line">int:</span><br><span class="line">    - 123</span><br><span class="line">    # 二进制表示</span><br><span class="line">    - 0b1010_0111_0100_1010_1110</span><br><span class="line">null:</span><br><span class="line">    nodeName: &#x27;node&#x27;</span><br><span class="line">    # 使用~表示null</span><br><span class="line">    parent: ~</span><br><span class="line">string:</span><br><span class="line">    - 字符串行</span><br><span class="line">    - newline</span><br><span class="line">    # 可以使用双引号或者单引号包裹特殊字符</span><br><span class="line">    - &#x27;Hello world&#x27;</span><br><span class="line">    # 字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="line">    - one_line</span><br><span class="line">      two_line</span><br><span class="line">date:</span><br><span class="line">    # 日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="line">    - 2018-02-17</span><br><span class="line">datetime:</span><br><span class="line">    # 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br><span class="line">    -  2018-02-17T15:02:31+08:00</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;None: &#123;&#x27;nodeName&#x27;: &#x27;node&#x27;, &#x27;parent&#x27;: None&#125;,</span><br><span class="line"> &#x27;boolean&#x27;: [True, False],</span><br><span class="line"> &#x27;date&#x27;: [datetime.date(2018, 2, 17)],</span><br><span class="line"> &#x27;datetime&#x27;: [datetime.datetime(2018, 2, 17, 15, 2, 31, tzinfo=datetime.timezone(datetime.timedelta(seconds=28800)))],</span><br><span class="line"> &#x27;float&#x27;: [3.14, 685230.15],</span><br><span class="line"> &#x27;int&#x27;: [123, 685230],</span><br><span class="line"> &#x27;string&#x27;: [&#x27;字符串行&#x27;, &#x27;newline&#x27;, &#x27;Hello world&#x27;, &#x27;one_line two_line&#x27;]&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><h3 id="类型强转"><a href="#类型强转" class="headerlink" title="!! 类型强转"></a>!! 类型强转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">int2string: !!str 123</span><br><span class="line">boolean2string: !!str true</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;boolean2string&#x27;: &#x27;true&#x27;, &#x27;int2string&#x27;: &#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="…-和-—"><a href="#…-和-—" class="headerlink" title="… 和 —"></a>… 和 —</h3><p>… 和—配合使用，在一个配置文件中代表一个文件的结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line">import yaml</span><br><span class="line"></span><br><span class="line"># yaml 文件内容</span><br><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">---</span><br><span class="line">time: 10:05:07</span><br><span class="line">user: userA</span><br><span class="line">action: &#x27;delete job (id: 13579)&#x27;</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">time: 11:13:45</span><br><span class="line">user: userB</span><br><span class="line">action: download dataset A</span><br><span class="line">...</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">values = yaml.safe_load_all(yaml_context)</span><br><span class="line"></span><br><span class="line">print(values)</span><br><span class="line">for value in values:</span><br><span class="line">    pprint(value)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object load_all at 0x000001C786A58C80&gt;</span><br><span class="line">&#123;&#x27;action&#x27;: &#x27;delete job (id: 13579)&#x27;, &#x27;time&#x27;: 36307, &#x27;user&#x27;: &#x27;userA&#x27;&#125;</span><br><span class="line">&#123;&#x27;action&#x27;: &#x27;download dataset A&#x27;, &#x27;time&#x27;: 40425, &#x27;user&#x27;: &#x27;userB&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="控制符-和-gt-控制符"><a href="#控制符-和-gt-控制符" class="headerlink" title="| 控制符 和 &gt; 控制符"></a>| 控制符 和 &gt; 控制符</h3><p>这两个符号是YAML中字符串经常使用的符号</p><h4 id="控制符"><a href="#控制符" class="headerlink" title="| 控制符"></a>| 控制符</h4><p>这个控制符的作用是保留文本每一行尾部的换行符。</p><ul><li>| 保证整段文本最后有且只有一个换行符</li><li>|+ 保留整段文本最后的所有换行符</li><li>|- 删除整段文本最后的所有换行符</li></ul><ol><li><p>最后有且只有一个换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: |</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash\n-c \n\n\nsleep 3600\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>保留整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: |+</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash\n-c \n\n\nsleep 3600\n\n\n\n\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: |-</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash\n-c \n\n\nsleep 3600&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="gt-控制符"><a href="#gt-控制符" class="headerlink" title="&gt; 控制符"></a>&gt; 控制符</h4><p>这个控制符的作用是将每一行尾部的换行符替换为空格，也就是将多行文本视为一行</p><ul><li><blockquote><p>保证文本最后有且只有一个换行符</p></blockquote></li><li><blockquote><ul><li>保留文本最后的所有换行符</li></ul></blockquote></li><li><blockquote><ul><li>删除文本最后的所有换行符</li></ul></blockquote></li></ul><ol><li><p>最后有且只有一个换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: &gt;</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash -c \n\nsleep 3600\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>保留整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: &gt;+</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash -c \n\nsleep 3600\n\n\n\n\n&#x27;&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除整段文本最后的所有换行符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">cmd: &gt;-</span><br><span class="line">bash</span><br><span class="line">-c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;cmd&#x27;: &#x27;bash -c \n\nsleep 3600&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="引用-amp-和"><a href="#引用-amp-和" class="headerlink" title="引用 &amp; 和 *"></a>引用 &amp; 和 *</h3><p>重复的内容在YAML中可以使用&amp;来完成锚点定义，使用*来完成锚点引用，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yaml_context = &quot;&quot;&quot;</span><br><span class="line">defaults: &amp;defaults</span><br><span class="line">  host: localhost</span><br><span class="line">  db: postgres</span><br><span class="line"></span><br><span class="line">production:</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line">  host: 10.10.10.123</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  db: mysql</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">staging:</span><br><span class="line">  env: *defaults</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;defaults&#x27;: &#123;&#x27;db&#x27;: &#x27;postgres&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;&#125;,</span><br><span class="line"> &#x27;development&#x27;: &#123;&#x27;db&#x27;: &#x27;mysql&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;&#125;,</span><br><span class="line"> &#x27;production&#x27;: &#123;&#x27;db&#x27;: &#x27;postgres&#x27;, &#x27;host&#x27;: &#x27;10.10.10.123&#x27;&#125;,</span><br><span class="line"> &#x27;staging&#x27;: &#123;&#x27;env&#x27;: &#123;&#x27;db&#x27;: &#x27;postgres&#x27;, &#x27;host&#x27;: &#x27;localhost&#x27;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>CentOS 搭建 nfs server</p><h1 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h1><ol><li><p>安装软件包</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y rpcbind nfs-utils</span><br></pre></td></tr></table></figure></li><li><p>创建共享目录</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir -p /srv/data/nfs_data</span><br><span class="line"># chmod 777 /srv/data/nfs_data</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><p>将配置文件exports填写以下内容</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/exports</span><br><span class="line"></span><br><span class="line">/data/nfs_data/data *(insecure,rw,sync,no_root_squash,fsid=0)</span><br></pre></td></tr></table></figure></li><li><p>启动 nfs 服务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rpcbind</span><br><span class="line">systemctl enable nfs-server</span><br><span class="line"></span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs-server</span><br></pre></td></tr></table></figure></li><li><p>检查配置是否生效</p><p>使用 exportfs 命令，会显示共享的目录</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># exportfs</span><br><span class="line">/srv/data/nfs_data</span><br><span class="line">                &lt;world&gt;</span><br></pre></td></tr></table></figure></li><li><p>开发防火墙</p><p>服务器端开放 111、662、875、892、2049 的 tcp &#x2F; udp 端口即可</p></li></ol><h1 id="客户端挂载"><a href="#客户端挂载" class="headerlink" title="客户端挂载"></a>客户端挂载</h1><ol><li><p>客户端安装软件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br></pre></td></tr></table></figure></li><li><p>执行命令检查共享目录</p><p>使用命令 showmount 进行显示，注意替换成当前的服务器地址，这里是 10.6.70.4</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># showmount -e 10.6.70.4</span><br><span class="line">Export list for 10.6.70.4:</span><br><span class="line">/srv/data/nfs_data *</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>挂载并测试</p><p>客户端挂载并创建测试文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ls /mnt/</span><br><span class="line"># mount -t nfs 10.6.70.4:/ /mnt/</span><br><span class="line"># ls /mnt/</span><br><span class="line"># echo &#x27;aaa&#x27; &gt; /mnt/a.txt</span><br></pre></td></tr></table></figure><p>服务器端查看目录，可以看到已经生成文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /srv/data/nfs_data/a.txt</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 介绍</title>
      <link href="/docker-introduction/"/>
      <url>/docker-introduction/</url>
      
        <content type="html"><![CDATA[<p>全部的 <a href="https://realtiger.github.io/k8s-learning/">K8S学习笔记总目录</a>，请点击查看。</p><h1 id="认识docker"><a href="#认识docker" class="headerlink" title="认识docker"></a>认识docker</h1><p>Docker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。</p><p>Hypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。</p><p>Container Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。Docker是其中最知名的一种容器Container Runtime，其他的还有 CoreOS 容器 Rkt ，Podman。</p><span id="more"></span><p><img src="/post/docker/docker-different.svg" alt="docker-different"></p><p>docker能做什么呢？ 它主要基于轻量的特性，解决软件交付过程中的环境依赖</p><ul><li>可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署</li><li>可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删）</li><li>container容器之间相互隔离，且每个容器可以设置资源限额</li><li>提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立</li></ul><h1 id="docker的发展史"><a href="#docker的发展史" class="headerlink" title="docker的发展史"></a>docker的发展史</h1><p>13年成立，15年开始，迎来了飞速发展。</p><p>Docker 1.8 之前，使用<a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，Docker在上层做了封装， 把LXC复杂的容器创建与使用方式简化为自己的一套命令体系。</p><p>之后，为了实现跨平台等复杂的场景，Docker抽出了libcontainer项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。</p><p>2015年6月，Docker牵头成立了 OCI（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。</p><p>OCI成立后，libcontainer 交给OCI组织来维护，但是libcontainer中只包含了与kernel交互的库，因此基于libcontainer项目，后面又加入了一个CLI工具，并且项目改名为runC (<a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a> )， 目前runC已经成为一个功能强大的runtime工具。</p><p>Docker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了<strong>containerd</strong>。containerd向上为Docker Daemon提供了<code>gRPC接口</code>，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过<code>containerd-shim</code>结合<code>runC</code>，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。</p><p><img src="/post/docker/containerd.png" alt="containerd"></p><ul><li>runC（libcontainer）是符合OCI标准的一个实现，与底层系统交互</li><li>containerd是实现了OCI之上的容器的高级功能，比如镜像管理、容器执行的调用等</li><li>Dockerd目前是最上层与CLI交互的进程，接收cli的请求并与containerd协作</li></ul><h1 id="docker总结"><a href="#docker总结" class="headerlink" title="docker总结"></a>docker总结</h1><ol><li>为了提供一种更加轻量的虚拟化技术，docker出现了</li><li>借助于docker容器的轻、快等特性，解决了软件交付过程中的环境依赖问题，使得docker得以快速发展</li><li>Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理</li><li>docker-ce，每季度发布stable版本。18.06，18.09，19.03</li><li>发展至今，docker已经通过制定OCI标准对最初的项目做了拆分，其中runC和containerd是docker的核心项目，理解docker整个请求的流程，对我们深入理解docker有很大的帮助</li></ol><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>docker安装查看这篇文章 <a href="http://www.ganchangde.com/article/cc0cb74b891f731e4f37c683b3f7362b5481e0f1_Vc1tfQHK_0">docker安装（Centos8版本）</a></p><h1 id="核心要素"><a href="#核心要素" class="headerlink" title="核心要素"></a>核心要素</h1><p>docker中的三大核心要素：镜像(Image)、容器(Container)、仓库(Registry)</p><ol><li>镜像（Image）:打包了业务代码及运行环境的包，是静态的文件，不能直接对外提供服务。</li><li>容器（Container）: 镜像的运行时，可以对外提供服务。</li><li>仓库（Registry）: 存放镜像的地方<ul><li>公有仓库，Docker Hub，阿里仓库，网易仓库…</li><li>私有仓库，企业内部搭建<ul><li>Docker Registry，Docker官方提供的镜像仓库存储服务</li><li>Harbor, 是Docker Registry的更高级封装，它除了提供友好的Web UI界面，角色和用户权限管理，用户操作审计等功能</li></ul></li><li>镜像访问地址形式 registry.devops.com&#x2F;demo&#x2F;hello:latest,若没有前面的url地址，则默认寻找Docker Hub中的镜像，若没有tag标签，则使用latest作为标签。 比如，docker pull nginx，会被解析成docker.io&#x2F;library&#x2F;nginx:latest</li><li>公有的仓库中，一般存在这么几类镜像<ul><li>操作系统基础镜像（centos，ubuntu，suse，alpine）</li><li>中间件（nginx，redis，mysql，tomcat）</li><li>语言编译环境（python，java，golang）</li><li>业务镜像（django-demo…）</li></ul></li></ul></li></ol><p>容器和仓库不会直接交互，都是以镜像为载体来操作。</p><h1 id="docker基本命令"><a href="#docker基本命令" class="headerlink" title="docker基本命令"></a>docker基本命令</h1><p><img src="/post/docker/docker-command.jpg" alt="docker-command"></p><ol><li><p>查看镜像列表</p><p>根据以下指标确定唯一镜像</p><ul><li>image_id</li><li>repository:tag</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx         alpine              377c0837328f        2 weeks ago         19.7MB</span><br></pre></td></tr></table></figure></li><li><p>如何获取镜像</p><ul><li><p>从远程仓库拉取</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐alpine</span></span><br><span class="line">$ docker pull nginx:alpine</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure></li><li><p>使用tag命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure></li><li><p>本地构建（通过Dockerfile）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t my-nginx:ubuntu -f Dockerfile</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如何通过镜像启动容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name my-nginx-alpine -d nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>如何知道容器内部运行了什么程序？</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部,分配一个tty终端</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti my-nginx-alpine /bin/sh</span><br><span class="line"><span class="comment"># ps aux</span></span><br></pre></td></tr></table></figure></li><li><p>docker怎么知道容器启动后该执行什么命令？</p><p> 通过docker build来模拟构建一个nginx的镜像，</p><ul><li><p>创建Dockerfile</p>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告诉docker使用哪个基础镜像作为模板，后续命令都以这个镜像为基础 </span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list &amp;&amp; sed -i <span class="string">&#x27;s/security.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN命令会在上面指定的镜像里执行命令 </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt install -y nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#告诉docker，启动容器时执行如下命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>构建本地镜像</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t my-nginx:ubuntu -f Dockerfile</span><br></pre></td></tr></table></figure></li><li><p>使用新镜像启动容器</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name my-nginx-ubuntu -d my-nginx:ubuntu</span><br></pre></td></tr></table></figure></li><li><p>进入容器查看进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -ti my-nginx-ubuntu /bin/sh</span><br><span class="line"><span class="comment"># ps aux</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如何访问容器内服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -ti my-nginx-alpine /bin/sh</span><br><span class="line"><span class="comment"># ps aux|grep nginx</span></span><br><span class="line"><span class="comment"># curl localhost:80</span></span><br></pre></td></tr></table></figure></li><li><p>宿主机中如何访问容器服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删掉旧服务,重新启动</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f my-nginx-alpine</span><br><span class="line">$ docker run --name my-nginx-alpine -d -p 8080:80 nginx:alpine</span><br><span class="line">$ curl 172.21.51.143:8080</span><br></pre></td></tr></table></figure></li><li><p>docker client如何与daemon通信</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /var/run/docker.sock</span></span><br><span class="line">$ docker run --name portainer -d -p 9001:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span><br></pre></td></tr></table></figure></li><li><p>导出镜像到文件中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save -o nginx-alpine.tar nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>从文件中加载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i nginx-alpine.tar</span><br></pre></td></tr></table></figure></li><li><p>部署带认证的镜像仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Docker Registry 认证文件目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /var/lib/registry_auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 htpasswd 来创建加密文件</span></span><br><span class="line">yum install -y httpd-tools</span><br><span class="line">htpasswd -Bbn admin admin &gt; /var/lib/registry_auth/htpasswd</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用docker镜像启动镜像仓库服务</span></span><br><span class="line">docker run -p 5000:5000 \</span><br><span class="line">--restart=always \</span><br><span class="line">--name registry \</span><br><span class="line">-v /var/lib/registry:/var/lib/registry \</span><br><span class="line">-v /var/lib/registry_auth/:/auth/ \</span><br><span class="line">-e <span class="string">&quot;REGISTRY_AUTH=htpasswd&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd&quot;</span> \</span><br><span class="line">-d registry</span><br></pre></td></tr></table></figure></li><li><p>推送本地镜像到镜像仓库中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 镜像仓库给外部访问，不能通过localhost，尝试使用内网地址172.21.51.143:5000/nginx:alpine</span></span><br><span class="line">docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine</span><br><span class="line">docker push 172.21.51.143:5000/nginx:alpine</span><br><span class="line">The push refers to repository [172.21.51.143:5000/nginx]</span><br><span class="line">Get https://172.21.51.143:5000/v2/: http: server gave HTTP response to HTTPS client</span><br><span class="line"><span class="comment">## docker默认不允许向http的仓库地址推送，如何做成https的，参考：https://docs.docker.com/registry/deploying/#run-an-externally-accessible-registry</span></span><br><span class="line"><span class="comment">## 我们没有可信证书机构颁发的证书和域名，自签名证书需要在每个节点中拷贝证书文件，比较麻烦，因此我们通过配置daemon的方式，来跳过证书的验证：</span></span><br><span class="line"><span class="built_in">cat</span> /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://8xpk5wnt.mirror.aliyuncs.com&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;172.21.51.143:5000&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">systemctl restart docker</span><br><span class="line">docker push 172.21.51.143:5000/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会提示认证失败 ，no basic auth credentials,需要登录</span></span><br><span class="line">docker login 172.21.51.143:5000</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看仓库内元数据</span></span><br><span class="line">curl -u admin:admin -X GET http://172.21.51.143:5000/v2/_catalog</span><br><span class="line">curl -u admin:admin  -X GET http://172.21.51.143:5000/v2/nginx/tags/list</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>查看容器列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看运行状态的容器列表</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看全部状态的容器列表</span></span><br><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 后台启动</span></span><br><span class="line">$ docker run --name nginx -d nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">## 映射端口,把容器的端口映射到宿主机中,-p &lt;host_port&gt;:&lt;container_port&gt;</span></span><br><span class="line">$ docker run --name nginx -d -p 8080:80 nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">## 资源限制,最大可用内存500M</span></span><br><span class="line">$ docker run --memory=500m nginx:alpine</span><br></pre></td></tr></table></figure></li><li><p>容器数据持久化</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 挂载主机目录</span></span><br><span class="line">$ docker run --name nginx -d -v /opt:/opt nginx:alpine</span><br><span class="line">$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d -v /opt/mysql/:/var/lib/mysql mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>进入容器或者执行容器内的命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -ti &lt;container_id_or_name&gt; /bin/sh</span><br><span class="line">$ docker <span class="built_in">exec</span> &lt;container_id_or_name&gt; hostname</span><br></pre></td></tr></table></figure></li><li><p>主机与容器之间拷贝数据</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 主机拷贝到容器</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;data&#x27;</span>&gt;/tmp/test.txt</span><br><span class="line">$ docker <span class="built_in">cp</span> /tmp/test.txt nginx:/tmp</span><br><span class="line">$ docker <span class="built_in">exec</span> nginx <span class="built_in">cat</span> /tmp/test.txt</span><br><span class="line">data</span><br><span class="line"></span><br><span class="line"><span class="comment">## 容器拷贝到主机</span></span><br><span class="line">$ docker <span class="built_in">cp</span> nginx:/tmp/test.txt ./</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看全部日志</span></span><br><span class="line">$ docker logs nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 实时查看最新日志</span></span><br><span class="line">$ docker logs -f nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从最新的100条开始查看</span></span><br><span class="line">$ docker logs --<span class="built_in">tail</span>=100 -f nginx</span><br></pre></td></tr></table></figure></li><li><p>停止或者删除容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 停止运行中的容器</span></span><br><span class="line">$ docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动退出容器</span></span><br><span class="line">$ docker start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除非运行中状态的容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除运行中的容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f nginx</span><br></pre></td></tr></table></figure></li><li><p>查看容器或者镜像的明细</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看容器详细信息，包括容器IP地址等</span></span><br><span class="line">$ docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看镜像的明细信息</span></span><br><span class="line">$ docker inspect nginx:alpine</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 设计模式 02</title>
      <link href="/python-design-patterns-02/"/>
      <url>/python-design-patterns-02/</url>
      
        <content type="html"><![CDATA[<h1 id="重载（Overload）和重写（Override）"><a href="#重载（Overload）和重写（Override）" class="headerlink" title="重载（Overload）和重写（Override）"></a>重载（Overload）和重写（Override）</h1><span id="more"></span><h2 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>方法重载的好处就是让类以统一的方式处理不同类型的一种手段，调用方法时通过传递给他们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性。</p><p>它的特点是：重载发生在本类，方法名相同，参数列表不同，与返回值无关，只和方法名，参数的类型相关。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>没有重载前，不同的参数的方法需要定义不同的名字防止冲突（JAVA示例）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestMath &#123;</span><br><span class="line"></span><br><span class="line">    public int sumWithTwoNum(int num1, int num2) &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int sumWithThreeNum(int num1, int num2, int num3) &#123;</span><br><span class="line">        return num1 + num2 + num3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sumWithFourNum(int num1, int num2, int num3, int num4) &#123;</span><br><span class="line">        return num1 + num2 + num3 + num4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载后可以定义为同一个名字的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestMath &#123;</span><br><span class="line"></span><br><span class="line">    public int sum(int num1, int num2) &#123;</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int sum(int num1, int num2, int num3) &#123;</span><br><span class="line">        return num1 + num2 + num3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sum(int num1, int num2, int num3, int num4) &#123;</span><br><span class="line">        return num1 + num2 + num3 + num4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java重载有一些规则，比如仅仅是返回值类型不同和修饰符不同都不构成方法的重载，仅仅是方法参数的名称不同也不构成重载。</p><p>主要是介绍python，只介绍重载定义，具体重载规则请自行百度学习。</p><h2 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h2><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写。</p><p>重写是发生在类的继承关系，或者类的实现关系中的，重写后的方法和原方法需要保持完全相同的返回值类型、方法名、参数个数以及参数类型，简单来说，就是子类重写的方法必须和父类保持完全一致，说白了就是多态。</p><p>比如：定义了一个动物类，其中有一个进食的方法，动物类有两个子类：猫类和狗类，猫类应该对这个进食的方法重写，具体为：猫吃鱼，而狗类则应重写为：狗啃骨头。因为猫和狗进食的具体内容都不同，所以需要重写。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>不同对象调用父类的同一方法产生不同的结果。调用不同的子类将会产生不同的行为，而无须明确知道这个子类实际上是什么，这是多态的重要应用场景。多态的表现形式之一就是继承，先抽象，再继承。</p><p>鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。</p><p>鸭子类型这一名字出自美国James Whitcomb Riley(有的材料说他是诗人，有的说他是测试人员)提出的如下的表述：</p><p>When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.</p><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Duck:</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&quot;Walk like a duck&quot;)</span><br><span class="line"></span><br><span class="line">    def quack(self):</span><br><span class="line">        print(&quot;Quack like a duck&quot;)</span><br><span class="line"></span><br><span class="line">    def attack(self):</span><br><span class="line">        print(&quot;Attack like a duck&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 可达鸭</span><br><span class="line">class MallardDuck(Duck):</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&quot;MallardDuck walking&quot;)</span><br><span class="line"></span><br><span class="line">    def quack(self):</span><br><span class="line">        print(&quot;MallardDuck quacking&quot;)</span><br><span class="line"></span><br><span class="line">    def attack(self):</span><br><span class="line">        print(&quot;MallardDuck attacking&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 大葱鸭</span><br><span class="line">class FarfetchdDuck(Duck):</span><br><span class="line">    def walk(self):</span><br><span class="line">        print(&quot;FarfetchdDuck walking&quot;)</span><br><span class="line"></span><br><span class="line">    def quack(self):</span><br><span class="line">        print(&quot;FarfetchdDuck quacking&quot;)</span><br><span class="line"></span><br><span class="line">    def attack(self):</span><br><span class="line">        print(&quot;FarfetchdDuck attacking&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 和火箭队战斗</span><br><span class="line">def fight_with_team_rocket(duck: Duck):</span><br><span class="line">    duck.walk()</span><br><span class="line">    duck.quack()</span><br><span class="line">    duck.attack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mallard_duck = MallardDuck()</span><br><span class="line">    fight_with_team_rocket(mallard_duck)</span><br><span class="line">    farfetchd_duck = FarfetchdDuck()</span><br><span class="line">    fight_with_team_rocket(farfetchd_duck)</span><br></pre></td></tr></table></figure><h1 id="C-设计模式"><a href="#C-设计模式" class="headerlink" title="C# 设计模式"></a>C# 设计模式</h1><p>继承分为「接口继承」和「实现继承」。在编程语言或者 framework 中实现「接口继承」比较容易，一般保证一定的二进制接口兼容，或者一定的命名规范即可（比如 SICP 中的查表 data-driven）。著名的 Microsoft Component Object Model 和 CORBA 只有接口继承。实现「实现继承」则相对复杂。一般需要在编译级别支持，所以多为语言本身支持。拥有「实现继承」的语言可以通过通过自限的方式模拟「接口继承」。C++ 实现了完全的「多实现继承」，所以它可以完全通过自限的方式模拟「多接口继承」。Java 和 C# 只有「单实现继承」，如果通过自限的方式只能支持「单接口继承」，所以 Java 和 C# 引入了特别的 interface。</p><p>作者：冯东<br>链接：<a href="https://www.zhihu.com/question/20685467/answer/15848984">https://www.zhihu.com/question/20685467/answer/15848984</a><br>来源：知乎</p><p>根据以上信息可以知道，再Java或者C#中，实现设计模式都是通过接口的方式进行设计。</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>两种实现方式：</p><ol><li>类适配器：使用多继承</li><li>对象适配器：使用组合</li></ol><h3 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h3><ul><li>目标接口（Target）</li><li>待适配的类（Adaptee）</li><li>适配器（Adapter）</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>想使用一个已经存在的类，而它的接口不符合你的要求<br>2.（对象适配器）想使用一些已经存在的子类，但不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>类适配器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ColMap(AlgorithmInterface):</span><br><span class="line">    def __init__(self, params):</span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(f&quot;I am running with params: &#123;self.params&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TorchNgp:</span><br><span class="line">    def view(self):</span><br><span class="line">        print(&quot;I am running with no params&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类适配器</span><br><span class="line">class TorchNgpAdapter(AlgorithmInterface, TorchNgp):</span><br><span class="line">    def run(self):</span><br><span class="line">        self.view()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># web点击算法发起任务</span><br><span class="line">def web_show_and_click(algorithm):</span><br><span class="line">    algorithm.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    colmap = ColMap(&quot;params&quot;)</span><br><span class="line">    web_show_and_click(colmap)</span><br><span class="line"></span><br><span class="line">    torch_ngp = TorchNgpAdapter()</span><br><span class="line">    web_show_and_click(torch_ngp)</span><br></pre></td></tr></table></figure><p>对象适配器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ColMap(AlgorithmInterface):</span><br><span class="line">    def __init__(self, params):</span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(f&quot;I am running with params: &#123;self.params&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TorchNgp:</span><br><span class="line">    def view(self):</span><br><span class="line">        print(&quot;I am running with no params&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 类适配器</span><br><span class="line">class AlgorithmAdapter(AlgorithmInterface):</span><br><span class="line">    def __init__(self, algorithm):</span><br><span class="line">        self.algorithm = algorithm</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        if hasattr(self.algorithm, &quot;run&quot;):</span><br><span class="line">            self.algorithm.run()</span><br><span class="line">        elif hasattr(self.algorithm, &quot;view&quot;):</span><br><span class="line">            self.algorithm.view()</span><br><span class="line">        else:</span><br><span class="line">            raise NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># web点击算法发起任务</span><br><span class="line">def web_show_and_click(algorithm):</span><br><span class="line">    algorithm.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    col_map = ColMap(&quot;params&quot;)</span><br><span class="line">    torch_ngp = TorchNgp()</span><br><span class="line">    web_show_and_click(AlgorithmAdapter(col_map))</span><br><span class="line">    web_show_and_click(AlgorithmAdapter(torch_ngp))</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>聚合(aggregation)：指的是整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构。从而找出一些组成类，该整体类和组成类之间就形成了聚合关系。需求描述中“包含”、“组成”、“分为…部分”等词常意味着聚合关系。</p><p>简单的说就是类中使用的实例是外部传入的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Cpu:</span><br><span class="line">    def show(self):</span><br><span class="line">        print(&quot;I am cpu&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Computer:</span><br><span class="line">    def __init__(self, cpu):</span><br><span class="line">        self.cpu = cpu</span><br><span class="line"></span><br><span class="line">    def has_cpu(self):</span><br><span class="line">        self.cpu.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cpu = Cpu()</span><br><span class="line">computer = Computer(cpu)</span><br><span class="line">computer.has_cpu()</span><br></pre></td></tr></table></figure><p>组合(composition)：也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在。部分对象与整体对象之间具有共生死的关系。</p><p>简单的说就是使用的实例是类中生成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Cpu:</span><br><span class="line">    def show(self):</span><br><span class="line">        print(&quot;I am cpu&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Computer:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.cpu = Cpu()</span><br><span class="line"></span><br><span class="line">    def has_cpu(self):</span><br><span class="line">        self.cpu.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">computer = Computer()</span><br><span class="line">computer.has_cpu()</span><br></pre></td></tr></table></figure><h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>将一个事物的两个维度分离，使其都可以独立地变化</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象（Abstraction）</li><li>细化抽象（RefinedAbstraction）</li><li>实现者（Implementor）</li><li>具体实现者（ConcreteImplementor</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 实现者</span><br><span class="line">class GL(ABC):</span><br><span class="line">    def __init__(self, loader):</span><br><span class="line">        self.loader = loader</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def screen(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象</span><br><span class="line">class Loader(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def loader(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 细化抽象</span><br><span class="line">class PlyLoader(Loader):</span><br><span class="line">    def loader(self):</span><br><span class="line">        print(&quot;ply loader&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ObjLoader(Loader):</span><br><span class="line">    def loader(self):</span><br><span class="line">        print(&quot;obj loader&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体实现者</span><br><span class="line">class WebGL(GL):</span><br><span class="line">    def screen(self):</span><br><span class="line">        self.loader.loader()</span><br><span class="line">        print(&quot;call webgl screen method&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OpenGL(GL):</span><br><span class="line">    def screen(self):</span><br><span class="line">        self.loader.loader()</span><br><span class="line">        print(&quot;call opengl screen method&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    webgl = WebGL(PlyLoader())</span><br><span class="line">    webgl.screen()</span><br><span class="line">    opengl = OpenGL(ObjLoader())</span><br><span class="line">    opengl.screen()</span><br></pre></td></tr></table></figure><p>这样之后即使再增加其他模型的加在类或者其他类型的GL方式都可以方便的添加。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当事物有两个维度上的表现，两个维度都可能扩展时。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>抽象和实现相分离</li><li>优秀的扩展能力</li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象组件（Component）</li><li>叶子组件（Leaf）</li><li>复合组件（Composite）</li><li>客户端（Client）</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def train_model(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ColMapApp(AlgorithmInterface):</span><br><span class="line">    def __init__(self, params):</span><br><span class="line">        self.params = params</span><br><span class="line"></span><br><span class="line">    def train_model(self):</span><br><span class="line">        print(f&quot;ColMapApp am training with params: &#123;self.params&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TorchNgpApp(AlgorithmInterface):</span><br><span class="line">    def train_model(self):</span><br><span class="line">        print(f&quot;TorchNgpApp am training with no params&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class NewBeeApp(AlgorithmInterface):</span><br><span class="line">    def __init__(self, algorithms):</span><br><span class="line">        self.algorithms = []</span><br><span class="line"></span><br><span class="line">        for algorithm in algorithms:</span><br><span class="line">            self.add_algorithm(algorithm)</span><br><span class="line"></span><br><span class="line">    def add_algorithm(self, algorithm):</span><br><span class="line">        self.algorithms.append(algorithm)</span><br><span class="line"></span><br><span class="line">    def train_model(self):</span><br><span class="line">        print(&quot;###### NewBeeApp Training ######&quot;)</span><br><span class="line">        for algorithm in self.algorithms:</span><br><span class="line">            algorithm.train_model()</span><br><span class="line">        print(&quot;###### NewBeeApp Trained ######&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># web点击算法发起任务</span><br><span class="line">def web_show_and_click(algorithm):</span><br><span class="line">    algorithm.train_model()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    colmap_app = ColMapApp(params=&quot;colmap_params&quot;)</span><br><span class="line">    torch_ngp_app = TorchNgpApp()</span><br><span class="line">    new_bee_app = NewBeeApp(algorithms=[colmap_app, torch_ngp_app])</span><br><span class="line"></span><br><span class="line">    # 单个算法发起任务</span><br><span class="line">    web_show_and_click(colmap_app)</span><br><span class="line">    # 组合算法发起任务，调用方式相同</span><br><span class="line">    web_show_and_click(new_bee_app)</span><br></pre></td></tr></table></figure><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>表示对象的“部分-整体”层次结构（特别是结构是递归的）</li><li>希望用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中的所有对象</li></ol><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>定义了包含基本对象和组合对象的类层次结构</li><li>简化客户端代码，即客户端可以一致地使用组合对象和单个对象</li><li>更容易增加新类型的组件</li></ul><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>装饰模式是在原有对象的基础上，动态增加一个新的特性。与继承的最大区别是，这种新增特性是比较泛化的，可以被多种对象增加。</p><p>python中通常用的是通过函数装饰器或者类装饰器，直接对对象所属的类进行装饰，语言特性已包含，因此此设计模式略过。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>外观模式又被称为门面模式，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><h3 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h3><ul><li>外观（facade）</li><li>子系统类（subsystem classes）</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class LoaderModel:</span><br><span class="line">    def loader(self):</span><br><span class="line">        print(&quot;loader model&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DrawScreen:</span><br><span class="line">    def draw(self):</span><br><span class="line">        print(&quot;draw screen&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LoadAnimation:</span><br><span class="line">    def animation(self):</span><br><span class="line">        print(&quot;load animation&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Page:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.loader = LoaderModel()</span><br><span class="line">        self.draw = DrawScreen()</span><br><span class="line">        self.animation = LoadAnimation()</span><br><span class="line"></span><br><span class="line">    def load(self):</span><br><span class="line">        self.loader.loader()</span><br><span class="line">        self.draw.draw()</span><br><span class="line">        self.animation.animation()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    page = Page()</span><br><span class="line">    page.load()</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个例子是比如维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展，但是它包含很重要的功能，新的开发必须依赖于它，这样增加外观Facade类，为系统封装一个比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>减少系统相互依赖</li><li>提高了灵活性</li><li>提高了安全性</li></ul><h2 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式(Flyweight)"></a>享元模式(Flyweight)</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><ul><li>图形图像处理软件：在图形图像处理软件中，可能需要创建大量的形状对象，如矩形、圆形等。通过使用享元模式，可以共享形状对象的属性，从而减少内存使用和提高性能。</li><li>游戏开发：在游戏开发中，可能需要创建大量的游戏角色、武器等对象。通过使用享元模式，可以共享游戏对象的属性，从而减少内存使用和提高性能。</li><li>网络服务器：在网络服务器中，可能需要创建大量的网络连接对象。通过使用享元模式，可以共享网络连接对象的属性，从而减少内存使用和提高性能。</li><li>数据库连接池：在数据库连接池中，可能需要创建大量的数据库连接对象。通过使用享元模式，可以共享数据库连接对象的属性，从而减少内存使用和提高性能。</li></ul><h3 id="角色：-1"><a href="#角色：-1" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象享元角色（Flyweight）</li><li>具体享元角色（Concrete Flyweight）</li><li>非享元角色（Unsharable Flyweight)</li><li>享元工厂角色（Flyweight Factory）</li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>想使用一个已经存在的类，而它的接口不符合你的要求<br>2.（对象适配器）想使用一些已经存在的子类，但不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ol><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Flyweight(ABC):</span><br><span class="line">    def __init__(self, shared_state):</span><br><span class="line">        self.shared_state = shared_state</span><br><span class="line">        print(f&quot;Flyweight: (&#123;self.shared_state&#125;)&quot;)</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self, unique_state):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteFlyweight(Flyweight):</span><br><span class="line">    def show(self, unique_state):</span><br><span class="line">        print(f&quot;ConcreteFlyweight: (&#123;self.shared_state&#125;, &#123;unique_state&#125;)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FlyweightFactory:</span><br><span class="line">    _flyweights = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def __init__(self, shared_states):</span><br><span class="line">        for shared_state in shared_states:</span><br><span class="line">            self._flyweights[str(shared_state)] = ConcreteFlyweight(shared_state)</span><br><span class="line"></span><br><span class="line">    def get_flyweight(self, shared_state):</span><br><span class="line">        key = str(shared_state)</span><br><span class="line">        if key not in self._flyweights:</span><br><span class="line">            self._flyweights[key] = ConcreteFlyweight(shared_state)</span><br><span class="line">        return self._flyweights[key]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示模型的客户端代码</span><br><span class="line">class Client:</span><br><span class="line">    def __init__(self, factory):</span><br><span class="line">        self.factory = factory</span><br><span class="line"></span><br><span class="line">    def screen(self, model, position):</span><br><span class="line">        flyweight = self.factory.get_flyweight(model)</span><br><span class="line">        flyweight.show(position)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这里定义模型类，load_model在FlyweightFactory中的初始化时调用</span><br><span class="line">class Model:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 初始化模型</span><br><span class="line">    roma = Model(&quot;罗马斗兽场&quot;)</span><br><span class="line">    lion = Model(&quot;狮子&quot;)</span><br><span class="line">    wolf = Model(&quot;狼&quot;)</span><br><span class="line">    bird = Model(&quot;鸟&quot;)</span><br><span class="line">    car = Model(&quot;汽车&quot;)</span><br><span class="line"></span><br><span class="line">    # 客户端代码, 初始化时加载模型</span><br><span class="line">    client = Client(FlyweightFactory([roma, lion, bird, car]))</span><br><span class="line"></span><br><span class="line">    # 显示模型</span><br><span class="line">    client.screen(roma, (0, 0, 0))</span><br><span class="line">    client.screen(lion, (1, 1, 1))</span><br><span class="line">    client.screen(wolf, (2, 2, 2))</span><br><span class="line">    client.screen(bird, (3, 3, 3))</span><br><span class="line">    client.screen(car, (4, 4, 4))</span><br><span class="line">    client.screen(lion, (5, 5, 5))</span><br><span class="line">    client.screen(wolf, (6, 6, 6))</span><br><span class="line">    client.screen(bird, (7, 7, 7))</span><br></pre></td></tr></table></figure><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.为了共享对象，需要将不能共享的状态外部化，会增加程序的复杂性</p><p>2.对享元模式的外部状态会增长运行时间</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="内容-6"><a href="#内容-6" class="headerlink" title="内容"></a>内容</h3><p>为其他对象提供一种代理，以此控制一个对象的访问方式。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><h3 id="角色：-2"><a href="#角色：-2" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象角色（Subject）</li><li>真实角色（Real Subject）</li><li>代理角色（Proxy）</li></ul><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>远程代理：隐藏对象位于远程地址空间的事实。例如写入数据，而数据库不在本地，需要远程访问。隐藏数据库不在本地的事实，使用代理进行远程存储。</li><li>虚代理：为了节省资源开销，在功能没有被真正调用时，就不运行。例如浏览器中的无图模式，不显示图片，等你真正需要查看某张时，点击才会真正加载图像，不点击时，只会告诉你，此处是一张图像，并不显示</li><li>保护代理：访问一个对象时有一些附加的内务处理。例如为了区分用户权限而设置的代理，普通用户只有访问权限，而开发人员有写入权限。</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Subject(ABC):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.model = None</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RealSubject(Subject):</span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        if not self.model:</span><br><span class="line">            print(f&quot;本地模型 &#123;model&#125; 加载中...&quot;)</span><br><span class="line">            self.model = model</span><br><span class="line">        print(f&quot;&#123;model&#125; 模型加载完成！&quot;)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        print(f&quot;&#123;self.model&#125; 模型展示！&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RemoteProxy(Subject):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.subject = RealSubject()</span><br><span class="line"></span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        print(&quot;远程模型加载中...&quot;)</span><br><span class="line">        self.subject.model = model</span><br><span class="line">        self.subject.load(model)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        return self.subject.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class VirtualProxy(Subject):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.subject = RemoteProxy()</span><br><span class="line"></span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        self.model = model</span><br><span class="line">        print(&quot;虚拟模型已经记录...&quot;)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        if not self.model:</span><br><span class="line">            print(&quot;虚拟模型未记录！&quot;)</span><br><span class="line">            return</span><br><span class="line">        print(&quot;虚拟模型展示！&quot;)</span><br><span class="line">        self.subject.load(self.model)</span><br><span class="line">        self.subject.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ProtectionProxy(Subject):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.subject = VirtualProxy()</span><br><span class="line"></span><br><span class="line">    def load(self, model, *args):</span><br><span class="line">        user = args[0]</span><br><span class="line">        if user == &quot;admin&quot;:</span><br><span class="line">            self.subject.load(model)</span><br><span class="line">            self.model = model</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;权限不足！&quot;)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        if not self.model:</span><br><span class="line">            print(&quot;模型未加载！&quot;)</span><br><span class="line">            return</span><br><span class="line">        self.subject.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def client_code(models_and_users):</span><br><span class="line">    proxy_list = []</span><br><span class="line"></span><br><span class="line">    for user, model in models_and_users:</span><br><span class="line">        # proxy = RealSubject()</span><br><span class="line">        # proxy = RemoteProxy()</span><br><span class="line">        # proxy = VirtualProxy()</span><br><span class="line">        proxy = ProtectionProxy()</span><br><span class="line">        proxy.load(model, user)</span><br><span class="line">        proxy_list.append(proxy)</span><br><span class="line"></span><br><span class="line">    for proxy in proxy_list:</span><br><span class="line">        proxy.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    model_and_user = [</span><br><span class="line">        (&quot;admin&quot;, &quot;roma&quot;),</span><br><span class="line">        (&quot;user&quot;, &quot;bird&quot;),</span><br><span class="line">        (&quot;admin&quot;, &quot;car&quot;)</span><br><span class="line">    ]</span><br><span class="line">    client_code(model_and_user)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 设计模式 03</title>
      <link href="/python-design-patterns-03/"/>
      <url>/python-design-patterns-03/</url>
      
        <content type="html"><![CDATA[<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><span id="more"></span><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>给定一个语言，定义它的文法、语法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p>主要是解释器使用，这里省略</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>责任链模式，将多个处理方法连接成一条链条，请求将在这条链条上流动直到该链条中有一个节点可以处理该请求。通常这条链条是一个对象包含对另一个对象的引用而形成链条，每个节点有对请求的条件，当不满足条件将传递给下一个节点处理。</p><p>责任链模式就是种“推卸”责任的模式，你的问题在我这里能解决我就解决，不行就把你推给另一个对象。至于到底谁解决了这个问题了呢?我管呢!</p><h3 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象处理者(Handler)：定义了处理请求的抽象方法和一个设置责任链的下一个处理者的方法。</li><li>具体处理者(ConcreteHandler)：实现处理请求的方法，判断自己能否处理本次请求，如果能，则处理，如果不能，则把请求转发给责任链的下一个处理者。</li><li>客户类(Client)：创建处理链，对链头提交请求，并不需要关心处理细节。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>若某个请求可以由多个对象进行处理，但具体由哪个对象处理该请求则是由请求内容和对象处理权限确定。</li><li>在请求处理者不明确的情况下，对多个处理者中的一个提交请求。</li><li>需要动态处理一组对象处理请求，比如新增新的处理者。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Request(Enum):</span><br><span class="line">    VACATION = 1</span><br><span class="line">    SALARY_RAISE = 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Handler(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def set_next(self, handler):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def handle(self, request: Request, number: int):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteHandler(Handler):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._next = None</span><br><span class="line"></span><br><span class="line">    def set_next(self, handler):</span><br><span class="line">        self._next = handler</span><br><span class="line">        return handler</span><br><span class="line"></span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if self._next:</span><br><span class="line">            return self._next.handle(request, number)</span><br><span class="line">        print(&quot;No handler found for request: &#123;&#125;&quot;.format(request))</span><br><span class="line"></span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            print(&quot;You can&#x27;t take a vacation.&quot;)</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            print(&quot;You can&#x27;t get a raise.&quot;)</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GeneralManager(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 10:</span><br><span class="line">                print(&quot;General Manager: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 1000:</span><br><span class="line">                print(&quot;General Manager: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DepartmentManager(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 5:</span><br><span class="line">                print(&quot;Department Manager: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 500:</span><br><span class="line">                print(&quot;Department Manager: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        print(&quot;Department Manager: My permissions are insufficient. I&#x27;ll pass this request to next one.&quot;)</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Supervisor(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 3:</span><br><span class="line">                print(&quot;Supervisor: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 300:</span><br><span class="line">                print(&quot;Supervisor: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        print(&quot;Supervisor: My permissions are insufficient. I&#x27;ll pass this request to next one.&quot;)</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Employee(ConcreteHandler):</span><br><span class="line">    def handle(self, request, number):</span><br><span class="line">        if request is Request.VACATION:</span><br><span class="line">            if number &lt;= 1:</span><br><span class="line">                print(&quot;Employee: I&#x27;ll approve your vacation.&quot;)</span><br><span class="line">                return</span><br><span class="line">        elif request is Request.SALARY_RAISE:</span><br><span class="line">            if number &lt;= 100:</span><br><span class="line">                print(&quot;Employee: I&#x27;ll approve your salary raise.&quot;)</span><br><span class="line">                return</span><br><span class="line">        print(&quot;Employee: My permissions are insufficient. I&#x27;ll pass this request to next one.&quot;)</span><br><span class="line">        super().handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Client:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._employee = Employee()</span><br><span class="line">        self._supervisor = Supervisor()</span><br><span class="line">        self._department_manager = DepartmentManager()</span><br><span class="line">        self._general_manager = GeneralManager()</span><br><span class="line"></span><br><span class="line">        self._employee.set_next(self._supervisor).set_next(self._department_manager).set_next(self._general_manager)</span><br><span class="line"></span><br><span class="line">    def make_request(self, request, number):</span><br><span class="line">        self._employee.handle(request, number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    client = Client()</span><br><span class="line">    print(&quot;######## Client: I want to take a vacation for 2 days.&quot;)</span><br><span class="line">    client.make_request(Request.VACATION, 2)</span><br><span class="line">    print(&quot;######## Client: I want to raise my salary for 200.&quot;)</span><br><span class="line">    client.make_request(Request.SALARY_RAISE, 200)</span><br><span class="line">    print(&quot;######## Client: I want to take a vacation for 7 days.&quot;)</span><br><span class="line">    client.make_request(Request.VACATION, 7)</span><br><span class="line">    print(&quot;######## Client: I want to raise my salary for 600.&quot;)</span><br><span class="line">    client.make_request(Request.SALARY_RAISE, 600)</span><br><span class="line">    print(&quot;######## Client: I want to take a vacation for 12 days.&quot;)</span><br><span class="line">    client.make_request(Request.VACATION, 12)</span><br><span class="line">    print(&quot;######## Client: I want to raise my salary for 1200.&quot;)</span><br><span class="line">    client.make_request(Request.SALARY_RAISE, 1200)</span><br></pre></td></tr></table></figure><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>命令模式可将请求转换为一个包含与请求相关的所有信息的独立对象，这个独立对象实现了调用者与接收者之间的解耦，命令模式最大的杀手锏是它能非常轻松的实现撤销操作。</p><p>主要的应用场景就是GUI，将每一个具体命令封装称为一个类，使用不同的命令则调用不同的类，参数通过类进行传递。</p><p>这里省略</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来，放入一个独立的迭代器对象中。迭代器类定义了访问该列表元素的接口。迭代器类提供的方法负责跟踪当前的元素，即它知道哪些元素已经遍历过了，哪些元素还没有被遍历。</p><p>迭代器模式能够提供一种方法按照顺序访问一个聚合对象中的所有元素，而又不需要暴露该对象的内部表示。</p><p>python中提供了iter()方法实现，这里略过</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p><p>主要使用在多个类相互耦合，形成了网状结构时，将上述网状结构分离为星型结构。</p><h3 id="角色：-1"><a href="#角色：-1" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li><li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li><li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>如机场调度系统（多个跑道、飞机、指挥塔之间的调度）</li><li>路由系统；著名的MVC框架中，其中的C（Controller）就是M（Model）和V（View）的中介者。</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象中介者</span><br><span class="line">class Mediator(ABC):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.x = 0</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def register(self, colleague):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象同事类</span><br><span class="line">class Colleague:</span><br><span class="line">    def __init__(self, name, x):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体同事类 汽车</span><br><span class="line">class ConcreteColleagueCar(Colleague):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体同事类 鸟</span><br><span class="line">class ConcreteColleagueBird(Colleague):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体中介类</span><br><span class="line">class ConcreteMediator(Mediator):</span><br><span class="line">    collections = []</span><br><span class="line"></span><br><span class="line">    def register(self, colleague):</span><br><span class="line">        self.collections.append(colleague)</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        for colleague in self.collections:</span><br><span class="line">            print(colleague.name, colleague.x)</span><br><span class="line">            print(f&#x27;place x is &#123;self.x&#125; - &#123;self.x + colleague.x&#125;&#x27;)</span><br><span class="line">            self.x = self.x + colleague.x + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mediator = ConcreteMediator()</span><br><span class="line">    car1 = ConcreteColleagueCar(&#x27;car1&#x27;, 1)</span><br><span class="line">    car2 = ConcreteColleagueCar(&#x27;car2&#x27;, 1)</span><br><span class="line">    bird1 = ConcreteColleagueBird(&#x27;bird1&#x27;, 2)</span><br><span class="line">    bird2 = ConcreteColleagueBird(&#x27;bird2&#x27;, 2)</span><br><span class="line">    mediator.register(car1)</span><br><span class="line">    mediator.register(car2)</span><br><span class="line">    mediator.register(bird1)</span><br><span class="line">    mediator.register(bird2)</span><br><span class="line"></span><br><span class="line">    mediator.show()</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>通过让对象彼此解耦，增加对象的复用性</li><li>通过将控制逻辑集中，可以简化系统维护</li><li>通过中介者使一对多变成了一对一，便于理解</li><li>符合迪米特原则</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>在具体中介者类中包含了同事之间的交互细节，如果设计不好，引入中介者会使程序变的复杂</li><li>中介者承担过多责任，是中心化模式，若中介者出现了问题，整个系统将会崩溃</li></ol><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.bilibili.com/video/BV1Y8411V7gR/">一个被Eclipse，NetBean等项目使用的设计模式</a></p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><p>备忘录模式（Memento Pattern）用于保存一个对象的某个状态，以便在适当的时候恢复对象。特点是不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br>跟原型模式很像，不过在原型模式中保存对象的一切，而备忘录模式中只保存恢复时需要的数据。</p><h3 id="角色：-2"><a href="#角色：-2" class="headerlink" title="角色："></a>角色：</h3><ul><li>Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。</li><li>Memento(备忘录)<br>：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。</li><li>Caretaker(管理者): 负责备忘录Memento，不能对Memento的内容进行访问或者操作。</li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>需要保存和恢复数据的相关状态场景。如保存游戏状态的场景；撤销场景，如Ctrl-Z操作；事务回滚的应用。一般情况下事务回滚有两种方式：一是把从恢复点开始的操作都反向执行一遍；二是直接恢复到恢复点的各种状态。两种方式各有优缺点，要结合业务场景，决定使用哪种模式；</li><li>副本监控场景。备忘录可以当作一个临时的副本监控，实现非实时和准实时的监控。</li></ol><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Originator(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def save(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def restore(self, memento):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def set(self, state):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def get(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteOriginator(Originator):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._state = None</span><br><span class="line"></span><br><span class="line">    def save(self):</span><br><span class="line">        return ConcreteMemento(self._state)</span><br><span class="line"></span><br><span class="line">    def restore(self, memento):</span><br><span class="line">        self._state = memento.get_state()</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        print(f&quot;State: &#123;self._state&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    def set(self, state):</span><br><span class="line">        self._state = state</span><br><span class="line"></span><br><span class="line">    def get(self):</span><br><span class="line">        return self._state</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Memento(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def get_name(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def get_date(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteMemento(Memento):</span><br><span class="line">    def __init__(self, state):</span><br><span class="line">        self._state = state</span><br><span class="line">        self._date = str(datetime.now())[:19]</span><br><span class="line"></span><br><span class="line">    def get_state(self):</span><br><span class="line">        return self._state</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        return f&quot;&#123;self._date&#125; / (&#123;self._state[0:9]&#125;...)&quot;</span><br><span class="line"></span><br><span class="line">    def get_date(self):</span><br><span class="line">        return self._date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Caretaker:</span><br><span class="line">    def __init__(self, originator):</span><br><span class="line">        self._mementos = []</span><br><span class="line">        self._originator = originator</span><br><span class="line"></span><br><span class="line">    def backup(self):</span><br><span class="line">        print(&quot;Caretaker: Saving Originator&#x27;s state...&quot;)</span><br><span class="line">        self._mementos.append(self._originator.save())</span><br><span class="line"></span><br><span class="line">    def undo(self):</span><br><span class="line">        if not len(self._mementos):</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        memento = self._mementos.pop()</span><br><span class="line">        print(f&quot;Caretaker: Restoring state to: &#123;memento.get_name()&#125;&quot;)</span><br><span class="line">        try:</span><br><span class="line">            self._originator.restore(memento)</span><br><span class="line">        except Exception:</span><br><span class="line">            self.undo()</span><br><span class="line"></span><br><span class="line">    def show_history(self):</span><br><span class="line">        print(&quot;Caretaker: Here&#x27;s the list of mementos:&quot;)</span><br><span class="line">        for memento in self._mementos:</span><br><span class="line">            print(memento.get_name())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    originator = ConcreteOriginator()</span><br><span class="line">    caretaker = Caretaker(originator)</span><br><span class="line"></span><br><span class="line">    originator.set(&quot;State #1&quot;)</span><br><span class="line">    originator.set(&quot;State #2&quot;)</span><br><span class="line">    caretaker.backup()</span><br><span class="line"></span><br><span class="line">    originator.set(&quot;State #3&quot;)</span><br><span class="line">    caretaker.backup()</span><br><span class="line"></span><br><span class="line">    originator.set(&quot;State #4&quot;)</span><br><span class="line">    caretaker.backup()</span><br><span class="line"></span><br><span class="line">    caretaker.undo()</span><br><span class="line">    caretaker.undo()</span><br><span class="line"></span><br><span class="line">    caretaker.show_history()</span><br><span class="line"></span><br><span class="line">    print(&quot;\nClient: Now, let&#x27;s rollback!\n&quot;)</span><br><span class="line">    caretaker.undo()</span><br><span class="line"></span><br><span class="line">    originator.show()</span><br><span class="line"></span><br><span class="line">    # Output:</span><br><span class="line">    # Caretaker: Saving Originator&#x27;s state...</span><br><span class="line">    # Caretaker: Saving Originator&#x27;s state...</span><br><span class="line">    # Caretaker: Restoring state to: 2020-07-07 22:07:54 / (State #4...)</span><br><span class="line">    # Caretaker: Restoring state to: 2020-07-07 22:07:54 / (State #3...)</span><br><span class="line">    # Caretaker: Here&#x27;s the list of mementos:</span><br><span class="line">    # 2020-07-07 22:07:54 / (State #2...)</span><br><span class="line">    #</span><br><span class="line">    # Client: Now, let&#x27;s rollback!</span><br><span class="line">    #</span><br><span class="line">    # Caretaker: Restoring state to: 2020-07-07 22:07:54 / (State #2...)</span><br><span class="line">    # State: State #2</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，<br>使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</li><li>本模式简化了发起人的类。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需<br>要的这些状态的版本。</li><li>当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。</li><li>当负责人角色将一个备忘录存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。</li><li>当发起人角色的状态改变的时候，有可能这个协议无效。</li></ol><h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.bilibili.com/video/BV1Za4113734">用Java实现Redis的RDB机制 离不开这个设计模式</a></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="内容-6"><a href="#内容-6" class="headerlink" title="内容"></a>内容</h3><p>观察者模式应用比较广泛，又被称为“发布-订阅”模式。它用来定义对象间一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都得到通知并被自动更新。</p><h3 id="角色：-3"><a href="#角色：-3" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象主题(Subject)</li><li>具体主题（ConcreteSubject）– 发布者</li><li>抽象观察者(Observer)</li><li>具体观察者（ConcreteObserver）– 订阅者</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当一个抽象模型有两个方面，其中一个方面依赖另一个方面。将这两者封装在独立对象中以使它们可以各自独立地改变和复用</li><li>当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象待改变</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧耦合的。</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象主题</span><br><span class="line">class Subject(object):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def register(self, observer):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def unregister(self, observer):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def notify(self, notice):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象的订阅者</span><br><span class="line">class Observer(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def update(self, notice):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param notice: Notice类的对象</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体主题， 微信服务号</span><br><span class="line">class ConcreteSubject(Subject):</span><br><span class="line">    def __init__(self, service_name):</span><br><span class="line">        self._users = []</span><br><span class="line"></span><br><span class="line">        # 服务号名称</span><br><span class="line">        self.service_name = service_name</span><br><span class="line"></span><br><span class="line">    # 添加订阅者信息</span><br><span class="line">    def register(self, observer):</span><br><span class="line">        if observer not in self._users:</span><br><span class="line">            self._users.append(observer)</span><br><span class="line"></span><br><span class="line">    # 用户取消关注，取消订阅者</span><br><span class="line">    def unregister(self, observer):</span><br><span class="line">        self._users.remove(observer)</span><br><span class="line"></span><br><span class="line">    # 通知所有订阅者</span><br><span class="line">    def notify(self, notice):</span><br><span class="line">        for observer in self._users:</span><br><span class="line">            observer.update(notice)</span><br><span class="line"></span><br><span class="line">    # 发布消息</span><br><span class="line">    def write_new_post(self, post_name):</span><br><span class="line">        print(&#x27;微信服务号&#123;&#125;：&#123;&#125;&#x27;.format(self.service_name, post_name))</span><br><span class="line">        self.notify(post_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体订阅者，微信用户</span><br><span class="line">class ConcreteObserver(Observer):</span><br><span class="line">    def __init__(self, username):</span><br><span class="line">        self.username = username</span><br><span class="line"></span><br><span class="line">    def update(self, post_name):</span><br><span class="line">        print(f&#x27;微信用户&#123;self.username&#125;接收到消息，公众号发布了新帖子：&#123;post_name&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 程序入口</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 微信服务号</span><br><span class="line">    python_service = ConcreteSubject(&quot;Python论坛&quot;)</span><br><span class="line">    # 用户对象</span><br><span class="line">    user1 = ConcreteObserver(&#x27;cd&#x27;)</span><br><span class="line">    user2 = ConcreteObserver(&#x27;yx&#x27;)</span><br><span class="line">    user3 = ConcreteObserver(&#x27;xl&#x27;)</span><br><span class="line">    # 订阅Python论坛公帐号</span><br><span class="line">    python_service.register(user1)</span><br><span class="line">    python_service.register(user2)</span><br><span class="line">    python_service.register(user3)</span><br><span class="line">    # 公众号发布文章通知所有订阅</span><br><span class="line">    python_service.write_new_post(&quot;python设计模式01&quot;)</span><br><span class="line">    # 用户2取消订阅旅游知识号</span><br><span class="line">    python_service.unregister(user2)</span><br><span class="line">    # 取消订阅的用户接收不到通知</span><br><span class="line">    python_service.write_new_post(&quot;python设计模式02&quot;)</span><br><span class="line"></span><br><span class="line"># Output</span><br><span class="line"># 微信服务号Python论坛：python设计模式01</span><br><span class="line"># 微信用户cd接收到消息，公众号发布了新帖子：python设计模式01</span><br><span class="line"># 微信用户yx接收到消息，公众号发布了新帖子：python设计模式01</span><br><span class="line"># 微信用户xl接收到消息，公众号发布了新帖子：python设计模式01</span><br><span class="line"># 微信服务号Python论坛：python设计模式02</span><br><span class="line"># 微信用户cd接收到消息，公众号发布了新帖子：python设计模式02</span><br><span class="line"># 微信用户xl接收到消息，公众号发布了新帖子：python设计模式02</span><br></pre></td></tr></table></figure><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol><li>目标和观察者之间的抽象耦合最小</li><li>支持广播通信。</li></ol><h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><ul><li>中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。</li><li>中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接，<br>使得部分对象可作为其他对象的附属发挥作用。</li><li>有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。<br>当中介者以这种方式实现时， 它可能看上去与观察者非常相似。</li><li>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同，<br>但这仍是一种中介者模式。</li><li>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象，<br>而只有一些分布式的观察者。</li></ul><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="内容-7"><a href="#内容-7" class="headerlink" title="内容"></a>内容</h3><p>行为模式关注的是对象的响应性。它们通过对象之间的交互以实现更强大的功能。状态设计模式是一种行为设计模式，有时也被称为状态模式对象。在此模式中，一个对象可以基于其内部状态封装多个行为。状态模式也可以看作是在运行时改变对象行为的一种方式。</p><p>状态设计模式允许对象在其内部状态变化时改变其行为。这看起来就像对象本身已经改变了它的类一样。状态设计模式常用于开发有限状态机，并帮助协调状态处理操作。</p><h3 id="角色：-4"><a href="#角色：-4" class="headerlink" title="角色："></a>角色：</h3><ul><li>State：这被认为是封装对象行为的接口。这个行为与对象的状态相关联。</li><li>ConcreteState：这是实现State接口的子类。ConcreteState实现对象的特定状态相关联的实际行为</li><li>Context：这定义了客户感兴趣的接口。Context还维护一个ConcreteState子类的实例，该子类在内部定义了对象的特定状态的实现</li></ul><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class State(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def handle(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteStateA(State):</span><br><span class="line">    def handle(self):</span><br><span class="line">        print(&quot;ConcreteStateA&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteStateB(State):</span><br><span class="line">    def handle(self):</span><br><span class="line">        print(&quot;ConcreteStateB&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Context(State):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.state = None</span><br><span class="line"></span><br><span class="line">    def get_state(self):</span><br><span class="line">        return self.state</span><br><span class="line"></span><br><span class="line">    def set_state(self, state):</span><br><span class="line">        self.state = state</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        self.state.handle()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context = Context()</span><br><span class="line">state = ConcreteStateA()</span><br><span class="line">stateB = ConcreteStateB()</span><br><span class="line">context.set_state(state)</span><br><span class="line">context.handle()</span><br><span class="line">state = ConcreteStateB()</span><br><span class="line">context.set_state(state)</span><br><span class="line">context.handle()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算机开关机状态</span><br><span class="line">class ComputerState:</span><br><span class="line">    name = &#x27;state&#x27;</span><br><span class="line">    allowed = []</span><br><span class="line"></span><br><span class="line">    def switch(self, state):</span><br><span class="line">        if state.name in self.allowed:</span><br><span class="line">            print(&#x27;Current:&#x27;, self, &#x27;=&gt;switched to new state&#x27;, state.name)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;Current:&#x27;, self, &#x27;=&gt;switched to&#x27;, state.name, &#x27;not possible&#x27;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Off(ComputerState):</span><br><span class="line">    name = &#x27;off&#x27;</span><br><span class="line">    allowed = [&#x27;on&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class On(ComputerState):</span><br><span class="line">    name = &#x27;on&#x27;</span><br><span class="line">    allowed = [&#x27;off&#x27;, &#x27;suspend&#x27;, &#x27;hibernate&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Suspend(ComputerState):</span><br><span class="line">    name = &#x27;suspend&#x27;</span><br><span class="line">    allowed = [&#x27;on&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Hibernate(ComputerState):</span><br><span class="line">    name = &#x27;hibernate&#x27;</span><br><span class="line">    allowed = [&#x27;on&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Computer(object):</span><br><span class="line">    def __init__(self, model=&#x27;HP&#x27;):</span><br><span class="line">        self.model = model</span><br><span class="line">        self.state = Off()</span><br><span class="line"></span><br><span class="line">    def change(self, state):</span><br><span class="line">        self.state.switch(state)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    comp = Computer()</span><br><span class="line">    comp.change(On)</span><br><span class="line">    comp.change(Off)</span><br><span class="line">    comp.change(On)</span><br><span class="line">    comp.change(Suspend)</span><br><span class="line">    comp.change(Hibernate)</span><br><span class="line">    comp.change(On)</span><br><span class="line">    comp.change(Off)</span><br></pre></td></tr></table></figure><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>在状态设计模式中，对象的行为是其状态的函数结果，并且行为在运动时根据状态而改变。这消除了if&#x2F;else或switch&#x2F;case条件逻辑的依赖。</li><li>使用状态模式，实现多态行为的好处显而易见的，并且更易于添加状态来支持额外的行为</li><li>状态设计还提高了聚合性，因为特定于状态的行为被聚合到ConcreteState类中，并且放置在代码中的同一个地方</li><li>使用状态设计模式，通过只添加一个ConcreteState类来添加行为是非常容易的。因此，状态模式不仅改善了扩展应用程序行为时的灵活性，而且全面提高了代码的可维护性。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>类爆炸：由于每个状态都需要在ConcreteState的帮助下定义，因此我们可能导致创建了太多功能比较单一的类。我们不妨考虑有限状态机的情况——如果有许多状态，但是每个状态与另一个状态没有太大的不同，我们仍然需要将它们写成单独的ConcreteState类。这即增加了代码量，又使得状态机构更加难以审查。</li><li>随着每个新行为的引入，Context类都需要进行相应的更新处理每个行为。这使得上下文行为更容易受到每个新的行为的影响。</li></ul><h3 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.bilibili.com/video/BV1oi4y1g7Nn/">五分钟学设计模式.09.状态模式</a></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="内容-8"><a href="#内容-8" class="headerlink" title="内容"></a>内容</h3><p>定义一系列的算法，把它们封装起来，并且使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化。</p><h3 id="角色：-5"><a href="#角色：-5" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象策略 Strategy：定义了一个共同的接口。所有具体的算法类实现这个接口。环境（上下文）类 Context 使用这个接口调用具体的算法类。</li><li>具体策略 ConcreteStrategy：封装了具体的算法，实现同一个接口。</li><li>上下文 Context：环境（上下文）类。用于配置一个具体的算法策略对象，维持一个策略接口类型的参考（Reference），并且可以定义一个让接口<br>Strategy 的具体对象访问的接口。在简单情况下，Context 类可以省略。</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>在以下情况之一发生时可以使用策略模式。</p><ul><li>当有多个仅在行为上不同但是相关的类存在时，策略模式提供了一个为一个类配置多种行为之一的方法。</li><li>当一个算法使用用户不应该知道的数据时，使用策略模式可以将算法的实现细节隐藏起来，避免暴露与算法相关的复杂细节。注意，虽然可以将算法的实现细节封装起来，但是客户程序必须知道各个策略子类的接口。</li><li>当一个类有多种行为，这些行为以大块的条件语句实现时可以使用策略模式，这时可以将条件块移入它们自己的 Strategy 类。</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 抽象策略</span><br><span class="line">class Strategy(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def execute(self, data):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体策略</span><br><span class="line">class CStrategy(Strategy):</span><br><span class="line">    def execute(self, data):</span><br><span class="line">        print(f&quot;使用C算法处理&#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体策略</span><br><span class="line">class NStrategy(Strategy):</span><br><span class="line">    def execute(self, data):</span><br><span class="line">        print(F&quot;使用N算法处理&#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 上下文</span><br><span class="line">class Context:</span><br><span class="line">    def __init__(self, strategy, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.strategy = strategy</span><br><span class="line">        # 可以定义用户不知道的东西</span><br><span class="line">        self.date = datetime.now()</span><br><span class="line"></span><br><span class="line">    def set_strategy(self, strategy):</span><br><span class="line">        self.strategy = strategy</span><br><span class="line"></span><br><span class="line">    def do_strategy(self):</span><br><span class="line">        self.strategy.execute(self.data)</span><br><span class="line"></span><br><span class="line"># Client</span><br><span class="line">data = &quot;Hello!&quot;</span><br><span class="line">context = Context(None, data)</span><br><span class="line"></span><br><span class="line"># 使用C算法处理</span><br><span class="line">context.set_strategy(CStrategy())</span><br><span class="line">context.do_strategy()</span><br><span class="line"># 使用N算法处理</span><br><span class="line">context.set_strategy(NStrategy())</span><br><span class="line">context.do_strategy()</span><br></pre></td></tr></table></figure><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ol><li>得到一系列可以复用的算法，这些算法继承一个共同的抽象类，因此共有的功能可以放到超类中。</li><li>将不同的算法封装在不同的策略子类中，使逻辑更加清晰，各个算法可以独立地变化，消除了大量的 if…else 语句。</li><li>提供了相同行为的不同实现。客户可以根据不同时间或空间要求选择不同的策略。</li><li>使功能改变或者扩展更容易。具体地说，修改一个算法不必重新编译“Client”与“Context”类。增加一个新算法时，在应用程序暂时还不想使用该新算法的情况下，不必重新编译“Client”与“Context”类。</li></ol><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这与“依赖倒置原则”是背道而驰的。</li><li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</li><li>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</li><li>在客户类中通常存在许多与策略类各个分支相关的条件语句，用于选择产生策略子类对象，然后将这些对象传递给 Context 类，而<br>Context 类则直接使用此对象调用策略模式的策略子类的方法。</li></ol><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="内容-9"><a href="#内容-9" class="headerlink" title="内容"></a>内容</h3><p>访问者模式是指作用于一个对象结构体上的元素的操作。访问者可以使用户在不改变该结构体中的类的基础上定义一个新的操作。</p><h3 id="角色：-6"><a href="#角色：-6" class="headerlink" title="角色："></a>角色：</h3><ul><li>Visitor：为每个 Element 的对象声明一个访问操作。该访问操作的名字最好要包含被访问的类的名字，以便确认该访问操作是专门针对哪个具体的类，如 visitFamilyNoChildren 是专门为了服务类 FamilyNoChildren 的。</li><li>ConcreteVisitor：实现 Visitor 声明的运算。每个运算实现为对应的类的对象定义的算法的一部分。ConcreteVisitor 提供算法的环境并且存储其局部状态。</li><li>Element：定义了一些基本的方法，其中包含提供基本数据的方法，例如一些 get()与 set()方法。重要的是，每个 Element 子类都必须定义一个接收者方法，该方法以 Visitor 为参数类型：Accept(Visitor)，其作用是为被访问者对象和访问者对象之间的交互提供接口。</li><li>ConcreteElement：具体的 Element 的子类，例如 ElementA，该类包含一个 accept 方法接收访问者对象。另外，该类还可能定义一些其他的方法以帮助访问者实现一些功能。</li><li>ObjectStructure：提供一个高层接口，允许访问者访问 Element 的子类。在该类中可以包含一个结构，例如 ArrayList、Vector 等，提供所要访问的 element 的列表。</li></ul><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当一个对象的结构中，包含有多种类型的具有不同接口的对象，且用户要在这些对象上进行依赖于具体的类的运算时，需要用到访问者模式。这就是为什么访问者模式要针对每个被访问的子类都设计一个不同的接口的原因。事实上，如果每个被访问的子类都有相同的接口，包括构造方法、其他方法、参数都一致，则访问者类只需要设计一个访问方法，在该方法中含有一个用于区别不同的被访问的子类的参数即可，例如可以使用被访问者基类作为参数类型。在对象的结构中包含有多种类型的有不同接口的对象时，各个不同的访问方法可能为访问所对应的类提供不同的参数类型。</li><li>当有多个不同的并且互不相关的运算将作用到这些对象上，而用户不希望这些运算混淆这些类时，可以使用访问者模式将相关的操作放到独立的类中，例如为了实现每个结点类中的计算价格方法，可以将所有的计算价格方法放到一个 VisitPrice 类中。</li><li>在对象的数据类型很少改变，但是需要经常改变操作或者增加新的操作的情况下，可以使用访问者模式。反之，如果 Element 的子类经常改变结构，例如需要增加一个新的税种，这就需要在访问者类中增加新的访问方法，因此，在这种情况下使用访问者模式代价较高，尽量不要使用访问者模式。</li></ul><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Visitor(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def visit_element_a(self, element_a):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def visit_element_b(self, element_b):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteVisitor1(Visitor):</span><br><span class="line">    def visit_element_a(self, element_a):</span><br><span class="line">        print(&#x27;ConcreteVisitor1&#x27;, &#x27;element_a&#x27;)</span><br><span class="line"></span><br><span class="line">    def visit_element_b(self, element_b):</span><br><span class="line">        print(&#x27;ConcreteVisitor1&#x27;, &#x27;element_b&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteVisitor2(Visitor):</span><br><span class="line">    def visit_element_a(self, element_a):</span><br><span class="line">        print(&#x27;ConcreteVisitor2&#x27;, &#x27;element_a&#x27;)</span><br><span class="line"></span><br><span class="line">    def visit_element_b(self, element_b):</span><br><span class="line">        print(&#x27;ConcreteVisitor2&#x27;, &#x27;element_b&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Element(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def accept(self, visitor):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ElementA(Element):</span><br><span class="line">    def accept(self, visitor):</span><br><span class="line">        visitor.visit_element_a(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ElementB(Element):</span><br><span class="line">    def accept(self, visitor):</span><br><span class="line">        visitor.visit_element_b(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ObjectStructure:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.elements = [ElementA(), ElementB()]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Client:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def main():</span><br><span class="line">        object_structure = ObjectStructure()</span><br><span class="line">        visitor = ConcreteVisitor1()</span><br><span class="line">        for element in object_structure.elements:</span><br><span class="line">            element.accept(visitor)</span><br><span class="line">        visitor = ConcreteVisitor2()</span><br><span class="line">        for element in object_structure.elements:</span><br><span class="line">            element.accept(visitor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    Client.main()</span><br></pre></td></tr></table></figure><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ol><li>使得在访问者类中针对复杂类结构中的某个类添加新方法较为容易，即只需要简单地添加一个新的访问者方法即可。如果不采用访问者模式，这需要在每个类中添加一个新的方法。</li><li>访问者将相关的方法集中在一个具体的访问者类中，而其他相关的方法集中在另外一个具体的访问者类中。也就是说，访问者子类是按照方法的类型来分类的。</li></ol><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>在增加新的元素类的时候比较困难。每增加一个新的元素类，所有的访问者类都要增加一个新的方法，这违背了“开闭原则”。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="内容-10"><a href="#内容-10" class="headerlink" title="内容"></a>内容</h3><p>定义一个操作中的算法骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h3 id="角色：-7"><a href="#角色：-7" class="headerlink" title="角色："></a>角色：</h3><ul><li>抽象类 AbstractClass：声明一个定义算法步骤的接口，作用是定义抽象类（钩子操作），实现一个模板方法作为算法的骨架</li><li>具体类 ConcreteClass：定义子类特定的步骤，作用是实现原子操作。</li></ul><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一次性实现一个算法的不变部分，各个子类中的公共行为应该被提取出来并集中到一个公共父类中以避免代码重复</li><li>控制子类扩展</li><li>当多个算法或类实现类似或相同逻辑的时候</li><li>在子类中实现算法有助于减少重复代码的时候</li><li>可以让子类利用覆盖实现行为来定义多个算法的时候</li></ul><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AbstractClass(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def parse(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def allocate(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def preprocessing(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def training(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def inference(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def saving_result(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def template_method(self):</span><br><span class="line">        print(&quot;算法流程&quot;)</span><br><span class="line">        print(&quot;1. 解析数据&quot;)</span><br><span class="line">        self.parse()</span><br><span class="line">        print(&quot;2. 分配资源&quot;)</span><br><span class="line">        self.allocate()</span><br><span class="line">        print(&quot;3. 预处理&quot;)</span><br><span class="line">        self.preprocessing()</span><br><span class="line">        print(&quot;4. 训练&quot;)</span><br><span class="line">        self.training()</span><br><span class="line">        print(&quot;5. 推理&quot;)</span><br><span class="line">        self.inference()</span><br><span class="line">        print(&quot;6. 保存结果&quot;)</span><br><span class="line">        self.saving_result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ConcreteClass(AbstractClass):</span><br><span class="line">    def parse(self):</span><br><span class="line">        print(&quot;解析数据&quot;)</span><br><span class="line"></span><br><span class="line">    def allocate(self):</span><br><span class="line">        print(&quot;分配资源&quot;)</span><br><span class="line"></span><br><span class="line">    def preprocessing(self):</span><br><span class="line">        print(&quot;预处理&quot;)</span><br><span class="line"></span><br><span class="line">    def training(self):</span><br><span class="line">        print(&quot;训练&quot;)</span><br><span class="line"></span><br><span class="line">    def inference(self):</span><br><span class="line">        print(&quot;推理&quot;)</span><br><span class="line"></span><br><span class="line">    def saving_result(self):</span><br><span class="line">        print(&quot;保存结果&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Client(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 应该通过命令、参数等可配置不同的具体的类，这里为了简单直接实例化</span><br><span class="line">        self.concreate = ConcreteClass()</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        self.concreate.template_method()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client = Client()</span><br><span class="line">client.main()</span><br></pre></td></tr></table></figure><h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ol><li>没有重复代码</li><li>由于模板方法模式使用继承而不是合成，因此能够对代码进行重用。所以，只有为数不多的几个方法需要重写。</li><li>灵活性允许子类决定如何实现算法中的步骤。</li></ol><h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ol><li>调试和理解模板方法模式中的流程序列有时会令人困惑。你最终实现的方法可能是一个不应该实现的方法，或根本没有实现抽象方法。文档和严格的错误处理必须由程序员完成。</li><li>模板框架的维护可能是一个问题，因为任何层次（低层或高层）的变更都可能对现实造成干扰。因此使用模板方法模式可能使维护变得异常痛苦。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 设计模式 01</title>
      <link href="/python-design-patterns-01/"/>
      <url>/python-design-patterns-01/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式（Design pattern）是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</p><p>每一个设计模式系统地命名、解释和评价了面向对象系统中一个重要的和重复出现的设计。</p><p>这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。</p><p>我们使用设计模式最终的目的是实现代码的高内聚和低耦合。</p><p>设计模式中有一些重要的人物如，“四人帮”（Gang of Four， GoF）：Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides，他们写了一本书在设计模式中影响比较大《设计模式：可复用面向对象软件的基础》</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>这里的设计模式特指OOP中的设计模式，说明之前需要明确几个概念。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象的三大特性：</p><ul><li>封装：将数据、方法封装到一个类里；具有公有和私有属性。</li><li>继承：多个类之间复用代码使用继承。</li><li>多态：python本身就是一门多态语言，不用程序员去考虑多态，语言特性自己做了。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口：若干抽象方法的集合。<br>作用：限制实现接口的类必须按照接口给定的调用方式实现这些方法；对高层模块隐藏了类的内部实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@abstractmethod：抽象方法，含abstractmethod方法的类不能实例化，继承了含abstractmethod方法的子类必须复写所有abstractmethod装饰的方法，未被装饰的可以不重写</span><br><span class="line">@property：方法伪装属性，方法返回值及属性值，被装饰方法不能有参数，必须实例化后调用，类不能调用</span><br><span class="line">@classmethod：类方法，可以通过实例对象和类对象调用，被该函数修饰的方法第一个参数代表类本身常用cls，被修饰函数内可调用类属性，不能调用实例属性</span><br><span class="line">@staticmethod：静态方法，可以通过实例对象和类对象调用，被装饰函数可无参数，被装饰函数内部通过类名.属性引用 类属性或类方法，不能引用实例属性</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># abstract class 有抽象方法就是抽象类：抽象类不可被实例化</span><br><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># class BaseAlgorithmInterface:</span><br><span class="line">#     def run(self):</span><br><span class="line">#         raise NotImplementedError</span><br><span class="line">#</span><br><span class="line">class BaseAlgorithmInterface(ABC):</span><br><span class="line">    # 该类被子类继承时必须实现被abstractmethod装饰的方法</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Colmap(BaseAlgorithmInterface):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;do something with Colmap&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerf(BaseAlgorithmInterface):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;do something with HashNert&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = Colmap()</span><br><span class="line">c.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="面向对象设计SOLID原则"><a href="#面向对象设计SOLID原则" class="headerlink" title="面向对象设计SOLID原则"></a>面向对象设计SOLID原则</h1><ol><li><p>单一职责原则</p><p>就一个类而言，应该仅有一个引起它变化的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱他的设计，当变化发生时，设计会遭受到意想不到的破坏；软件设计真正要做的许多内容就是发现职责并把那些职责相互分离。</p></li><li><p>开放-封闭原则</p><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p><p>该原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的可维护、可扩展、可复用、灵活性好。</p><p>设计人员必须对于他设计的模块应该对哪种变化封闭做出选择，必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。最初编写程序时假设变化不会发生，当变化发生时，就创建抽象来隔离以后发生的同类变化，拒绝不成熟的抽象。</p></li><li><p>里氏替换原则</p><p>所有引用父类的地方必须能透明地使用其子类的对象。</p><p>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</p></li><li><p>依赖倒置原则</p><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p><p>要针对接口编程，而不是针对实现编程。该原则可以说是面向对象设计的标志，编写时考虑的是如何对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口。</p></li><li><p>迪迷特原则（最少知识原则）</p><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>该原则其根本思想，是强调了类之间的松耦合；类之间的耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</p></li><li><p>接口隔离原则</p><p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></li><li><p>合成&#x2F;聚合复用原则</p><p>尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p><p>聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p><p>优先使用对象的合成&#x2F;聚合将有助于你保持每个类被封装，并被击中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p></li></ol><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ol><li><p>创建型模式（5种）</p><p>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p><ul><li>工厂方法模式</li><li>抽象工厂模式</li><li>创建者模式</li><li>原型模式</li><li>单例模式</li></ul></li><li><p>结构型模式（7种）</p><p>把类或对象结合在一起形成一个更大的结构。</p><ul><li>适配器模式</li><li>桥模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul></li><li><p>行为型模式（11种）</p><p>类和对象如何交互，及划分责任和算法。</p><ul><li>解释器模式</li><li>责任链模式</li><li>命令模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>访问者模式</li><li>模板方法模式</li></ul></li></ol><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>工厂角色（Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseAlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Colmap(BaseAlgorithmInterface):</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with Colmap&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerf(BaseAlgorithmInterface):</span><br><span class="line">    def __init__(self, application=None):</span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        if self.application:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with &#123;self.application&#125; base on HashNerf&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with HashNerf&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AlgorithmFactory:</span><br><span class="line">    def create_algorithm(self, name):</span><br><span class="line">        match name:</span><br><span class="line">            case &#x27;colmap&#x27;:</span><br><span class="line">                return Colmap()</span><br><span class="line">            case &#x27;hashnerf&#x27;:</span><br><span class="line">                return HashNerf()</span><br><span class="line">            case &#x27;slam&#x27;:</span><br><span class="line">                return HashNerf(application=&#x27;slam&#x27;)</span><br><span class="line">            case _:</span><br><span class="line">                raise ValueError(f&#x27;Algorithm &#123;name&#125; is not supported&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line"># 算法应用创建工厂</span><br><span class="line">algorithm_factory = AlgorithmFactory()</span><br><span class="line"></span><br><span class="line">nerf = algorithm_factory.create_algorithm(&#x27;hashnerf&#x27;)</span><br><span class="line">nerf.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br><span class="line"></span><br><span class="line"># 隐藏类的内部实现</span><br><span class="line">slam = algorithm_factory.create_algorithm(&#x27;slam&#x27;)</span><br><span class="line">slam.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>隐藏了对象创建的实现细节</li><li>客户端不需要修改代码</li></ul><p>缺点：</p><ul><li>违反了单一职责原则，将创建逻辑几种到一个工厂类里</li><li>当添加新产品时，需要修改工厂类代码，违反了开闭原则</li></ul><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>定义一个用于创建对象的接口（工厂接口），让子类决定实例化哪一个产品类。</p><h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象工厂角色（Creator）</li><li>具体工厂角色（Concrete Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseAlgorithmInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Colmap(BaseAlgorithmInterface):</span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with Colmap&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerf(BaseAlgorithmInterface):</span><br><span class="line">    def __init__(self, application=None):</span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    def run(self, dataset=None, params=None, output_dir=None):</span><br><span class="line">        if self.application:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with &#123;self.application&#125; base on HashNerf&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&#x27;do something(dataset: &#123;dataset&#125;, params: &#123;params&#125;, output_dir: &#123;output_dir&#125;) with HashNerf&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体工厂 #####</span><br><span class="line">class ColmapFactory:</span><br><span class="line">    def create_algorithm(self):</span><br><span class="line">        return Colmap()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashNerfFactory:</span><br><span class="line">    def create_algorithm(self):</span><br><span class="line">        return HashNerf()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SlamFactory:</span><br><span class="line">    def create_algorithm(self):</span><br><span class="line">        return HashNerf(application=&#x27;slam&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line">nerf = HashNerfFactory().create_algorithm()</span><br><span class="line">nerf.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br><span class="line"></span><br><span class="line">slam = SlamFactory().create_algorithm()</span><br><span class="line">slam.run(dataset=&#x27;dataset&#x27;, params=&#x27;params&#x27;, output_dir=&#x27;output_dir&#x27;)</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>每个具体产品都对应一个具体工厂类，不需要修改工厂类代码</li><li>隐藏了对象创建的实现细节</li></ul><p>缺点：</p><ul><li>每增加一个具体产品类，就必须增加一个相应的具体工厂类</li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象。</p><p>例：生产一部手机，需要手机壳、CPU、操作系统三类对象进行组装，其中每类对象都有不同的种类。对每个具体工厂，分别生产一部手机所需要的三个对象。</p><p>相比工厂方法模式，抽象工厂模式中的每个具体工厂都生产一套产品。</p><h3 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象工厂角色（Creator）</li><li>具体工厂角色（Concrete Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li><li>客户端（Client）</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 抽象产品 #####</span><br><span class="line">class PhoneShell(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CPU(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OS(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def show_os(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 抽象工厂 #####</span><br><span class="line">class PhoneFactory(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def make_shell(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def make_os(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体产品 #####</span><br><span class="line">class SmallShell(PhoneShell):</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        print(&quot;普通手机小手机壳&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BigShell(PhoneShell):</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        print(&quot;普通手机大手机壳&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AppleShell(PhoneShell):</span><br><span class="line">    def show_shell(self):</span><br><span class="line">        print(&quot;苹果手机壳&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SnapDragonCPU(CPU):</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        print(&quot;骁龙CPU&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MediaTekCPU(CPU):</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        print(&quot;联发科CPU&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AppleCPU(CPU):</span><br><span class="line">    def show_cpu(self):</span><br><span class="line">        print(&quot;苹果CPU&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Android(OS):</span><br><span class="line">    def show_os(self):</span><br><span class="line">        print(&quot;Android系统&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IOS(OS):</span><br><span class="line">    def show_os(self):</span><br><span class="line">        print(&quot;iOS系统&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体工厂 #####</span><br><span class="line">class MiFactory(PhoneFactory):</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        return SnapDragonCPU()</span><br><span class="line"></span><br><span class="line">    def make_os(self):</span><br><span class="line">        return Android()</span><br><span class="line"></span><br><span class="line">    def make_shell(self):</span><br><span class="line">        return BigShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HuaweiFactory(PhoneFactory):</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        return MediaTekCPU()</span><br><span class="line"></span><br><span class="line">    def make_os(self):</span><br><span class="line">        return Android()</span><br><span class="line"></span><br><span class="line">    def make_shell(self):</span><br><span class="line">        return SmallShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IPhoneFactory(PhoneFactory):</span><br><span class="line">    def make_cpu(self):</span><br><span class="line">        return AppleCPU()</span><br><span class="line"></span><br><span class="line">    def make_os(self):</span><br><span class="line">        return IOS()</span><br><span class="line"></span><br><span class="line">    def make_shell(self):</span><br><span class="line">        return AppleShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line">class Phone:</span><br><span class="line">    def __init__(self, cpu, os, shell):</span><br><span class="line">        self.cpu = cpu</span><br><span class="line">        self.os = os</span><br><span class="line">        self.shell = shell</span><br><span class="line"></span><br><span class="line">    def show_info(self):</span><br><span class="line">        print(&quot;手机信息:&quot;)</span><br><span class="line">        self.cpu.show_cpu()</span><br><span class="line">        self.os.show_os()</span><br><span class="line">        self.shell.show_shell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def make_phone(factory):</span><br><span class="line">    cpu = factory.make_cpu()</span><br><span class="line">    os = factory.make_os()</span><br><span class="line">    shell = factory.make_shell()</span><br><span class="line">    return Phone(cpu, os, shell)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = make_phone(IPhoneFactory())</span><br><span class="line">p1.show_info()</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>将客户端与类的具体实现相分离</li><li>每个工厂创建了一个完整的产品系列，使得易于交换产品系列</li><li>有利于产品的一致性（即产品之间的约束关系）</li></ul><p>缺点：</p><ul><li>难以支持新种类的（抽象）产品</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="角色-3"><a href="#角色-3" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象建造者（Builder）</li><li>具体建造者（Concrete Builder）</li><li>指挥者（Director）</li><li>产品（Product）</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 产品 #####</span><br><span class="line">class Player:</span><br><span class="line">    def __init__(self, face=None, body=None, arm=None, leg=None):</span><br><span class="line">        self.face = face</span><br><span class="line">        self.body = body</span><br><span class="line">        self.arm = arm</span><br><span class="line">        self.leg = leg</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;%s, %s, %s, %s&quot; % (self.face, self.body, self.arm, self.leg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 抽象建造者 #####</span><br><span class="line">class PlayerBuilder(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_face(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_body(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_arm(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def build_leg(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 具体建造者 #####</span><br><span class="line">class SexyGirlBuilder(PlayerBuilder):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.player = Player()</span><br><span class="line"></span><br><span class="line">    def build_face(self):</span><br><span class="line">        self.player.face = &quot;漂亮脸蛋&quot;</span><br><span class="line"></span><br><span class="line">    def build_body(self):</span><br><span class="line">        self.player.body = &quot;苗条&quot;</span><br><span class="line"></span><br><span class="line">    def build_arm(self):</span><br><span class="line">        self.player.arm = &quot;漂亮胳膊&quot;</span><br><span class="line"></span><br><span class="line">    def build_leg(self):</span><br><span class="line">        self.player.leg = &quot;大长腿&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Monster(PlayerBuilder):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.player = Player()</span><br><span class="line"></span><br><span class="line">    def build_face(self):</span><br><span class="line">        self.player.face = &quot;怪兽脸&quot;</span><br><span class="line"></span><br><span class="line">    def build_body(self):</span><br><span class="line">        self.player.body = &quot;怪兽身材&quot;</span><br><span class="line"></span><br><span class="line">    def build_arm(self):</span><br><span class="line">        self.player.arm = &quot;长毛的胳膊&quot;</span><br><span class="line"></span><br><span class="line">    def build_leg(self):</span><br><span class="line">        self.player.leg = &quot;长毛的腿&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 指挥者 #####</span><br><span class="line">class PlayerDirector:  # 控制组装顺序</span><br><span class="line">    def build_player(self, builder):</span><br><span class="line">        builder.build_body()</span><br><span class="line">        builder.build_face()</span><br><span class="line">        builder.build_arm()</span><br><span class="line">        builder.build_leg()</span><br><span class="line">        return builder.player</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 客户端使用 #####</span><br><span class="line">builder = Monster()</span><br><span class="line">director = PlayerDirector()</span><br><span class="line">player = director.build_player(builder)</span><br><span class="line">print(player)</span><br></pre></td></tr></table></figure><p>建造者模式与抽象工厂模式相似，也用来创建复杂对象。</p><p>主要区别是建造者模式着重一步步构造一个复杂对象，而抽象工厂模式着重于多个系列的产品对象。</p><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>隐藏了一个产品的内部结构和装配过程</li><li>将构造代码与表示代码分开，构造顺序修改不影响表示代码</li><li>可以对构造过程进行更精细的控制</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>保证一个类只有一个实例，并提供一个访问它的全局访问点。</p><h3 id="角色-4"><a href="#角色-4" class="headerlink" title="角色"></a>角色</h3><p>单例（Singleton）</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>在 Python 中，我们可以用多种方法来实现单例模式：</p><ul><li>使用模块</li><li>使用装饰器</li><li>使用类</li><li>基于 <strong>new</strong> 方法实现</li><li>基于 metaclass 方式实现</li></ul><h4 id="1-使用模块"><a href="#1-使用模块" class="headerlink" title="1. 使用模块"></a>1. 使用模块</h4><p>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。</p><p>因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p><p>单独定义一个文件，保存为 singleton.py 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Singleton:</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;I am running&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">singleton = Singleton()</span><br></pre></td></tr></table></figure><p>使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from singleton import singleton</span><br><span class="line"></span><br><span class="line"># Now, we can call the run method on the singleton object:</span><br><span class="line">singleton.run()</span><br></pre></td></tr></table></figure><h4 id="2-使用装饰器"><a href="#2-使用装饰器" class="headerlink" title="2. 使用装饰器"></a>2. 使用装饰器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls):</span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def _singleton(*args, **kwargs):</span><br><span class="line">        if cls not in _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        return _instance[cls]</span><br><span class="line"></span><br><span class="line">    return _singleton</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class SingletonObject:</span><br><span class="line">    a = 1</span><br><span class="line"></span><br><span class="line">    def __init__(self, x=0):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = SingletonObject(2)</span><br><span class="line">a2 = SingletonObject(3)</span><br><span class="line"></span><br><span class="line">print(a1.x)</span><br><span class="line">print(a2.x)</span><br></pre></td></tr></table></figure><h4 id="3-使用类"><a href="#3-使用类" class="headerlink" title="3. 使用类"></a>3. 使用类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">            with Singleton._instance_lock:</span><br><span class="line">                if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">                    Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        return Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    singleton_obj = Singleton.instance()</span><br><span class="line">    print(singleton_obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    t = threading.Thread(target=task, args=[i, ])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(20)</span><br><span class="line">obj = Singleton.instance()</span><br><span class="line">print(obj)</span><br></pre></td></tr></table></figure><p>这种方式实现的单例模式，使用时会有限制，以后实例化必须通过 obj &#x3D; Singleton.instance()</p><p>如果用 obj &#x3D; Singleton()，这种方式得到的不是单例。</p><h4 id="4-基于-new-方法实现"><a href="#4-基于-new-方法实现" class="headerlink" title="4. 基于 new 方法实现"></a>4. 基于 <strong>new</strong> 方法实现</h4><p>当我们实例化一个对象时，先执行类的 <strong>new</strong> 方法（我们没写时，默认调用 object.__new__），实例化对象；然后再执行类的 <strong>init</strong> 方法，对这个对象进行初始化，所有可以基于此，实现单例模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">            with Singleton._instance_lock:</span><br><span class="line">                if not hasattr(Singleton, &quot;_instance&quot;):</span><br><span class="line">                    Singleton._instance = object.__new__(cls)</span><br><span class="line">        return Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    obj = Singleton()</span><br><span class="line">    print(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    t = threading.Thread(target=task, args=[i, ])</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">obj1 = Singleton()</span><br><span class="line">obj2 = Singleton()</span><br><span class="line">print(obj1, obj2)</span><br></pre></td></tr></table></figure><p>采用这种方式的单例模式，以后实例化对象时，和平时实例化对象的方法一样 obj &#x3D; Singleton()</p><h4 id="5-基于-metaclass-方式实现"><a href="#5-基于-metaclass-方式实现" class="headerlink" title="5. 基于 metaclass 方式实现"></a>5. 基于 metaclass 方式实现</h4><p>相关知识:</p><ul><li>类由 type 创建，创建类时，type 的 <strong>init</strong> 方法自动执行，类() 执行 type 的 <strong>call</strong> 方法(类的 <strong>new</strong> 方法，类的 <strong>init</strong> 方法)</li><li>对象由类创建，创建对象时，类的 <strong>init</strong> 方法自动执行，对象()执行类的 <strong>call</strong> 方法</li></ul><p>元类使用例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class TestType(type):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;TestType.__new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __init__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;TestType.__init__&quot;)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;TestType.__call__&quot;)</span><br><span class="line">        return super().__call__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Test(metaclass=TestType):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;Test.__new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;Test.__init__&quot;)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;Test.__call__&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 1. 什么都不调用时输出 #####</span><br><span class="line"># TestType.__new__</span><br><span class="line"># TestType.__init__</span><br><span class="line"></span><br><span class="line"># ##### 2. 实例化类时输出 #####</span><br><span class="line"># TestType.__new__</span><br><span class="line"># TestType.__init__</span><br><span class="line"># TestType.__call__</span><br><span class="line"># Test.__new__</span><br><span class="line"># Test.__init__</span><br><span class="line">#</span><br><span class="line"># test = Test()</span><br><span class="line"></span><br><span class="line"># ##### 3. 调用实例时输出 #####</span><br><span class="line"># TestType.__new__</span><br><span class="line"># TestType.__init__</span><br><span class="line"># TestType.__call__</span><br><span class="line"># Test.__new__</span><br><span class="line"># Test.__init__</span><br><span class="line"># Test.__call__</span><br><span class="line">test = Test()</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>单例模式实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingletonType(type):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(cls, &quot;_instance&quot;):</span><br><span class="line">            with SingletonType._instance_lock:</span><br><span class="line">                if not hasattr(cls, &quot;_instance&quot;):</span><br><span class="line">                    cls._instance = super(SingletonType, cls).__call__(*args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(metaclass=SingletonType):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &#x27;_instance&#x27;))</span><br><span class="line">obj1 = Foo(&#x27;name&#x27;)</span><br><span class="line">print(hasattr(Foo, &#x27;_instance&#x27;))</span><br><span class="line">print(Foo._instance)</span><br><span class="line">obj2 = Foo(&#x27;name&#x27;)</span><br><span class="line">print(obj1, obj2)</span><br></pre></td></tr></table></figure><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>对唯一实例的受控访问</li><li>单例相当于全局变量，但防止了命名空间被污染</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><p>也可以称为复制模式。本质就是克隆对象，在对象初始化操作比较复杂的情况下，很实用，这既隐藏了对象创建的细节，又能大大降低耗时，提高性能。</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Book:</span><br><span class="line">    def __init__(self, name, authors, price, **rest):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        rest的例子有：出版商、长度、标签、出版日期</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.authors = authors</span><br><span class="line">        self.price = price</span><br><span class="line">        # 添加其他额外属性</span><br><span class="line">        self.__dict__.update(rest)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        format_string = &#x27;&#x27;</span><br><span class="line">        for key, value in self.__dict__.items():</span><br><span class="line">            format_string = f&#x27;&#123;format_string&#125;&#123;key&#125;: &#123;value&#125;, &#x27;</span><br><span class="line">        return format_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Prototype:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化一个原型列表</span><br><span class="line">        self.objects = dict()</span><br><span class="line"></span><br><span class="line">    def register(self, identifier, obj):</span><br><span class="line">        # 在原型列表中注册原型对象</span><br><span class="line">        self.objects[identifier] = obj</span><br><span class="line"></span><br><span class="line">    def unregister(self, identifier):</span><br><span class="line">        # 从原型列表中删除原型对象</span><br><span class="line">        del self.objects[identifier]</span><br><span class="line"></span><br><span class="line">    def clone(self, identifier, **attr):</span><br><span class="line">        # 根据 identifier 在原型列表中查找原型对象并克隆</span><br><span class="line">        found = self.objects.get(identifier)</span><br><span class="line">        if not found:</span><br><span class="line">            raise ValueError(&#x27;Incorrect object identifier: &#123;&#125;&#x27;.format(identifier))</span><br><span class="line">        obj = copy.deepcopy(found)</span><br><span class="line">        # 用新的属性值替换原型对象中的对应属性</span><br><span class="line">        obj.__dict__.update(attr)</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    book1 = Book(</span><br><span class="line">        &#x27;The C Programming Language&#x27;,</span><br><span class="line">        (&#x27;Brian W. Kernighan&#x27;, &#x27;Dennis M.Ritchie&#x27;),</span><br><span class="line">        price=118,</span><br><span class="line">        publisher=&#x27;Prentice Hall&#x27;,</span><br><span class="line">        length=228, publication_date=&#x27;1978-02-22&#x27;,</span><br><span class="line">        tags=(&#x27;C&#x27;, &#x27;programming&#x27;, &#x27;algorithms&#x27;, &#x27;data structures&#x27;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    prototype = Prototype()</span><br><span class="line">    register_id = &#x27;book1&#x27;</span><br><span class="line"></span><br><span class="line">    # 注册原型对象</span><br><span class="line">    prototype.register(register_id, book1)</span><br><span class="line">    book2 = prototype.clone(</span><br><span class="line">        register_id,</span><br><span class="line">        name=&#x27;The C Programming Language(ANSI)&#x27;,</span><br><span class="line">        price=48.99,</span><br><span class="line">        length=274,</span><br><span class="line">        publication_date=&#x27;1988-04-01&#x27;,</span><br><span class="line">        edition=2</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    print(book1)</span><br><span class="line">    print(book2)</span><br><span class="line">    print(f&quot;ID book1 : &#123;id(book1)&#125; != ID book2 : &#123;id(book2)&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>其实这段代码在 Python 中，要实现一样的效果，并没有这么复杂。以下代码除了原型模式类删除之外，只有 main 函数有些变更。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Book:</span><br><span class="line">    def __init__(self, name, authors, price, **rest):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        rest的例子有：出版商、长度、标签、出版日期</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.authors = authors</span><br><span class="line">        self.price = price</span><br><span class="line">        # 添加其他额外属性</span><br><span class="line">        self.__dict__.update(rest)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        format_string = &#x27;&#x27;</span><br><span class="line">        for key, value in self.__dict__.items():</span><br><span class="line">            format_string = f&#x27;&#123;format_string&#125;&#123;key&#125;: &#123;value&#125;, &#x27;</span><br><span class="line">        return format_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    book1 = Book(</span><br><span class="line">        &#x27;The C Programming Language&#x27;,</span><br><span class="line">        (&#x27;Brian W. Kernighan&#x27;, &#x27;Dennis M.Ritchie&#x27;),</span><br><span class="line">        price=118,</span><br><span class="line">        publisher=&#x27;Prentice Hall&#x27;,</span><br><span class="line">        length=228, publication_date=&#x27;1978-02-22&#x27;,</span><br><span class="line">        tags=(&#x27;C&#x27;, &#x27;programming&#x27;, &#x27;algorithms&#x27;, &#x27;data structures&#x27;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 这里我们彻底抛弃之前的原型设计模式的写法，同样的内容，经过不同的方式，可以得到同样的效果。</span><br><span class="line">    book2 = copy.deepcopy(book1)</span><br><span class="line">    book2.name = &#x27;The C Programming Language(ANSI)&#x27;</span><br><span class="line">    book2.price = 48.99</span><br><span class="line">    book2.length = 274</span><br><span class="line">    book2.publication_date = &#x27;1988-04-01&#x27;</span><br><span class="line">    book2.edition = 2</span><br><span class="line"></span><br><span class="line">    print(book1)</span><br><span class="line">    print(book2)</span><br><span class="line">    print(f&quot;ID book1 : &#123;id(book1)&#125; != ID book2 : &#123;id(book2)&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>原型模式用于创建复杂的和耗时的实例，复制一个已经存在的实例使程序运行更高效。</li></ul><p>缺点：</p><ul><li>每一个产品类都必须配置一个克隆方法，并且这个克隆方法需要对类的功能进行整体考虑。</li></ul><h2 id="创建型模式小结"><a href="#创建型模式小结" class="headerlink" title="创建型模式小结"></a>创建型模式小结</h2><p>抽象工厂模式和建造者模式相比于简单工厂模式和工厂方法模式而言更灵活也更复杂。</p><p>通常情况下，设计以简单工厂模式或工厂方法模式开始，当你发现设计需要更大的灵活性时，则向更复杂的设计模式演化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
